var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to3, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to3, key) && key !== except)
        __defProp(to3, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to3;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "../node_modules/kind-of/index.js"(exports, module) {
    "use strict";
    var toString = Object.prototype.toString;
    module.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// ../node_modules/shallow-clone/index.js
var require_shallow_clone = __commonJS({
  "../node_modules/shallow-clone/index.js"(exports, module) {
    "use strict";
    var valueOf = Symbol.prototype.valueOf;
    var typeOf = require_kind_of();
    function clone(val, deep) {
      switch (typeOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer(val);
        case "symbol":
          return cloneSymbol(val);
        case "arraybuffer":
          return cloneArrayBuffer(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray(val);
        case "regexp":
          return cloneRegExp(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re3 = new val.constructor(val.source, flags);
      re3.lastIndex = val.lastIndex;
      return re3;
    }
    function cloneArrayBuffer(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer(val) {
      const len = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    module.exports = clone;
  }
});

// ../node_modules/isobject/index.js
var require_isobject = __commonJS({
  "../node_modules/isobject/index.js"(exports, module) {
    "use strict";
    module.exports = function isObject2(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// ../node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "../node_modules/is-plain-object/index.js"(exports, module) {
    "use strict";
    var isObject2 = require_isobject();
    function isObjectObject(o4) {
      return isObject2(o4) === true && Object.prototype.toString.call(o4) === "[object Object]";
    }
    module.exports = function isPlainObject(o4) {
      var ctor, prot;
      if (isObjectObject(o4) === false)
        return false;
      ctor = o4.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// ../node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "../node_modules/clone-deep/index.js"(exports, module) {
    "use strict";
    var clone = require_shallow_clone();
    var typeOf = require_kind_of();
    var isPlainObject = require_is_plain_object();
    function cloneDeep2(val, instanceClone) {
      switch (typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return clone(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep2(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i3 = 0; i3 < val.length; i3++) {
        res[i3] = cloneDeep2(val[i3], instanceClone);
      }
      return res;
    }
    module.exports = cloneDeep2;
  }
});

// ../node_modules/events/events.js
var require_events = __commonJS({
  "../node_modules/events/events.js"(exports, module) {
    "use strict";
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
      if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
      }
      this._maxListeners = n3;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i3 = 1; i3 < arguments.length; i3++)
        args.push(arguments[i3]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err.context = er3;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i3 = 0; i3 < len; ++i3)
          ReflectApply(listeners[i3], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m3;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m3 = _getMaxListeners(target);
        if (m3 > 0 && existing.length > m3 && !existing.warned) {
          existing.warned = true;
          var w3 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w3.name = "MaxListenersExceededWarning";
          w3.emitter = target;
          w3.type = type;
          w3.count = existing.length;
          ProcessEmitWarning(w3);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i3, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i3 = list.length - 1; i3 >= 0; i3--) {
          if (list[i3] === listener || list[i3].listener === listener) {
            originalListener = list[i3].listener;
            position = i3;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i3;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i3 = 0; i3 < keys.length; ++i3) {
          key = keys[i3];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i3 = listeners.length - 1; i3 >= 0; i3--) {
          this.removeListener(type, listeners[i3]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n3) {
      var copy = new Array(n3);
      for (var i3 = 0; i3 < n3; ++i3)
        copy[i3] = arr[i3];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i3 = 0; i3 < ret.length; ++i3) {
        ret[i3] = arr[i3].listener || arr[i3];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../node_modules/@pipecat-ai/client-js/dist/index.module.js
var import_clone_deep = __toESM(require_clone_deep());
var import_events = __toESM(require_events());

// ../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
var i3;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// ../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../node_modules/@pipecat-ai/client-js/dist/index.module.js
function $parcel$export(e4, n3, v3, s3) {
  Object.defineProperty(e4, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
function $parcel$interopDefault(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
var $4bb349f22aee5185$exports = {};
$parcel$export($4bb349f22aee5185$exports, "httpActionGenerator", () => $4bb349f22aee5185$export$8728b60ea57bf43e);
async function $4bb349f22aee5185$export$8728b60ea57bf43e(actionUrl, action, params, handleResponse) {
  try {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI] Fetch action", actionUrl, action);
    const headers = new Headers({
      ...Object.fromEntries((params.headers ?? new Headers()).entries())
    });
    if (!headers.has("Content-Type"))
      headers.set("Content-Type", "application/json");
    headers.set("Cache-Control", "no-cache");
    headers.set("Connection", "keep-alive");
    const response = await fetch(actionUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        ...params.requestData,
        actions: [
          action
        ]
      })
    });
    const contentType = response.headers.get("content-type");
    if (!response.ok) {
      const errorMessage = await response.text();
      throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)(`Failed to resolve action: ${errorMessage}`, response.status);
    }
    if (response.body && contentType?.includes("text/event-stream")) {
      const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
      let buffer = "";
      while (true) {
        const { value, done } = await reader.read();
        if (done)
          break;
        buffer += value;
        let boundary = buffer.indexOf("\n\n");
        while (boundary !== -1) {
          const message = buffer.slice(0, boundary);
          buffer = buffer.slice(boundary + 2);
          const lines = message.split("\n");
          let encodedData = "";
          for (const line of lines) {
            const colonIndex = line.indexOf(":");
            if (colonIndex !== -1)
              encodedData += line.slice(colonIndex + 1).trim();
          }
          try {
            const jsonData = atob(encodedData);
            const parsedData = JSON.parse(jsonData);
            handleResponse(parsedData);
          } catch (error) {
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[RTVI] Failed to parse JSON:", error);
            throw error;
          }
          boundary = buffer.indexOf("\n\n");
        }
      }
    } else {
      const data = await response.json();
      handleResponse(data);
    }
  } catch (error) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[RTVI] Error during fetch:", error);
    throw error;
  }
}
var $a7c324a73303ad55$exports = {};
$parcel$export($a7c324a73303ad55$exports, "RTVIClient", () => $a7c324a73303ad55$export$fa42a01c1d60f4a1);
var $e3bad9cc25e327f7$exports = {};
$e3bad9cc25e327f7$exports = JSON.parse('{"name":"@pipecat-ai/client-js","version":"0.4.1","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"jest --silent && parcel build --no-cache","dev":"parcel watch","lint":"eslint src/ --report-unused-disable-directives --max-warnings 0","test":"jest"},"jest":{"preset":"ts-jest","testEnvironment":"node"},"devDependencies":{"@jest/globals":"^29.7.0","@types/clone-deep":"^4.0.4","@types/jest":"^29.5.12","@types/uuid":"^10.0.0","eslint":"^9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-simple-import-sort":"^12.1.1","jest":"^29.7.0","ts-jest":"^29.2.5"},"dependencies":{"@types/events":"^3.0.3","clone-deep":"^4.0.1","events":"^3.3.0","typed-emitter":"^2.1.0","uuid":"^10.0.0"}}');
var $8ead7b33b8402751$exports = {};
$parcel$export($8ead7b33b8402751$exports, "RTVIError", () => $8ead7b33b8402751$export$59b4786f333aac02);
$parcel$export($8ead7b33b8402751$exports, "ConnectionTimeoutError", () => $8ead7b33b8402751$export$c67992fa684a81a6);
$parcel$export($8ead7b33b8402751$exports, "StartBotError", () => $8ead7b33b8402751$export$e7544ab812238a61);
$parcel$export($8ead7b33b8402751$exports, "TransportStartError", () => $8ead7b33b8402751$export$e0624a511a2c4e9);
$parcel$export($8ead7b33b8402751$exports, "BotNotReadyError", () => $8ead7b33b8402751$export$885fb96b850e8fbb);
$parcel$export($8ead7b33b8402751$exports, "ConfigUpdateError", () => $8ead7b33b8402751$export$4eda4fd287fbbca5);
$parcel$export($8ead7b33b8402751$exports, "ActionEndpointNotSetError", () => $8ead7b33b8402751$export$be839f0100cd3132);
var $8ead7b33b8402751$export$59b4786f333aac02 = class extends Error {
  constructor(message, status) {
    super(message);
    this.status = status;
  }
};
var $8ead7b33b8402751$export$c67992fa684a81a6 = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Bot did not enter ready state within the specified timeout period.");
  }
};
var $8ead7b33b8402751$export$e7544ab812238a61 = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message, status) {
    super(message ?? `Failed to connect / invalid auth bundle from base url`, status ?? 500);
    this.error = "invalid-request-error";
  }
};
var $8ead7b33b8402751$export$e0624a511a2c4e9 = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Unable to connect to transport");
  }
};
var $8ead7b33b8402751$export$885fb96b850e8fbb = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Attempt to call action on transport when not in 'ready' state.");
  }
};
var $8ead7b33b8402751$export$4eda4fd287fbbca5 = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Unable to update configuration");
    this.status = 400;
  }
};
var $8ead7b33b8402751$export$be839f0100cd3132 = class extends $8ead7b33b8402751$export$59b4786f333aac02 {
  constructor(message) {
    super(message ?? "Action endpoint is not set");
  }
};
function $16f019d4d16917df$export$f1586721024c4dab(_target, propertyKey, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args) {
    if (this.state === "ready")
      return originalMethod.apply(this, args);
    else
      throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`);
  };
  return descriptor;
}
function $16f019d4d16917df$export$5c35b4fe6fa8c9a6(...states) {
  states = [
    "ready",
    ...states
  ];
  return function(_target, propertyKey, descriptor) {
    const originalGetter = descriptor.get;
    descriptor.get = function() {
      if (states.includes(this.state))
        return originalGetter?.apply(this);
      else
        throw new (0, $8ead7b33b8402751$export$885fb96b850e8fbb)(`Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`);
    };
    return descriptor;
  };
}
var $f9fc0c57b9aaed9c$exports = {};
$parcel$export($f9fc0c57b9aaed9c$exports, "RTVIEvent", () => $f9fc0c57b9aaed9c$export$6b4624d233c61fcb);
var $f9fc0c57b9aaed9c$export$6b4624d233c61fcb;
(function(RTVIEvent) {
  RTVIEvent["MessageError"] = "messageError";
  RTVIEvent["Error"] = "error";
  RTVIEvent["Connected"] = "connected";
  RTVIEvent["Disconnected"] = "disconnected";
  RTVIEvent["TransportStateChanged"] = "transportStateChanged";
  RTVIEvent["Config"] = "config";
  RTVIEvent["ConfigDescribe"] = "configDescribe";
  RTVIEvent["ActionsAvailable"] = "actionsAvailable";
  RTVIEvent["ParticipantConnected"] = "participantConnected";
  RTVIEvent["ParticipantLeft"] = "participantLeft";
  RTVIEvent["TrackStarted"] = "trackStarted";
  RTVIEvent["TrackStopped"] = "trackStopped";
  RTVIEvent["ScreenTrackStarted"] = "screenTrackStarted";
  RTVIEvent["ScreenTrackStopped"] = "screenTrackStopped";
  RTVIEvent["ScreenShareError"] = "screenShareError";
  RTVIEvent["AvailableCamsUpdated"] = "availableCamsUpdated";
  RTVIEvent["AvailableMicsUpdated"] = "availableMicsUpdated";
  RTVIEvent["AvailableSpeakersUpdated"] = "availableSpeakersUpdated";
  RTVIEvent["CamUpdated"] = "camUpdated";
  RTVIEvent["MicUpdated"] = "micUpdated";
  RTVIEvent["SpeakerUpdated"] = "speakerUpdated";
  RTVIEvent["BotConnected"] = "botConnected";
  RTVIEvent["BotReady"] = "botReady";
  RTVIEvent["BotDisconnected"] = "botDisconnected";
  RTVIEvent["BotStartedSpeaking"] = "botStartedSpeaking";
  RTVIEvent["BotStoppedSpeaking"] = "botStoppedSpeaking";
  RTVIEvent["RemoteAudioLevel"] = "remoteAudioLevel";
  RTVIEvent["UserStartedSpeaking"] = "userStartedSpeaking";
  RTVIEvent["UserStoppedSpeaking"] = "userStoppedSpeaking";
  RTVIEvent["LocalAudioLevel"] = "localAudioLevel";
  RTVIEvent["Metrics"] = "metrics";
  RTVIEvent["UserTranscript"] = "userTranscript";
  RTVIEvent["BotTranscript"] = "botTranscript";
  RTVIEvent["BotLlmText"] = "botLlmText";
  RTVIEvent["BotLlmStarted"] = "botLlmStarted";
  RTVIEvent["BotLlmStopped"] = "botLlmStopped";
  RTVIEvent["BotTtsText"] = "botTtsText";
  RTVIEvent["BotTtsStarted"] = "botTtsStarted";
  RTVIEvent["BotTtsStopped"] = "botTtsStopped";
  RTVIEvent["LLMFunctionCall"] = "llmFunctionCall";
  RTVIEvent["LLMFunctionCallStart"] = "llmFunctionCallStart";
  RTVIEvent["LLMJsonCompletion"] = "llmJsonCompletion";
  RTVIEvent["StorageItemStored"] = "storageItemStored";
  RTVIEvent["BotLlmSearchResponse"] = "botLlmSearchResponse";
  RTVIEvent["ServerMessage"] = "serverMessage";
})($f9fc0c57b9aaed9c$export$6b4624d233c61fcb || ($f9fc0c57b9aaed9c$export$6b4624d233c61fcb = {}));
var $7614fb2168c523cc$exports = {};
$parcel$export($7614fb2168c523cc$exports, "RTVIClientHelper", () => $7614fb2168c523cc$export$23bc637255b2a471);
var $7614fb2168c523cc$export$23bc637255b2a471 = class {
  constructor(options) {
    this._options = options;
  }
  set client(client) {
    this._client = client;
  }
  set service(service) {
    this._service = service;
  }
};
var $7afbbd59ebaa42bf$exports = {};
$parcel$export($7afbbd59ebaa42bf$exports, "LogLevel", () => $7afbbd59ebaa42bf$export$243e62d78d3b544d);
$parcel$export($7afbbd59ebaa42bf$exports, "logger", () => $7afbbd59ebaa42bf$export$af88d00dbe7f521);
var $7afbbd59ebaa42bf$export$243e62d78d3b544d;
(function(LogLevel2) {
  LogLevel2[LogLevel2["NONE"] = 0] = "NONE";
  LogLevel2[LogLevel2["ERROR"] = 1] = "ERROR";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["INFO"] = 3] = "INFO";
  LogLevel2[LogLevel2["DEBUG"] = 4] = "DEBUG";
})($7afbbd59ebaa42bf$export$243e62d78d3b544d || ($7afbbd59ebaa42bf$export$243e62d78d3b544d = {}));
var $7afbbd59ebaa42bf$var$Logger = class _$7afbbd59ebaa42bf$var$Logger {
  constructor() {
    this.level = $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG;
  }
  static getInstance() {
    if (!_$7afbbd59ebaa42bf$var$Logger.instance)
      _$7afbbd59ebaa42bf$var$Logger.instance = new _$7afbbd59ebaa42bf$var$Logger();
    return _$7afbbd59ebaa42bf$var$Logger.instance;
  }
  setLevel(level) {
    this.level = level;
  }
  debug(...args) {
    if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.DEBUG)
      console.debug(...args);
  }
  info(...args) {
    if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.INFO)
      console.info(...args);
  }
  warn(...args) {
    if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.WARN)
      console.warn(...args);
  }
  error(...args) {
    if (this.level >= $7afbbd59ebaa42bf$export$243e62d78d3b544d.ERROR)
      console.error(...args);
  }
};
var $7afbbd59ebaa42bf$export$af88d00dbe7f521 = $7afbbd59ebaa42bf$var$Logger.getInstance();
var $b48f893ed1354c1e$exports = {};
$parcel$export($b48f893ed1354c1e$exports, "RTVI_MESSAGE_LABEL", () => $b48f893ed1354c1e$export$882b13c7fda338f5);
$parcel$export($b48f893ed1354c1e$exports, "RTVIMessageType", () => $b48f893ed1354c1e$export$38b3db05cbf0e240);
$parcel$export($b48f893ed1354c1e$exports, "RTVIMessage", () => $b48f893ed1354c1e$export$69aa9ab0334b212);
$parcel$export($b48f893ed1354c1e$exports, "RTVIActionRequest", () => $b48f893ed1354c1e$export$378529d7a8bead8b);
$parcel$export($b48f893ed1354c1e$exports, "MessageDispatcher", () => $b48f893ed1354c1e$export$e9a960646cc432aa);
var $b48f893ed1354c1e$export$882b13c7fda338f5 = "rtvi-ai";
var $b48f893ed1354c1e$export$38b3db05cbf0e240;
(function(RTVIMessageType) {
  RTVIMessageType["CLIENT_READY"] = "client-ready";
  RTVIMessageType["UPDATE_CONFIG"] = "update-config";
  RTVIMessageType["GET_CONFIG"] = "get-config";
  RTVIMessageType["DESCRIBE_CONFIG"] = "describe-config";
  RTVIMessageType["DESCRIBE_ACTIONS"] = "describe-actions";
  RTVIMessageType["DISCONNECT_BOT"] = "disconnect-bot";
  RTVIMessageType["ACTION"] = "action";
  RTVIMessageType["BOT_READY"] = "bot-ready";
  RTVIMessageType["ERROR"] = "error";
  RTVIMessageType["ERROR_RESPONSE"] = "error-response";
  RTVIMessageType["CONFIG"] = "config";
  RTVIMessageType["CONFIG_AVAILABLE"] = "config-available";
  RTVIMessageType["CONFIG_ERROR"] = "config-error";
  RTVIMessageType["ACTIONS_AVAILABLE"] = "actions-available";
  RTVIMessageType["ACTION_RESPONSE"] = "action-response";
  RTVIMessageType["METRICS"] = "metrics";
  RTVIMessageType["USER_TRANSCRIPTION"] = "user-transcription";
  RTVIMessageType["BOT_TRANSCRIPTION"] = "bot-transcription";
  RTVIMessageType["USER_STARTED_SPEAKING"] = "user-started-speaking";
  RTVIMessageType["USER_STOPPED_SPEAKING"] = "user-stopped-speaking";
  RTVIMessageType["BOT_STARTED_SPEAKING"] = "bot-started-speaking";
  RTVIMessageType["BOT_STOPPED_SPEAKING"] = "bot-stopped-speaking";
  RTVIMessageType["USER_LLM_TEXT"] = "user-llm-text";
  RTVIMessageType["BOT_LLM_TEXT"] = "bot-llm-text";
  RTVIMessageType["BOT_LLM_STARTED"] = "bot-llm-started";
  RTVIMessageType["BOT_LLM_STOPPED"] = "bot-llm-stopped";
  RTVIMessageType["BOT_TTS_TEXT"] = "bot-tts-text";
  RTVIMessageType["BOT_TTS_STARTED"] = "bot-tts-started";
  RTVIMessageType["BOT_TTS_STOPPED"] = "bot-tts-stopped";
  RTVIMessageType["BOT_LLM_SEARCH_RESPONSE"] = "bot-llm-search-response";
  RTVIMessageType["STORAGE_ITEM_STORED"] = "storage-item-stored";
  RTVIMessageType["SERVER_MESSAGE"] = "server-message";
})($b48f893ed1354c1e$export$38b3db05cbf0e240 || ($b48f893ed1354c1e$export$38b3db05cbf0e240 = {}));
var $b48f893ed1354c1e$export$69aa9ab0334b212 = class _$b48f893ed1354c1e$export$69aa9ab0334b212 {
  constructor(type, data, id) {
    this.label = $b48f893ed1354c1e$export$882b13c7fda338f5;
    this.type = type;
    this.data = data;
    this.id = id || (0, v4_default)().slice(0, 8);
  }
  // Outbound message types
  static clientReady() {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.CLIENT_READY, {});
  }
  static updateConfig(config, interrupt = false) {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.UPDATE_CONFIG, {
      config,
      interrupt
    });
  }
  static describeConfig() {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_CONFIG, {});
  }
  static getBotConfig() {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.GET_CONFIG, {});
  }
  static describeActions() {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DESCRIBE_ACTIONS, {});
  }
  static disconnectBot() {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.DISCONNECT_BOT, {});
  }
  static error(message, fatal = false) {
    return new _$b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR, {
      message,
      fatal
    });
  }
};
var $b48f893ed1354c1e$export$378529d7a8bead8b = class extends $b48f893ed1354c1e$export$69aa9ab0334b212 {
  constructor(data) {
    super($b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION, data);
  }
};
var $b48f893ed1354c1e$export$e9a960646cc432aa = class {
  constructor(client) {
    this._queue = new Array();
    this._gcTime = 1e4;
    this._queue = [];
    this._client = client;
  }
  dispatch(message) {
    const promise = new Promise((resolve, reject) => {
      this._queue.push({
        message,
        timestamp: Date.now(),
        resolve,
        reject
      });
    });
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] dispatch", message);
    this._client.sendMessage(message);
    this._gc();
    return promise;
  }
  async dispatchAction(action, onMessage) {
    const promise = new Promise((resolve, reject) => {
      this._queue.push({
        message: action,
        timestamp: Date.now(),
        resolve,
        reject
      });
    });
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] action", action);
    if (this._client.connected)
      this._client.sendMessage(action);
    else {
      if (!this._client.params.endpoints?.action) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("[MessageDispatcher] Action endpoint is required when dispatching action in disconnected state");
        throw new (0, $8ead7b33b8402751$export$be839f0100cd3132)();
      }
      const actionUrl = this._client.constructUrl("action");
      try {
        await (0, $4bb349f22aee5185$export$8728b60ea57bf43e)(actionUrl, action, this._client.params, (response) => {
          onMessage(response);
        });
      } catch (e4) {
        onMessage(new $b48f893ed1354c1e$export$69aa9ab0334b212($b48f893ed1354c1e$export$38b3db05cbf0e240.ERROR_RESPONSE, `Action endpoint '${actionUrl}' returned an error response`, action.id));
      }
    }
    this._gc();
    return promise;
  }
  _resolveReject(message, resolve = true) {
    const queuedMessage = this._queue.find((msg) => msg.message.id === message.id);
    if (queuedMessage) {
      if (resolve) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Resolve", message);
        queuedMessage.resolve(message.type === $b48f893ed1354c1e$export$38b3db05cbf0e240.ACTION_RESPONSE ? message : message);
      } else {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Reject", message);
        queuedMessage.reject(message);
      }
      this._queue = this._queue.filter((msg) => msg.message.id !== message.id);
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] Queue", this._queue);
    }
    return message;
  }
  resolve(message) {
    return this._resolveReject(message, true);
  }
  reject(message) {
    return this._resolveReject(message, false);
  }
  _gc() {
    this._queue = this._queue.filter((msg) => {
      return Date.now() - msg.timestamp < this._gcTime;
    });
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[MessageDispatcher] GC", this._queue);
  }
};
var $4086f06442fcb7d7$exports = {};
$parcel$export($4086f06442fcb7d7$exports, "Transport", () => $4086f06442fcb7d7$export$86495b081fef8e52);
$parcel$export($4086f06442fcb7d7$exports, "TransportWrapper", () => $4086f06442fcb7d7$export$82b6ede160a64a3c);
var $4086f06442fcb7d7$export$86495b081fef8e52 = class {
  constructor() {
    this._state = "disconnected";
    this._expiry = void 0;
  }
  get expiry() {
    return this._expiry;
  }
};
var $4086f06442fcb7d7$export$82b6ede160a64a3c = class {
  constructor(transport) {
    this._transport = transport;
    this._proxy = new Proxy(this._transport, {
      get: (target, prop, receiver) => {
        if (typeof target[prop] === "function") {
          let errMsg;
          switch (String(prop)) {
            case "initialize":
              errMsg = `Direct calls to initialize() are disabled and used internally by the RTVIClient.`;
              break;
            case "initDevices":
              errMsg = `Direct calls to initDevices() are disabled. Please use the RTVIClient.initDevices() wrapper or let RTVIClient.connect() call it for you.`;
              break;
            case "sendReadyMessage":
              errMsg = `Direct calls to sendReadyMessage() are disabled and used internally by the RTVIClient.`;
              break;
            case "connect":
              errMsg = `Direct calls to connect() are disabled. Please use the RTVIClient.connect() wrapper.`;
              break;
            case "disconnect":
              errMsg = `Direct calls to disconnect() are disabled. Please use the RTVIClient.disconnect() wrapper.`;
              break;
          }
          if (errMsg)
            return () => {
              throw new Error(errMsg);
            };
          return (...args) => {
            return target[prop](...args);
          };
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  get proxy() {
    return this._proxy;
  }
};
var $a7c324a73303ad55$var$__decorate = function(decorators, target, key, desc) {
  var c3 = arguments.length, r4 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r4 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i3 = decorators.length - 1; i3 >= 0; i3--)
      if (d3 = decorators[i3])
        r4 = (c3 < 3 ? d3(r4) : c3 > 3 ? d3(target, key, r4) : d3(target, key)) || r4;
  return c3 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
};
var $a7c324a73303ad55$var$defaultEndpoints = {
  connect: "/connect",
  action: "/action"
};
var $a7c324a73303ad55$var$RTVIEventEmitter = class extends (0, import_events.default) {
};
var $a7c324a73303ad55$export$fa42a01c1d60f4a1 = class extends $a7c324a73303ad55$var$RTVIEventEmitter {
  constructor(options) {
    super();
    this.params = {
      ...options.params,
      endpoints: {
        ...$a7c324a73303ad55$var$defaultEndpoints,
        ...options.params.endpoints ?? {}
      }
    };
    this._helpers = {};
    this._transport = options.transport;
    this._transportWrapper = new (0, $4086f06442fcb7d7$export$82b6ede160a64a3c)(this._transport);
    const wrappedCallbacks = {
      ...options.callbacks,
      onMessageError: (message) => {
        options?.callbacks?.onMessageError?.(message);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MessageError, message);
      },
      onError: (message) => {
        options?.callbacks?.onError?.(message);
        try {
          this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Error, message);
        } catch (e4) {
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Could not emit error", message);
        }
        const data = message.data;
        if (data?.fatal) {
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Fatal error reported. Disconnecting...");
          this.disconnect();
        }
      },
      onConnected: () => {
        options?.callbacks?.onConnected?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Connected);
      },
      onDisconnected: () => {
        options?.callbacks?.onDisconnected?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Disconnected);
      },
      onTransportStateChanged: (state) => {
        options?.callbacks?.onTransportStateChanged?.(state);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TransportStateChanged, state);
      },
      onConfig: (config) => {
        options?.callbacks?.onConfig?.(config);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Config, config);
      },
      onConfigDescribe: (configDescription) => {
        options?.callbacks?.onConfigDescribe?.(configDescription);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ConfigDescribe, configDescription);
      },
      onActionsAvailable: (actionsAvailable) => {
        options?.callbacks?.onActionsAvailable?.(actionsAvailable);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ActionsAvailable, actionsAvailable);
      },
      onParticipantJoined: (p3) => {
        options?.callbacks?.onParticipantJoined?.(p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantConnected, p3);
      },
      onParticipantLeft: (p3) => {
        options?.callbacks?.onParticipantLeft?.(p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ParticipantLeft, p3);
      },
      onTrackStarted: (track2, p3) => {
        options?.callbacks?.onTrackStarted?.(track2, p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStarted, track2, p3);
      },
      onTrackStopped: (track2, p3) => {
        options?.callbacks?.onTrackStopped?.(track2, p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).TrackStopped, track2, p3);
      },
      onScreenTrackStarted: (track2, p3) => {
        options?.callbacks?.onScreenTrackStarted?.(track2, p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStarted, track2, p3);
      },
      onScreenTrackStopped: (track2, p3) => {
        options?.callbacks?.onScreenTrackStopped?.(track2, p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenTrackStopped, track2, p3);
      },
      onScreenShareError: (errorMessage) => {
        options?.callbacks?.onScreenShareError?.(errorMessage);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ScreenShareError, errorMessage);
      },
      onAvailableCamsUpdated: (cams) => {
        options?.callbacks?.onAvailableCamsUpdated?.(cams);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableCamsUpdated, cams);
      },
      onAvailableMicsUpdated: (mics) => {
        options?.callbacks?.onAvailableMicsUpdated?.(mics);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableMicsUpdated, mics);
      },
      onAvailableSpeakersUpdated: (speakers) => {
        options?.callbacks?.onAvailableSpeakersUpdated?.(speakers);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).AvailableSpeakersUpdated, speakers);
      },
      onCamUpdated: (cam) => {
        options?.callbacks?.onCamUpdated?.(cam);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).CamUpdated, cam);
      },
      onMicUpdated: (mic) => {
        options?.callbacks?.onMicUpdated?.(mic);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).MicUpdated, mic);
      },
      onSpeakerUpdated: (speaker) => {
        options?.callbacks?.onSpeakerUpdated?.(speaker);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).SpeakerUpdated, speaker);
      },
      onBotConnected: (p3) => {
        options?.callbacks?.onBotConnected?.(p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotConnected, p3);
      },
      onBotReady: (botReadyData) => {
        options?.callbacks?.onBotReady?.(botReadyData);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotReady, botReadyData);
      },
      onBotDisconnected: (p3) => {
        options?.callbacks?.onBotDisconnected?.(p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotDisconnected, p3);
      },
      onBotStartedSpeaking: () => {
        options?.callbacks?.onBotStartedSpeaking?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStartedSpeaking);
      },
      onBotStoppedSpeaking: () => {
        options?.callbacks?.onBotStoppedSpeaking?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotStoppedSpeaking);
      },
      onRemoteAudioLevel: (level, p3) => {
        options?.callbacks?.onRemoteAudioLevel?.(level, p3);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).RemoteAudioLevel, level, p3);
      },
      onUserStartedSpeaking: () => {
        options?.callbacks?.onUserStartedSpeaking?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStartedSpeaking);
      },
      onUserStoppedSpeaking: () => {
        options?.callbacks?.onUserStoppedSpeaking?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserStoppedSpeaking);
      },
      onLocalAudioLevel: (level) => {
        options?.callbacks?.onLocalAudioLevel?.(level);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LocalAudioLevel, level);
      },
      onUserTranscript: (data) => {
        options?.callbacks?.onUserTranscript?.(data);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).UserTranscript, data);
      },
      onBotTranscript: (text) => {
        options?.callbacks?.onBotTranscript?.(text);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTranscript, text);
      },
      onBotLlmText: (text) => {
        options?.callbacks?.onBotLlmText?.(text);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmText, text);
      },
      onBotLlmStarted: () => {
        options?.callbacks?.onBotLlmStarted?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStarted);
      },
      onBotLlmStopped: () => {
        options?.callbacks?.onBotLlmStopped?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmStopped);
      },
      onBotTtsText: (text) => {
        options?.callbacks?.onBotTtsText?.(text);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsText, text);
      },
      onBotTtsStarted: () => {
        options?.callbacks?.onBotTtsStarted?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStarted);
      },
      onBotTtsStopped: () => {
        options?.callbacks?.onBotTtsStopped?.();
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotTtsStopped);
      },
      onStorageItemStored: (data) => {
        options?.callbacks?.onStorageItemStored?.(data);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).StorageItemStored, data);
      }
    };
    this._options = {
      ...options,
      callbacks: wrappedCallbacks,
      enableMic: options.enableMic ?? true,
      enableCam: options.enableCam ?? false
    };
    this._initialize();
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Initialized", this.version);
  }
  constructUrl(endpoint) {
    if (!this.params.baseUrl)
      throw new $8ead7b33b8402751$export$59b4786f333aac02("Base URL not set. Please set rtviClient.params.baseUrl");
    const baseUrl = this.params.baseUrl.replace(/\/+$/, "");
    return baseUrl + (this.params.endpoints?.[endpoint] ?? "");
  }
  setLogLevel(level) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).setLevel(level);
  }
  // ------ Transport methods
  /**
   * Initialize local media devices
   */
  async initDevices() {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Initializing devices...");
    await this._transport.initDevices();
  }
  /**
   * Connect the voice client session with chosen transport
   * Call async (await) to handle errors
   */
  async connect() {
    if ([
      "authenticating",
      "connecting",
      "connected",
      "ready"
    ].includes(this._transport.state))
      throw new $8ead7b33b8402751$export$59b4786f333aac02("Voice client has already been started. Please call disconnect() before starting again.");
    this._abortController = new AbortController();
    return new Promise((resolve, reject) => {
      (async () => {
        this._startResolve = resolve;
        if (this._transport.state === "disconnected")
          await this._transport.initDevices();
        this._transport.state = "authenticating";
        if (this._options.timeout)
          this._handshakeTimeout = setTimeout(async () => {
            this._abortController?.abort();
            await this.disconnect();
            this._transport.state = "error";
            reject(new $8ead7b33b8402751$export$c67992fa684a81a6());
          }, this._options.timeout);
        let authBundle;
        const customConnectHandler = this._options.customConnectHandler;
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Start params", this.params);
        this.params = {
          ...this.params,
          requestData: {
            ...this.params.requestData,
            rtvi_client_version: this.version
          }
        };
        if (!this.params.baseUrl && !this.params.endpoints?.connect) {
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Connecting directly (skipping handshake / auth)...");
          clearTimeout(this._handshakeTimeout);
        } else {
          const connectUrl = this.constructUrl("connect");
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Connecting...", connectUrl);
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Start params", this.params);
          try {
            if (customConnectHandler)
              authBundle = await customConnectHandler(this.params, this._handshakeTimeout, this._abortController);
            else
              authBundle = await fetch(connectUrl, {
                method: "POST",
                mode: "cors",
                headers: new Headers({
                  "Content-Type": "application/json",
                  ...Object.fromEntries((this.params.headers ?? new Headers()).entries())
                }),
                body: JSON.stringify({
                  config: this.params.config,
                  ...this.params.services ? {
                    services: this.params.services
                  } : {},
                  ...this.params.requestData
                }),
                signal: this._abortController?.signal
              }).then((res) => {
                clearTimeout(this._handshakeTimeout);
                if (res.ok)
                  return res.json();
                return Promise.reject(res);
              });
          } catch (e4) {
            clearTimeout(this._handshakeTimeout);
            if (this._abortController?.signal.aborted)
              return;
            this._transport.state = "error";
            if (e4 instanceof Response) {
              const errorResp = await e4.json();
              reject(new $8ead7b33b8402751$export$e7544ab812238a61(errorResp.info ?? errorResp.detail ?? e4.statusText, e4.status));
            } else
              reject(new $8ead7b33b8402751$export$e7544ab812238a61());
            return;
          }
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Auth bundle received", authBundle);
        }
        try {
          await this._transport.connect(authBundle, this._abortController);
          await this._transport.sendReadyMessage();
        } catch (e4) {
          clearTimeout(this._handshakeTimeout);
          this.disconnect();
          reject(e4);
          return;
        }
      })();
    });
  }
  /**
   * Disconnect the voice client from the transport
   * Reset / reinitialize transport and abort any pending requests
   */
  async disconnect() {
    if (this._abortController)
      this._abortController.abort();
    clearTimeout(this._handshakeTimeout);
    await this._transport.disconnect();
    this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);
  }
  _initialize() {
    this._transport.initialize(this._options, this.handleMessage.bind(this));
    this._messageDispatcher = new (0, $b48f893ed1354c1e$export$e9a960646cc432aa)(this);
  }
  /**
   * Get the current state of the transport
   */
  get connected() {
    return [
      "connected",
      "ready"
    ].includes(this._transport.state);
  }
  get transport() {
    return this._transportWrapper.proxy;
  }
  get state() {
    return this._transport.state;
  }
  get version() {
    return (0, /* @__PURE__ */ $parcel$interopDefault($e3bad9cc25e327f7$exports)).version;
  }
  // ------ Device methods
  async getAllMics() {
    return await this._transport.getAllMics();
  }
  async getAllCams() {
    return await this._transport.getAllCams();
  }
  async getAllSpeakers() {
    return await this._transport.getAllSpeakers();
  }
  get selectedMic() {
    return this._transport.selectedMic;
  }
  get selectedCam() {
    return this._transport.selectedCam;
  }
  get selectedSpeaker() {
    return this._transport.selectedSpeaker;
  }
  updateMic(micId) {
    this._transport.updateMic(micId);
  }
  updateCam(camId) {
    this._transport.updateCam(camId);
  }
  updateSpeaker(speakerId) {
    this._transport.updateSpeaker(speakerId);
  }
  enableMic(enable) {
    this._transport.enableMic(enable);
  }
  get isMicEnabled() {
    return this._transport.isMicEnabled;
  }
  enableCam(enable) {
    this._transport.enableCam(enable);
  }
  get isCamEnabled() {
    return this._transport.isCamEnabled;
  }
  tracks() {
    return this._transport.tracks();
  }
  enableScreenShare(enable) {
    return this._transport.enableScreenShare(enable);
  }
  get isSharingScreen() {
    return this._transport.isSharingScreen;
  }
  // ------ Config methods
  /**
   * Request the bot to send the current configuration
   * @returns Promise<RTVIClientConfigOption[]> - Promise that resolves with the bot's configuration
   */
  async getConfig() {
    const configMsg = await this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).getBotConfig());
    return configMsg.data.config;
  }
  /**
   * Update pipeline and services
   * @param config - RTVIClientConfigOption[] partial object with the new configuration
   * @param interrupt - boolean flag to interrupt the current pipeline, or wait until the next turn
   * @returns Promise<RTVIMessage> - Promise that resolves with the updated configuration
   */
  async updateConfig(config, interrupt = false) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Client] Updating config", config);
    return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).updateConfig(config, interrupt));
  }
  /**
   * Request bot describe the current configuration options
   * @returns Promise<unknown> - Promise that resolves with the bot's configuration description
   */
  async describeConfig() {
    return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeConfig());
  }
  /**
   * Returns configuration options for specified service key
   * @param serviceKey - Service name to get options for (e.g. "llm")
   * @param config? - Optional RTVIClientConfigOption[] to query (vs. using remote config)
   * @returns RTVIClientConfigOption | undefined - Configuration options array for the service with specified key or undefined
   */
  async getServiceOptionsFromConfig(serviceKey, config) {
    if (!config && this.state !== "ready")
      throw new $8ead7b33b8402751$export$885fb96b850e8fbb("getServiceOptionsFromConfig called without config array before bot is ready");
    return Promise.resolve().then(async () => {
      if (!serviceKey) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Target service name is required");
        return void 0;
      }
      const passedConfig = config ?? await this.getConfig();
      const configServiceKey = passedConfig.find((config2) => config2.service === serviceKey);
      if (!configServiceKey) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("No service with name " + serviceKey + " not found in config");
        return void 0;
      }
      return configServiceKey;
    });
  }
  /**
   * Returns configuration option value (unknown) for specified service key and option name
   * @param serviceKey - Service name to get options for (e.g. "llm")
   * @optional option Name of option return from the config (e.g. "model")
   * @returns Promise<unknown | undefined> - Service configuration option value or undefined
   */
  async getServiceOptionValueFromConfig(serviceKey, option, config) {
    const configServiceKey = await this.getServiceOptionsFromConfig(serviceKey, config);
    if (!configServiceKey) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Service with name " + serviceKey + " not found in config");
      return void 0;
    }
    const optionValue = configServiceKey.options.find((o4) => o4.name === option);
    return optionValue ? optionValue.value : void 0;
  }
  _updateOrAddOption(existingOptions, newOption) {
    const existingOptionIndex = existingOptions.findIndex((item) => item.name === newOption.name);
    if (existingOptionIndex !== -1)
      return existingOptions.map((item, index) => index === existingOptionIndex ? {
        ...item,
        value: newOption.value
      } : item);
    else
      return [
        ...existingOptions,
        {
          name: newOption.name,
          value: newOption.value
        }
      ];
  }
  /**
   * Returns config with updated option(s) for specified service key and option name
   * Note: does not update current config, only returns a new object (call updateConfig to apply changes)
   * @param serviceKey - Service name to get options for (e.g. "llm")
   * @param option - Service name to get options for (e.g. "model")
   * @param config - Optional RTVIClientConfigOption[] to update (vs. using current config)
   * @returns Promise<RTVIClientConfigOption[] | undefined> - Configuration options array with updated option(s) or undefined
   */
  async setServiceOptionInConfig(serviceKey, option, config) {
    const newConfig = (0, import_clone_deep.default)(config ?? await this.getConfig());
    const serviceOptions = await this.getServiceOptionsFromConfig(serviceKey, newConfig);
    if (!serviceOptions) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Service with name '" + serviceKey + "' not found in config");
      return newConfig;
    }
    const optionsArray = Array.isArray(option) ? option : [
      option
    ];
    for (const opt of optionsArray) {
      const existingItem = newConfig.find((item) => item.service === serviceKey);
      const updatedOptions = existingItem ? this._updateOrAddOption(existingItem.options, opt) : [
        {
          name: opt.name,
          value: opt.value
        }
      ];
      if (existingItem)
        existingItem.options = updatedOptions;
      else
        newConfig.push({
          service: serviceKey,
          options: updatedOptions
        });
    }
    return newConfig;
  }
  /**
   * Returns config object with updated properties from passed array.
   * @param configOptions - Array of RTVIClientConfigOption[] to update
   * @param config? - Optional RTVIClientConfigOption[] to update (vs. using current config)
   * @returns Promise<RTVIClientConfigOption[]> - Configuration options
   */
  async setConfigOptions(configOptions, config) {
    let accumulator = (0, import_clone_deep.default)(config ?? await this.getConfig());
    for (const configOption of configOptions)
      accumulator = await this.setServiceOptionInConfig(configOption.service, configOption.options, accumulator) || accumulator;
    return accumulator;
  }
  // ------ Actions
  /**
   * Dispatch an action message to the bot or http single-turn endpoint
   */
  async action(action) {
    return this._messageDispatcher.dispatchAction(new (0, $b48f893ed1354c1e$export$378529d7a8bead8b)(action), this.handleMessage.bind(this));
  }
  /**
   * Describe available / registered actions the bot has
   * @returns Promise<unknown> - Promise that resolves with the bot's actions
   */
  async describeActions() {
    return this._messageDispatcher.dispatch((0, $b48f893ed1354c1e$export$69aa9ab0334b212).describeActions());
  }
  // ------ Transport methods
  /**
   * Get the session expiry time for the transport session (if applicable)
   * @returns number - Expiry time in milliseconds
   */
  get transportExpiry() {
    return this._transport.expiry;
  }
  // ------ Messages
  /**
   * Directly send a message to the bot via the transport
   * @param message - RTVIMessage object to send
   */
  sendMessage(message) {
    this._transport.sendMessage(message);
  }
  /**
   * Disconnects the bot, but keeps the session alive
   */
  disconnectBot() {
    this._transport.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)((0, $b48f893ed1354c1e$export$38b3db05cbf0e240).DISCONNECT_BOT, {}));
  }
  handleMessage(ev) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Message]", ev);
    switch (ev.type) {
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_READY:
        clearTimeout(this._handshakeTimeout);
        this._startResolve?.(ev.data);
        this._options.callbacks?.onBotReady?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG_AVAILABLE:
        this._messageDispatcher.resolve(ev);
        this._options.callbacks?.onConfigDescribe?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).CONFIG: {
        const resp = this._messageDispatcher.resolve(ev);
        this._options.callbacks?.onConfig?.(resp.data.config);
        break;
      }
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTIONS_AVAILABLE:
        this._messageDispatcher.resolve(ev);
        this._options.callbacks?.onActionsAvailable?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ACTION_RESPONSE:
        this._messageDispatcher.resolve(ev);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR_RESPONSE: {
        const resp = this._messageDispatcher.reject(ev);
        this._options.callbacks?.onMessageError?.(resp);
        break;
      }
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).ERROR:
        this._options.callbacks?.onError?.(ev);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STARTED_SPEAKING:
        this._options.callbacks?.onUserStartedSpeaking?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_STOPPED_SPEAKING:
        this._options.callbacks?.onUserStoppedSpeaking?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STARTED_SPEAKING:
        this._options.callbacks?.onBotStartedSpeaking?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_STOPPED_SPEAKING:
        this._options.callbacks?.onBotStoppedSpeaking?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).USER_TRANSCRIPTION: {
        const TranscriptData2 = ev.data;
        this._options.callbacks?.onUserTranscript?.(TranscriptData2);
        break;
      }
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TRANSCRIPTION:
        this._options.callbacks?.onBotTranscript?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_TEXT:
        this._options.callbacks?.onBotLlmText?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STARTED:
        this._options.callbacks?.onBotLlmStarted?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_STOPPED:
        this._options.callbacks?.onBotLlmStopped?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_TEXT:
        this._options.callbacks?.onBotTtsText?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STARTED:
        this._options.callbacks?.onBotTtsStarted?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_TTS_STOPPED:
        this._options.callbacks?.onBotTtsStopped?.();
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_LLM_SEARCH_RESPONSE:
        this._options.callbacks?.onBotLlmSearchResponse?.(ev.data);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).BotLlmSearchResponse, ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).METRICS:
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).Metrics, ev.data);
        this._options.callbacks?.onMetrics?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).STORAGE_ITEM_STORED:
        this._options.callbacks?.onStorageItemStored?.(ev.data);
        break;
      case (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).SERVER_MESSAGE:
        this._options.callbacks?.onServerMessage?.(ev.data);
        this.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).ServerMessage, ev.data);
        break;
      default: {
        let match = false;
        for (const helper of Object.values(this._helpers))
          if (helper.getMessageTypes().includes(ev.type)) {
            match = true;
            helper.handleMessage(ev);
          }
        if (!match)
          this._options.callbacks?.onGenericMessage?.(ev.data);
      }
    }
  }
  // ------ Helpers
  /**
   * Register a new helper to the client
   * This (optionally) provides a way to reference helpers directly
   * from the client and use the event dispatcher
   * @param service - Target service for this helper
   * @param helper - Helper instance
   * @returns RTVIClientHelper - Registered helper instance
   */
  registerHelper(service, helper) {
    if (this._helpers[service])
      throw new Error(`Helper with name '${service}' already registered`);
    if (!(helper instanceof (0, $7614fb2168c523cc$export$23bc637255b2a471)))
      throw new Error(`Helper must be an instance of RTVIClientHelper`);
    helper.service = service;
    helper.client = this;
    this._helpers[service] = helper;
    return this._helpers[service];
  }
  getHelper(service) {
    const helper = this._helpers[service];
    if (!helper) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Helper targeting service '${service}' not found`);
      return void 0;
    }
    return helper;
  }
  unregisterHelper(service) {
    if (!this._helpers[service])
      return;
    delete this._helpers[service];
  }
};
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "getConfig", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "updateConfig", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "describeConfig", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "describeActions", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$5c35b4fe6fa8c9a6)("connected", "ready")
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "transportExpiry", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "sendMessage", null);
$a7c324a73303ad55$var$__decorate([
  (0, $16f019d4d16917df$export$f1586721024c4dab)
], $a7c324a73303ad55$export$fa42a01c1d60f4a1.prototype, "disconnectBot", null);
var $0908f693e3e0724c$exports = {};
$parcel$export($0908f693e3e0724c$exports, "LLMMessageType", () => $0908f693e3e0724c$export$441bcd2e10762760);
$parcel$export($0908f693e3e0724c$exports, "LLMActionType", () => $0908f693e3e0724c$export$43cdfb26f790451);
$parcel$export($0908f693e3e0724c$exports, "LLMHelper", () => $0908f693e3e0724c$export$3cf39a62d076dd5c);
var $0908f693e3e0724c$export$441bcd2e10762760;
(function(LLMMessageType) {
  LLMMessageType["LLM_FUNCTION_CALL"] = "llm-function-call";
  LLMMessageType["LLM_FUNCTION_CALL_START"] = "llm-function-call-start";
  LLMMessageType["LLM_FUNCTION_CALL_RESULT"] = "llm-function-call-result";
  LLMMessageType["LLM_JSON_COMPLETION"] = "llm-json-completion";
})($0908f693e3e0724c$export$441bcd2e10762760 || ($0908f693e3e0724c$export$441bcd2e10762760 = {}));
var $0908f693e3e0724c$export$43cdfb26f790451;
(function(LLMActionType) {
  LLMActionType["APPEND_TO_MESSAGES"] = "append_to_messages";
  LLMActionType["GET_CONTEXT"] = "get_context";
  LLMActionType["SET_CONTEXT"] = "set_context";
  LLMActionType["RUN"] = "run";
})($0908f693e3e0724c$export$43cdfb26f790451 || ($0908f693e3e0724c$export$43cdfb26f790451 = {}));
var $0908f693e3e0724c$export$3cf39a62d076dd5c = class extends (0, $7614fb2168c523cc$export$23bc637255b2a471) {
  constructor(options) {
    super(options);
    this._functionCallCallback = null;
  }
  getMessageTypes() {
    return Object.values($0908f693e3e0724c$export$441bcd2e10762760);
  }
  // --- Actions
  /**
   * Retrieve the bot's current LLM context.
   * @returns Promise<LLMContext>
   */
  async getContext() {
    if (this._client.state !== "ready")
      throw new $8ead7b33b8402751$export$885fb96b850e8fbb("getContext called while transport not in ready state");
    const actionResponseMsg = await this._client.action({
      service: this._service,
      action: $0908f693e3e0724c$export$43cdfb26f790451.GET_CONTEXT
    });
    return actionResponseMsg.data.result;
  }
  /**
   * Update the bot's LLM context.
   * If this is called while the transport is not in the ready state, the local context will be updated
   * @param context LLMContext - The new context
   * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
   * @returns Promise<boolean>
   */
  async setContext(context, interrupt = false) {
    if (this._client.state !== "ready")
      throw new $8ead7b33b8402751$export$885fb96b850e8fbb("setContext called while transport not in ready state");
    const actionResponse = await this._client.action({
      service: this._service,
      action: $0908f693e3e0724c$export$43cdfb26f790451.SET_CONTEXT,
      arguments: [
        {
          name: "messages",
          value: context.messages
        },
        {
          name: "interrupt",
          value: interrupt
        }
      ]
    });
    return !!actionResponse.data.result;
  }
  /**
   * Append a new message to the LLM context.
   * If this is called while the transport is not in the ready state, the local context will be updated
   * @param context LLMContextMessage
   * @param runImmediately boolean - wait until pipeline is idle before running
   * @returns boolean
   */
  async appendToMessages(message, runImmediately = false) {
    if (this._client.state !== "ready")
      throw new $8ead7b33b8402751$export$885fb96b850e8fbb("setContext called while transport not in ready state");
    const actionResponse = await this._client.action({
      service: this._service,
      action: $0908f693e3e0724c$export$43cdfb26f790451.APPEND_TO_MESSAGES,
      arguments: [
        {
          name: "messages",
          value: [
            message
          ]
        },
        {
          name: "run_immediately",
          value: runImmediately
        }
      ]
    });
    return !!actionResponse.data.result;
  }
  /**
   * Run the bot's current LLM context.
   * Useful when appending messages to the context without runImmediately set to true.
   * Will do nothing if the bot is not in the ready state.
   * @param interrupt boolean - Whether to interrupt the bot, or wait until it has finished speaking
   * @returns Promise<unknown>
   */
  async run(interrupt = false) {
    if (this._client.state !== "ready")
      return;
    return this._client.action({
      service: this._service,
      action: $0908f693e3e0724c$export$43cdfb26f790451.RUN,
      arguments: [
        {
          name: "interrupt",
          value: interrupt
        }
      ]
    });
  }
  // --- Handlers
  /**
   * If the LLM wants to call a function, RTVI will invoke the callback defined
   * here. Whatever the callback returns will be sent to the LLM as the function result.
   * @param callback
   * @returns void
   */
  handleFunctionCall(callback) {
    this._functionCallCallback = callback;
  }
  handleMessage(ev) {
    switch (ev.type) {
      case $0908f693e3e0724c$export$441bcd2e10762760.LLM_JSON_COMPLETION:
        this._options.callbacks?.onLLMJsonCompletion?.(ev.data);
        this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMJsonCompletion, ev.data);
        break;
      case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL: {
        const d3 = ev.data;
        this._options.callbacks?.onLLMFunctionCall?.(ev.data);
        this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCall, ev.data);
        if (this._functionCallCallback) {
          const fn3 = {
            functionName: d3.function_name,
            arguments: d3.args
          };
          if (this._client.state === "ready")
            this._functionCallCallback(fn3).then((result) => {
              this._client.sendMessage(new (0, $b48f893ed1354c1e$export$69aa9ab0334b212)($0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_RESULT, {
                function_name: d3.function_name,
                tool_call_id: d3.tool_call_id,
                arguments: d3.args,
                result
              }));
            });
          else
            throw new $8ead7b33b8402751$export$885fb96b850e8fbb("Attempted to send a function call result from bot while transport not in ready state");
        }
        break;
      }
      case $0908f693e3e0724c$export$441bcd2e10762760.LLM_FUNCTION_CALL_START: {
        const e4 = ev.data;
        this._options.callbacks?.onLLMFunctionCallStart?.(e4.function_name);
        this._client.emit((0, $f9fc0c57b9aaed9c$export$6b4624d233c61fcb).LLMFunctionCallStart, e4.function_name);
        break;
      }
    }
  }
};

// src/client.ts
var Client = class extends $a7c324a73303ad55$export$fa42a01c1d60f4a1 {
  constructor(options) {
    super(options);
    console.log("[Client] Initialized with options:", options);
  }
  // Add custom method for sending text messages
  async sendTextMessage(text) {
    console.log("[Client] Sending text message:", text);
    const message = {
      type: "text",
      data: { text },
      id: crypto.randomUUID(),
      label: "user_message"
    };
    return this.sendMessage(message);
  }
  // Add custom method for sending actions with enhanced logging
  async sendCustomAction(action) {
    console.log("[Client] Sending custom action:", action);
    try {
      const response = await this.action(action);
      console.log("[Client] Action response:", response);
      return response;
    } catch (error) {
      console.error("[Client] Action failed:", error);
      throw error;
    }
  }
};

// src/utils/utils.ts
import { ProtobufFrameSerializer as ProtobufFrameSerializer2 } from "@pipecat-ai/websocket-transport";

// src/transport/transport.ts
import { WebSocketTransport, ProtobufFrameSerializer } from "@pipecat-ai/websocket-transport";

// ../node_modules/@daily-co/daily-js/dist/daily-esm.js
function e(e4, t3) {
  if (null == e4)
    return {};
  var n3, r4, i3 = function(e5, t4) {
    if (null == e5)
      return {};
    var n4 = {};
    for (var r5 in e5)
      if ({}.hasOwnProperty.call(e5, r5)) {
        if (-1 !== t4.indexOf(r5))
          continue;
        n4[r5] = e5[r5];
      }
    return n4;
  }(e4, t3);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e4);
    for (r4 = 0; r4 < o4.length; r4++)
      n3 = o4[r4], -1 === t3.indexOf(n3) && {}.propertyIsEnumerable.call(e4, n3) && (i3[n3] = e4[n3]);
  }
  return i3;
}
function t(e4, t3) {
  if (!(e4 instanceof t3))
    throw new TypeError("Cannot call a class as a function");
}
function n(e4) {
  return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
    return typeof e5;
  } : function(e5) {
    return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
  }, n(e4);
}
function r(e4) {
  var t3 = function(e5, t4) {
    if ("object" != n(e5) || !e5)
      return e5;
    var r4 = e5[Symbol.toPrimitive];
    if (void 0 !== r4) {
      var i3 = r4.call(e5, t4 || "default");
      if ("object" != n(i3))
        return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t4 ? String : Number)(e5);
  }(e4, "string");
  return "symbol" == n(t3) ? t3 : t3 + "";
}
function i(e4, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var i3 = t3[n3];
    i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e4, r(i3.key), i3);
  }
}
function o(e4, t3, n3) {
  return t3 && i(e4.prototype, t3), n3 && i(e4, n3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
}
function s(e4, t3) {
  if (t3 && ("object" == n(t3) || "function" == typeof t3))
    return t3;
  if (void 0 !== t3)
    throw new TypeError("Derived constructors may only return object or undefined");
  return function(e5) {
    if (void 0 === e5)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e5;
  }(e4);
}
function a(e4) {
  return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
    return e5.__proto__ || Object.getPrototypeOf(e5);
  }, a(e4);
}
function c(e4, t3) {
  return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t4) {
    return e5.__proto__ = t4, e5;
  }, c(e4, t3);
}
function l(e4, t3) {
  if ("function" != typeof t3 && null !== t3)
    throw new TypeError("Super expression must either be null or a function");
  e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && c(e4, t3);
}
function u(e4, t3, n3) {
  return (t3 = r(t3)) in e4 ? Object.defineProperty(e4, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e4[t3] = n3, e4;
}
function d(e4, t3, n3, r4, i3, o4, s3) {
  try {
    var a3 = e4[o4](s3), c3 = a3.value;
  } catch (e5) {
    return void n3(e5);
  }
  a3.done ? t3(c3) : Promise.resolve(c3).then(r4, i3);
}
function p(e4) {
  return function() {
    var t3 = this, n3 = arguments;
    return new Promise(function(r4, i3) {
      var o4 = e4.apply(t3, n3);
      function s3(e5) {
        d(o4, r4, i3, s3, a3, "next", e5);
      }
      function a3(e5) {
        d(o4, r4, i3, s3, a3, "throw", e5);
      }
      s3(void 0);
    });
  };
}
function h(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
function f(e4, t3) {
  return function(e5) {
    if (Array.isArray(e5))
      return e5;
  }(e4) || function(e5, t4) {
    var n3 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
    if (null != n3) {
      var r4, i3, o4, s3, a3 = [], c3 = true, l3 = false;
      try {
        if (o4 = (n3 = n3.call(e5)).next, 0 === t4) {
          if (Object(n3) !== n3)
            return;
          c3 = false;
        } else
          for (; !(c3 = (r4 = o4.call(n3)).done) && (a3.push(r4.value), a3.length !== t4); c3 = true)
            ;
      } catch (e6) {
        l3 = true, i3 = e6;
      } finally {
        try {
          if (!c3 && null != n3.return && (s3 = n3.return(), Object(s3) !== s3))
            return;
        } finally {
          if (l3)
            throw i3;
        }
      }
      return a3;
    }
  }(e4, t3) || function(e5, t4) {
    if (e5) {
      if ("string" == typeof e5)
        return h(e5, t4);
      var n3 = {}.toString.call(e5).slice(8, -1);
      return "Object" === n3 && e5.constructor && (n3 = e5.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e5) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? h(e5, t4) : void 0;
    }
  }(e4, t3) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function v(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
var g;
var m = { exports: {} };
var y = "object" == typeof Reflect ? Reflect : null;
var b = y && "function" == typeof y.apply ? y.apply : function(e4, t3, n3) {
  return Function.prototype.apply.call(e4, t3, n3);
};
g = y && "function" == typeof y.ownKeys ? y.ownKeys : Object.getOwnPropertySymbols ? function(e4) {
  return Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4));
} : function(e4) {
  return Object.getOwnPropertyNames(e4);
};
var _ = Number.isNaN || function(e4) {
  return e4 != e4;
};
function w() {
  w.init.call(this);
}
m.exports = w, m.exports.once = function(e4, t3) {
  return new Promise(function(n3, r4) {
    function i3(n4) {
      e4.removeListener(t3, o4), r4(n4);
    }
    function o4() {
      "function" == typeof e4.removeListener && e4.removeListener("error", i3), n3([].slice.call(arguments));
    }
    j(e4, t3, o4, { once: true }), "error" !== t3 && function(e5, t4, n4) {
      "function" == typeof e5.on && j(e5, "error", t4, n4);
    }(e4, i3, { once: true });
  });
}, w.EventEmitter = w, w.prototype._events = void 0, w.prototype._eventsCount = 0, w.prototype._maxListeners = void 0;
var S = 10;
function k(e4) {
  if ("function" != typeof e4)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e4);
}
function M(e4) {
  return void 0 === e4._maxListeners ? w.defaultMaxListeners : e4._maxListeners;
}
function C(e4, t3, n3, r4) {
  var i3, o4, s3, a3;
  if (k(n3), void 0 === (o4 = e4._events) ? (o4 = e4._events = /* @__PURE__ */ Object.create(null), e4._eventsCount = 0) : (void 0 !== o4.newListener && (e4.emit("newListener", t3, n3.listener ? n3.listener : n3), o4 = e4._events), s3 = o4[t3]), void 0 === s3)
    s3 = o4[t3] = n3, ++e4._eventsCount;
  else if ("function" == typeof s3 ? s3 = o4[t3] = r4 ? [n3, s3] : [s3, n3] : r4 ? s3.unshift(n3) : s3.push(n3), (i3 = M(e4)) > 0 && s3.length > i3 && !s3.warned) {
    s3.warned = true;
    var c3 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c3.name = "MaxListenersExceededWarning", c3.emitter = e4, c3.type = t3, c3.count = s3.length, a3 = c3, console && console.warn && console.warn(a3);
  }
  return e4;
}
function E() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function T(e4, t3, n3) {
  var r4 = { fired: false, wrapFn: void 0, target: e4, type: t3, listener: n3 }, i3 = E.bind(r4);
  return i3.listener = n3, r4.wrapFn = i3, i3;
}
function O(e4, t3, n3) {
  var r4 = e4._events;
  if (void 0 === r4)
    return [];
  var i3 = r4[t3];
  return void 0 === i3 ? [] : "function" == typeof i3 ? n3 ? [i3.listener || i3] : [i3] : n3 ? function(e5) {
    for (var t4 = new Array(e5.length), n4 = 0; n4 < t4.length; ++n4)
      t4[n4] = e5[n4].listener || e5[n4];
    return t4;
  }(i3) : A(i3, i3.length);
}
function P(e4) {
  var t3 = this._events;
  if (void 0 !== t3) {
    var n3 = t3[e4];
    if ("function" == typeof n3)
      return 1;
    if (void 0 !== n3)
      return n3.length;
  }
  return 0;
}
function A(e4, t3) {
  for (var n3 = new Array(t3), r4 = 0; r4 < t3; ++r4)
    n3[r4] = e4[r4];
  return n3;
}
function j(e4, t3, n3, r4) {
  if ("function" == typeof e4.on)
    r4.once ? e4.once(t3, n3) : e4.on(t3, n3);
  else {
    if ("function" != typeof e4.addEventListener)
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e4);
    e4.addEventListener(t3, function i3(o4) {
      r4.once && e4.removeEventListener(t3, i3), n3(o4);
    });
  }
}
Object.defineProperty(w, "defaultMaxListeners", { enumerable: true, get: function() {
  return S;
}, set: function(e4) {
  if ("number" != typeof e4 || e4 < 0 || _(e4))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e4 + ".");
  S = e4;
} }), w.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, w.prototype.setMaxListeners = function(e4) {
  if ("number" != typeof e4 || e4 < 0 || _(e4))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e4 + ".");
  return this._maxListeners = e4, this;
}, w.prototype.getMaxListeners = function() {
  return M(this);
}, w.prototype.emit = function(e4) {
  for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
    t3.push(arguments[n3]);
  var r4 = "error" === e4, i3 = this._events;
  if (void 0 !== i3)
    r4 = r4 && void 0 === i3.error;
  else if (!r4)
    return false;
  if (r4) {
    var o4;
    if (t3.length > 0 && (o4 = t3[0]), o4 instanceof Error)
      throw o4;
    var s3 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
    throw s3.context = o4, s3;
  }
  var a3 = i3[e4];
  if (void 0 === a3)
    return false;
  if ("function" == typeof a3)
    b(a3, this, t3);
  else {
    var c3 = a3.length, l3 = A(a3, c3);
    for (n3 = 0; n3 < c3; ++n3)
      b(l3[n3], this, t3);
  }
  return true;
}, w.prototype.addListener = function(e4, t3) {
  return C(this, e4, t3, false);
}, w.prototype.on = w.prototype.addListener, w.prototype.prependListener = function(e4, t3) {
  return C(this, e4, t3, true);
}, w.prototype.once = function(e4, t3) {
  return k(t3), this.on(e4, T(this, e4, t3)), this;
}, w.prototype.prependOnceListener = function(e4, t3) {
  return k(t3), this.prependListener(e4, T(this, e4, t3)), this;
}, w.prototype.removeListener = function(e4, t3) {
  var n3, r4, i3, o4, s3;
  if (k(t3), void 0 === (r4 = this._events))
    return this;
  if (void 0 === (n3 = r4[e4]))
    return this;
  if (n3 === t3 || n3.listener === t3)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r4[e4], r4.removeListener && this.emit("removeListener", e4, n3.listener || t3));
  else if ("function" != typeof n3) {
    for (i3 = -1, o4 = n3.length - 1; o4 >= 0; o4--)
      if (n3[o4] === t3 || n3[o4].listener === t3) {
        s3 = n3[o4].listener, i3 = o4;
        break;
      }
    if (i3 < 0)
      return this;
    0 === i3 ? n3.shift() : function(e5, t4) {
      for (; t4 + 1 < e5.length; t4++)
        e5[t4] = e5[t4 + 1];
      e5.pop();
    }(n3, i3), 1 === n3.length && (r4[e4] = n3[0]), void 0 !== r4.removeListener && this.emit("removeListener", e4, s3 || t3);
  }
  return this;
}, w.prototype.off = w.prototype.removeListener, w.prototype.removeAllListeners = function(e4) {
  var t3, n3, r4;
  if (void 0 === (n3 = this._events))
    return this;
  if (void 0 === n3.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e4] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e4]), this;
  if (0 === arguments.length) {
    var i3, o4 = Object.keys(n3);
    for (r4 = 0; r4 < o4.length; ++r4)
      "removeListener" !== (i3 = o4[r4]) && this.removeAllListeners(i3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t3 = n3[e4]))
    this.removeListener(e4, t3);
  else if (void 0 !== t3)
    for (r4 = t3.length - 1; r4 >= 0; r4--)
      this.removeListener(e4, t3[r4]);
  return this;
}, w.prototype.listeners = function(e4) {
  return O(this, e4, true);
}, w.prototype.rawListeners = function(e4) {
  return O(this, e4, false);
}, w.listenerCount = function(e4, t3) {
  return "function" == typeof e4.listenerCount ? e4.listenerCount(t3) : P.call(e4, t3);
}, w.prototype.listenerCount = P, w.prototype.eventNames = function() {
  return this._eventsCount > 0 ? g(this._events) : [];
};
var I = m.exports;
var x = v(I);
var L = Object.prototype.hasOwnProperty;
function D(e4, t3, n3) {
  for (n3 of e4.keys())
    if (N(n3, t3))
      return n3;
}
function N(e4, t3) {
  var n3, r4, i3;
  if (e4 === t3)
    return true;
  if (e4 && t3 && (n3 = e4.constructor) === t3.constructor) {
    if (n3 === Date)
      return e4.getTime() === t3.getTime();
    if (n3 === RegExp)
      return e4.toString() === t3.toString();
    if (n3 === Array) {
      if ((r4 = e4.length) === t3.length)
        for (; r4-- && N(e4[r4], t3[r4]); )
          ;
      return -1 === r4;
    }
    if (n3 === Set) {
      if (e4.size !== t3.size)
        return false;
      for (r4 of e4) {
        if ((i3 = r4) && "object" == typeof i3 && !(i3 = D(t3, i3)))
          return false;
        if (!t3.has(i3))
          return false;
      }
      return true;
    }
    if (n3 === Map) {
      if (e4.size !== t3.size)
        return false;
      for (r4 of e4) {
        if ((i3 = r4[0]) && "object" == typeof i3 && !(i3 = D(t3, i3)))
          return false;
        if (!N(r4[1], t3.get(i3)))
          return false;
      }
      return true;
    }
    if (n3 === ArrayBuffer)
      e4 = new Uint8Array(e4), t3 = new Uint8Array(t3);
    else if (n3 === DataView) {
      if ((r4 = e4.byteLength) === t3.byteLength)
        for (; r4-- && e4.getInt8(r4) === t3.getInt8(r4); )
          ;
      return -1 === r4;
    }
    if (ArrayBuffer.isView(e4)) {
      if ((r4 = e4.byteLength) === t3.byteLength)
        for (; r4-- && e4[r4] === t3[r4]; )
          ;
      return -1 === r4;
    }
    if (!n3 || "object" == typeof e4) {
      for (n3 in r4 = 0, e4) {
        if (L.call(e4, n3) && ++r4 && !L.call(t3, n3))
          return false;
        if (!(n3 in t3) || !N(e4[n3], t3[n3]))
          return false;
      }
      return Object.keys(t3).length === r4;
    }
  }
  return e4 != e4 && t3 != t3;
}
var R = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
var F = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
var B = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
var U = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
var V = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
var J = class _J {
  static getFirstMatch(e4, t3) {
    const n3 = t3.match(e4);
    return n3 && n3.length > 0 && n3[1] || "";
  }
  static getSecondMatch(e4, t3) {
    const n3 = t3.match(e4);
    return n3 && n3.length > 1 && n3[2] || "";
  }
  static matchAndReturnConst(e4, t3, n3) {
    if (e4.test(t3))
      return n3;
  }
  static getWindowsVersionName(e4) {
    switch (e4) {
      case "NT":
        return "NT";
      case "XP":
      case "NT 5.1":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(e4) {
    const t3 = e4.split(".").splice(0, 2).map((e5) => parseInt(e5, 10) || 0);
    if (t3.push(0), 10 === t3[0])
      switch (t3[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  static getAndroidVersionName(e4) {
    const t3 = e4.split(".").splice(0, 2).map((e5) => parseInt(e5, 10) || 0);
    if (t3.push(0), !(1 === t3[0] && t3[1] < 5))
      return 1 === t3[0] && t3[1] < 6 ? "Cupcake" : 1 === t3[0] && t3[1] >= 6 ? "Donut" : 2 === t3[0] && t3[1] < 2 ? "Eclair" : 2 === t3[0] && 2 === t3[1] ? "Froyo" : 2 === t3[0] && t3[1] > 2 ? "Gingerbread" : 3 === t3[0] ? "Honeycomb" : 4 === t3[0] && t3[1] < 1 ? "Ice Cream Sandwich" : 4 === t3[0] && t3[1] < 4 ? "Jelly Bean" : 4 === t3[0] && t3[1] >= 4 ? "KitKat" : 5 === t3[0] ? "Lollipop" : 6 === t3[0] ? "Marshmallow" : 7 === t3[0] ? "Nougat" : 8 === t3[0] ? "Oreo" : 9 === t3[0] ? "Pie" : void 0;
  }
  static getVersionPrecision(e4) {
    return e4.split(".").length;
  }
  static compareVersions(e4, t3, n3 = false) {
    const r4 = _J.getVersionPrecision(e4), i3 = _J.getVersionPrecision(t3);
    let o4 = Math.max(r4, i3), s3 = 0;
    const a3 = _J.map([e4, t3], (e5) => {
      const t4 = o4 - _J.getVersionPrecision(e5), n4 = e5 + new Array(t4 + 1).join(".0");
      return _J.map(n4.split("."), (e6) => new Array(20 - e6.length).join("0") + e6).reverse();
    });
    for (n3 && (s3 = o4 - Math.min(r4, i3)), o4 -= 1; o4 >= s3; ) {
      if (a3[0][o4] > a3[1][o4])
        return 1;
      if (a3[0][o4] === a3[1][o4]) {
        if (o4 === s3)
          return 0;
        o4 -= 1;
      } else if (a3[0][o4] < a3[1][o4])
        return -1;
    }
  }
  static map(e4, t3) {
    const n3 = [];
    let r4;
    if (Array.prototype.map)
      return Array.prototype.map.call(e4, t3);
    for (r4 = 0; r4 < e4.length; r4 += 1)
      n3.push(t3(e4[r4]));
    return n3;
  }
  static find(e4, t3) {
    let n3, r4;
    if (Array.prototype.find)
      return Array.prototype.find.call(e4, t3);
    for (n3 = 0, r4 = e4.length; n3 < r4; n3 += 1) {
      const r5 = e4[n3];
      if (t3(r5, n3))
        return r5;
    }
  }
  static assign(e4, ...t3) {
    const n3 = e4;
    let r4, i3;
    if (Object.assign)
      return Object.assign(e4, ...t3);
    for (r4 = 0, i3 = t3.length; r4 < i3; r4 += 1) {
      const e5 = t3[r4];
      if ("object" == typeof e5 && null !== e5) {
        Object.keys(e5).forEach((t4) => {
          n3[t4] = e5[t4];
        });
      }
    }
    return e4;
  }
  static getBrowserAlias(e4) {
    return R[e4];
  }
  static getBrowserTypeByAlias(e4) {
    return F[e4] || "";
  }
};
var $ = /version\/(\d+(\.?_?\d+)+)/i;
var q = [{ test: [/googlebot/i], describe(e4) {
  const t3 = { name: "Googlebot" }, n3 = J.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opera/i], describe(e4) {
  const t3 = { name: "Opera" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opr\/|opios/i], describe(e4) {
  const t3 = { name: "Opera" }, n3 = J.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/SamsungBrowser/i], describe(e4) {
  const t3 = { name: "Samsung Internet for Android" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/Whale/i], describe(e4) {
  const t3 = { name: "NAVER Whale Browser" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/MZBrowser/i], describe(e4) {
  const t3 = { name: "MZ Browser" }, n3 = J.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/focus/i], describe(e4) {
  const t3 = { name: "Focus" }, n3 = J.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/swing/i], describe(e4) {
  const t3 = { name: "Swing" }, n3 = J.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/coast/i], describe(e4) {
  const t3 = { name: "Opera Coast" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe(e4) {
  const t3 = { name: "Opera Touch" }, n3 = J.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/yabrowser/i], describe(e4) {
  const t3 = { name: "Yandex Browser" }, n3 = J.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/ucbrowser/i], describe(e4) {
  const t3 = { name: "UC Browser" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/Maxthon|mxios/i], describe(e4) {
  const t3 = { name: "Maxthon" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/epiphany/i], describe(e4) {
  const t3 = { name: "Epiphany" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/puffin/i], describe(e4) {
  const t3 = { name: "Puffin" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/sleipnir/i], describe(e4) {
  const t3 = { name: "Sleipnir" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/k-meleon/i], describe(e4) {
  const t3 = { name: "K-Meleon" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/micromessenger/i], describe(e4) {
  const t3 = { name: "WeChat" }, n3 = J.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/qqbrowser/i], describe(e4) {
  const t3 = { name: /qqbrowserlite/i.test(e4) ? "QQ Browser Lite" : "QQ Browser" }, n3 = J.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/msie|trident/i], describe(e4) {
  const t3 = { name: "Internet Explorer" }, n3 = J.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/\sedg\//i], describe(e4) {
  const t3 = { name: "Microsoft Edge" }, n3 = J.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/edg([ea]|ios)/i], describe(e4) {
  const t3 = { name: "Microsoft Edge" }, n3 = J.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/vivaldi/i], describe(e4) {
  const t3 = { name: "Vivaldi" }, n3 = J.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/seamonkey/i], describe(e4) {
  const t3 = { name: "SeaMonkey" }, n3 = J.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/sailfish/i], describe(e4) {
  const t3 = { name: "Sailfish" }, n3 = J.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/silk/i], describe(e4) {
  const t3 = { name: "Amazon Silk" }, n3 = J.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/phantom/i], describe(e4) {
  const t3 = { name: "PhantomJS" }, n3 = J.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/slimerjs/i], describe(e4) {
  const t3 = { name: "SlimerJS" }, n3 = J.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e4) {
  const t3 = { name: "BlackBerry" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/(web|hpw)[o0]s/i], describe(e4) {
  const t3 = { name: "WebOS Browser" }, n3 = J.getFirstMatch($, e4) || J.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/bada/i], describe(e4) {
  const t3 = { name: "Bada" }, n3 = J.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/tizen/i], describe(e4) {
  const t3 = { name: "Tizen" }, n3 = J.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/qupzilla/i], describe(e4) {
  const t3 = { name: "QupZilla" }, n3 = J.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/firefox|iceweasel|fxios/i], describe(e4) {
  const t3 = { name: "Firefox" }, n3 = J.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/electron/i], describe(e4) {
  const t3 = { name: "Electron" }, n3 = J.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/MiuiBrowser/i], describe(e4) {
  const t3 = { name: "Miui" }, n3 = J.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/chromium/i], describe(e4) {
  const t3 = { name: "Chromium" }, n3 = J.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e4) || J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/chrome|crios|crmo/i], describe(e4) {
  const t3 = { name: "Chrome" }, n3 = J.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/GSA/i], describe(e4) {
  const t3 = { name: "Google Search" }, n3 = J.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test(e4) {
  const t3 = !e4.test(/like android/i), n3 = e4.test(/android/i);
  return t3 && n3;
}, describe(e4) {
  const t3 = { name: "Android Browser" }, n3 = J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/playstation 4/i], describe(e4) {
  const t3 = { name: "PlayStation 4" }, n3 = J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/safari|applewebkit/i], describe(e4) {
  const t3 = { name: "Safari" }, n3 = J.getFirstMatch($, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/.*/i], describe(e4) {
  const t3 = -1 !== e4.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
  return { name: J.getFirstMatch(t3, e4), version: J.getSecondMatch(t3, e4) };
} }];
var z = [{ test: [/Roku\/DVP/], describe(e4) {
  const t3 = J.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e4);
  return { name: U.Roku, version: t3 };
} }, { test: [/windows phone/i], describe(e4) {
  const t3 = J.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e4);
  return { name: U.WindowsPhone, version: t3 };
} }, { test: [/windows /i], describe(e4) {
  const t3 = J.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e4), n3 = J.getWindowsVersionName(t3);
  return { name: U.Windows, version: t3, versionName: n3 };
} }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe(e4) {
  const t3 = { name: U.iOS }, n3 = J.getSecondMatch(/(Version\/)(\d[\d.]+)/, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/macintosh/i], describe(e4) {
  const t3 = J.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e4).replace(/[_\s]/g, "."), n3 = J.getMacOSVersionName(t3), r4 = { name: U.MacOS, version: t3 };
  return n3 && (r4.versionName = n3), r4;
} }, { test: [/(ipod|iphone|ipad)/i], describe(e4) {
  const t3 = J.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e4).replace(/[_\s]/g, ".");
  return { name: U.iOS, version: t3 };
} }, { test(e4) {
  const t3 = !e4.test(/like android/i), n3 = e4.test(/android/i);
  return t3 && n3;
}, describe(e4) {
  const t3 = J.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e4), n3 = J.getAndroidVersionName(t3), r4 = { name: U.Android, version: t3 };
  return n3 && (r4.versionName = n3), r4;
} }, { test: [/(web|hpw)[o0]s/i], describe(e4) {
  const t3 = J.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e4), n3 = { name: U.WebOS };
  return t3 && t3.length && (n3.version = t3), n3;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e4) {
  const t3 = J.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e4) || J.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e4) || J.getFirstMatch(/\bbb(\d+)/i, e4);
  return { name: U.BlackBerry, version: t3 };
} }, { test: [/bada/i], describe(e4) {
  const t3 = J.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e4);
  return { name: U.Bada, version: t3 };
} }, { test: [/tizen/i], describe(e4) {
  const t3 = J.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e4);
  return { name: U.Tizen, version: t3 };
} }, { test: [/linux/i], describe: () => ({ name: U.Linux }) }, { test: [/CrOS/], describe: () => ({ name: U.ChromeOS }) }, { test: [/PlayStation 4/], describe(e4) {
  const t3 = J.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e4);
  return { name: U.PlayStation4, version: t3 };
} }];
var W = [{ test: [/googlebot/i], describe: () => ({ type: "bot", vendor: "Google" }) }, { test: [/huawei/i], describe(e4) {
  const t3 = J.getFirstMatch(/(can-l01)/i, e4) && "Nova", n3 = { type: B.mobile, vendor: "Huawei" };
  return t3 && (n3.model = t3), n3;
} }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: () => ({ type: B.tablet, vendor: "Nexus" }) }, { test: [/ipad/i], describe: () => ({ type: B.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: () => ({ type: B.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/kftt build/i], describe: () => ({ type: B.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" }) }, { test: [/silk/i], describe: () => ({ type: B.tablet, vendor: "Amazon" }) }, { test: [/tablet(?! pc)/i], describe: () => ({ type: B.tablet }) }, { test(e4) {
  const t3 = e4.test(/ipod|iphone/i), n3 = e4.test(/like (ipod|iphone)/i);
  return t3 && !n3;
}, describe(e4) {
  const t3 = J.getFirstMatch(/(ipod|iphone)/i, e4);
  return { type: B.mobile, vendor: "Apple", model: t3 };
} }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: () => ({ type: B.mobile, vendor: "Nexus" }) }, { test: [/[^-]mobi/i], describe: () => ({ type: B.mobile }) }, { test: (e4) => "blackberry" === e4.getBrowserName(true), describe: () => ({ type: B.mobile, vendor: "BlackBerry" }) }, { test: (e4) => "bada" === e4.getBrowserName(true), describe: () => ({ type: B.mobile }) }, { test: (e4) => "windows phone" === e4.getBrowserName(), describe: () => ({ type: B.mobile, vendor: "Microsoft" }) }, { test(e4) {
  const t3 = Number(String(e4.getOSVersion()).split(".")[0]);
  return "android" === e4.getOSName(true) && t3 >= 3;
}, describe: () => ({ type: B.tablet }) }, { test: (e4) => "android" === e4.getOSName(true), describe: () => ({ type: B.mobile }) }, { test: (e4) => "macos" === e4.getOSName(true), describe: () => ({ type: B.desktop, vendor: "Apple" }) }, { test: (e4) => "windows" === e4.getOSName(true), describe: () => ({ type: B.desktop }) }, { test: (e4) => "linux" === e4.getOSName(true), describe: () => ({ type: B.desktop }) }, { test: (e4) => "playstation 4" === e4.getOSName(true), describe: () => ({ type: B.tv }) }, { test: (e4) => "roku" === e4.getOSName(true), describe: () => ({ type: B.tv }) }];
var H = [{ test: (e4) => "microsoft edge" === e4.getBrowserName(true), describe(e4) {
  if (/\sedg\//i.test(e4))
    return { name: V.Blink };
  const t3 = J.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e4);
  return { name: V.EdgeHTML, version: t3 };
} }, { test: [/trident/i], describe(e4) {
  const t3 = { name: V.Trident }, n3 = J.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: (e4) => e4.test(/presto/i), describe(e4) {
  const t3 = { name: V.Presto }, n3 = J.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test(e4) {
  const t3 = e4.test(/gecko/i), n3 = e4.test(/like gecko/i);
  return t3 && !n3;
}, describe(e4) {
  const t3 = { name: V.Gecko }, n3 = J.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/(apple)?webkit\/537\.36/i], describe: () => ({ name: V.Blink }) }, { test: [/(apple)?webkit/i], describe(e4) {
  const t3 = { name: V.WebKit }, n3 = J.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }];
var G = class {
  constructor(e4, t3 = false) {
    if (null == e4 || "" === e4)
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e4, this.parsedResult = {}, true !== t3 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(e4) {
    return e4.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const e4 = J.find(q, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.browser = e4.describe(this.getUA())), this.parsedResult.browser;
  }
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  getBrowserName(e4) {
    return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const e4 = J.find(z, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.os = e4.describe(this.getUA())), this.parsedResult.os;
  }
  getOSName(e4) {
    const { name: t3 } = this.getOS();
    return e4 ? String(t3).toLowerCase() || "" : t3 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  getPlatformType(e4 = false) {
    const { type: t3 } = this.getPlatform();
    return e4 ? String(t3).toLowerCase() || "" : t3 || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const e4 = J.find(W, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.platform = e4.describe(this.getUA())), this.parsedResult.platform;
  }
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  getEngineName(e4) {
    return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const e4 = J.find(H, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.engine = e4.describe(this.getUA())), this.parsedResult.engine;
  }
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  getResult() {
    return J.assign({}, this.parsedResult);
  }
  satisfies(e4) {
    const t3 = {};
    let n3 = 0;
    const r4 = {};
    let i3 = 0;
    if (Object.keys(e4).forEach((o4) => {
      const s3 = e4[o4];
      "string" == typeof s3 ? (r4[o4] = s3, i3 += 1) : "object" == typeof s3 && (t3[o4] = s3, n3 += 1);
    }), n3 > 0) {
      const e5 = Object.keys(t3), n4 = J.find(e5, (e6) => this.isOS(e6));
      if (n4) {
        const e6 = this.satisfies(t3[n4]);
        if (void 0 !== e6)
          return e6;
      }
      const r5 = J.find(e5, (e6) => this.isPlatform(e6));
      if (r5) {
        const e6 = this.satisfies(t3[r5]);
        if (void 0 !== e6)
          return e6;
      }
    }
    if (i3 > 0) {
      const e5 = Object.keys(r4), t4 = J.find(e5, (e6) => this.isBrowser(e6, true));
      if (void 0 !== t4)
        return this.compareVersion(r4[t4]);
    }
  }
  isBrowser(e4, t3 = false) {
    const n3 = this.getBrowserName().toLowerCase();
    let r4 = e4.toLowerCase();
    const i3 = J.getBrowserTypeByAlias(r4);
    return t3 && i3 && (r4 = i3.toLowerCase()), r4 === n3;
  }
  compareVersion(e4) {
    let t3 = [0], n3 = e4, r4 = false;
    const i3 = this.getBrowserVersion();
    if ("string" == typeof i3)
      return ">" === e4[0] || "<" === e4[0] ? (n3 = e4.substr(1), "=" === e4[1] ? (r4 = true, n3 = e4.substr(2)) : t3 = [], ">" === e4[0] ? t3.push(1) : t3.push(-1)) : "=" === e4[0] ? n3 = e4.substr(1) : "~" === e4[0] && (r4 = true, n3 = e4.substr(1)), t3.indexOf(J.compareVersions(i3, n3, r4)) > -1;
  }
  isOS(e4) {
    return this.getOSName(true) === String(e4).toLowerCase();
  }
  isPlatform(e4) {
    return this.getPlatformType(true) === String(e4).toLowerCase();
  }
  isEngine(e4) {
    return this.getEngineName(true) === String(e4).toLowerCase();
  }
  is(e4, t3 = false) {
    return this.isBrowser(e4, t3) || this.isOS(e4) || this.isPlatform(e4);
  }
  some(e4 = []) {
    return e4.some((e5) => this.is(e5));
  }
};
var Q = class {
  static getParser(e4, t3 = false) {
    if ("string" != typeof e4)
      throw new Error("UserAgent should be a string");
    return new G(e4, t3);
  }
  static parse(e4) {
    return new G(e4).getResult();
  }
  static get BROWSER_MAP() {
    return F;
  }
  static get ENGINE_MAP() {
    return V;
  }
  static get OS_MAP() {
    return U;
  }
  static get PLATFORMS_MAP() {
    return B;
  }
};
function K() {
  return Date.now() + Math.random().toString();
}
function Y() {
  throw new Error("Method must be implemented in subclass");
}
function X(e4, t3) {
  return null != t3 && t3.proxyUrl ? t3.proxyUrl + ("/" === t3.proxyUrl.slice(-1) ? "" : "/") + e4.substring(8) : e4;
}
function Z(e4) {
  return null != e4 && e4.callObjectBundleUrlOverride ? e4.callObjectBundleUrlOverride : X("https://c.daily.co/call-machine/versioned/".concat("0.77.0", "/static/call-machine-object-bundle.js"), e4);
}
function ee(e4) {
  try {
    new URL(e4);
  } catch (e5) {
    return false;
  }
  return true;
}
var te = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var ne = "8.55.0";
var re = globalThis;
function ie(e4, t3, n3) {
  const r4 = n3 || re, i3 = r4.__SENTRY__ = r4.__SENTRY__ || {}, o4 = i3[ne] = i3[ne] || {};
  return o4[e4] || (o4[e4] = t3());
}
var oe = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var se = ["debug", "info", "warn", "error", "log", "assert", "trace"];
var ae = {};
function ce(e4) {
  if (!("console" in re))
    return e4();
  const t3 = re.console, n3 = {}, r4 = Object.keys(ae);
  r4.forEach((e5) => {
    const r5 = ae[e5];
    n3[e5] = t3[e5], t3[e5] = r5;
  });
  try {
    return e4();
  } finally {
    r4.forEach((e5) => {
      t3[e5] = n3[e5];
    });
  }
}
var le = ie("logger", function() {
  let e4 = false;
  const t3 = { enable: () => {
    e4 = true;
  }, disable: () => {
    e4 = false;
  }, isEnabled: () => e4 };
  return oe ? se.forEach((n3) => {
    t3[n3] = (...t4) => {
      e4 && ce(() => {
        re.console[n3](`Sentry Logger [${n3}]:`, ...t4);
      });
    };
  }) : se.forEach((e5) => {
    t3[e5] = () => {
    };
  }), t3;
});
var ue = "?";
var de = /\(error: (.*)\)/;
var pe = /captureMessage|captureException/;
function he(e4) {
  return e4[e4.length - 1] || {};
}
var fe = "<anonymous>";
function ve(e4) {
  try {
    return e4 && "function" == typeof e4 && e4.name || fe;
  } catch (e5) {
    return fe;
  }
}
function ge(e4) {
  const t3 = e4.exception;
  if (t3) {
    const e5 = [];
    try {
      return t3.values.forEach((t4) => {
        t4.stacktrace.frames && e5.push(...t4.stacktrace.frames);
      }), e5;
    } catch (e6) {
      return;
    }
  }
}
var me = {};
var ye = {};
function be(e4, t3) {
  me[e4] = me[e4] || [], me[e4].push(t3);
}
function _e(e4, t3) {
  if (!ye[e4]) {
    ye[e4] = true;
    try {
      t3();
    } catch (t4) {
      oe && le.error(`Error while instrumenting ${e4}`, t4);
    }
  }
}
function we(e4, t3) {
  const n3 = e4 && me[e4];
  if (n3)
    for (const r4 of n3)
      try {
        r4(t3);
      } catch (t4) {
        oe && le.error(`Error while triggering instrumentation handler.
Type: ${e4}
Name: ${ve(r4)}
Error:`, t4);
      }
}
var Se = null;
function ke() {
  Se = re.onerror, re.onerror = function(e4, t3, n3, r4, i3) {
    return we("error", { column: r4, error: i3, line: n3, msg: e4, url: t3 }), !!Se && Se.apply(this, arguments);
  }, re.onerror.__SENTRY_INSTRUMENTED__ = true;
}
var Me = null;
function Ce() {
  Me = re.onunhandledrejection, re.onunhandledrejection = function(e4) {
    return we("unhandledrejection", e4), !Me || Me.apply(this, arguments);
  }, re.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
function Ee() {
  return Te(re), re;
}
function Te(e4) {
  const t3 = e4.__SENTRY__ = e4.__SENTRY__ || {};
  return t3.version = t3.version || ne, t3[ne] = t3[ne] || {};
}
var Oe = Object.prototype.toString;
function Pe(e4) {
  switch (Oe.call(e4)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return Be(e4, Error);
  }
}
function Ae(e4, t3) {
  return Oe.call(e4) === `[object ${t3}]`;
}
function je(e4) {
  return Ae(e4, "ErrorEvent");
}
function Ie(e4) {
  return Ae(e4, "DOMError");
}
function xe(e4) {
  return Ae(e4, "String");
}
function Le(e4) {
  return "object" == typeof e4 && null !== e4 && "__sentry_template_string__" in e4 && "__sentry_template_values__" in e4;
}
function De(e4) {
  return null === e4 || Le(e4) || "object" != typeof e4 && "function" != typeof e4;
}
function Ne(e4) {
  return Ae(e4, "Object");
}
function Re(e4) {
  return "undefined" != typeof Event && Be(e4, Event);
}
function Fe(e4) {
  return Boolean(e4 && e4.then && "function" == typeof e4.then);
}
function Be(e4, t3) {
  try {
    return e4 instanceof t3;
  } catch (e5) {
    return false;
  }
}
function Ue(e4) {
  return !("object" != typeof e4 || null === e4 || !e4.__isVue && !e4._isVue);
}
var Ve = re;
function Je(e4, t3 = {}) {
  if (!e4)
    return "<unknown>";
  try {
    let n3 = e4;
    const r4 = 5, i3 = [];
    let o4 = 0, s3 = 0;
    const a3 = " > ", c3 = a3.length;
    let l3;
    const u3 = Array.isArray(t3) ? t3 : t3.keyAttrs, d3 = !Array.isArray(t3) && t3.maxStringLength || 80;
    for (; n3 && o4++ < r4 && (l3 = $e(n3, u3), !("html" === l3 || o4 > 1 && s3 + i3.length * c3 + l3.length >= d3)); )
      i3.push(l3), s3 += l3.length, n3 = n3.parentNode;
    return i3.reverse().join(a3);
  } catch (e5) {
    return "<unknown>";
  }
}
function $e(e4, t3) {
  const n3 = e4, r4 = [];
  if (!n3 || !n3.tagName)
    return "";
  if (Ve.HTMLElement && n3 instanceof HTMLElement && n3.dataset) {
    if (n3.dataset.sentryComponent)
      return n3.dataset.sentryComponent;
    if (n3.dataset.sentryElement)
      return n3.dataset.sentryElement;
  }
  r4.push(n3.tagName.toLowerCase());
  const i3 = t3 && t3.length ? t3.filter((e5) => n3.getAttribute(e5)).map((e5) => [e5, n3.getAttribute(e5)]) : null;
  if (i3 && i3.length)
    i3.forEach((e5) => {
      r4.push(`[${e5[0]}="${e5[1]}"]`);
    });
  else {
    n3.id && r4.push(`#${n3.id}`);
    const e5 = n3.className;
    if (e5 && xe(e5)) {
      const t4 = e5.split(/\s+/);
      for (const e6 of t4)
        r4.push(`.${e6}`);
    }
  }
  const o4 = ["aria-label", "type", "name", "title", "alt"];
  for (const e5 of o4) {
    const t4 = n3.getAttribute(e5);
    t4 && r4.push(`[${e5}="${t4}"]`);
  }
  return r4.join("");
}
function qe(e4, t3 = 0) {
  return "string" != typeof e4 || 0 === t3 || e4.length <= t3 ? e4 : `${e4.slice(0, t3)}...`;
}
function ze(e4, t3) {
  if (!Array.isArray(e4))
    return "";
  const n3 = [];
  for (let t4 = 0; t4 < e4.length; t4++) {
    const r4 = e4[t4];
    try {
      Ue(r4) ? n3.push("[VueViewModel]") : n3.push(String(r4));
    } catch (e5) {
      n3.push("[value cannot be serialized]");
    }
  }
  return n3.join(t3);
}
function We(e4, t3, n3 = false) {
  return !!xe(e4) && (Ae(t3, "RegExp") ? t3.test(e4) : !!xe(t3) && (n3 ? e4 === t3 : e4.includes(t3)));
}
function He(e4, t3 = [], n3 = false) {
  return t3.some((t4) => We(e4, t4, n3));
}
function Ge(e4, t3, n3) {
  if (!(t3 in e4))
    return;
  const r4 = e4[t3], i3 = n3(r4);
  "function" == typeof i3 && Ke(i3, r4);
  try {
    e4[t3] = i3;
  } catch (n4) {
    oe && le.log(`Failed to replace method "${t3}" in object`, e4);
  }
}
function Qe(e4, t3, n3) {
  try {
    Object.defineProperty(e4, t3, { value: n3, writable: true, configurable: true });
  } catch (n4) {
    oe && le.log(`Failed to add non-enumerable property "${t3}" to object`, e4);
  }
}
function Ke(e4, t3) {
  try {
    const n3 = t3.prototype || {};
    e4.prototype = t3.prototype = n3, Qe(e4, "__sentry_original__", t3);
  } catch (e5) {
  }
}
function Ye(e4) {
  return e4.__sentry_original__;
}
function Xe(e4) {
  if (Pe(e4))
    return { message: e4.message, name: e4.name, stack: e4.stack, ...et(e4) };
  if (Re(e4)) {
    const t3 = { type: e4.type, target: Ze(e4.target), currentTarget: Ze(e4.currentTarget), ...et(e4) };
    return "undefined" != typeof CustomEvent && Be(e4, CustomEvent) && (t3.detail = e4.detail), t3;
  }
  return e4;
}
function Ze(e4) {
  try {
    return t3 = e4, "undefined" != typeof Element && Be(t3, Element) ? Je(e4) : Object.prototype.toString.call(e4);
  } catch (e5) {
    return "<unknown>";
  }
  var t3;
}
function et(e4) {
  if ("object" == typeof e4 && null !== e4) {
    const t3 = {};
    for (const n3 in e4)
      Object.prototype.hasOwnProperty.call(e4, n3) && (t3[n3] = e4[n3]);
    return t3;
  }
  return {};
}
function tt(e4) {
  return nt(e4, /* @__PURE__ */ new Map());
}
function nt(e4, t3) {
  if (function(e5) {
    if (!Ne(e5))
      return false;
    try {
      const t4 = Object.getPrototypeOf(e5).constructor.name;
      return !t4 || "Object" === t4;
    } catch (e6) {
      return true;
    }
  }(e4)) {
    const n3 = t3.get(e4);
    if (void 0 !== n3)
      return n3;
    const r4 = {};
    t3.set(e4, r4);
    for (const n4 of Object.getOwnPropertyNames(e4))
      void 0 !== e4[n4] && (r4[n4] = nt(e4[n4], t3));
    return r4;
  }
  if (Array.isArray(e4)) {
    const n3 = t3.get(e4);
    if (void 0 !== n3)
      return n3;
    const r4 = [];
    return t3.set(e4, r4), e4.forEach((e5) => {
      r4.push(nt(e5, t3));
    }), r4;
  }
  return e4;
}
function rt() {
  return Date.now() / 1e3;
}
var it = function() {
  const { performance: e4 } = re;
  if (!e4 || !e4.now)
    return rt;
  const t3 = Date.now() - e4.now(), n3 = null == e4.timeOrigin ? t3 : e4.timeOrigin;
  return () => (n3 + e4.now()) / 1e3;
}();
function ot() {
  const e4 = re, t3 = e4.crypto || e4.msCrypto;
  let n3 = () => 16 * Math.random();
  try {
    if (t3 && t3.randomUUID)
      return t3.randomUUID().replace(/-/g, "");
    t3 && t3.getRandomValues && (n3 = () => {
      const e5 = new Uint8Array(1);
      return t3.getRandomValues(e5), e5[0];
    });
  } catch (e5) {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (e5) => (e5 ^ (15 & n3()) >> e5 / 4).toString(16));
}
function st(e4) {
  return e4.exception && e4.exception.values ? e4.exception.values[0] : void 0;
}
function at(e4) {
  const { message: t3, event_id: n3 } = e4;
  if (t3)
    return t3;
  const r4 = st(e4);
  return r4 ? r4.type && r4.value ? `${r4.type}: ${r4.value}` : r4.type || r4.value || n3 || "<unknown>" : n3 || "<unknown>";
}
function ct(e4, t3, n3) {
  const r4 = e4.exception = e4.exception || {}, i3 = r4.values = r4.values || [], o4 = i3[0] = i3[0] || {};
  o4.value || (o4.value = t3 || ""), o4.type || (o4.type = n3 || "Error");
}
function lt(e4, t3) {
  const n3 = st(e4);
  if (!n3)
    return;
  const r4 = n3.mechanism;
  if (n3.mechanism = { type: "generic", handled: true, ...r4, ...t3 }, t3 && "data" in t3) {
    const e5 = { ...r4 && r4.data, ...t3.data };
    n3.mechanism.data = e5;
  }
}
function ut(e4) {
  if (function(e5) {
    try {
      return e5.__sentry_captured__;
    } catch (e6) {
    }
  }(e4))
    return true;
  try {
    Qe(e4, "__sentry_captured__", true);
  } catch (e5) {
  }
  return false;
}
var dt;
function pt(e4) {
  return new ft((t3) => {
    t3(e4);
  });
}
function ht(e4) {
  return new ft((t3, n3) => {
    n3(e4);
  });
}
(() => {
  const { performance: e4 } = re;
  if (!e4 || !e4.now)
    return;
  const t3 = 36e5, n3 = e4.now(), r4 = Date.now(), i3 = e4.timeOrigin ? Math.abs(e4.timeOrigin + n3 - r4) : t3, o4 = i3 < t3, s3 = e4.timing && e4.timing.navigationStart, a3 = "number" == typeof s3 ? Math.abs(s3 + n3 - r4) : t3;
  (o4 || a3 < t3) && (i3 <= a3 && e4.timeOrigin);
})(), function(e4) {
  e4[e4.PENDING = 0] = "PENDING";
  e4[e4.RESOLVED = 1] = "RESOLVED";
  e4[e4.REJECTED = 2] = "REJECTED";
}(dt || (dt = {}));
var ft = class _ft {
  constructor(e4) {
    _ft.prototype.__init.call(this), _ft.prototype.__init2.call(this), _ft.prototype.__init3.call(this), _ft.prototype.__init4.call(this), this._state = dt.PENDING, this._handlers = [];
    try {
      e4(this._resolve, this._reject);
    } catch (e5) {
      this._reject(e5);
    }
  }
  then(e4, t3) {
    return new _ft((n3, r4) => {
      this._handlers.push([false, (t4) => {
        if (e4)
          try {
            n3(e4(t4));
          } catch (e5) {
            r4(e5);
          }
        else
          n3(t4);
      }, (e5) => {
        if (t3)
          try {
            n3(t3(e5));
          } catch (e6) {
            r4(e6);
          }
        else
          r4(e5);
      }]), this._executeHandlers();
    });
  }
  catch(e4) {
    return this.then((e5) => e5, e4);
  }
  finally(e4) {
    return new _ft((t3, n3) => {
      let r4, i3;
      return this.then((t4) => {
        i3 = false, r4 = t4, e4 && e4();
      }, (t4) => {
        i3 = true, r4 = t4, e4 && e4();
      }).then(() => {
        i3 ? n3(r4) : t3(r4);
      });
    });
  }
  __init() {
    this._resolve = (e4) => {
      this._setResult(dt.RESOLVED, e4);
    };
  }
  __init2() {
    this._reject = (e4) => {
      this._setResult(dt.REJECTED, e4);
    };
  }
  __init3() {
    this._setResult = (e4, t3) => {
      this._state === dt.PENDING && (Fe(t3) ? t3.then(this._resolve, this._reject) : (this._state = e4, this._value = t3, this._executeHandlers()));
    };
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === dt.PENDING)
        return;
      const e4 = this._handlers.slice();
      this._handlers = [], e4.forEach((e5) => {
        e5[0] || (this._state === dt.RESOLVED && e5[1](this._value), this._state === dt.REJECTED && e5[2](this._value), e5[0] = true);
      });
    };
  }
};
function vt(e4) {
  const t3 = it(), n3 = { sid: ot(), init: true, timestamp: t3, started: t3, duration: 0, status: "ok", errors: 0, ignoreDuration: false, toJSON: () => function(e5) {
    return tt({ sid: `${e5.sid}`, init: e5.init, started: new Date(1e3 * e5.started).toISOString(), timestamp: new Date(1e3 * e5.timestamp).toISOString(), status: e5.status, errors: e5.errors, did: "number" == typeof e5.did || "string" == typeof e5.did ? `${e5.did}` : void 0, duration: e5.duration, abnormal_mechanism: e5.abnormal_mechanism, attrs: { release: e5.release, environment: e5.environment, ip_address: e5.ipAddress, user_agent: e5.userAgent } });
  }(n3) };
  return e4 && gt(n3, e4), n3;
}
function gt(e4, t3 = {}) {
  if (t3.user && (!e4.ipAddress && t3.user.ip_address && (e4.ipAddress = t3.user.ip_address), e4.did || t3.did || (e4.did = t3.user.id || t3.user.email || t3.user.username)), e4.timestamp = t3.timestamp || it(), t3.abnormal_mechanism && (e4.abnormal_mechanism = t3.abnormal_mechanism), t3.ignoreDuration && (e4.ignoreDuration = t3.ignoreDuration), t3.sid && (e4.sid = 32 === t3.sid.length ? t3.sid : ot()), void 0 !== t3.init && (e4.init = t3.init), !e4.did && t3.did && (e4.did = `${t3.did}`), "number" == typeof t3.started && (e4.started = t3.started), e4.ignoreDuration)
    e4.duration = void 0;
  else if ("number" == typeof t3.duration)
    e4.duration = t3.duration;
  else {
    const t4 = e4.timestamp - e4.started;
    e4.duration = t4 >= 0 ? t4 : 0;
  }
  t3.release && (e4.release = t3.release), t3.environment && (e4.environment = t3.environment), !e4.ipAddress && t3.ipAddress && (e4.ipAddress = t3.ipAddress), !e4.userAgent && t3.userAgent && (e4.userAgent = t3.userAgent), "number" == typeof t3.errors && (e4.errors = t3.errors), t3.status && (e4.status = t3.status);
}
function mt() {
  return ot();
}
function yt() {
  return ot().substring(16);
}
function bt(e4, t3, n3 = 2) {
  if (!t3 || "object" != typeof t3 || n3 <= 0)
    return t3;
  if (e4 && t3 && 0 === Object.keys(t3).length)
    return e4;
  const r4 = { ...e4 };
  for (const e5 in t3)
    Object.prototype.hasOwnProperty.call(t3, e5) && (r4[e5] = bt(r4[e5], t3[e5], n3 - 1));
  return r4;
}
var _t = "_sentrySpan";
function wt(e4, t3) {
  t3 ? Qe(e4, _t, t3) : delete e4[_t];
}
function St(e4) {
  return e4[_t];
}
var kt = class _kt {
  constructor() {
    this._notifyingListeners = false, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = { traceId: mt(), spanId: yt() };
  }
  clone() {
    const e4 = new _kt();
    return e4._breadcrumbs = [...this._breadcrumbs], e4._tags = { ...this._tags }, e4._extra = { ...this._extra }, e4._contexts = { ...this._contexts }, this._contexts.flags && (e4._contexts.flags = { values: [...this._contexts.flags.values] }), e4._user = this._user, e4._level = this._level, e4._session = this._session, e4._transactionName = this._transactionName, e4._fingerprint = this._fingerprint, e4._eventProcessors = [...this._eventProcessors], e4._requestSession = this._requestSession, e4._attachments = [...this._attachments], e4._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e4._propagationContext = { ...this._propagationContext }, e4._client = this._client, e4._lastEventId = this._lastEventId, wt(e4, St(this)), e4;
  }
  setClient(e4) {
    this._client = e4;
  }
  setLastEventId(e4) {
    this._lastEventId = e4;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(e4) {
    this._scopeListeners.push(e4);
  }
  addEventProcessor(e4) {
    return this._eventProcessors.push(e4), this;
  }
  setUser(e4) {
    return this._user = e4 || { email: void 0, id: void 0, ip_address: void 0, username: void 0 }, this._session && gt(this._session, { user: e4 }), this._notifyScopeListeners(), this;
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(e4) {
    return this._requestSession = e4, this;
  }
  setTags(e4) {
    return this._tags = { ...this._tags, ...e4 }, this._notifyScopeListeners(), this;
  }
  setTag(e4, t3) {
    return this._tags = { ...this._tags, [e4]: t3 }, this._notifyScopeListeners(), this;
  }
  setExtras(e4) {
    return this._extra = { ...this._extra, ...e4 }, this._notifyScopeListeners(), this;
  }
  setExtra(e4, t3) {
    return this._extra = { ...this._extra, [e4]: t3 }, this._notifyScopeListeners(), this;
  }
  setFingerprint(e4) {
    return this._fingerprint = e4, this._notifyScopeListeners(), this;
  }
  setLevel(e4) {
    return this._level = e4, this._notifyScopeListeners(), this;
  }
  setTransactionName(e4) {
    return this._transactionName = e4, this._notifyScopeListeners(), this;
  }
  setContext(e4, t3) {
    return null === t3 ? delete this._contexts[e4] : this._contexts[e4] = t3, this._notifyScopeListeners(), this;
  }
  setSession(e4) {
    return e4 ? this._session = e4 : delete this._session, this._notifyScopeListeners(), this;
  }
  getSession() {
    return this._session;
  }
  update(e4) {
    if (!e4)
      return this;
    const t3 = "function" == typeof e4 ? e4(this) : e4, [n3, r4] = t3 instanceof Mt ? [t3.getScopeData(), t3.getRequestSession()] : Ne(t3) ? [e4, e4.requestSession] : [], { tags: i3, extra: o4, user: s3, contexts: a3, level: c3, fingerprint: l3 = [], propagationContext: u3 } = n3 || {};
    return this._tags = { ...this._tags, ...i3 }, this._extra = { ...this._extra, ...o4 }, this._contexts = { ...this._contexts, ...a3 }, s3 && Object.keys(s3).length && (this._user = s3), c3 && (this._level = c3), l3.length && (this._fingerprint = l3), u3 && (this._propagationContext = u3), r4 && (this._requestSession = r4), this;
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, wt(this, void 0), this._attachments = [], this.setPropagationContext({ traceId: mt() }), this._notifyScopeListeners(), this;
  }
  addBreadcrumb(e4, t3) {
    const n3 = "number" == typeof t3 ? t3 : 100;
    if (n3 <= 0)
      return this;
    const r4 = { timestamp: rt(), ...e4 };
    return this._breadcrumbs.push(r4), this._breadcrumbs.length > n3 && (this._breadcrumbs = this._breadcrumbs.slice(-n3), this._client && this._client.recordDroppedEvent("buffer_overflow", "log_item")), this._notifyScopeListeners(), this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  addAttachment(e4) {
    return this._attachments.push(e4), this;
  }
  clearAttachments() {
    return this._attachments = [], this;
  }
  getScopeData() {
    return { breadcrumbs: this._breadcrumbs, attachments: this._attachments, contexts: this._contexts, tags: this._tags, extra: this._extra, user: this._user, level: this._level, fingerprint: this._fingerprint || [], eventProcessors: this._eventProcessors, propagationContext: this._propagationContext, sdkProcessingMetadata: this._sdkProcessingMetadata, transactionName: this._transactionName, span: St(this) };
  }
  setSDKProcessingMetadata(e4) {
    return this._sdkProcessingMetadata = bt(this._sdkProcessingMetadata, e4, 2), this;
  }
  setPropagationContext(e4) {
    return this._propagationContext = { spanId: yt(), ...e4 }, this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(e4, t3) {
    const n3 = t3 && t3.event_id ? t3.event_id : ot();
    if (!this._client)
      return le.warn("No client configured on scope - will not capture exception!"), n3;
    const r4 = new Error("Sentry syntheticException");
    return this._client.captureException(e4, { originalException: e4, syntheticException: r4, ...t3, event_id: n3 }, this), n3;
  }
  captureMessage(e4, t3, n3) {
    const r4 = n3 && n3.event_id ? n3.event_id : ot();
    if (!this._client)
      return le.warn("No client configured on scope - will not capture message!"), r4;
    const i3 = new Error(e4);
    return this._client.captureMessage(e4, t3, { originalException: e4, syntheticException: i3, ...n3, event_id: r4 }, this), r4;
  }
  captureEvent(e4, t3) {
    const n3 = t3 && t3.event_id ? t3.event_id : ot();
    return this._client ? (this._client.captureEvent(e4, { ...t3, event_id: n3 }, this), n3) : (le.warn("No client configured on scope - will not capture event!"), n3);
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = true, this._scopeListeners.forEach((e4) => {
      e4(this);
    }), this._notifyingListeners = false);
  }
};
var Mt = kt;
var Ct = class {
  constructor(e4, t3) {
    let n3, r4;
    n3 = e4 || new Mt(), r4 = t3 || new Mt(), this._stack = [{ scope: n3 }], this._isolationScope = r4;
  }
  withScope(e4) {
    const t3 = this._pushScope();
    let n3;
    try {
      n3 = e4(t3);
    } catch (e5) {
      throw this._popScope(), e5;
    }
    return Fe(n3) ? n3.then((e5) => (this._popScope(), e5), (e5) => {
      throw this._popScope(), e5;
    }) : (this._popScope(), n3);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const e4 = this.getScope().clone();
    return this._stack.push({ client: this.getClient(), scope: e4 }), e4;
  }
  _popScope() {
    return !(this._stack.length <= 1) && !!this._stack.pop();
  }
};
function Et() {
  const e4 = Te(Ee());
  return e4.stack = e4.stack || new Ct(ie("defaultCurrentScope", () => new Mt()), ie("defaultIsolationScope", () => new Mt()));
}
function Tt(e4) {
  return Et().withScope(e4);
}
function Ot(e4, t3) {
  const n3 = Et();
  return n3.withScope(() => (n3.getStackTop().scope = e4, t3(e4)));
}
function Pt(e4) {
  return Et().withScope(() => e4(Et().getIsolationScope()));
}
function At(e4) {
  const t3 = Te(e4);
  return t3.acs ? t3.acs : { withIsolationScope: Pt, withScope: Tt, withSetScope: Ot, withSetIsolationScope: (e5, t4) => Pt(t4), getCurrentScope: () => Et().getScope(), getIsolationScope: () => Et().getIsolationScope() };
}
function jt() {
  return At(Ee()).getCurrentScope();
}
function It() {
  return At(Ee()).getIsolationScope();
}
function xt() {
  return jt().getClient();
}
function Lt(e4) {
  const t3 = e4.getPropagationContext(), { traceId: n3, spanId: r4, parentSpanId: i3 } = t3;
  return tt({ trace_id: n3, span_id: r4, parent_span_id: i3 });
}
function Dt(e4) {
  const t3 = e4._sentryMetrics;
  if (!t3)
    return;
  const n3 = {};
  for (const [, [e5, r4]] of t3) {
    (n3[e5] || (n3[e5] = [])).push(tt(r4));
  }
  return n3;
}
var Nt = /^sentry-/;
function Rt(e4) {
  const t3 = function(e5) {
    if (!e5 || !xe(e5) && !Array.isArray(e5))
      return;
    if (Array.isArray(e5))
      return e5.reduce((e6, t4) => {
        const n4 = Ft(t4);
        return Object.entries(n4).forEach(([t5, n5]) => {
          e6[t5] = n5;
        }), e6;
      }, {});
    return Ft(e5);
  }(e4);
  if (!t3)
    return;
  const n3 = Object.entries(t3).reduce((e5, [t4, n4]) => {
    if (t4.match(Nt)) {
      e5[t4.slice(7)] = n4;
    }
    return e5;
  }, {});
  return Object.keys(n3).length > 0 ? n3 : void 0;
}
function Ft(e4) {
  return e4.split(",").map((e5) => e5.split("=").map((e6) => decodeURIComponent(e6.trim()))).reduce((e5, [t3, n3]) => (t3 && n3 && (e5[t3] = n3), e5), {});
}
var Bt = false;
function Ut(e4) {
  const { spanId: t3, traceId: n3, isRemote: r4 } = e4.spanContext();
  return tt({ parent_span_id: r4 ? t3 : $t(e4).parent_span_id, span_id: r4 ? yt() : t3, trace_id: n3 });
}
function Vt(e4) {
  return "number" == typeof e4 ? Jt(e4) : Array.isArray(e4) ? e4[0] + e4[1] / 1e9 : e4 instanceof Date ? Jt(e4.getTime()) : it();
}
function Jt(e4) {
  return e4 > 9999999999 ? e4 / 1e3 : e4;
}
function $t(e4) {
  if (function(e5) {
    return "function" == typeof e5.getSpanJSON;
  }(e4))
    return e4.getSpanJSON();
  try {
    const { spanId: t3, traceId: n3 } = e4.spanContext();
    if (function(e5) {
      const t4 = e5;
      return !!(t4.attributes && t4.startTime && t4.name && t4.endTime && t4.status);
    }(e4)) {
      const { attributes: r4, startTime: i3, name: o4, endTime: s3, parentSpanId: a3, status: c3 } = e4;
      return tt({ span_id: t3, trace_id: n3, data: r4, description: o4, parent_span_id: a3, start_timestamp: Vt(i3), timestamp: Vt(s3) || void 0, status: qt(c3), op: r4["sentry.op"], origin: r4["sentry.origin"], _metrics_summary: Dt(e4) });
    }
    return { span_id: t3, trace_id: n3 };
  } catch (e5) {
    return {};
  }
}
function qt(e4) {
  if (e4 && 0 !== e4.code)
    return 1 === e4.code ? "ok" : e4.message || "unknown_error";
}
function zt(e4) {
  return e4._sentryRootSpan || e4;
}
function Wt() {
  Bt || (ce(() => {
    console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.");
  }), Bt = true);
}
var Ht = "production";
function Gt(e4, t3) {
  const n3 = t3.getOptions(), { publicKey: r4 } = t3.getDsn() || {}, i3 = tt({ environment: n3.environment || Ht, release: n3.release, public_key: r4, trace_id: e4 });
  return t3.emit("createDsc", i3), i3;
}
function Qt(e4) {
  const t3 = xt();
  if (!t3)
    return {};
  const n3 = zt(e4), r4 = n3._frozenDsc;
  if (r4)
    return r4;
  const i3 = n3.spanContext().traceState, o4 = i3 && i3.get("sentry.dsc"), s3 = o4 && Rt(o4);
  if (s3)
    return s3;
  const a3 = Gt(e4.spanContext().traceId, t3), c3 = $t(n3), l3 = c3.data || {}, u3 = l3["sentry.sample_rate"];
  null != u3 && (a3.sample_rate = `${u3}`);
  const d3 = l3["sentry.source"], p3 = c3.description;
  return "url" !== d3 && p3 && (a3.transaction = p3), function(e5) {
    if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
      return false;
    const t4 = xt(), n4 = e5 || t4 && t4.getOptions();
    return !!n4 && (n4.enableTracing || "tracesSampleRate" in n4 || "tracesSampler" in n4);
  }() && (a3.sampled = String(function(e5) {
    const { traceFlags: t4 } = e5.spanContext();
    return 1 === t4;
  }(n3))), t3.emit("createDsc", a3, n3), a3;
}
var Kt = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Yt(e4, t3 = false) {
  const { host: n3, path: r4, pass: i3, port: o4, projectId: s3, protocol: a3, publicKey: c3 } = e4;
  return `${a3}://${c3}${t3 && i3 ? `:${i3}` : ""}@${n3}${o4 ? `:${o4}` : ""}/${r4 ? `${r4}/` : r4}${s3}`;
}
function Xt(e4) {
  return { protocol: e4.protocol, publicKey: e4.publicKey || "", pass: e4.pass || "", host: e4.host, port: e4.port || "", path: e4.path || "", projectId: e4.projectId };
}
function Zt(e4) {
  const t3 = "string" == typeof e4 ? function(e5) {
    const t4 = Kt.exec(e5);
    if (!t4)
      return void ce(() => {
        console.error(`Invalid Sentry Dsn: ${e5}`);
      });
    const [n3, r4, i3 = "", o4 = "", s3 = "", a3 = ""] = t4.slice(1);
    let c3 = "", l3 = a3;
    const u3 = l3.split("/");
    if (u3.length > 1 && (c3 = u3.slice(0, -1).join("/"), l3 = u3.pop()), l3) {
      const e6 = l3.match(/^\d+/);
      e6 && (l3 = e6[0]);
    }
    return Xt({ host: o4, pass: i3, path: c3, projectId: l3, port: s3, protocol: n3, publicKey: r4 });
  }(e4) : Xt(e4);
  if (t3 && function(e5) {
    if (!oe)
      return true;
    const { port: t4, projectId: n3, protocol: r4 } = e5;
    return !(["protocol", "publicKey", "host", "projectId"].find((t5) => !e5[t5] && (le.error(`Invalid Sentry Dsn: ${t5} missing`), true)) || (n3.match(/^\d+$/) ? function(e6) {
      return "http" === e6 || "https" === e6;
    }(r4) ? t4 && isNaN(parseInt(t4, 10)) && (le.error(`Invalid Sentry Dsn: Invalid port ${t4}`), 1) : (le.error(`Invalid Sentry Dsn: Invalid protocol ${r4}`), 1) : (le.error(`Invalid Sentry Dsn: Invalid projectId ${n3}`), 1)));
  }(t3))
    return t3;
}
function en(e4, t3 = 100, n3 = 1 / 0) {
  try {
    return nn("", e4, t3, n3);
  } catch (e5) {
    return { ERROR: `**non-serializable** (${e5})` };
  }
}
function tn(e4, t3 = 3, n3 = 102400) {
  const r4 = en(e4, t3);
  return i3 = r4, function(e5) {
    return ~-encodeURI(e5).split(/%..|./).length;
  }(JSON.stringify(i3)) > n3 ? tn(e4, t3 - 1, n3) : r4;
  var i3;
}
function nn(e4, t3, n3 = 1 / 0, r4 = 1 / 0, i3 = function() {
  const e5 = "function" == typeof WeakSet, t4 = e5 ? /* @__PURE__ */ new WeakSet() : [];
  return [function(n4) {
    if (e5)
      return !!t4.has(n4) || (t4.add(n4), false);
    for (let e6 = 0; e6 < t4.length; e6++)
      if (t4[e6] === n4)
        return true;
    return t4.push(n4), false;
  }, function(n4) {
    if (e5)
      t4.delete(n4);
    else
      for (let e6 = 0; e6 < t4.length; e6++)
        if (t4[e6] === n4) {
          t4.splice(e6, 1);
          break;
        }
  }];
}()) {
  const [o4, s3] = i3;
  if (null == t3 || ["boolean", "string"].includes(typeof t3) || "number" == typeof t3 && Number.isFinite(t3))
    return t3;
  const a3 = function(e5, t4) {
    try {
      if ("domain" === e5 && t4 && "object" == typeof t4 && t4._events)
        return "[Domain]";
      if ("domainEmitter" === e5)
        return "[DomainEmitter]";
      if ("undefined" != typeof global && t4 === global)
        return "[Global]";
      if ("undefined" != typeof window && t4 === window)
        return "[Window]";
      if ("undefined" != typeof document && t4 === document)
        return "[Document]";
      if (Ue(t4))
        return "[VueViewModel]";
      if (Ne(n4 = t4) && "nativeEvent" in n4 && "preventDefault" in n4 && "stopPropagation" in n4)
        return "[SyntheticEvent]";
      if ("number" == typeof t4 && !Number.isFinite(t4))
        return `[${t4}]`;
      if ("function" == typeof t4)
        return `[Function: ${ve(t4)}]`;
      if ("symbol" == typeof t4)
        return `[${String(t4)}]`;
      if ("bigint" == typeof t4)
        return `[BigInt: ${String(t4)}]`;
      const r5 = function(e6) {
        const t5 = Object.getPrototypeOf(e6);
        return t5 ? t5.constructor.name : "null prototype";
      }(t4);
      return /^HTML(\w*)Element$/.test(r5) ? `[HTMLElement: ${r5}]` : `[object ${r5}]`;
    } catch (e6) {
      return `**non-serializable** (${e6})`;
    }
    var n4;
  }(e4, t3);
  if (!a3.startsWith("[object "))
    return a3;
  if (t3.__sentry_skip_normalization__)
    return t3;
  const c3 = "number" == typeof t3.__sentry_override_normalization_depth__ ? t3.__sentry_override_normalization_depth__ : n3;
  if (0 === c3)
    return a3.replace("object ", "");
  if (o4(t3))
    return "[Circular ~]";
  const l3 = t3;
  if (l3 && "function" == typeof l3.toJSON)
    try {
      return nn("", l3.toJSON(), c3 - 1, r4, i3);
    } catch (e5) {
    }
  const u3 = Array.isArray(t3) ? [] : {};
  let d3 = 0;
  const p3 = Xe(t3);
  for (const e5 in p3) {
    if (!Object.prototype.hasOwnProperty.call(p3, e5))
      continue;
    if (d3 >= r4) {
      u3[e5] = "[MaxProperties ~]";
      break;
    }
    const t4 = p3[e5];
    u3[e5] = nn(e5, t4, c3 - 1, r4, i3), d3++;
  }
  return s3(t3), u3;
}
function rn(e4, t3 = []) {
  return [e4, t3];
}
function on(e4, t3) {
  const [n3, r4] = e4;
  return [n3, [...r4, t3]];
}
function sn(e4, t3) {
  const n3 = e4[1];
  for (const e5 of n3) {
    if (t3(e5, e5[0].type))
      return true;
  }
  return false;
}
function an(e4) {
  return re.__SENTRY__ && re.__SENTRY__.encodePolyfill ? re.__SENTRY__.encodePolyfill(e4) : new TextEncoder().encode(e4);
}
function cn(e4) {
  const [t3, n3] = e4;
  let r4 = JSON.stringify(t3);
  function i3(e5) {
    "string" == typeof r4 ? r4 = "string" == typeof e5 ? r4 + e5 : [an(r4), e5] : r4.push("string" == typeof e5 ? an(e5) : e5);
  }
  for (const e5 of n3) {
    const [t4, n4] = e5;
    if (i3(`
${JSON.stringify(t4)}
`), "string" == typeof n4 || n4 instanceof Uint8Array)
      i3(n4);
    else {
      let e6;
      try {
        e6 = JSON.stringify(n4);
      } catch (t5) {
        e6 = JSON.stringify(en(n4));
      }
      i3(e6);
    }
  }
  return "string" == typeof r4 ? r4 : function(e5) {
    const t4 = e5.reduce((e6, t5) => e6 + t5.length, 0), n4 = new Uint8Array(t4);
    let r5 = 0;
    for (const t5 of e5)
      n4.set(t5, r5), r5 += t5.length;
    return n4;
  }(r4);
}
function ln(e4) {
  const t3 = "string" == typeof e4.data ? an(e4.data) : e4.data;
  return [tt({ type: "attachment", length: t3.length, filename: e4.filename, content_type: e4.contentType, attachment_type: e4.attachmentType }), t3];
}
var un = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", profile_chunk: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor", feedback: "feedback", span: "span", statsd: "metric_bucket", raw_security: "security" };
function dn(e4) {
  return un[e4];
}
function pn(e4) {
  if (!e4 || !e4.sdk)
    return;
  const { name: t3, version: n3 } = e4.sdk;
  return { name: t3, version: n3 };
}
function hn(e4, t3, n3, r4) {
  const i3 = pn(n3), o4 = e4.type && "replay_event" !== e4.type ? e4.type : "event";
  !function(e5, t4) {
    t4 && (e5.sdk = e5.sdk || {}, e5.sdk.name = e5.sdk.name || t4.name, e5.sdk.version = e5.sdk.version || t4.version, e5.sdk.integrations = [...e5.sdk.integrations || [], ...t4.integrations || []], e5.sdk.packages = [...e5.sdk.packages || [], ...t4.packages || []]);
  }(e4, n3 && n3.sdk);
  const s3 = function(e5, t4, n4, r5) {
    const i4 = e5.sdkProcessingMetadata && e5.sdkProcessingMetadata.dynamicSamplingContext;
    return { event_id: e5.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t4 && { sdk: t4 }, ...!!n4 && r5 && { dsn: Yt(r5) }, ...i4 && { trace: tt({ ...i4 }) } };
  }(e4, i3, r4, t3);
  delete e4.sdkProcessingMetadata;
  return rn(s3, [[{ type: o4 }, e4]]);
}
function fn(e4, t3, n3, r4 = 0) {
  return new ft((i3, o4) => {
    const s3 = e4[r4];
    if (null === t3 || "function" != typeof s3)
      i3(t3);
    else {
      const a3 = s3({ ...t3 }, n3);
      te && s3.id && null === a3 && le.log(`Event processor "${s3.id}" dropped event`), Fe(a3) ? a3.then((t4) => fn(e4, t4, n3, r4 + 1).then(i3)).then(null, o4) : fn(e4, a3, n3, r4 + 1).then(i3).then(null, o4);
    }
  });
}
var vn;
var gn;
var mn;
function yn(e4, t3) {
  const { fingerprint: n3, span: r4, breadcrumbs: i3, sdkProcessingMetadata: o4 } = t3;
  !function(e5, t4) {
    const { extra: n4, tags: r5, user: i4, contexts: o5, level: s3, transactionName: a3 } = t4, c3 = tt(n4);
    c3 && Object.keys(c3).length && (e5.extra = { ...c3, ...e5.extra });
    const l3 = tt(r5);
    l3 && Object.keys(l3).length && (e5.tags = { ...l3, ...e5.tags });
    const u3 = tt(i4);
    u3 && Object.keys(u3).length && (e5.user = { ...u3, ...e5.user });
    const d3 = tt(o5);
    d3 && Object.keys(d3).length && (e5.contexts = { ...d3, ...e5.contexts });
    s3 && (e5.level = s3);
    a3 && "transaction" !== e5.type && (e5.transaction = a3);
  }(e4, t3), r4 && function(e5, t4) {
    e5.contexts = { trace: Ut(t4), ...e5.contexts }, e5.sdkProcessingMetadata = { dynamicSamplingContext: Qt(t4), ...e5.sdkProcessingMetadata };
    const n4 = zt(t4), r5 = $t(n4).description;
    r5 && !e5.transaction && "transaction" === e5.type && (e5.transaction = r5);
  }(e4, r4), function(e5, t4) {
    e5.fingerprint = e5.fingerprint ? Array.isArray(e5.fingerprint) ? e5.fingerprint : [e5.fingerprint] : [], t4 && (e5.fingerprint = e5.fingerprint.concat(t4));
    e5.fingerprint && !e5.fingerprint.length && delete e5.fingerprint;
  }(e4, n3), function(e5, t4) {
    const n4 = [...e5.breadcrumbs || [], ...t4];
    e5.breadcrumbs = n4.length ? n4 : void 0;
  }(e4, i3), function(e5, t4) {
    e5.sdkProcessingMetadata = { ...e5.sdkProcessingMetadata, ...t4 };
  }(e4, o4);
}
function bn(e4, t3) {
  const { extra: n3, tags: r4, user: i3, contexts: o4, level: s3, sdkProcessingMetadata: a3, breadcrumbs: c3, fingerprint: l3, eventProcessors: u3, attachments: d3, propagationContext: p3, transactionName: h4, span: f3 } = t3;
  _n(e4, "extra", n3), _n(e4, "tags", r4), _n(e4, "user", i3), _n(e4, "contexts", o4), e4.sdkProcessingMetadata = bt(e4.sdkProcessingMetadata, a3, 2), s3 && (e4.level = s3), h4 && (e4.transactionName = h4), f3 && (e4.span = f3), c3.length && (e4.breadcrumbs = [...e4.breadcrumbs, ...c3]), l3.length && (e4.fingerprint = [...e4.fingerprint, ...l3]), u3.length && (e4.eventProcessors = [...e4.eventProcessors, ...u3]), d3.length && (e4.attachments = [...e4.attachments, ...d3]), e4.propagationContext = { ...e4.propagationContext, ...p3 };
}
function _n(e4, t3, n3) {
  e4[t3] = bt(e4[t3], n3, 1);
}
function wn(e4, t3, n3, r4, i3, o4) {
  const { normalizeDepth: s3 = 3, normalizeMaxBreadth: a3 = 1e3 } = e4, c3 = { ...t3, event_id: t3.event_id || n3.event_id || ot(), timestamp: t3.timestamp || rt() }, l3 = n3.integrations || e4.integrations.map((e5) => e5.name);
  !function(e5, t4) {
    const { environment: n4, release: r5, dist: i4, maxValueLength: o5 = 250 } = t4;
    e5.environment = e5.environment || n4 || Ht, !e5.release && r5 && (e5.release = r5);
    !e5.dist && i4 && (e5.dist = i4);
    e5.message && (e5.message = qe(e5.message, o5));
    const s4 = e5.exception && e5.exception.values && e5.exception.values[0];
    s4 && s4.value && (s4.value = qe(s4.value, o5));
    const a4 = e5.request;
    a4 && a4.url && (a4.url = qe(a4.url, o5));
  }(c3, e4), function(e5, t4) {
    t4.length > 0 && (e5.sdk = e5.sdk || {}, e5.sdk.integrations = [...e5.sdk.integrations || [], ...t4]);
  }(c3, l3), i3 && i3.emit("applyFrameMetadata", t3), void 0 === t3.type && function(e5, t4) {
    const n4 = function(e6) {
      const t5 = re._sentryDebugIds;
      if (!t5)
        return {};
      const n5 = Object.keys(t5);
      return mn && n5.length === gn || (gn = n5.length, mn = n5.reduce((n6, r5) => {
        vn || (vn = {});
        const i4 = vn[r5];
        if (i4)
          n6[i4[0]] = i4[1];
        else {
          const i5 = e6(r5);
          for (let e7 = i5.length - 1; e7 >= 0; e7--) {
            const o5 = i5[e7], s4 = o5 && o5.filename, a4 = t5[r5];
            if (s4 && a4) {
              n6[s4] = a4, vn[r5] = [s4, a4];
              break;
            }
          }
        }
        return n6;
      }, {})), mn;
    }(t4);
    try {
      e5.exception.values.forEach((e6) => {
        e6.stacktrace.frames.forEach((e7) => {
          n4 && e7.filename && (e7.debug_id = n4[e7.filename]);
        });
      });
    } catch (e6) {
    }
  }(c3, e4.stackParser);
  const u3 = function(e5, t4) {
    if (!t4)
      return e5;
    const n4 = e5 ? e5.clone() : new Mt();
    return n4.update(t4), n4;
  }(r4, n3.captureContext);
  n3.mechanism && lt(c3, n3.mechanism);
  const d3 = i3 ? i3.getEventProcessors() : [], p3 = ie("globalScope", () => new Mt()).getScopeData();
  if (o4) {
    bn(p3, o4.getScopeData());
  }
  if (u3) {
    bn(p3, u3.getScopeData());
  }
  const h4 = [...n3.attachments || [], ...p3.attachments];
  h4.length && (n3.attachments = h4), yn(c3, p3);
  return fn([...d3, ...p3.eventProcessors], c3, n3).then((e5) => (e5 && function(e6) {
    const t4 = {};
    try {
      e6.exception.values.forEach((e7) => {
        e7.stacktrace.frames.forEach((e8) => {
          e8.debug_id && (e8.abs_path ? t4[e8.abs_path] = e8.debug_id : e8.filename && (t4[e8.filename] = e8.debug_id), delete e8.debug_id);
        });
      });
    } catch (e7) {
    }
    if (0 === Object.keys(t4).length)
      return;
    e6.debug_meta = e6.debug_meta || {}, e6.debug_meta.images = e6.debug_meta.images || [];
    const n4 = e6.debug_meta.images;
    Object.entries(t4).forEach(([e7, t5]) => {
      n4.push({ type: "sourcemap", code_file: e7, debug_id: t5 });
    });
  }(e5), "number" == typeof s3 && s3 > 0 ? function(e6, t4, n4) {
    if (!e6)
      return null;
    const r5 = { ...e6, ...e6.breadcrumbs && { breadcrumbs: e6.breadcrumbs.map((e7) => ({ ...e7, ...e7.data && { data: en(e7.data, t4, n4) } })) }, ...e6.user && { user: en(e6.user, t4, n4) }, ...e6.contexts && { contexts: en(e6.contexts, t4, n4) }, ...e6.extra && { extra: en(e6.extra, t4, n4) } };
    e6.contexts && e6.contexts.trace && r5.contexts && (r5.contexts.trace = e6.contexts.trace, e6.contexts.trace.data && (r5.contexts.trace.data = en(e6.contexts.trace.data, t4, n4)));
    e6.spans && (r5.spans = e6.spans.map((e7) => ({ ...e7, ...e7.data && { data: en(e7.data, t4, n4) } })));
    e6.contexts && e6.contexts.flags && r5.contexts && (r5.contexts.flags = en(e6.contexts.flags, 3, n4));
    return r5;
  }(e5, s3, a3) : e5));
}
function Sn(e4) {
  if (e4)
    return function(e5) {
      return e5 instanceof Mt || "function" == typeof e5;
    }(e4) || function(e5) {
      return Object.keys(e5).some((e6) => kn.includes(e6));
    }(e4) ? { captureContext: e4 } : e4;
}
var kn = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
function Mn(e4, t3) {
  return jt().captureEvent(e4, t3);
}
function Cn(e4) {
  const t3 = xt(), n3 = It(), r4 = jt(), { release: i3, environment: o4 = Ht } = t3 && t3.getOptions() || {}, { userAgent: s3 } = re.navigator || {}, a3 = vt({ release: i3, environment: o4, user: r4.getUser() || n3.getUser(), ...s3 && { userAgent: s3 }, ...e4 }), c3 = n3.getSession();
  return c3 && "ok" === c3.status && gt(c3, { status: "exited" }), En(), n3.setSession(a3), r4.setSession(a3), a3;
}
function En() {
  const e4 = It(), t3 = jt(), n3 = t3.getSession() || e4.getSession();
  n3 && function(e5, t4) {
    let n4 = {};
    t4 ? n4 = { status: t4 } : "ok" === e5.status && (n4 = { status: "exited" }), gt(e5, n4);
  }(n3), Tn(), e4.setSession(), t3.setSession();
}
function Tn() {
  const e4 = It(), t3 = jt(), n3 = xt(), r4 = t3.getSession() || e4.getSession();
  r4 && n3 && n3.captureSession(r4);
}
function On(e4 = false) {
  e4 ? En() : Tn();
}
function Pn(e4, t3, n3) {
  return t3 || `${function(e5) {
    return `${function(e6) {
      const t4 = e6.protocol ? `${e6.protocol}:` : "", n4 = e6.port ? `:${e6.port}` : "";
      return `${t4}//${e6.host}${n4}${e6.path ? `/${e6.path}` : ""}/api/`;
    }(e5)}${e5.projectId}/envelope/`;
  }(e4)}?${function(e5, t4) {
    const n4 = { sentry_version: "7" };
    return e5.publicKey && (n4.sentry_key = e5.publicKey), t4 && (n4.sentry_client = `${t4.name}/${t4.version}`), new URLSearchParams(n4).toString();
  }(e4, n3)}`;
}
var An = [];
function jn(e4, t3) {
  for (const n3 of t3)
    n3 && n3.afterAllSetup && n3.afterAllSetup(e4);
}
function In(e4, t3, n3) {
  if (n3[t3.name])
    te && le.log(`Integration skipped because it was already installed: ${t3.name}`);
  else {
    if (n3[t3.name] = t3, -1 === An.indexOf(t3.name) && "function" == typeof t3.setupOnce && (t3.setupOnce(), An.push(t3.name)), t3.setup && "function" == typeof t3.setup && t3.setup(e4), "function" == typeof t3.preprocessEvent) {
      const n4 = t3.preprocessEvent.bind(t3);
      e4.on("preprocessEvent", (t4, r4) => n4(t4, r4, e4));
    }
    if ("function" == typeof t3.processEvent) {
      const n4 = t3.processEvent.bind(t3), r4 = Object.assign((t4, r5) => n4(t4, r5, e4), { id: t3.name });
      e4.addEventProcessor(r4);
    }
    te && le.log(`Integration installed: ${t3.name}`);
  }
}
var xn = class extends Error {
  constructor(e4, t3 = "warn") {
    super(e4), this.message = e4, this.logLevel = t3;
  }
};
var Ln = "Not capturing exception because it's already been captured.";
var Dn = class {
  constructor(e4) {
    if (this._options = e4, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e4.dsn ? this._dsn = Zt(e4.dsn) : te && le.warn("No DSN provided, client will not send events."), this._dsn) {
      const t4 = Pn(this._dsn, e4.tunnel, e4._metadata ? e4._metadata.sdk : void 0);
      this._transport = e4.transport({ tunnel: this._options.tunnel, recordDroppedEvent: this.recordDroppedEvent.bind(this), ...e4.transportOptions, url: t4 });
    }
    const t3 = ["enableTracing", "tracesSampleRate", "tracesSampler"].find((t4) => t4 in e4 && null == e4[t4]);
    t3 && ce(() => {
      console.warn(`[Sentry] Deprecation warning: \`${t3}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`);
    });
  }
  captureException(e4, t3, n3) {
    const r4 = ot();
    if (ut(e4))
      return te && le.log(Ln), r4;
    const i3 = { event_id: r4, ...t3 };
    return this._process(this.eventFromException(e4, i3).then((e5) => this._captureEvent(e5, i3, n3))), i3.event_id;
  }
  captureMessage(e4, t3, n3, r4) {
    const i3 = { event_id: ot(), ...n3 }, o4 = Le(e4) ? e4 : String(e4), s3 = De(e4) ? this.eventFromMessage(o4, t3, i3) : this.eventFromException(e4, i3);
    return this._process(s3.then((e5) => this._captureEvent(e5, i3, r4))), i3.event_id;
  }
  captureEvent(e4, t3, n3) {
    const r4 = ot();
    if (t3 && t3.originalException && ut(t3.originalException))
      return te && le.log(Ln), r4;
    const i3 = { event_id: r4, ...t3 }, o4 = (e4.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e4, i3, o4 || n3)), i3.event_id;
  }
  captureSession(e4) {
    "string" != typeof e4.release ? te && le.warn("Discarded session because of missing or non-string release") : (this.sendSession(e4), gt(e4, { init: false }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(e4) {
    const t3 = this._transport;
    return t3 ? (this.emit("flush"), this._isClientDoneProcessing(e4).then((n3) => t3.flush(e4).then((e5) => n3 && e5))) : pt(true);
  }
  close(e4) {
    return this.flush(e4).then((e5) => (this.getOptions().enabled = false, this.emit("close"), e5));
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e4) {
    this._eventProcessors.push(e4);
  }
  init() {
    (this._isEnabled() || this._options.integrations.some(({ name: e4 }) => e4.startsWith("Spotlight"))) && this._setupIntegrations();
  }
  getIntegrationByName(e4) {
    return this._integrations[e4];
  }
  addIntegration(e4) {
    const t3 = this._integrations[e4.name];
    In(this, e4, this._integrations), t3 || jn(this, [e4]);
  }
  sendEvent(e4, t3 = {}) {
    this.emit("beforeSendEvent", e4, t3);
    let n3 = hn(e4, this._dsn, this._options._metadata, this._options.tunnel);
    for (const e5 of t3.attachments || [])
      n3 = on(n3, ln(e5));
    const r4 = this.sendEnvelope(n3);
    r4 && r4.then((t4) => this.emit("afterSendEvent", e4, t4), null);
  }
  sendSession(e4) {
    const t3 = function(e5, t4, n3, r4) {
      const i3 = pn(n3);
      return rn({ sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...i3 && { sdk: i3 }, ...!!r4 && t4 && { dsn: Yt(t4) } }, ["aggregates" in e5 ? [{ type: "sessions" }, e5] : [{ type: "session" }, e5.toJSON()]]);
    }(e4, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(t3);
  }
  recordDroppedEvent(e4, t3, n3) {
    if (this._options.sendClientReports) {
      const r4 = "number" == typeof n3 ? n3 : 1, i3 = `${e4}:${t3}`;
      te && le.log(`Recording outcome: "${i3}"${r4 > 1 ? ` (${r4} times)` : ""}`), this._outcomes[i3] = (this._outcomes[i3] || 0) + r4;
    }
  }
  on(e4, t3) {
    const n3 = this._hooks[e4] = this._hooks[e4] || [];
    return n3.push(t3), () => {
      const e5 = n3.indexOf(t3);
      e5 > -1 && n3.splice(e5, 1);
    };
  }
  emit(e4, ...t3) {
    const n3 = this._hooks[e4];
    n3 && n3.forEach((e5) => e5(...t3));
  }
  sendEnvelope(e4) {
    return this.emit("beforeEnvelope", e4), this._isEnabled() && this._transport ? this._transport.send(e4).then(null, (e5) => (te && le.error("Error while sending envelope:", e5), e5)) : (te && le.error("Transport disabled"), pt({}));
  }
  _setupIntegrations() {
    const { integrations: e4 } = this._options;
    this._integrations = function(e5, t3) {
      const n3 = {};
      return t3.forEach((t4) => {
        t4 && In(e5, t4, n3);
      }), n3;
    }(this, e4), jn(this, e4);
  }
  _updateSessionFromEvent(e4, t3) {
    let n3 = "fatal" === t3.level, r4 = false;
    const i3 = t3.exception && t3.exception.values;
    if (i3) {
      r4 = true;
      for (const e5 of i3) {
        const t4 = e5.mechanism;
        if (t4 && false === t4.handled) {
          n3 = true;
          break;
        }
      }
    }
    const o4 = "ok" === e4.status;
    (o4 && 0 === e4.errors || o4 && n3) && (gt(e4, { ...n3 && { status: "crashed" }, errors: e4.errors || Number(r4 || n3) }), this.captureSession(e4));
  }
  _isClientDoneProcessing(e4) {
    return new ft((t3) => {
      let n3 = 0;
      const r4 = setInterval(() => {
        0 == this._numProcessing ? (clearInterval(r4), t3(true)) : (n3 += 1, e4 && n3 >= e4 && (clearInterval(r4), t3(false)));
      }, 1);
    });
  }
  _isEnabled() {
    return false !== this.getOptions().enabled && void 0 !== this._transport;
  }
  _prepareEvent(e4, t3, n3 = jt(), r4 = It()) {
    const i3 = this.getOptions(), o4 = Object.keys(this._integrations);
    return !t3.integrations && o4.length > 0 && (t3.integrations = o4), this.emit("preprocessEvent", e4, t3), e4.type || r4.setLastEventId(e4.event_id || t3.event_id), wn(i3, e4, t3, n3, this, r4).then((e5) => {
      if (null === e5)
        return e5;
      e5.contexts = { trace: Lt(n3), ...e5.contexts };
      const t4 = function(e6, t5) {
        const n4 = t5.getPropagationContext();
        return n4.dsc || Gt(n4.traceId, e6);
      }(this, n3);
      return e5.sdkProcessingMetadata = { dynamicSamplingContext: t4, ...e5.sdkProcessingMetadata }, e5;
    });
  }
  _captureEvent(e4, t3 = {}, n3) {
    return this._processEvent(e4, t3, n3).then((e5) => e5.event_id, (e5) => {
      te && (e5 instanceof xn && "log" === e5.logLevel ? le.log(e5.message) : le.warn(e5));
    });
  }
  _processEvent(e4, t3, n3) {
    const r4 = this.getOptions(), { sampleRate: i3 } = r4, o4 = Rn(e4), s3 = Nn(e4), a3 = e4.type || "error", c3 = `before send for type \`${a3}\``, l3 = void 0 === i3 ? void 0 : function(e5) {
      if ("boolean" == typeof e5)
        return Number(e5);
      const t4 = "string" == typeof e5 ? parseFloat(e5) : e5;
      if (!("number" != typeof t4 || isNaN(t4) || t4 < 0 || t4 > 1))
        return t4;
      te && le.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e5)} of type ${JSON.stringify(typeof e5)}.`);
    }(i3);
    if (s3 && "number" == typeof l3 && Math.random() > l3)
      return this.recordDroppedEvent("sample_rate", "error", e4), ht(new xn(`Discarding event because it's not included in the random sample (sampling rate = ${i3})`, "log"));
    const u3 = "replay_event" === a3 ? "replay" : a3, d3 = (e4.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e4, t3, n3, d3).then((n4) => {
      if (null === n4)
        throw this.recordDroppedEvent("event_processor", u3, e4), new xn("An event processor returned `null`, will not send event.", "log");
      if (t3.data && true === t3.data.__sentry__)
        return n4;
      const i4 = function(e5, t4, n5, r5) {
        const { beforeSend: i5, beforeSendTransaction: o5, beforeSendSpan: s4 } = t4;
        if (Nn(n5) && i5)
          return i5(n5, r5);
        if (Rn(n5)) {
          if (n5.spans && s4) {
            const t5 = [];
            for (const r6 of n5.spans) {
              const n6 = s4(r6);
              n6 ? t5.push(n6) : (Wt(), e5.recordDroppedEvent("before_send", "span"));
            }
            n5.spans = t5;
          }
          if (o5) {
            if (n5.spans) {
              const e6 = n5.spans.length;
              n5.sdkProcessingMetadata = { ...n5.sdkProcessingMetadata, spanCountBeforeProcessing: e6 };
            }
            return o5(n5, r5);
          }
        }
        return n5;
      }(this, r4, n4, t3);
      return function(e5, t4) {
        const n5 = `${t4} must return \`null\` or a valid event.`;
        if (Fe(e5))
          return e5.then((e6) => {
            if (!Ne(e6) && null !== e6)
              throw new xn(n5);
            return e6;
          }, (e6) => {
            throw new xn(`${t4} rejected with ${e6}`);
          });
        if (!Ne(e5) && null !== e5)
          throw new xn(n5);
        return e5;
      }(i4, c3);
    }).then((r5) => {
      if (null === r5) {
        if (this.recordDroppedEvent("before_send", u3, e4), o4) {
          const t4 = 1 + (e4.spans || []).length;
          this.recordDroppedEvent("before_send", "span", t4);
        }
        throw new xn(`${c3} returned \`null\`, will not send event.`, "log");
      }
      const i4 = n3 && n3.getSession();
      if (!o4 && i4 && this._updateSessionFromEvent(i4, r5), o4) {
        const e5 = (r5.sdkProcessingMetadata && r5.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (r5.spans ? r5.spans.length : 0);
        e5 > 0 && this.recordDroppedEvent("before_send", "span", e5);
      }
      const s4 = r5.transaction_info;
      if (o4 && s4 && r5.transaction !== e4.transaction) {
        const e5 = "custom";
        r5.transaction_info = { ...s4, source: e5 };
      }
      return this.sendEvent(r5, t3), r5;
    }).then(null, (e5) => {
      if (e5 instanceof xn)
        throw e5;
      throw this.captureException(e5, { data: { __sentry__: true }, originalException: e5 }), new xn(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${e5}`);
    });
  }
  _process(e4) {
    this._numProcessing++, e4.then((e5) => (this._numProcessing--, e5), (e5) => (this._numProcessing--, e5));
  }
  _clearOutcomes() {
    const e4 = this._outcomes;
    return this._outcomes = {}, Object.entries(e4).map(([e5, t3]) => {
      const [n3, r4] = e5.split(":");
      return { reason: n3, category: r4, quantity: t3 };
    });
  }
  _flushOutcomes() {
    te && le.log("Flushing outcomes...");
    const e4 = this._clearOutcomes();
    if (0 === e4.length)
      return void (te && le.log("No outcomes to send"));
    if (!this._dsn)
      return void (te && le.log("No dsn provided, will not send outcomes"));
    te && le.log("Sending outcomes:", e4);
    const t3 = (n3 = e4, rn((r4 = this._options.tunnel && Yt(this._dsn)) ? { dsn: r4 } : {}, [[{ type: "client_report" }, { timestamp: i3 || rt(), discarded_events: n3 }]]));
    var n3, r4, i3;
    this.sendEnvelope(t3);
  }
};
function Nn(e4) {
  return void 0 === e4.type;
}
function Rn(e4) {
  return "transaction" === e4.type;
}
function Fn(e4) {
  const t3 = [];
  function n3(e5) {
    return t3.splice(t3.indexOf(e5), 1)[0] || Promise.resolve(void 0);
  }
  return { $: t3, add: function(r4) {
    if (!(void 0 === e4 || t3.length < e4))
      return ht(new xn("Not adding Promise because buffer limit was reached."));
    const i3 = r4();
    return -1 === t3.indexOf(i3) && t3.push(i3), i3.then(() => n3(i3)).then(null, () => n3(i3).then(null, () => {
    })), i3;
  }, drain: function(e5) {
    return new ft((n4, r4) => {
      let i3 = t3.length;
      if (!i3)
        return n4(true);
      const o4 = setTimeout(() => {
        e5 && e5 > 0 && n4(false);
      }, e5);
      t3.forEach((e6) => {
        pt(e6).then(() => {
          --i3 || (clearTimeout(o4), n4(true));
        }, r4);
      });
    });
  } };
}
function Bn(e4, { statusCode: t3, headers: n3 }, r4 = Date.now()) {
  const i3 = { ...e4 }, o4 = n3 && n3["x-sentry-rate-limits"], s3 = n3 && n3["retry-after"];
  if (o4)
    for (const e5 of o4.trim().split(",")) {
      const [t4, n4, , , o5] = e5.split(":", 5), s4 = parseInt(t4, 10), a3 = 1e3 * (isNaN(s4) ? 60 : s4);
      if (n4)
        for (const e6 of n4.split(";"))
          "metric_bucket" === e6 && o5 && !o5.split(";").includes("custom") || (i3[e6] = r4 + a3);
      else
        i3.all = r4 + a3;
    }
  else
    s3 ? i3.all = r4 + function(e5, t4 = Date.now()) {
      const n4 = parseInt(`${e5}`, 10);
      if (!isNaN(n4))
        return 1e3 * n4;
      const r5 = Date.parse(`${e5}`);
      return isNaN(r5) ? 6e4 : r5 - t4;
    }(s3, r4) : 429 === t3 && (i3.all = r4 + 6e4);
  return i3;
}
function Un(e4, t3, n3 = Fn(e4.bufferSize || 64)) {
  let r4 = {};
  return { send: function(i3) {
    const o4 = [];
    if (sn(i3, (t4, n4) => {
      const i4 = dn(n4);
      if (function(e5, t5, n5 = Date.now()) {
        return function(e6, t6) {
          return e6[t6] || e6.all || 0;
        }(e5, t5) > n5;
      }(r4, i4)) {
        const r5 = Vn(t4, n4);
        e4.recordDroppedEvent("ratelimit_backoff", i4, r5);
      } else
        o4.push(t4);
    }), 0 === o4.length)
      return pt({});
    const s3 = rn(i3[0], o4), a3 = (t4) => {
      sn(s3, (n4, r5) => {
        const i4 = Vn(n4, r5);
        e4.recordDroppedEvent(t4, dn(r5), i4);
      });
    };
    return n3.add(() => t3({ body: cn(s3) }).then((e5) => (void 0 !== e5.statusCode && (e5.statusCode < 200 || e5.statusCode >= 300) && te && le.warn(`Sentry responded with status code ${e5.statusCode} to sent event.`), r4 = Bn(r4, e5), e5), (e5) => {
      throw a3("network_error"), e5;
    })).then((e5) => e5, (e5) => {
      if (e5 instanceof xn)
        return te && le.error("Skipped sending event because buffer is full."), a3("queue_overflow"), pt({});
      throw e5;
    });
  }, flush: (e5) => n3.drain(e5) };
}
function Vn(e4, t3) {
  if ("event" === t3 || "transaction" === t3)
    return Array.isArray(e4) ? e4[1] : void 0;
}
var Jn = 100;
function $n(e4, t3) {
  const n3 = xt(), r4 = It();
  if (!n3)
    return;
  const { beforeBreadcrumb: i3 = null, maxBreadcrumbs: o4 = Jn } = n3.getOptions();
  if (o4 <= 0)
    return;
  const s3 = { timestamp: rt(), ...e4 }, a3 = i3 ? ce(() => i3(s3, t3)) : s3;
  null !== a3 && (n3.emit && n3.emit("beforeAddBreadcrumb", a3, t3), r4.addBreadcrumb(a3, o4));
}
var qn;
var zn = /* @__PURE__ */ new WeakMap();
var Wn = () => ({ name: "FunctionToString", setupOnce() {
  qn = Function.prototype.toString;
  try {
    Function.prototype.toString = function(...e4) {
      const t3 = Ye(this), n3 = zn.has(xt()) && void 0 !== t3 ? t3 : this;
      return qn.apply(n3, e4);
    };
  } catch (e4) {
  }
}, setup(e4) {
  zn.set(e4, true);
} });
var Hn = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/];
var Gn = (e4 = {}) => ({ name: "InboundFilters", processEvent(t3, n3, r4) {
  const i3 = r4.getOptions(), o4 = function(e5 = {}, t4 = {}) {
    return { allowUrls: [...e5.allowUrls || [], ...t4.allowUrls || []], denyUrls: [...e5.denyUrls || [], ...t4.denyUrls || []], ignoreErrors: [...e5.ignoreErrors || [], ...t4.ignoreErrors || [], ...e5.disableErrorDefaults ? [] : Hn], ignoreTransactions: [...e5.ignoreTransactions || [], ...t4.ignoreTransactions || []], ignoreInternal: void 0 === e5.ignoreInternal || e5.ignoreInternal };
  }(e4, i3);
  return function(e5, t4) {
    if (t4.ignoreInternal && function(e6) {
      try {
        return "SentryError" === e6.exception.values[0].type;
      } catch (e7) {
      }
      return false;
    }(e5))
      return te && le.warn(`Event dropped due to being internal Sentry Error.
Event: ${at(e5)}`), true;
    if (function(e6, t5) {
      if (e6.type || !t5 || !t5.length)
        return false;
      return function(e7) {
        const t6 = [];
        e7.message && t6.push(e7.message);
        let n4;
        try {
          n4 = e7.exception.values[e7.exception.values.length - 1];
        } catch (e8) {
        }
        n4 && n4.value && (t6.push(n4.value), n4.type && t6.push(`${n4.type}: ${n4.value}`));
        return t6;
      }(e6).some((e7) => He(e7, t5));
    }(e5, t4.ignoreErrors))
      return te && le.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${at(e5)}`), true;
    if (function(e6) {
      if (e6.type)
        return false;
      if (!e6.exception || !e6.exception.values || 0 === e6.exception.values.length)
        return false;
      return !e6.message && !e6.exception.values.some((e7) => e7.stacktrace || e7.type && "Error" !== e7.type || e7.value);
    }(e5))
      return te && le.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${at(e5)}`), true;
    if (function(e6, t5) {
      if ("transaction" !== e6.type || !t5 || !t5.length)
        return false;
      const n4 = e6.transaction;
      return !!n4 && He(n4, t5);
    }(e5, t4.ignoreTransactions))
      return te && le.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${at(e5)}`), true;
    if (function(e6, t5) {
      if (!t5 || !t5.length)
        return false;
      const n4 = Qn(e6);
      return !!n4 && He(n4, t5);
    }(e5, t4.denyUrls))
      return te && le.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${at(e5)}.
Url: ${Qn(e5)}`), true;
    if (!function(e6, t5) {
      if (!t5 || !t5.length)
        return true;
      const n4 = Qn(e6);
      return !n4 || He(n4, t5);
    }(e5, t4.allowUrls))
      return te && le.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${at(e5)}.
Url: ${Qn(e5)}`), true;
    return false;
  }(t3, o4) ? null : t3;
} });
function Qn(e4) {
  try {
    let t3;
    try {
      t3 = e4.exception.values[0].stacktrace.frames;
    } catch (e5) {
    }
    return t3 ? function(e5 = []) {
      for (let t4 = e5.length - 1; t4 >= 0; t4--) {
        const n3 = e5[t4];
        if (n3 && "<anonymous>" !== n3.filename && "[native code]" !== n3.filename)
          return n3.filename || null;
      }
      return null;
    }(t3) : null;
  } catch (t3) {
    return te && le.error(`Cannot extract url for event ${at(e4)}`), null;
  }
}
function Kn(e4, t3, n3 = 250, r4, i3, o4, s3) {
  if (!(o4.exception && o4.exception.values && s3 && Be(s3.originalException, Error)))
    return;
  const a3 = o4.exception.values.length > 0 ? o4.exception.values[o4.exception.values.length - 1] : void 0;
  var c3, l3;
  a3 && (o4.exception.values = (c3 = Yn(e4, t3, i3, s3.originalException, r4, o4.exception.values, a3, 0), l3 = n3, c3.map((e5) => (e5.value && (e5.value = qe(e5.value, l3)), e5))));
}
function Yn(e4, t3, n3, r4, i3, o4, s3, a3) {
  if (o4.length >= n3 + 1)
    return o4;
  let c3 = [...o4];
  if (Be(r4[i3], Error)) {
    Xn(s3, a3);
    const o5 = e4(t3, r4[i3]), l3 = c3.length;
    Zn(o5, i3, l3, a3), c3 = Yn(e4, t3, n3, r4[i3], i3, [o5, ...c3], o5, l3);
  }
  return Array.isArray(r4.errors) && r4.errors.forEach((r5, o5) => {
    if (Be(r5, Error)) {
      Xn(s3, a3);
      const l3 = e4(t3, r5), u3 = c3.length;
      Zn(l3, `errors[${o5}]`, u3, a3), c3 = Yn(e4, t3, n3, r5, i3, [l3, ...c3], l3, u3);
    }
  }), c3;
}
function Xn(e4, t3) {
  e4.mechanism = e4.mechanism || { type: "generic", handled: true }, e4.mechanism = { ...e4.mechanism, ..."AggregateError" === e4.type && { is_exception_group: true }, exception_id: t3 };
}
function Zn(e4, t3, n3, r4) {
  e4.mechanism = e4.mechanism || { type: "generic", handled: true }, e4.mechanism = { ...e4.mechanism, type: "chained", source: t3, exception_id: n3, parent_id: r4 };
}
function er(e4) {
  if (!e4)
    return {};
  const t3 = e4.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t3)
    return {};
  const n3 = t3[6] || "", r4 = t3[8] || "";
  return { host: t3[4], path: t3[5], protocol: t3[2], search: n3, hash: r4, relative: t3[5] + n3 + r4 };
}
function tr() {
  "console" in re && se.forEach(function(e4) {
    e4 in re.console && Ge(re.console, e4, function(t3) {
      return ae[e4] = t3, function(...t4) {
        we("console", { args: t4, level: e4 });
        const n3 = ae[e4];
        n3 && n3.apply(re.console, t4);
      };
    });
  });
}
function nr(e4) {
  return "warn" === e4 ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(e4) ? e4 : "log";
}
var rr = () => {
  let e4;
  return { name: "Dedupe", processEvent(t3) {
    if (t3.type)
      return t3;
    try {
      if (function(e5, t4) {
        if (!t4)
          return false;
        if (function(e6, t5) {
          const n3 = e6.message, r4 = t5.message;
          if (!n3 && !r4)
            return false;
          if (n3 && !r4 || !n3 && r4)
            return false;
          if (n3 !== r4)
            return false;
          if (!or(e6, t5))
            return false;
          if (!ir(e6, t5))
            return false;
          return true;
        }(e5, t4))
          return true;
        if (function(e6, t5) {
          const n3 = sr(t5), r4 = sr(e6);
          if (!n3 || !r4)
            return false;
          if (n3.type !== r4.type || n3.value !== r4.value)
            return false;
          if (!or(e6, t5))
            return false;
          if (!ir(e6, t5))
            return false;
          return true;
        }(e5, t4))
          return true;
        return false;
      }(t3, e4))
        return te && le.warn("Event dropped due to being a duplicate of previously captured event."), null;
    } catch (e5) {
    }
    return e4 = t3;
  } };
};
function ir(e4, t3) {
  let n3 = ge(e4), r4 = ge(t3);
  if (!n3 && !r4)
    return true;
  if (n3 && !r4 || !n3 && r4)
    return false;
  if (r4.length !== n3.length)
    return false;
  for (let e5 = 0; e5 < r4.length; e5++) {
    const t4 = r4[e5], i3 = n3[e5];
    if (t4.filename !== i3.filename || t4.lineno !== i3.lineno || t4.colno !== i3.colno || t4.function !== i3.function)
      return false;
  }
  return true;
}
function or(e4, t3) {
  let n3 = e4.fingerprint, r4 = t3.fingerprint;
  if (!n3 && !r4)
    return true;
  if (n3 && !r4 || !n3 && r4)
    return false;
  try {
    return !(n3.join("") !== r4.join(""));
  } catch (e5) {
    return false;
  }
}
function sr(e4) {
  return e4.exception && e4.exception.values && e4.exception.values[0];
}
function ar(e4) {
  return void 0 === e4 ? void 0 : e4 >= 400 && e4 < 500 ? "warning" : e4 >= 500 ? "error" : void 0;
}
var cr = re;
function lr(e4) {
  return e4 && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e4.toString());
}
function ur() {
  if ("string" == typeof EdgeRuntime)
    return true;
  if (!function() {
    if (!("fetch" in cr))
      return false;
    try {
      return new Headers(), new Request("http://www.example.com"), new Response(), true;
    } catch (e5) {
      return false;
    }
  }())
    return false;
  if (lr(cr.fetch))
    return true;
  let e4 = false;
  const t3 = cr.document;
  if (t3 && "function" == typeof t3.createElement)
    try {
      const n3 = t3.createElement("iframe");
      n3.hidden = true, t3.head.appendChild(n3), n3.contentWindow && n3.contentWindow.fetch && (e4 = lr(n3.contentWindow.fetch)), t3.head.removeChild(n3);
    } catch (e5) {
      oe && le.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e5);
    }
  return e4;
}
function dr(e4, t3) {
  const n3 = "fetch";
  be(n3, e4), _e(n3, () => function(e5, t4 = false) {
    if (t4 && !ur())
      return;
    Ge(re, "fetch", function(t5) {
      return function(...n4) {
        const r4 = new Error(), { method: i3, url: o4 } = function(e6) {
          if (0 === e6.length)
            return { method: "GET", url: "" };
          if (2 === e6.length) {
            const [t7, n5] = e6;
            return { url: hr(t7), method: pr(n5, "method") ? String(n5.method).toUpperCase() : "GET" };
          }
          const t6 = e6[0];
          return { url: hr(t6), method: pr(t6, "method") ? String(t6.method).toUpperCase() : "GET" };
        }(n4), s3 = { args: n4, fetchData: { method: i3, url: o4 }, startTimestamp: 1e3 * it(), virtualError: r4 };
        return e5 || we("fetch", { ...s3 }), t5.apply(re, n4).then(async (t6) => (e5 ? e5(t6) : we("fetch", { ...s3, endTimestamp: 1e3 * it(), response: t6 }), t6), (e6) => {
          throw we("fetch", { ...s3, endTimestamp: 1e3 * it(), error: e6 }), Pe(e6) && void 0 === e6.stack && (e6.stack = r4.stack, Qe(e6, "framesToPop", 1)), e6;
        });
      };
    });
  }(void 0, t3));
}
function pr(e4, t3) {
  return !!e4 && "object" == typeof e4 && !!e4[t3];
}
function hr(e4) {
  return "string" == typeof e4 ? e4 : e4 ? pr(e4, "url") ? e4.url : e4.toString ? e4.toString() : "" : "";
}
var fr = re;
var vr = re;
var gr = 0;
function mr() {
  return gr > 0;
}
function yr(e4, t3 = {}) {
  if (!function(e5) {
    return "function" == typeof e5;
  }(e4))
    return e4;
  try {
    const t4 = e4.__sentry_wrapped__;
    if (t4)
      return "function" == typeof t4 ? t4 : e4;
    if (Ye(e4))
      return e4;
  } catch (t4) {
    return e4;
  }
  const n3 = function(...n4) {
    try {
      const r4 = n4.map((e5) => yr(e5, t3));
      return e4.apply(this, r4);
    } catch (e5) {
      throw gr++, setTimeout(() => {
        gr--;
      }), function(...e6) {
        const t4 = At(Ee());
        if (2 === e6.length) {
          const [n5, r4] = e6;
          return n5 ? t4.withSetScope(n5, r4) : t4.withScope(r4);
        }
        t4.withScope(e6[0]);
      }((r4) => {
        var i3, o4;
        r4.addEventProcessor((e6) => (t3.mechanism && (ct(e6, void 0, void 0), lt(e6, t3.mechanism)), e6.extra = { ...e6.extra, arguments: n4 }, e6)), i3 = e5, jt().captureException(i3, Sn(o4));
      }), e5;
    }
  };
  try {
    for (const t4 in e4)
      Object.prototype.hasOwnProperty.call(e4, t4) && (n3[t4] = e4[t4]);
  } catch (e5) {
  }
  Ke(n3, e4), Qe(e4, "__sentry_wrapped__", n3);
  try {
    Object.getOwnPropertyDescriptor(n3, "name").configurable && Object.defineProperty(n3, "name", { get: () => e4.name });
  } catch (e5) {
  }
  return n3;
}
var br = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
function _r(e4, t3) {
  const n3 = kr(e4, t3), r4 = { type: Er(t3), value: Tr(t3) };
  return n3.length && (r4.stacktrace = { frames: n3 }), void 0 === r4.type && "" === r4.value && (r4.value = "Unrecoverable error caught"), r4;
}
function wr(e4, t3, n3, r4) {
  const i3 = xt(), o4 = i3 && i3.getOptions().normalizeDepth, s3 = function(e5) {
    for (const t4 in e5)
      if (Object.prototype.hasOwnProperty.call(e5, t4)) {
        const n4 = e5[t4];
        if (n4 instanceof Error)
          return n4;
      }
    return;
  }(t3), a3 = { __serialized__: tn(t3, o4) };
  if (s3)
    return { exception: { values: [_r(e4, s3)] }, extra: a3 };
  const c3 = { exception: { values: [{ type: Re(t3) ? t3.constructor.name : r4 ? "UnhandledRejection" : "Error", value: Ar(t3, { isUnhandledRejection: r4 }) }] }, extra: a3 };
  if (n3) {
    const t4 = kr(e4, n3);
    t4.length && (c3.exception.values[0].stacktrace = { frames: t4 });
  }
  return c3;
}
function Sr(e4, t3) {
  return { exception: { values: [_r(e4, t3)] } };
}
function kr(e4, t3) {
  const n3 = t3.stacktrace || t3.stack || "", r4 = function(e5) {
    if (e5 && Mr.test(e5.message))
      return 1;
    return 0;
  }(t3), i3 = function(e5) {
    if ("number" == typeof e5.framesToPop)
      return e5.framesToPop;
    return 0;
  }(t3);
  try {
    return e4(n3, r4, i3);
  } catch (e5) {
  }
  return [];
}
var Mr = /Minified React error #\d+;/i;
function Cr(e4) {
  return "undefined" != typeof WebAssembly && void 0 !== WebAssembly.Exception && e4 instanceof WebAssembly.Exception;
}
function Er(e4) {
  const t3 = e4 && e4.name;
  if (!t3 && Cr(e4)) {
    return e4.message && Array.isArray(e4.message) && 2 == e4.message.length ? e4.message[0] : "WebAssembly.Exception";
  }
  return t3;
}
function Tr(e4) {
  const t3 = e4 && e4.message;
  return t3 ? t3.error && "string" == typeof t3.error.message ? t3.error.message : Cr(e4) && Array.isArray(e4.message) && 2 == e4.message.length ? e4.message[1] : t3 : "No error message";
}
function Or(e4, t3, n3, r4, i3) {
  let o4;
  if (je(t3) && t3.error) {
    return Sr(e4, t3.error);
  }
  if (Ie(t3) || Ae(t3, "DOMException")) {
    const i4 = t3;
    if ("stack" in t3)
      o4 = Sr(e4, t3);
    else {
      const t4 = i4.name || (Ie(i4) ? "DOMError" : "DOMException"), s3 = i4.message ? `${t4}: ${i4.message}` : t4;
      o4 = Pr(e4, s3, n3, r4), ct(o4, s3);
    }
    return "code" in i4 && (o4.tags = { ...o4.tags, "DOMException.code": `${i4.code}` }), o4;
  }
  if (Pe(t3))
    return Sr(e4, t3);
  if (Ne(t3) || Re(t3)) {
    return o4 = wr(e4, t3, n3, i3), lt(o4, { synthetic: true }), o4;
  }
  return o4 = Pr(e4, t3, n3, r4), ct(o4, `${t3}`, void 0), lt(o4, { synthetic: true }), o4;
}
function Pr(e4, t3, n3, r4) {
  const i3 = {};
  if (r4 && n3) {
    const r5 = kr(e4, n3);
    r5.length && (i3.exception = { values: [{ value: t3, stacktrace: { frames: r5 } }] }), lt(i3, { synthetic: true });
  }
  if (Le(t3)) {
    const { __sentry_template_string__: e5, __sentry_template_values__: n4 } = t3;
    return i3.logentry = { message: e5, params: n4 }, i3;
  }
  return i3.message = t3, i3;
}
function Ar(e4, { isUnhandledRejection: t3 }) {
  const n3 = function(e5, t4 = 40) {
    const n4 = Object.keys(Xe(e5));
    n4.sort();
    const r5 = n4[0];
    if (!r5)
      return "[object has no keys]";
    if (r5.length >= t4)
      return qe(r5, t4);
    for (let e6 = n4.length; e6 > 0; e6--) {
      const r6 = n4.slice(0, e6).join(", ");
      if (!(r6.length > t4))
        return e6 === n4.length ? r6 : qe(r6, t4);
    }
    return "";
  }(e4), r4 = t3 ? "promise rejection" : "exception";
  if (je(e4))
    return `Event \`ErrorEvent\` captured as ${r4} with message \`${e4.message}\``;
  if (Re(e4)) {
    return `Event \`${function(e5) {
      try {
        const t4 = Object.getPrototypeOf(e5);
        return t4 ? t4.constructor.name : void 0;
      } catch (e6) {
      }
    }(e4)}\` (type=${e4.type}) captured as ${r4}`;
  }
  return `Object captured as ${r4} with keys: ${n3}`;
}
var jr = class extends Dn {
  constructor(e4) {
    const t3 = { parentSpanIsAlwaysRootSpan: true, ...e4 };
    !function(e5, t4, n3 = [t4], r4 = "npm") {
      const i3 = e5._metadata || {};
      i3.sdk || (i3.sdk = { name: `sentry.javascript.${t4}`, packages: n3.map((e6) => ({ name: `${r4}:@sentry/${e6}`, version: ne })), version: ne }), e5._metadata = i3;
    }(t3, "browser", ["browser"], vr.SENTRY_SDK_SOURCE || "npm"), super(t3), t3.sendClientReports && vr.document && vr.document.addEventListener("visibilitychange", () => {
      "hidden" === vr.document.visibilityState && this._flushOutcomes();
    });
  }
  eventFromException(e4, t3) {
    return function(e5, t4, n3, r4) {
      const i3 = Or(e5, t4, n3 && n3.syntheticException || void 0, r4);
      return lt(i3), i3.level = "error", n3 && n3.event_id && (i3.event_id = n3.event_id), pt(i3);
    }(this._options.stackParser, e4, t3, this._options.attachStacktrace);
  }
  eventFromMessage(e4, t3 = "info", n3) {
    return function(e5, t4, n4 = "info", r4, i3) {
      const o4 = Pr(e5, t4, r4 && r4.syntheticException || void 0, i3);
      return o4.level = n4, r4 && r4.event_id && (o4.event_id = r4.event_id), pt(o4);
    }(this._options.stackParser, e4, t3, n3, this._options.attachStacktrace);
  }
  captureUserFeedback(e4) {
    if (!this._isEnabled())
      return void (br && le.warn("SDK not enabled, will not capture user feedback."));
    const t3 = function(e5, { metadata: t4, tunnel: n3, dsn: r4 }) {
      const i3 = { event_id: e5.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t4 && t4.sdk && { sdk: { name: t4.sdk.name, version: t4.sdk.version } }, ...!!n3 && !!r4 && { dsn: Yt(r4) } }, o4 = function(e6) {
        return [{ type: "user_report" }, e6];
      }(e5);
      return rn(i3, [o4]);
    }(e4, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel });
    this.sendEnvelope(t3);
  }
  _prepareEvent(e4, t3, n3) {
    return e4.platform = e4.platform || "javascript", super._prepareEvent(e4, t3, n3);
  }
};
var Ir = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var xr = re;
var Lr;
var Dr;
var Nr;
var Rr;
function Fr() {
  if (!xr.document)
    return;
  const e4 = we.bind(null, "dom"), t3 = Br(e4, true);
  xr.document.addEventListener("click", t3, false), xr.document.addEventListener("keypress", t3, false), ["EventTarget", "Node"].forEach((t4) => {
    const n3 = xr[t4], r4 = n3 && n3.prototype;
    r4 && r4.hasOwnProperty && r4.hasOwnProperty("addEventListener") && (Ge(r4, "addEventListener", function(t5) {
      return function(n4, r5, i3) {
        if ("click" === n4 || "keypress" == n4)
          try {
            const r6 = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}, o4 = r6[n4] = r6[n4] || { refCount: 0 };
            if (!o4.handler) {
              const r7 = Br(e4);
              o4.handler = r7, t5.call(this, n4, r7, i3);
            }
            o4.refCount++;
          } catch (e5) {
          }
        return t5.call(this, n4, r5, i3);
      };
    }), Ge(r4, "removeEventListener", function(e5) {
      return function(t5, n4, r5) {
        if ("click" === t5 || "keypress" == t5)
          try {
            const n5 = this.__sentry_instrumentation_handlers__ || {}, i3 = n5[t5];
            i3 && (i3.refCount--, i3.refCount <= 0 && (e5.call(this, t5, i3.handler, r5), i3.handler = void 0, delete n5[t5]), 0 === Object.keys(n5).length && delete this.__sentry_instrumentation_handlers__);
          } catch (e6) {
          }
        return e5.call(this, t5, n4, r5);
      };
    }));
  });
}
function Br(e4, t3 = false) {
  return (n3) => {
    if (!n3 || n3._sentryCaptured)
      return;
    const r4 = function(e5) {
      try {
        return e5.target;
      } catch (e6) {
        return null;
      }
    }(n3);
    if (function(e5, t4) {
      return "keypress" === e5 && (!t4 || !t4.tagName || "INPUT" !== t4.tagName && "TEXTAREA" !== t4.tagName && !t4.isContentEditable);
    }(n3.type, r4))
      return;
    Qe(n3, "_sentryCaptured", true), r4 && !r4._sentryId && Qe(r4, "_sentryId", ot());
    const i3 = "keypress" === n3.type ? "input" : n3.type;
    if (!function(e5) {
      if (e5.type !== Dr)
        return false;
      try {
        if (!e5.target || e5.target._sentryId !== Nr)
          return false;
      } catch (e6) {
      }
      return true;
    }(n3)) {
      e4({ event: n3, name: i3, global: t3 }), Dr = n3.type, Nr = r4 ? r4._sentryId : void 0;
    }
    clearTimeout(Lr), Lr = xr.setTimeout(() => {
      Nr = void 0, Dr = void 0;
    }, 1e3);
  };
}
function Ur(e4) {
  const t3 = "history";
  be(t3, e4), _e(t3, Vr);
}
function Vr() {
  if (!function() {
    const e5 = fr.chrome, t4 = e5 && e5.app && e5.app.runtime, n3 = "history" in fr && !!fr.history.pushState && !!fr.history.replaceState;
    return !t4 && n3;
  }())
    return;
  const e4 = xr.onpopstate;
  function t3(e5) {
    return function(...t4) {
      const n3 = t4.length > 2 ? t4[2] : void 0;
      if (n3) {
        const e6 = Rr, t5 = String(n3);
        Rr = t5;
        we("history", { from: e6, to: t5 });
      }
      return e5.apply(this, t4);
    };
  }
  xr.onpopstate = function(...t4) {
    const n3 = xr.location.href, r4 = Rr;
    Rr = n3;
    if (we("history", { from: r4, to: n3 }), e4)
      try {
        return e4.apply(this, t4);
      } catch (e5) {
      }
  }, Ge(xr.history, "pushState", t3), Ge(xr.history, "replaceState", t3);
}
var Jr = {};
function $r(e4) {
  Jr[e4] = void 0;
}
var qr = "__sentry_xhr_v3__";
function zr() {
  if (!xr.XMLHttpRequest)
    return;
  const e4 = XMLHttpRequest.prototype;
  e4.open = new Proxy(e4.open, { apply(e5, t3, n3) {
    const r4 = new Error(), i3 = 1e3 * it(), o4 = xe(n3[0]) ? n3[0].toUpperCase() : void 0, s3 = function(e6) {
      if (xe(e6))
        return e6;
      try {
        return e6.toString();
      } catch (e7) {
      }
      return;
    }(n3[1]);
    if (!o4 || !s3)
      return e5.apply(t3, n3);
    t3[qr] = { method: o4, url: s3, request_headers: {} }, "POST" === o4 && s3.match(/sentry_key/) && (t3.__sentry_own_request__ = true);
    const a3 = () => {
      const e6 = t3[qr];
      if (e6 && 4 === t3.readyState) {
        try {
          e6.status_code = t3.status;
        } catch (e7) {
        }
        we("xhr", { endTimestamp: 1e3 * it(), startTimestamp: i3, xhr: t3, virtualError: r4 });
      }
    };
    return "onreadystatechange" in t3 && "function" == typeof t3.onreadystatechange ? t3.onreadystatechange = new Proxy(t3.onreadystatechange, { apply: (e6, t4, n4) => (a3(), e6.apply(t4, n4)) }) : t3.addEventListener("readystatechange", a3), t3.setRequestHeader = new Proxy(t3.setRequestHeader, { apply(e6, t4, n4) {
      const [r5, i4] = n4, o5 = t4[qr];
      return o5 && xe(r5) && xe(i4) && (o5.request_headers[r5.toLowerCase()] = i4), e6.apply(t4, n4);
    } }), e5.apply(t3, n3);
  } }), e4.send = new Proxy(e4.send, { apply(e5, t3, n3) {
    const r4 = t3[qr];
    if (!r4)
      return e5.apply(t3, n3);
    void 0 !== n3[0] && (r4.body = n3[0]);
    return we("xhr", { startTimestamp: 1e3 * it(), xhr: t3 }), e5.apply(t3, n3);
  } });
}
function Wr(e4, t3 = function(e5) {
  const t4 = Jr[e5];
  if (t4)
    return t4;
  let n3 = xr[e5];
  if (lr(n3))
    return Jr[e5] = n3.bind(xr);
  const r4 = xr.document;
  if (r4 && "function" == typeof r4.createElement)
    try {
      const t5 = r4.createElement("iframe");
      t5.hidden = true, r4.head.appendChild(t5);
      const i3 = t5.contentWindow;
      i3 && i3[e5] && (n3 = i3[e5]), r4.head.removeChild(t5);
    } catch (t5) {
      Ir && le.warn(`Could not create sandbox iframe for ${e5} check, bailing to window.${e5}: `, t5);
    }
  return n3 ? Jr[e5] = n3.bind(xr) : n3;
}("fetch")) {
  let n3 = 0, r4 = 0;
  return Un(e4, function(i3) {
    const o4 = i3.body.length;
    n3 += o4, r4++;
    const s3 = { body: i3.body, method: "POST", referrerPolicy: "origin", headers: e4.headers, keepalive: n3 <= 6e4 && r4 < 15, ...e4.fetchOptions };
    if (!t3)
      return $r("fetch"), ht("No fetch implementation available");
    try {
      return t3(e4.url, s3).then((e5) => (n3 -= o4, r4--, { statusCode: e5.status, headers: { "x-sentry-rate-limits": e5.headers.get("X-Sentry-Rate-Limits"), "retry-after": e5.headers.get("Retry-After") } }));
    } catch (e5) {
      return $r("fetch"), n3 -= o4, r4--, ht(e5);
    }
  });
}
function Hr(e4, t3, n3, r4) {
  const i3 = { filename: e4, function: "<anonymous>" === t3 ? ue : t3, in_app: true };
  return void 0 !== n3 && (i3.lineno = n3), void 0 !== r4 && (i3.colno = r4), i3;
}
var Gr = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
var Qr = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var Kr = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var Yr = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var Xr = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var Zr = function(...e4) {
  const t3 = e4.sort((e5, t4) => e5[0] - t4[0]).map((e5) => e5[1]);
  return (e5, n3 = 0, r4 = 0) => {
    const i3 = [], o4 = e5.split("\n");
    for (let e6 = n3; e6 < o4.length; e6++) {
      const n4 = o4[e6];
      if (n4.length > 1024)
        continue;
      const s3 = de.test(n4) ? n4.replace(de, "$1") : n4;
      if (!s3.match(/\S*Error: /)) {
        for (const e7 of t3) {
          const t4 = e7(s3);
          if (t4) {
            i3.push(t4);
            break;
          }
        }
        if (i3.length >= 50 + r4)
          break;
      }
    }
    return function(e6) {
      if (!e6.length)
        return [];
      const t4 = Array.from(e6);
      /sentryWrapped/.test(he(t4).function || "") && t4.pop();
      t4.reverse(), pe.test(he(t4).function || "") && (t4.pop(), pe.test(he(t4).function || "") && t4.pop());
      return t4.slice(0, 50).map((e7) => ({ ...e7, filename: e7.filename || he(t4).filename, function: e7.function || ue }));
    }(i3.slice(r4));
  };
}(...[[30, (e4) => {
  const t3 = Gr.exec(e4);
  if (t3) {
    const [, e5, n4, r4] = t3;
    return Hr(e5, ue, +n4, +r4);
  }
  const n3 = Qr.exec(e4);
  if (n3) {
    if (n3[2] && 0 === n3[2].indexOf("eval")) {
      const e6 = Kr.exec(n3[2]);
      e6 && (n3[2] = e6[1], n3[3] = e6[2], n3[4] = e6[3]);
    }
    const [e5, t4] = ei(n3[1] || ue, n3[2]);
    return Hr(t4, e5, n3[3] ? +n3[3] : void 0, n3[4] ? +n3[4] : void 0);
  }
}], [50, (e4) => {
  const t3 = Yr.exec(e4);
  if (t3) {
    if (t3[3] && t3[3].indexOf(" > eval") > -1) {
      const e6 = Xr.exec(t3[3]);
      e6 && (t3[1] = t3[1] || "eval", t3[3] = e6[1], t3[4] = e6[2], t3[5] = "");
    }
    let e5 = t3[3], n3 = t3[1] || ue;
    return [n3, e5] = ei(n3, e5), Hr(e5, n3, t3[4] ? +t3[4] : void 0, t3[5] ? +t3[5] : void 0);
  }
}]]);
var ei = (e4, t3) => {
  const n3 = -1 !== e4.indexOf("safari-extension"), r4 = -1 !== e4.indexOf("safari-web-extension");
  return n3 || r4 ? [-1 !== e4.indexOf("@") ? e4.split("@")[0] : ue, n3 ? `safari-extension:${t3}` : `safari-web-extension:${t3}`] : [e4, t3];
};
var ti = 1024;
var ni = (e4 = {}) => {
  const t3 = { console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true, ...e4 };
  return { name: "Breadcrumbs", setup(e5) {
    var n3;
    t3.console && function(e6) {
      const t4 = "console";
      be(t4, e6), _e(t4, tr);
    }(function(e6) {
      return function(t4) {
        if (xt() !== e6)
          return;
        const n4 = { category: "console", data: { arguments: t4.args, logger: "console" }, level: nr(t4.level), message: ze(t4.args, " ") };
        if ("assert" === t4.level) {
          if (false !== t4.args[0])
            return;
          n4.message = `Assertion failed: ${ze(t4.args.slice(1), " ") || "console.assert"}`, n4.data.arguments = t4.args.slice(1);
        }
        $n(n4, { input: t4.args, level: t4.level });
      };
    }(e5)), t3.dom && (n3 = function(e6, t4) {
      return function(n4) {
        if (xt() !== e6)
          return;
        let r4, i3, o4 = "object" == typeof t4 ? t4.serializeAttribute : void 0, s3 = "object" == typeof t4 && "number" == typeof t4.maxStringLength ? t4.maxStringLength : void 0;
        s3 && s3 > ti && (br && le.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${s3} was configured. Sentry will use 1024 instead.`), s3 = ti), "string" == typeof o4 && (o4 = [o4]);
        try {
          const e7 = n4.event, t5 = function(e8) {
            return !!e8 && !!e8.target;
          }(e7) ? e7.target : e7;
          r4 = Je(t5, { keyAttrs: o4, maxStringLength: s3 }), i3 = function(e8) {
            if (!Ve.HTMLElement)
              return null;
            let t6 = e8;
            for (let e9 = 0; e9 < 5; e9++) {
              if (!t6)
                return null;
              if (t6 instanceof HTMLElement) {
                if (t6.dataset.sentryComponent)
                  return t6.dataset.sentryComponent;
                if (t6.dataset.sentryElement)
                  return t6.dataset.sentryElement;
              }
              t6 = t6.parentNode;
            }
            return null;
          }(t5);
        } catch (e7) {
          r4 = "<unknown>";
        }
        if (0 === r4.length)
          return;
        const a3 = { category: `ui.${n4.name}`, message: r4 };
        i3 && (a3.data = { "ui.component_name": i3 }), $n(a3, { event: n4.event, name: n4.name, global: n4.global });
      };
    }(e5, t3.dom), be("dom", n3), _e("dom", Fr)), t3.xhr && function(e6) {
      be("xhr", e6), _e("xhr", zr);
    }(function(e6) {
      return function(t4) {
        if (xt() !== e6)
          return;
        const { startTimestamp: n4, endTimestamp: r4 } = t4, i3 = t4.xhr[qr];
        if (!n4 || !r4 || !i3)
          return;
        const { method: o4, url: s3, status_code: a3, body: c3 } = i3, l3 = { method: o4, url: s3, status_code: a3 }, u3 = { xhr: t4.xhr, input: c3, startTimestamp: n4, endTimestamp: r4 };
        $n({ category: "xhr", data: l3, type: "http", level: ar(a3) }, u3);
      };
    }(e5)), t3.fetch && dr(function(e6) {
      return function(t4) {
        if (xt() !== e6)
          return;
        const { startTimestamp: n4, endTimestamp: r4 } = t4;
        if (r4 && (!t4.fetchData.url.match(/sentry_key/) || "POST" !== t4.fetchData.method))
          if (t4.error) {
            $n({ category: "fetch", data: t4.fetchData, level: "error", type: "http" }, { data: t4.error, input: t4.args, startTimestamp: n4, endTimestamp: r4 });
          } else {
            const e7 = t4.response, i3 = { ...t4.fetchData, status_code: e7 && e7.status }, o4 = { input: t4.args, response: e7, startTimestamp: n4, endTimestamp: r4 };
            $n({ category: "fetch", data: i3, type: "http", level: ar(i3.status_code) }, o4);
          }
      };
    }(e5)), t3.history && Ur(function(e6) {
      return function(t4) {
        if (xt() !== e6)
          return;
        let n4 = t4.from, r4 = t4.to;
        const i3 = er(vr.location.href);
        let o4 = n4 ? er(n4) : void 0;
        const s3 = er(r4);
        o4 && o4.path || (o4 = i3), i3.protocol === s3.protocol && i3.host === s3.host && (r4 = s3.relative), i3.protocol === o4.protocol && i3.host === o4.host && (n4 = o4.relative), $n({ category: "navigation", data: { from: n4, to: r4 } });
      };
    }(e5)), t3.sentry && e5.on("beforeSendEvent", function(e6) {
      return function(t4) {
        xt() === e6 && $n({ category: "sentry." + ("transaction" === t4.type ? "transaction" : "event"), event_id: t4.event_id, level: t4.level, message: at(t4) }, { event: t4 });
      };
    }(e5));
  } };
};
var ri = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
var ii = (e4 = {}) => {
  const t3 = { XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true, ...e4 };
  return { name: "BrowserApiErrors", setupOnce() {
    t3.setTimeout && Ge(vr, "setTimeout", oi), t3.setInterval && Ge(vr, "setInterval", oi), t3.requestAnimationFrame && Ge(vr, "requestAnimationFrame", si), t3.XMLHttpRequest && "XMLHttpRequest" in vr && Ge(XMLHttpRequest.prototype, "send", ai);
    const e5 = t3.eventTarget;
    if (e5) {
      (Array.isArray(e5) ? e5 : ri).forEach(ci);
    }
  } };
};
function oi(e4) {
  return function(...t3) {
    const n3 = t3[0];
    return t3[0] = yr(n3, { mechanism: { data: { function: ve(e4) }, handled: false, type: "instrument" } }), e4.apply(this, t3);
  };
}
function si(e4) {
  return function(t3) {
    return e4.apply(this, [yr(t3, { mechanism: { data: { function: "requestAnimationFrame", handler: ve(e4) }, handled: false, type: "instrument" } })]);
  };
}
function ai(e4) {
  return function(...t3) {
    const n3 = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((e5) => {
      e5 in n3 && "function" == typeof n3[e5] && Ge(n3, e5, function(t4) {
        const n4 = { mechanism: { data: { function: e5, handler: ve(t4) }, handled: false, type: "instrument" } }, r4 = Ye(t4);
        return r4 && (n4.mechanism.data.handler = ve(r4)), yr(t4, n4);
      });
    }), e4.apply(this, t3);
  };
}
function ci(e4) {
  const t3 = vr[e4], n3 = t3 && t3.prototype;
  n3 && n3.hasOwnProperty && n3.hasOwnProperty("addEventListener") && (Ge(n3, "addEventListener", function(t4) {
    return function(n4, r4, i3) {
      try {
        "function" == typeof r4.handleEvent && (r4.handleEvent = yr(r4.handleEvent, { mechanism: { data: { function: "handleEvent", handler: ve(r4), target: e4 }, handled: false, type: "instrument" } }));
      } catch (e5) {
      }
      return t4.apply(this, [n4, yr(r4, { mechanism: { data: { function: "addEventListener", handler: ve(r4), target: e4 }, handled: false, type: "instrument" } }), i3]);
    };
  }), Ge(n3, "removeEventListener", function(e5) {
    return function(t4, n4, r4) {
      try {
        const i3 = n4.__sentry_wrapped__;
        i3 && e5.call(this, t4, i3, r4);
      } catch (e6) {
      }
      return e5.call(this, t4, n4, r4);
    };
  }));
}
var li = () => ({ name: "BrowserSession", setupOnce() {
  void 0 !== vr.document ? (Cn({ ignoreDuration: true }), On(), Ur(({ from: e4, to: t3 }) => {
    void 0 !== e4 && e4 !== t3 && (Cn({ ignoreDuration: true }), On());
  })) : br && le.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
} });
var ui = (e4 = {}) => {
  const t3 = { onerror: true, onunhandledrejection: true, ...e4 };
  return { name: "GlobalHandlers", setupOnce() {
    Error.stackTraceLimit = 50;
  }, setup(e5) {
    t3.onerror && (!function(e6) {
      !function(e7) {
        const t4 = "error";
        be(t4, e7), _e(t4, ke);
      }((t4) => {
        const { stackParser: n3, attachStacktrace: r4 } = pi();
        if (xt() !== e6 || mr())
          return;
        const { msg: i3, url: o4, line: s3, column: a3, error: c3 } = t4, l3 = function(e7, t5, n4, r5) {
          const i4 = e7.exception = e7.exception || {}, o5 = i4.values = i4.values || [], s4 = o5[0] = o5[0] || {}, a4 = s4.stacktrace = s4.stacktrace || {}, c4 = a4.frames = a4.frames || [], l4 = r5, u3 = n4, d3 = xe(t5) && t5.length > 0 ? t5 : function() {
            try {
              return Ve.document.location.href;
            } catch (e8) {
              return "";
            }
          }();
          0 === c4.length && c4.push({ colno: l4, filename: d3, function: ue, in_app: true, lineno: u3 });
          return e7;
        }(Or(n3, c3 || i3, void 0, r4, false), o4, s3, a3);
        l3.level = "error", Mn(l3, { originalException: c3, mechanism: { handled: false, type: "onerror" } });
      });
    }(e5), di("onerror")), t3.onunhandledrejection && (!function(e6) {
      !function(e7) {
        const t4 = "unhandledrejection";
        be(t4, e7), _e(t4, Ce);
      }((t4) => {
        const { stackParser: n3, attachStacktrace: r4 } = pi();
        if (xt() !== e6 || mr())
          return;
        const i3 = function(e7) {
          if (De(e7))
            return e7;
          try {
            if ("reason" in e7)
              return e7.reason;
            if ("detail" in e7 && "reason" in e7.detail)
              return e7.detail.reason;
          } catch (e8) {
          }
          return e7;
        }(t4), o4 = De(i3) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(i3)}` }] } } : Or(n3, i3, void 0, r4, true);
        o4.level = "error", Mn(o4, { originalException: i3, mechanism: { handled: false, type: "onunhandledrejection" } });
      });
    }(e5), di("onunhandledrejection"));
  } };
};
function di(e4) {
  br && le.log(`Global Handler attached: ${e4}`);
}
function pi() {
  const e4 = xt();
  return e4 && e4.getOptions() || { stackParser: () => [], attachStacktrace: false };
}
var hi = () => ({ name: "HttpContext", preprocessEvent(e4) {
  if (!vr.navigator && !vr.location && !vr.document)
    return;
  const t3 = e4.request && e4.request.url || vr.location && vr.location.href, { referrer: n3 } = vr.document || {}, { userAgent: r4 } = vr.navigator || {}, i3 = { ...e4.request && e4.request.headers, ...n3 && { Referer: n3 }, ...r4 && { "User-Agent": r4 } }, o4 = { ...e4.request, ...t3 && { url: t3 }, headers: i3 };
  e4.request = o4;
} });
var fi = (e4 = {}) => {
  const t3 = e4.limit || 5, n3 = e4.key || "cause";
  return { name: "LinkedErrors", preprocessEvent(e5, r4, i3) {
    const o4 = i3.getOptions();
    Kn(_r, o4.stackParser, o4.maxValueLength, n3, t3, e5, r4);
  } };
};
var vi = "new";
var gi = "loading";
var mi = "loaded";
var yi = "joining-meeting";
var bi = "joined-meeting";
var _i = "left-meeting";
var wi = "error";
var Ti = "playable";
var Oi = "unknown";
var Pi = "full";
var Ii = "base";
var Bi = "no-room";
var Vi = "end-of-life";
var $i = "connection-error";
var Xi = "iframe-ready-for-launch-config";
var Zi = "iframe-launch-config";
var eo = "theme-updated";
var to = "loading";
var no = "load-attempt-failed";
var ro = "loaded";
var io = "started-camera";
var oo = "camera-error";
var so = "joining-meeting";
var ao = "joined-meeting";
var co = "left-meeting";
var lo = "participant-joined";
var uo = "participant-updated";
var po = "participant-left";
var ho = "participant-counts-updated";
var fo = "access-state-updated";
var vo = "meeting-session-summary-updated";
var go = "meeting-session-state-updated";
var yo = "waiting-participant-added";
var bo = "waiting-participant-updated";
var _o = "waiting-participant-removed";
var wo = "track-started";
var So = "track-stopped";
var ko = "transcription-started";
var Mo = "transcription-stopped";
var Co = "transcription-error";
var Eo = "recording-started";
var To = "recording-stopped";
var Oo = "recording-stats";
var Po = "recording-error";
var Ao = "recording-upload-completed";
var jo = "recording-data";
var Io = "app-message";
var xo = "transcription-message";
var Lo = "remote-media-player-started";
var Do = "remote-media-player-updated";
var No = "remote-media-player-stopped";
var Ro = "local-screen-share-started";
var Fo = "local-screen-share-stopped";
var Bo = "local-screen-share-canceled";
var Uo = "active-speaker-change";
var Vo = "active-speaker-mode-change";
var Jo = "network-quality-change";
var $o = "network-connection";
var qo = "cpu-load-change";
var zo = "face-counts-updated";
var Wo = "fullscreen";
var Ho = "exited-fullscreen";
var Go = "live-streaming-started";
var Qo = "live-streaming-updated";
var Ko = "live-streaming-stopped";
var Yo = "live-streaming-error";
var Xo = "lang-updated";
var Zo = "receive-settings-updated";
var es = "input-settings-updated";
var ts = "nonfatal-error";
var ns = "error";
var rs = 4096;
var is = 102400;
var os = "iframe-call-message";
var ss = "local-screen-start";
var as = "daily-method-update-live-streaming-endpoints";
var cs = "transmit-log";
var ls = "daily-custom-track";
var us = { NONE: "none", BGBLUR: "background-blur", BGIMAGE: "background-image", FACE_DETECTION: "face-detection" };
var ds = { NONE: "none", NOISE_CANCELLATION: "noise-cancellation" };
var ps = { PLAY: "play", PAUSE: "pause" };
var hs = ["jpg", "png", "jpeg"];
var fs = "add-endpoints";
var vs = "remove-endpoints";
var gs = "sip-call-transfer";
function ms() {
  return !ys() && "undefined" != typeof window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
}
function ys() {
  return "undefined" != typeof navigator && navigator.product && "ReactNative" === navigator.product;
}
function bs() {
  return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
}
function _s() {
  return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (function(e4, t3) {
    if (!e4 || !t3)
      return true;
    switch (e4) {
      case "Chrome":
        return t3.major >= 75;
      case "Safari":
        return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(13 === t3.major && 0 === t3.minor && 0 === t3.point);
      case "Firefox":
        return t3.major >= 67;
    }
    return true;
  }(Os(), Ps()) || ys());
}
function ws() {
  if (ys())
    return false;
  if (!document)
    return false;
  var e4 = document.createElement("iframe");
  return !!e4.requestFullscreen || !!e4.webkitRequestFullscreen;
}
var Ss = function() {
  try {
    var e4 = document.createElement("canvas"), t3 = null != (navigator.webdriver ? e4.getContext("webgl2") : e4.getContext("webgl2", { failIfMajorPerformanceCaveat: true }));
    return e4.remove(), t3;
  } catch (e5) {
    return false;
  }
}();
function ks() {
  var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
  return !ys() && (!!Ss && (e4 ? function() {
    if (Ts())
      return false;
    return ["Chrome", "Firefox"].includes(Os());
  }() : function() {
    if (Ts())
      return false;
    var e5 = Os();
    if ("Safari" === e5) {
      var t3 = xs();
      if (t3.major < 15 || 15 === t3.major && t3.minor < 4)
        return false;
    }
    if ("Chrome" === e5) {
      return As().major >= 77;
    }
    if ("Firefox" === e5) {
      return Ls().major >= 97;
    }
    return ["Chrome", "Firefox", "Safari"].includes(e5);
  }()));
}
function Ms() {
  if (ys())
    return false;
  if (Es())
    return false;
  if ("undefined" == typeof AudioWorkletNode)
    return false;
  switch (Os()) {
    case "Chrome":
    case "Firefox":
      return true;
    case "Safari":
      var e4 = Ps();
      return e4.major > 17 || 17 === e4.major && e4.minor >= 4;
  }
  return false;
}
function Cs() {
  return bs() && !function() {
    var e4, t3 = Os();
    if (!ms())
      return true;
    switch (t3) {
      case "Chrome":
        return (e4 = As()).major && e4.major > 0 && e4.major < 75;
      case "Firefox":
        return (e4 = Ls()).major < 91;
      case "Safari":
        return (e4 = xs()).major < 13 || 13 === e4.major && e4.minor < 1;
      default:
        return true;
    }
  }();
}
function Es() {
  return ms().match(/Linux; Android/);
}
function Ts() {
  var e4, t3 = ms(), n3 = t3.match(/Mac/) && (!ys() && "undefined" != typeof window && null !== (e4 = window) && void 0 !== e4 && null !== (e4 = e4.navigator) && void 0 !== e4 && e4.maxTouchPoints ? window.navigator.maxTouchPoints : 0) >= 5;
  return !!(t3.match(/Mobi/) || t3.match(/Android/) || n3) || (!!ms().match(/DailyAnd\//) || void 0);
}
function Os() {
  if ("undefined" != typeof window) {
    var e4 = ms();
    return js() ? "Safari" : e4.indexOf("Edge") > -1 ? "Edge" : e4.match(/Chrome\//) ? "Chrome" : e4.indexOf("Safari") > -1 || Is() ? "Safari" : e4.indexOf("Firefox") > -1 ? "Firefox" : e4.indexOf("MSIE") > -1 || e4.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
  }
}
function Ps() {
  switch (Os()) {
    case "Chrome":
      return As();
    case "Safari":
      return xs();
    case "Firefox":
      return Ls();
    case "Edge":
      return function() {
        var e4 = 0, t3 = 0;
        if ("undefined" != typeof window) {
          var n3 = ms().match(/Edge\/(\d+).(\d+)/);
          if (n3)
            try {
              e4 = parseInt(n3[1]), t3 = parseInt(n3[2]);
            } catch (e5) {
            }
        }
        return { major: e4, minor: t3 };
      }();
  }
}
function As() {
  var e4 = 0, t3 = 0, n3 = 0, r4 = 0, i3 = false;
  if ("undefined" != typeof window) {
    var o4 = ms(), s3 = o4.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
    if (s3)
      try {
        e4 = parseInt(s3[1]), t3 = parseInt(s3[2]), n3 = parseInt(s3[3]), r4 = parseInt(s3[4]), i3 = o4.indexOf("OPR/") > -1;
      } catch (e5) {
      }
  }
  return { major: e4, minor: t3, build: n3, patch: r4, opera: i3 };
}
function js() {
  return !!ms().match(/iPad|iPhone|iPod/i) && bs();
}
function Is() {
  return ms().indexOf("AppleWebKit/605.1.15") > -1;
}
function xs() {
  var e4 = 0, t3 = 0, n3 = 0;
  if ("undefined" != typeof window) {
    var r4 = ms().match(/Version\/(\d+).(\d+)(.(\d+))?/);
    if (r4)
      try {
        e4 = parseInt(r4[1]), t3 = parseInt(r4[2]), n3 = parseInt(r4[4]);
      } catch (e5) {
      }
    else
      (js() || Is()) && (e4 = 14, t3 = 0, n3 = 3);
  }
  return { major: e4, minor: t3, point: n3 };
}
function Ls() {
  var e4 = 0, t3 = 0;
  if ("undefined" != typeof window) {
    var n3 = ms().match(/Firefox\/(\d+).(\d+)/);
    if (n3)
      try {
        e4 = parseInt(n3[1]), t3 = parseInt(n3[2]);
      } catch (e5) {
      }
  }
  return { major: e4, minor: t3 };
}
var Ds = function() {
  return o(function e4() {
    t(this, e4);
  }, [{ key: "addListenerForMessagesFromCallMachine", value: function(e4, t3, n3) {
    Y();
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e4, t3, n3) {
    Y();
  } }, { key: "sendMessageToCallMachine", value: function(e4, t3, n3, r4) {
    Y();
  } }, { key: "sendMessageToDailyJs", value: function(e4, t3) {
    Y();
  } }, { key: "removeListener", value: function(e4) {
    Y();
  } }]);
}();
function Ns(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function Rs(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? Ns(Object(n3), true).forEach(function(t4) {
      u(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Ns(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
function Fs() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Fs = function() {
    return !!e4;
  })();
}
var Bs = function() {
  function e4() {
    var n3, r4, i3, o4;
    return t(this, e4), r4 = this, i3 = a(i3 = e4), (n3 = s(r4, Fs() ? Reflect.construct(i3, o4 || [], a(r4).constructor) : i3.apply(r4, o4)))._wrappedListeners = {}, n3._messageCallbacks = {}, n3;
  }
  return l(e4, Ds), o(e4, [{ key: "addListenerForMessagesFromCallMachine", value: function(e5, t3, n3) {
    var r4 = this, i3 = function(i4) {
      if (i4.data && "iframe-call-message" === i4.data.what && (!i4.data.callClientId || i4.data.callClientId === t3) && (!i4.data.from || "module" !== i4.data.from)) {
        var o4 = Rs({}, i4.data);
        if (delete o4.from, o4.callbackStamp && r4._messageCallbacks[o4.callbackStamp]) {
          var s3 = o4.callbackStamp;
          r4._messageCallbacks[s3].call(n3, o4), delete r4._messageCallbacks[s3];
        }
        delete o4.what, delete o4.callbackStamp, e5.call(n3, o4);
      }
    };
    this._wrappedListeners[e5] = i3, window.addEventListener("message", i3);
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e5, t3, n3) {
    var r4 = function(r5) {
      var i3;
      if (!(!r5.data || r5.data.what !== os || !r5.data.action || r5.data.from && "module" !== r5.data.from || r5.data.callClientId && t3 && r5.data.callClientId !== t3 || null != r5 && null !== (i3 = r5.data) && void 0 !== i3 && i3.callFrameId)) {
        var o4 = r5.data;
        e5.call(n3, o4);
      }
    };
    this._wrappedListeners[e5] = r4, window.addEventListener("message", r4);
  } }, { key: "sendMessageToCallMachine", value: function(e5, t3, n3, r4) {
    if (!n3)
      throw new Error("undefined callClientId. Are you trying to use a DailyCall instance previously destroyed?");
    var i3 = Rs({}, e5);
    if (i3.what = os, i3.from = "module", i3.callClientId = n3, t3) {
      var o4 = K();
      this._messageCallbacks[o4] = t3, i3.callbackStamp = o4;
    }
    var s3 = r4 ? r4.contentWindow : window, a3 = this._callMachineTargetOrigin(r4);
    a3 && s3.postMessage(i3, a3);
  } }, { key: "sendMessageToDailyJs", value: function(e5, t3) {
    e5.what = os, e5.callClientId = t3, e5.from = "embedded", window.postMessage(e5, this._targetOriginFromWindowLocation());
  } }, { key: "removeListener", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (window.removeEventListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e5, t3, n3) {
    var r4 = Rs({}, e5);
    r4.callClientId = n3;
    var i3 = t3 ? t3.contentWindow : window, o4 = this._callMachineTargetOrigin(t3);
    o4 && i3.postMessage(r4, o4);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e5, t3) {
    var n3 = function(n4) {
      if (n4.data && "iframe-call-message" === n4.data.what && (!n4.data.callClientId || n4.data.callClientId === t3) && (!n4.data.from || "module" !== n4.data.from)) {
        var r4 = n4.data;
        e5(r4);
      }
    };
    return this._wrappedListeners[e5] = n3, window.addEventListener("message", n3), e5;
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (window.removeEventListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "_callMachineTargetOrigin", value: function(e5) {
    return e5 ? e5.src ? new URL(e5.src).origin : void 0 : this._targetOriginFromWindowLocation();
  } }, { key: "_targetOriginFromWindowLocation", value: function() {
    return "file:" === window.location.protocol ? "*" : window.location.origin;
  } }]);
}();
function Us(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function Vs() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Vs = function() {
    return !!e4;
  })();
}
var Js = function() {
  function e4() {
    var n3, r4, i3, o4;
    return t(this, e4), r4 = this, i3 = a(i3 = e4), n3 = s(r4, Vs() ? Reflect.construct(i3, o4 || [], a(r4).constructor) : i3.apply(r4, o4)), global.callMachineToDailyJsEmitter = global.callMachineToDailyJsEmitter || new I.EventEmitter(), global.dailyJsToCallMachineEmitter = global.dailyJsToCallMachineEmitter || new I.EventEmitter(), n3._wrappedListeners = {}, n3._messageCallbacks = {}, n3;
  }
  return l(e4, Ds), o(e4, [{ key: "addListenerForMessagesFromCallMachine", value: function(e5, t3, n3) {
    this._addListener(e5, global.callMachineToDailyJsEmitter, t3, n3, "received call machine message");
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e5, t3, n3) {
    this._addListener(e5, global.dailyJsToCallMachineEmitter, t3, n3, "received daily-js message");
  } }, { key: "sendMessageToCallMachine", value: function(e5, t3, n3) {
    this._sendMessage(e5, global.dailyJsToCallMachineEmitter, n3, t3, "sending message to call machine");
  } }, { key: "sendMessageToDailyJs", value: function(e5, t3) {
    this._sendMessage(e5, global.callMachineToDailyJsEmitter, t3, null, "sending message to daily-js");
  } }, { key: "removeListener", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (global.callMachineToDailyJsEmitter.removeListener("message", t3), global.dailyJsToCallMachineEmitter.removeListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "_addListener", value: function(e5, t3, n3, r4, i3) {
    var o4 = this, s3 = function(t4) {
      if (t4.callClientId === n3) {
        if (t4.callbackStamp && o4._messageCallbacks[t4.callbackStamp]) {
          var i4 = t4.callbackStamp;
          o4._messageCallbacks[i4].call(r4, t4), delete o4._messageCallbacks[i4];
        }
        e5.call(r4, t4);
      }
    };
    this._wrappedListeners[e5] = s3, t3.addListener("message", s3);
  } }, { key: "_sendMessage", value: function(e5, t3, n3, r4, i3) {
    var o4 = function(e6) {
      for (var t4 = 1; t4 < arguments.length; t4++) {
        var n4 = null != arguments[t4] ? arguments[t4] : {};
        t4 % 2 ? Us(Object(n4), true).forEach(function(t5) {
          u(e6, t5, n4[t5]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(n4)) : Us(Object(n4)).forEach(function(t5) {
          Object.defineProperty(e6, t5, Object.getOwnPropertyDescriptor(n4, t5));
        });
      }
      return e6;
    }({}, e5);
    if (o4.callClientId = n3, r4) {
      var s3 = K();
      this._messageCallbacks[s3] = r4, o4.callbackStamp = s3;
    }
    t3.emit("message", o4);
  } }]);
}();
var $s = "replace";
var qs = "shallow-merge";
var zs = [$s, qs];
var Ws = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.data, i3 = n3.mergeStrategy, o4 = void 0 === i3 ? $s : i3;
    t(this, e4), e4._validateMergeStrategy(o4), e4._validateData(r4, o4), this.mergeStrategy = o4, this.data = r4;
  }
  return o(e4, [{ key: "isNoOp", value: function() {
    return e4.isNoOpUpdate(this.data, this.mergeStrategy);
  } }], [{ key: "isNoOpUpdate", value: function(e5, t3) {
    return 0 === Object.keys(e5).length && t3 === qs;
  } }, { key: "_validateMergeStrategy", value: function(e5) {
    if (!zs.includes(e5))
      throw Error("Unrecognized mergeStrategy provided. Options are: [".concat(zs, "]"));
  } }, { key: "_validateData", value: function(e5, t3) {
    if (!function(e6) {
      if (null == e6 || "object" !== n(e6))
        return false;
      var t4 = Object.getPrototypeOf(e6);
      return null == t4 || t4 === Object.prototype;
    }(e5))
      throw Error("Meeting session data must be a plain (map-like) object");
    var r4;
    try {
      if (r4 = JSON.stringify(e5), t3 === $s) {
        var i3 = JSON.parse(r4);
        N(i3, e5) || console.warn("The meeting session data provided will be modified when serialized.", i3, e5);
      } else if (t3 === qs) {
        for (var o4 in e5)
          if (Object.hasOwnProperty.call(e5, o4) && void 0 !== e5[o4]) {
            var s3 = JSON.parse(JSON.stringify(e5[o4]));
            N(e5[o4], s3) || console.warn("At least one key in the meeting session data provided will be modified when serialized.", s3, e5[o4]);
          }
      }
    } catch (e6) {
      throw Error("Meeting session data must be serializable to JSON: ".concat(e6));
    }
    if (r4.length > is)
      throw Error("Meeting session data is too large (".concat(r4.length, " characters). Maximum size suppported is ").concat(is, "."));
  } }]);
}();
function Hs() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Hs = function() {
    return !!e4;
  })();
}
function Gs(e4) {
  var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return Gs = function(e5) {
    if (null === e5 || !function(e6) {
      try {
        return -1 !== Function.toString.call(e6).indexOf("[native code]");
      } catch (t4) {
        return "function" == typeof e6;
      }
    }(e5))
      return e5;
    if ("function" != typeof e5)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t3) {
      if (t3.has(e5))
        return t3.get(e5);
      t3.set(e5, n3);
    }
    function n3() {
      return function(e6, t4, n4) {
        if (Hs())
          return Reflect.construct.apply(null, arguments);
        var r4 = [null];
        r4.push.apply(r4, t4);
        var i3 = new (e6.bind.apply(e6, r4))();
        return n4 && c(i3, n4.prototype), i3;
      }(e5, arguments, a(this).constructor);
    }
    return n3.prototype = Object.create(e5.prototype, { constructor: { value: n3, enumerable: false, writable: true, configurable: true } }), c(n3, e5);
  }, Gs(e4);
}
function Qs() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Qs = function() {
    return !!e4;
  })();
}
function Ks(e4) {
  var t3, n3 = null === (t3 = window._daily) || void 0 === t3 ? void 0 : t3.pendings;
  if (n3) {
    var r4 = n3.indexOf(e4);
    -1 !== r4 && n3.splice(r4, 1);
  }
}
var Ys = function() {
  return o(function e4(n3) {
    t(this, e4), this._currentLoad = null, this._callClientId = n3;
  }, [{ key: "load", value: function() {
    var e4, t3 = this, n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = arguments.length > 1 ? arguments[1] : void 0, i3 = arguments.length > 2 ? arguments[2] : void 0;
    if (this.loaded)
      return window._daily.instances[this._callClientId].callMachine.reset(), void r4(true);
    e4 = this._callClientId, window._daily.pendings.push(e4), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new Xs(n3, function() {
      r4(false);
    }, function(e5, n4) {
      n4 || Ks(t3._callClientId), i3(e5, n4);
    }), this._currentLoad.start();
  } }, { key: "cancel", value: function() {
    this._currentLoad && this._currentLoad.cancel(), Ks(this._callClientId);
  } }, { key: "loaded", get: function() {
    return this._currentLoad && this._currentLoad.succeeded;
  } }]);
}();
var Xs = function() {
  return o(function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = arguments.length > 1 ? arguments[1] : void 0, i3 = arguments.length > 2 ? arguments[2] : void 0;
    t(this, e4), this._attemptsRemaining = 3, this._currentAttempt = null, this._dailyConfig = n3, this._successCallback = r4, this._failureCallback = i3;
  }, [{ key: "start", value: function() {
    var e4 = this;
    if (!this._currentAttempt) {
      var t3 = function(n3) {
        e4._currentAttempt.cancelled || (e4._attemptsRemaining--, e4._failureCallback(n3, e4._attemptsRemaining > 0), e4._attemptsRemaining <= 0 || setTimeout(function() {
          e4._currentAttempt.cancelled || (e4._currentAttempt = new ta(e4._dailyConfig, e4._successCallback, t3), e4._currentAttempt.start());
        }, 3e3));
      };
      this._currentAttempt = new ta(this._dailyConfig, this._successCallback, t3), this._currentAttempt.start();
    }
  } }, { key: "cancel", value: function() {
    this._currentAttempt && this._currentAttempt.cancel();
  } }, { key: "cancelled", get: function() {
    return this._currentAttempt && this._currentAttempt.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._currentAttempt && this._currentAttempt.succeeded;
  } }]);
}();
var Zs = function() {
  function e4() {
    return t(this, e4), n3 = this, i3 = arguments, r4 = a(r4 = e4), s(n3, Qs() ? Reflect.construct(r4, i3 || [], a(n3).constructor) : r4.apply(n3, i3));
    var n3, r4, i3;
  }
  return l(e4, Gs(Error)), o(e4);
}();
var ea = 2e4;
var ta = function() {
  return o(function e5(n3, r4, i3) {
    t(this, e5), this._loadAttemptImpl = ys() || !n3.avoidEval ? new na(n3, r4, i3) : new ra(n3, r4, i3);
  }, [{ key: "start", value: (e4 = p(function* () {
    return this._loadAttemptImpl.start();
  }), function() {
    return e4.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    this._loadAttemptImpl.cancel();
  } }, { key: "cancelled", get: function() {
    return this._loadAttemptImpl.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._loadAttemptImpl.succeeded;
  } }]);
  var e4;
}();
var na = function() {
  return o(function e5(n4, r5, i4) {
    t(this, e5), this.cancelled = false, this.succeeded = false, this._networkTimedOut = false, this._networkTimeout = null, this._iosCache = "undefined" != typeof iOSCallObjectBundleCache && iOSCallObjectBundleCache, this._refetchHeaders = null, this._dailyConfig = n4, this._successCallback = r5, this._failureCallback = i4;
  }, [{ key: "start", value: (i3 = p(function* () {
    var e5 = Z(this._dailyConfig);
    !(yield this._tryLoadFromIOSCache(e5)) && this._loadFromNetwork(e5);
  }), function() {
    return i3.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    clearTimeout(this._networkTimeout), this.cancelled = true;
  } }, { key: "_tryLoadFromIOSCache", value: (r4 = p(function* (e5) {
    if (!this._iosCache)
      return false;
    try {
      var t3 = yield this._iosCache.get(e5);
      return !!this.cancelled || !!t3 && (t3.code ? (Function('"use strict";' + t3.code)(), this.succeeded = true, this._successCallback(), true) : (this._refetchHeaders = t3.refetchHeaders, false));
    } catch (e6) {
      return false;
    }
  }), function(e5) {
    return r4.apply(this, arguments);
  }) }, { key: "_loadFromNetwork", value: (n3 = p(function* (e5) {
    var t3 = this;
    this._networkTimeout = setTimeout(function() {
      t3._networkTimedOut = true, t3._failureCallback({ msg: "Timed out (>".concat(ea, " ms) when loading call object bundle ").concat(e5), type: "timeout" });
    }, ea);
    try {
      var n4 = this._refetchHeaders ? { headers: this._refetchHeaders } : {}, r5 = yield fetch(e5, n4);
      if (clearTimeout(this._networkTimeout), this.cancelled || this._networkTimedOut)
        throw new Zs();
      var i4 = yield this._getBundleCodeFromResponse(e5, r5);
      if (this.cancelled)
        throw new Zs();
      Function('"use strict";' + i4)(), this._iosCache && this._iosCache.set(e5, i4, r5.headers), this.succeeded = true, this._successCallback();
    } catch (t4) {
      if (clearTimeout(this._networkTimeout), t4 instanceof Zs || this.cancelled || this._networkTimedOut)
        return;
      this._failureCallback({ msg: "Failed to load call object bundle ".concat(e5, ": ").concat(t4), type: t4.message });
    }
  }), function(e5) {
    return n3.apply(this, arguments);
  }) }, { key: "_getBundleCodeFromResponse", value: (e4 = p(function* (e5, t3) {
    if (t3.ok)
      return yield t3.text();
    if (this._iosCache && 304 === t3.status)
      return (yield this._iosCache.renew(e5, t3.headers)).code;
    throw new Error("Received ".concat(t3.status, " response"));
  }), function(t3, n4) {
    return e4.apply(this, arguments);
  }) }]);
  var e4, n3, r4, i3;
}();
var ra = function() {
  return o(function e4(n3, r4, i3) {
    t(this, e4), this.cancelled = false, this.succeeded = false, this._dailyConfig = n3, this._successCallback = r4, this._failureCallback = i3, this._attemptId = K(), this._networkTimeout = null, this._scriptElement = null;
  }, [{ key: "start", value: function() {
    window._dailyCallMachineLoadWaitlist || (window._dailyCallMachineLoadWaitlist = /* @__PURE__ */ new Set());
    var e4 = Z(this._dailyConfig);
    "object" === ("undefined" == typeof document ? "undefined" : n(document)) ? this._startLoading(e4) : this._failureCallback({ msg: "Call object bundle must be loaded in a DOM/web context", type: "missing context" });
  } }, { key: "cancel", value: function() {
    this._stopLoading(), this.cancelled = true;
  } }, { key: "_startLoading", value: function(e4) {
    var t3 = this;
    this._signUpForCallMachineLoadWaitlist(), this._networkTimeout = setTimeout(function() {
      t3._stopLoading(), t3._failureCallback({ msg: "Timed out (>".concat(ea, " ms) when loading call object bundle ").concat(e4), type: "timeout" });
    }, ea);
    var n3 = document.getElementsByTagName("head")[0], r4 = document.createElement("script");
    this._scriptElement = r4, r4.onload = function() {
      t3._stopLoading(), t3.succeeded = true, t3._successCallback();
    }, r4.onerror = function(e5) {
      t3._stopLoading(), t3._failureCallback({ msg: "Failed to load call object bundle ".concat(e5.target.src), type: e5.message });
    }, r4.src = e4, n3.appendChild(r4);
  } }, { key: "_stopLoading", value: function() {
    this._withdrawFromCallMachineLoadWaitlist(), clearTimeout(this._networkTimeout), this._scriptElement && (this._scriptElement.onload = null, this._scriptElement.onerror = null);
  } }, { key: "_signUpForCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.add(this._attemptId);
  } }, { key: "_withdrawFromCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.delete(this._attemptId);
  } }]);
}();
var ia = function(e4, t3, n3) {
  return true === aa(e4.local, t3, n3);
};
var oa = function(e4, t3, n3) {
  return e4.local.streams && e4.local.streams[t3] && e4.local.streams[t3].stream && e4.local.streams[t3].stream["get".concat("video" === n3 ? "Video" : "Audio", "Tracks")]()[0];
};
var sa = function(e4, t3, n3, r4) {
  var i3 = ca(e4, t3, n3, r4);
  return i3 && i3.pendingTrack;
};
var aa = function(e4, t3, n3) {
  if (!e4)
    return false;
  var r4 = function(e5) {
    switch (e5) {
      case "avatar":
        return true;
      case "staged":
        return e5;
      default:
        return !!e5;
    }
  }, i3 = e4.public.subscribedTracks;
  return i3 && i3[t3] ? -1 === ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo"].indexOf(n3) && i3[t3].custom ? [true, "staged"].includes(i3[t3].custom) ? r4(i3[t3].custom) : r4(i3[t3].custom[n3]) : r4(i3[t3][n3]) : !i3 || r4(i3.ALL);
};
var ca = function(e4, t3, n3, r4) {
  var i3 = Object.values(e4.streams || {}).filter(function(e5) {
    return e5.participantId === t3 && e5.type === n3 && e5.pendingTrack && e5.pendingTrack.kind === r4;
  }).sort(function(e5, t4) {
    return new Date(t4.starttime) - new Date(e5.starttime);
  });
  return i3 && i3[0];
};
var la = function(e4, t3) {
  var n3 = e4.local.public.customTracks;
  if (n3 && n3[t3])
    return n3[t3].track;
};
function ua(e4, t3) {
  for (var n3 = t3.getState(), r4 = 0, i3 = ["cam", "screen"]; r4 < i3.length; r4++)
    for (var o4 = i3[r4], s3 = 0, a3 = ["video", "audio"]; s3 < a3.length; s3++) {
      var c3 = a3[s3], l3 = "cam" === o4 ? c3 : "screen".concat(c3.charAt(0).toUpperCase() + c3.slice(1)), u3 = e4.tracks[l3];
      if (u3) {
        var d3 = e4.local ? oa(n3, o4, c3) : sa(n3, e4.session_id, o4, c3);
        "playable" === u3.state && (u3.track = d3), u3.persistentTrack = d3;
      }
    }
}
function da(e4, t3) {
  try {
    var n3 = t3.getState();
    for (var r4 in e4.tracks)
      if (!pa(r4)) {
        var i3 = e4.tracks[r4].kind;
        if (i3) {
          var o4 = e4.tracks[r4];
          if (o4) {
            var s3 = e4.local ? la(n3, r4) : sa(n3, e4.session_id, r4, i3);
            "playable" === o4.state && (e4.tracks[r4].track = s3), o4.persistentTrack = s3;
          }
        } else
          console.error("unknown type for custom track");
      }
  } catch (e5) {
    console.error(e5);
  }
}
function pa(e4) {
  return ["video", "audio", "screenVideo", "screenAudio"].includes(e4);
}
function ha(e4, t3, n3) {
  var r4 = n3.getState();
  if (e4.local) {
    if (e4.audio)
      try {
        e4.audioTrack = r4.local.streams.cam.stream.getAudioTracks()[0], e4.audioTrack || (e4.audio = false);
      } catch (e5) {
      }
    if (e4.video)
      try {
        e4.videoTrack = r4.local.streams.cam.stream.getVideoTracks()[0], e4.videoTrack || (e4.video = false);
      } catch (e5) {
      }
    if (e4.screen)
      try {
        e4.screenVideoTrack = r4.local.streams.screen.stream.getVideoTracks()[0], e4.screenAudioTrack = r4.local.streams.screen.stream.getAudioTracks()[0], e4.screenVideoTrack || e4.screenAudioTrack || (e4.screen = false);
      } catch (e5) {
      }
  } else {
    var i3 = true;
    try {
      var o4 = r4.participants[e4.session_id];
      o4 && o4.public && o4.public.rtcType && "peer-to-peer" === o4.public.rtcType.impl && o4.private && !["connected", "completed"].includes(o4.private.peeringState) && (i3 = false);
    } catch (e5) {
      console.error(e5);
    }
    if (!i3)
      return e4.audio = false, e4.audioTrack = false, e4.video = false, e4.videoTrack = false, e4.screen = false, void (e4.screenTrack = false);
    try {
      r4.streams;
      if (e4.audio && ia(r4, e4.session_id, "cam-audio")) {
        var s3 = sa(r4, e4.session_id, "cam", "audio");
        s3 && (t3 && t3.audioTrack && t3.audioTrack.id === s3.id ? e4.audioTrack = s3 : s3.muted || (e4.audioTrack = s3)), e4.audioTrack || (e4.audio = false);
      }
      if (e4.video && ia(r4, e4.session_id, "cam-video")) {
        var a3 = sa(r4, e4.session_id, "cam", "video");
        a3 && (t3 && t3.videoTrack && t3.videoTrack.id === a3.id ? e4.videoTrack = a3 : a3.muted || (e4.videoTrack = a3)), e4.videoTrack || (e4.video = false);
      }
      if (e4.screen && ia(r4, e4.session_id, "screen-audio")) {
        var c3 = sa(r4, e4.session_id, "screen", "audio");
        c3 && (t3 && t3.screenAudioTrack && t3.screenAudioTrack.id === c3.id ? e4.screenAudioTrack = c3 : c3.muted || (e4.screenAudioTrack = c3));
      }
      if (e4.screen && ia(r4, e4.session_id, "screen-video")) {
        var l3 = sa(r4, e4.session_id, "screen", "video");
        l3 && (t3 && t3.screenVideoTrack && t3.screenVideoTrack.id === l3.id ? e4.screenVideoTrack = l3 : l3.muted || (e4.screenVideoTrack = l3));
      }
      e4.screenVideoTrack || e4.screenAudioTrack || (e4.screen = false);
    } catch (e5) {
      console.error("unexpected error matching up tracks", e5);
    }
  }
}
function fa(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return va(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? va(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function va(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var ga = /* @__PURE__ */ new Map();
var ma = null;
function ya(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return ba(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? ba(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function ba(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var _a = /* @__PURE__ */ new Map();
var wa = null;
function Sa(e4) {
  Ma() ? function(e5) {
    ga.has(e5) || (ga.set(e5, {}), navigator.mediaDevices.enumerateDevices().then(function(t3) {
      ga.has(e5) && (ga.get(e5).lastDevicesString = JSON.stringify(t3), ma || (ma = function() {
        var e6 = p(function* () {
          var e7, t4 = yield navigator.mediaDevices.enumerateDevices(), n3 = fa(ga.keys());
          try {
            for (n3.s(); !(e7 = n3.n()).done; ) {
              var r4 = e7.value, i3 = JSON.stringify(t4);
              i3 !== ga.get(r4).lastDevicesString && (ga.get(r4).lastDevicesString = i3, r4(t4));
            }
          } catch (e8) {
            n3.e(e8);
          } finally {
            n3.f();
          }
        });
        return function() {
          return e6.apply(this, arguments);
        };
      }(), navigator.mediaDevices.addEventListener("devicechange", ma)));
    }).catch(function() {
    }));
  }(e4) : function(e5) {
    _a.has(e5) || (_a.set(e5, {}), navigator.mediaDevices.enumerateDevices().then(function(t3) {
      _a.has(e5) && (_a.get(e5).lastDevicesString = JSON.stringify(t3), wa || (wa = setInterval(p(function* () {
        var e6, t4 = yield navigator.mediaDevices.enumerateDevices(), n3 = ya(_a.keys());
        try {
          for (n3.s(); !(e6 = n3.n()).done; ) {
            var r4 = e6.value, i3 = JSON.stringify(t4);
            i3 !== _a.get(r4).lastDevicesString && (_a.get(r4).lastDevicesString = i3, r4(t4));
          }
        } catch (e7) {
          n3.e(e7);
        } finally {
          n3.f();
        }
      }), 3e3)));
    }));
  }(e4);
}
function ka(e4) {
  Ma() ? function(e5) {
    ga.has(e5) && (ga.delete(e5), 0 === ga.size && ma && (navigator.mediaDevices.removeEventListener("devicechange", ma), ma = null));
  }(e4) : function(e5) {
    _a.has(e5) && (_a.delete(e5), 0 === _a.size && wa && (clearInterval(wa), wa = null));
  }(e4);
}
function Ma() {
  var e4;
  return ys() || void 0 !== (null === (e4 = navigator.mediaDevices) || void 0 === e4 ? void 0 : e4.ondevicechange);
}
var Ca = /* @__PURE__ */ new Set();
function Ea(e4, t3) {
  var n3 = t3.isLocalScreenVideo;
  return e4 && "live" === e4.readyState && !function(e5, t4) {
    return (!t4.isLocalScreenVideo || "Chrome" !== Os()) && e5.muted && !Ca.has(e5.id);
  }(e4, { isLocalScreenVideo: n3 });
}
function Ta(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function Oa(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? Ta(Object(n3), true).forEach(function(t4) {
      u(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Ta(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
var Pa = Object.freeze({ VIDEO: "video", AUDIO: "audio", SCREEN_VIDEO: "screenVideo", SCREEN_AUDIO: "screenAudio", CUSTOM_VIDEO: "customVideo", CUSTOM_AUDIO: "customAudio" });
var Aa = Object.freeze({ PARTICIPANTS: "participants", STREAMING: "streaming", TRANSCRIPTION: "transcription" });
var ja = Object.values(Pa);
var Ia = ["v", "a", "sv", "sa", "cv", "ca"];
Object.freeze(ja.reduce(function(e4, t3, n3) {
  return e4[t3] = Ia[n3], e4;
}, {})), Object.freeze(Ia.reduce(function(e4, t3, n3) {
  return e4[t3] = ja[n3], e4;
}, {}));
var xa = [Pa.VIDEO, Pa.AUDIO, Pa.SCREEN_VIDEO, Pa.SCREEN_AUDIO];
var La = Object.values(Aa);
var Da = ["p", "s", "t"];
Object.freeze(La.reduce(function(e4, t3, n3) {
  return e4[t3] = Da[n3], e4;
}, {})), Object.freeze(Da.reduce(function(e4, t3, n3) {
  return e4[t3] = La[n3], e4;
}, {}));
var Na = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.base, i3 = n3.byUserId, o4 = n3.byParticipantId;
    t(this, e4), this.base = r4, this.byUserId = i3, this.byParticipantId = o4;
  }
  return o(e4, [{ key: "clone", value: function() {
    var t3 = new e4();
    if (this.base instanceof Ra ? t3.base = this.base.clone() : t3.base = this.base, void 0 !== this.byUserId)
      for (var n3 in t3.byUserId = {}, this.byUserId) {
        var r4 = this.byUserId[n3];
        t3.byUserId[n3] = r4 instanceof Ra ? r4.clone() : r4;
      }
    if (void 0 !== this.byParticipantId)
      for (var i3 in t3.byParticipantId = {}, this.byParticipantId) {
        var o4 = this.byParticipantId[i3];
        t3.byParticipantId[i3] = o4 instanceof Ra ? o4.clone() : o4;
      }
    return t3;
  } }, { key: "toJSONObject", value: function() {
    var e5 = {};
    if ("boolean" == typeof this.base ? e5.base = this.base : this.base instanceof Ra && (e5.base = this.base.toJSONObject()), void 0 !== this.byUserId)
      for (var t3 in e5.byUserId = {}, this.byUserId) {
        var n3 = this.byUserId[t3];
        e5.byUserId[t3] = n3 instanceof Ra ? n3.toJSONObject() : n3;
      }
    if (void 0 !== this.byParticipantId)
      for (var r4 in e5.byParticipantId = {}, this.byParticipantId) {
        var i3 = this.byParticipantId[r4];
        e5.byParticipantId[r4] = i3 instanceof Ra ? i3.toJSONObject() : i3;
      }
    return e5;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e5 = {};
    if (void 0 !== this.base && ("boolean" == typeof this.base ? e5.b = this.base : e5.b = this.base.toMinifiedJSONObject()), void 0 !== this.byUserId)
      for (var t3 in e5.u = {}, this.byUserId) {
        var n3 = this.byUserId[t3];
        e5.u[t3] = "boolean" == typeof n3 ? n3 : n3.toMinifiedJSONObject();
      }
    if (void 0 !== this.byParticipantId)
      for (var r4 in e5.p = {}, this.byParticipantId) {
        var i3 = this.byParticipantId[r4];
        e5.p[r4] = "boolean" == typeof i3 ? i3 : i3.toMinifiedJSONObject();
      }
    return e5;
  } }, { key: "normalize", value: function() {
    return this.base instanceof Ra && (this.base = this.base.normalize()), this.byUserId && (this.byUserId = Object.fromEntries(Object.entries(this.byUserId).map(function(e5) {
      var t3 = f(e5, 2), n3 = t3[0], r4 = t3[1];
      return [n3, r4 instanceof Ra ? r4.normalize() : r4];
    }))), this.byParticipantId && (this.byParticipantId = Object.fromEntries(Object.entries(this.byParticipantId).map(function(e5) {
      var t3 = f(e5, 2), n3 = t3[0], r4 = t3[1];
      return [n3, r4 instanceof Ra ? r4.normalize() : r4];
    }))), this;
  } }], [{ key: "fromJSONObject", value: function(t3) {
    var n3, r4, i3;
    if (void 0 !== t3.base && (n3 = "boolean" == typeof t3.base ? t3.base : Ra.fromJSONObject(t3.base)), void 0 !== t3.byUserId)
      for (var o4 in r4 = {}, t3.byUserId) {
        var s3 = t3.byUserId[o4];
        r4[o4] = "boolean" == typeof s3 ? s3 : Ra.fromJSONObject(s3);
      }
    if (void 0 !== t3.byParticipantId)
      for (var a3 in i3 = {}, t3.byParticipantId) {
        var c3 = t3.byParticipantId[a3];
        i3[a3] = "boolean" == typeof c3 ? c3 : Ra.fromJSONObject(c3);
      }
    return new e4({ base: n3, byUserId: r4, byParticipantId: i3 });
  } }, { key: "fromMinifiedJSONObject", value: function(t3) {
    var n3, r4, i3;
    if (void 0 !== t3.b && (n3 = "boolean" == typeof t3.b ? t3.b : Ra.fromMinifiedJSONObject(t3.b)), void 0 !== t3.u)
      for (var o4 in r4 = {}, t3.u) {
        var s3 = t3.u[o4];
        r4[o4] = "boolean" == typeof s3 ? s3 : Ra.fromMinifiedJSONObject(s3);
      }
    if (void 0 !== t3.p)
      for (var a3 in i3 = {}, t3.p) {
        var c3 = t3.p[a3];
        i3[a3] = "boolean" == typeof c3 ? c3 : Ra.fromMinifiedJSONObject(c3);
      }
    return new e4({ base: n3, byUserId: r4, byParticipantId: i3 });
  } }, { key: "validateJSONObject", value: function(e5) {
    if ("object" !== n(e5))
      return [false, "canReceive must be an object"];
    for (var t3 = ["base", "byUserId", "byParticipantId"], r4 = 0, i3 = Object.keys(e5); r4 < i3.length; r4++) {
      var o4 = i3[r4];
      if (!t3.includes(o4))
        return [false, "canReceive can only contain keys (".concat(t3.join(", "), ")")];
      if ("base" === o4) {
        var s3 = f(Ra.validateJSONObject(e5.base, true), 2), a3 = s3[0], c3 = s3[1];
        if (!a3)
          return [false, c3];
      } else {
        if ("object" !== n(e5[o4]))
          return [false, "invalid (non-object) value for field '".concat(o4, "' in canReceive")];
        for (var l3 = 0, u3 = Object.values(e5[o4]); l3 < u3.length; l3++) {
          var d3 = u3[l3], p3 = f(Ra.validateJSONObject(d3), 2), h4 = p3[0], v3 = p3[1];
          if (!h4)
            return [false, v3];
        }
      }
    }
    return [true];
  } }]);
}();
var Ra = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.video, i3 = n3.audio, o4 = n3.screenVideo, s3 = n3.screenAudio, a3 = n3.customVideo, c3 = n3.customAudio;
    t(this, e4), this.video = r4, this.audio = i3, this.screenVideo = o4, this.screenAudio = s3, this.customVideo = a3, this.customAudio = c3;
  }
  return o(e4, [{ key: "clone", value: function() {
    var t3 = new e4();
    return void 0 !== this.video && (t3.video = this.video), void 0 !== this.audio && (t3.audio = this.audio), void 0 !== this.screenVideo && (t3.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (t3.screenAudio = this.screenAudio), void 0 !== this.customVideo && (t3.customVideo = Oa({}, this.customVideo)), void 0 !== this.customAudio && (t3.customAudio = Oa({}, this.customAudio)), t3;
  } }, { key: "toJSONObject", value: function() {
    var e5 = {};
    return void 0 !== this.video && (e5.video = this.video), void 0 !== this.audio && (e5.audio = this.audio), void 0 !== this.screenVideo && (e5.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (e5.screenAudio = this.screenAudio), void 0 !== this.customVideo && (e5.customVideo = Oa({}, this.customVideo)), void 0 !== this.customAudio && (e5.customAudio = Oa({}, this.customAudio)), e5;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e5 = {};
    return void 0 !== this.video && (e5.v = this.video), void 0 !== this.audio && (e5.a = this.audio), void 0 !== this.screenVideo && (e5.sv = this.screenVideo), void 0 !== this.screenAudio && (e5.sa = this.screenAudio), void 0 !== this.customVideo && (e5.cv = Oa({}, this.customVideo)), void 0 !== this.customAudio && (e5.ca = Oa({}, this.customAudio)), e5;
  } }, { key: "normalize", value: function() {
    function e5(e6, t3) {
      return e6 && 1 === Object.keys(e6).length && e6["*"] === t3;
    }
    return !(true !== this.video || true !== this.audio || true !== this.screenVideo || true !== this.screenAudio || !e5(this.customVideo, true) || !e5(this.customAudio, true)) || (false !== this.video || false !== this.audio || false !== this.screenVideo || false !== this.screenAudio || !e5(this.customVideo, false) || !e5(this.customAudio, false)) && this;
  } }], [{ key: "fromBoolean", value: function(t3) {
    return new e4({ video: t3, audio: t3, screenVideo: t3, screenAudio: t3, customVideo: { "*": t3 }, customAudio: { "*": t3 } });
  } }, { key: "fromJSONObject", value: function(t3) {
    return new e4({ video: t3.video, audio: t3.audio, screenVideo: t3.screenVideo, screenAudio: t3.screenAudio, customVideo: void 0 !== t3.customVideo ? Oa({}, t3.customVideo) : void 0, customAudio: void 0 !== t3.customAudio ? Oa({}, t3.customAudio) : void 0 });
  } }, { key: "fromMinifiedJSONObject", value: function(t3) {
    return new e4({ video: t3.v, audio: t3.a, screenVideo: t3.sv, screenAudio: t3.sa, customVideo: t3.cv, customAudio: t3.ca });
  } }, { key: "validateJSONObject", value: function(e5, t3) {
    if ("boolean" == typeof e5)
      return [true];
    if ("object" !== n(e5))
      return [false, "invalid (non-object, non-boolean) value in canReceive"];
    for (var r4 = Object.keys(e5), i3 = 0, o4 = r4; i3 < o4.length; i3++) {
      var s3 = o4[i3];
      if (!ja.includes(s3))
        return [false, "invalid media type '".concat(s3, "' in canReceive")];
      if (xa.includes(s3)) {
        if ("boolean" != typeof e5[s3])
          return [false, "invalid (non-boolean) value for media type '".concat(s3, "' in canReceive")];
      } else {
        if ("object" !== n(e5[s3]))
          return [false, "invalid (non-object) value for media type '".concat(s3, "' in canReceive")];
        for (var a3 = 0, c3 = Object.values(e5[s3]); a3 < c3.length; a3++) {
          if ("boolean" != typeof c3[a3])
            return [false, "invalid (non-boolean) value for entry within '".concat(s3, "' in canReceive")];
        }
        if (t3 && void 0 === e5[s3]["*"])
          return [false, `canReceive "base" permission must specify "*" as an entry within '`.concat(s3, "'")];
      }
    }
    return t3 && r4.length !== ja.length ? [false, 'canReceive "base" permission must specify all media types: '.concat(ja.join(", "), " (or be set to a boolean shorthand)")] : [true];
  } }]);
}();
var Fa = ["result"];
var Ba = ["preserveIframe"];
function Ua(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function Va(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? Ua(Object(n3), true).forEach(function(t4) {
      u(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Ua(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
function Ja() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Ja = function() {
    return !!e4;
  })();
}
function $a(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return qa(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? qa(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function qa(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var za = {};
var Wa = "video";
var Ha = "voice";
var Ga = ys() ? { data: {} } : { data: {}, topology: "none" };
var Qa = { present: 0, hidden: 0 };
var Ka = { maxBitrate: { min: 1e5, max: 25e5 }, maxFramerate: { min: 1, max: 30 }, scaleResolutionDownBy: { min: 1, max: 8 } };
var Ya = Object.keys(Ka);
var Xa = ["state", "volume", "simulcastEncodings"];
var Za = { androidInCallNotification: { title: "string", subtitle: "string", iconName: "string", disableForCustomOverride: "boolean" }, disableAutoDeviceManagement: { audio: "boolean", video: "boolean" } };
var ec = { id: { iconPath: "string", iconPathDarkMode: "string", label: "string", tooltip: "string", visualState: "'default' | 'sidebar-open' | 'active'" } };
var tc = { id: { allow: "string", controlledBy: "'*' | 'owners' | string[]", csp: "string", iconURL: "string", label: "string", loading: "'eager' | 'lazy'", location: "'main' | 'sidebar'", name: "string", referrerPolicy: "string", sandbox: "string", src: "string", srcdoc: "string", shared: "string[] | 'owners' | boolean" } };
var nc = { customIntegrations: { validate: Ec, help: Mc() }, customTrayButtons: { validate: Cc, help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify(ec)) }, url: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "url should be a string" }, baseUrl: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "baseUrl should be a string" }, token: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "token should be a string", queryString: "t" }, dailyConfig: { validate: function(e4, t3) {
  try {
    return t3.validateDailyConfig(e4), true;
  } catch (e5) {
    console.error("Failed to validate dailyConfig", e5);
  }
  return false;
}, help: "Unsupported dailyConfig. Check error logs for detailed info." }, reactNativeConfig: { validate: function(e4) {
  return Tc(e4, Za);
}, help: "reactNativeConfig should look like ".concat(JSON.stringify(Za), ", all fields optional") }, lang: { validate: function(e4) {
  return ["da", "de", "en-us", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pl", "pt", "pt-BR", "ru", "sv", "tr", "user"].includes(e4);
}, help: "language not supported. Options are: da, de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, pt-BR, ru, sv, tr, user" }, userName: true, userData: { validate: function(e4) {
  try {
    return vc(e4), true;
  } catch (e5) {
    return console.error(e5), false;
  }
}, help: "invalid userData type provided" }, startVideoOff: true, startAudioOff: true, allowLocalVideo: true, allowLocalAudio: true, activeSpeakerMode: true, showLeaveButton: true, showLocalVideo: true, showParticipantsBar: true, showFullscreenButton: true, showUserNameChangeUI: true, iframeStyle: true, customLayout: true, cssFile: true, cssText: true, bodyClass: true, videoSource: { validate: function(e4, t3) {
  if ("boolean" == typeof e4)
    return t3._preloadCache.allowLocalVideo = e4, true;
  var n3;
  if (e4 instanceof MediaStreamTrack)
    t3._sharedTracks.videoTrack = e4, n3 = { customTrack: ls };
  else {
    if (delete t3._sharedTracks.videoTrack, "string" != typeof e4)
      return console.error("videoSource must be a MediaStreamTrack, boolean, or a string"), false;
    n3 = { deviceId: e4 };
  }
  return t3._updatePreloadCacheInputSettings({ video: { settings: n3 } }, false), true;
} }, audioSource: { validate: function(e4, t3) {
  if ("boolean" == typeof e4)
    return t3._preloadCache.allowLocalAudio = e4, true;
  var n3;
  if (e4 instanceof MediaStreamTrack)
    t3._sharedTracks.audioTrack = e4, n3 = { customTrack: ls };
  else {
    if (delete t3._sharedTracks.audioTrack, "string" != typeof e4)
      return console.error("audioSource must be a MediaStreamTrack, boolean, or a string"), false;
    n3 = { deviceId: e4 };
  }
  return t3._updatePreloadCacheInputSettings({ audio: { settings: n3 } }, false), true;
} }, subscribeToTracksAutomatically: { validate: function(e4, t3) {
  return t3._preloadCache.subscribeToTracksAutomatically = e4, true;
} }, theme: { validate: function(e4) {
  var t3 = ["accent", "accentText", "background", "backgroundAccent", "baseText", "border", "mainAreaBg", "mainAreaBgAccent", "mainAreaText", "supportiveText"], r4 = function(e5) {
    for (var n3 = 0, r5 = Object.keys(e5); n3 < r5.length; n3++) {
      var i3 = r5[n3];
      if (!t3.includes(i3))
        return console.error('unsupported color "'.concat(i3, '". Valid colors: ').concat(t3.join(", "))), false;
      if (!e5[i3].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i))
        return console.error("".concat(i3, ' theme color should be provided in valid hex color format. Received: "').concat(e5[i3], '"')), false;
    }
    return true;
  };
  return "object" === n(e4) && ("light" in e4 && "dark" in e4 || "colors" in e4) ? "light" in e4 && "dark" in e4 ? "colors" in e4.light ? "colors" in e4.dark ? r4(e4.light.colors) && r4(e4.dark.colors) : (console.error('Dark theme is missing "colors" property.', e4), false) : (console.error('Light theme is missing "colors" property.', e4), false) : r4(e4.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e4), false);
}, help: "unsupported theme configuration. Check error logs for detailed info." }, layoutConfig: { validate: function(e4) {
  if ("grid" in e4) {
    var t3 = e4.grid;
    if ("maxTilesPerPage" in t3) {
      if (!Number.isInteger(t3.maxTilesPerPage))
        return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t3.maxTilesPerPage, ".")), false;
      if (t3.maxTilesPerPage > 49)
        return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), false;
    }
    if ("minTilesPerPage" in t3) {
      if (!Number.isInteger(t3.minTilesPerPage))
        return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t3.minTilesPerPage, ".")), false;
      if (t3.minTilesPerPage < 1)
        return console.error("grid.minTilesPerPage can't be lower than 1."), false;
      if ("maxTilesPerPage" in t3 && t3.minTilesPerPage > t3.maxTilesPerPage)
        return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), false;
    }
  }
  return true;
}, help: "unsupported layoutConfig. Check error logs for detailed info." }, receiveSettings: { validate: function(e4) {
  return gc(e4, { allowAllParticipantsKey: false });
}, help: kc({ allowAllParticipantsKey: false }) }, sendSettings: { validate: function(e4, t3) {
  return !!function(e5, t4) {
    try {
      return t4.validateUpdateSendSettings(e5), true;
    } catch (e6) {
      return console.error("Failed to validate send settings", e6), false;
    }
  }(e4, t3) && (t3._preloadCache.sendSettings = e4, true);
}, help: "Invalid sendSettings provided. Check error logs for detailed info." }, inputSettings: { validate: function(e4, t3) {
  var n3;
  return !!mc(e4) && (t3._inputSettings || (t3._inputSettings = {}), yc(e4, null === (n3 = t3.properties) || void 0 === n3 ? void 0 : n3.dailyConfig, t3._sharedTracks), t3._updatePreloadCacheInputSettings(e4, true), true);
}, help: Sc() }, layout: { validate: function(e4) {
  return "custom-v1" === e4 || "browser" === e4 || "none" === e4;
}, help: 'layout may only be set to "custom-v1"', queryString: "layout" }, emb: { queryString: "emb" }, embHref: { queryString: "embHref" }, dailyJsVersion: { queryString: "dailyJsVersion" }, proxy: { queryString: "proxy" }, strictMode: true, allowMultipleCallInstances: true };
var rc = { styles: { validate: function(e4) {
  for (var t3 in e4)
    if ("cam" !== t3 && "screen" !== t3)
      return false;
  if (e4.cam) {
    for (var n3 in e4.cam)
      if ("div" !== n3 && "video" !== n3)
        return false;
  }
  if (e4.screen) {
    for (var r4 in e4.screen)
      if ("div" !== r4 && "video" !== r4)
        return false;
  }
  return true;
}, help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }" }, setSubscribedTracks: { validate: function(e4, t3) {
  if (t3._preloadCache.subscribeToTracksAutomatically)
    return false;
  var n3 = [true, false, "staged"];
  if (n3.includes(e4) || !ys() && "avatar" === e4)
    return true;
  var r4 = ["audio", "video", "screenAudio", "screenVideo", "rmpAudio", "rmpVideo"], i3 = function(e5) {
    var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    for (var o4 in e5)
      if ("custom" === o4) {
        if (!n3.includes(e5[o4]) && !i3(e5[o4], true))
          return false;
      } else {
        var s3 = !t4 && !r4.includes(o4), a3 = !n3.includes(e5[o4]);
        if (s3 || a3)
          return false;
      }
    return true;
  };
  return i3(e4);
}, help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(ys() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }") }, setAudio: true, setVideo: true, setScreenShare: { validate: function(e4) {
  return false === e4;
}, help: "setScreenShare must be false, as it's only meant for stopping remote participants' screen shares" }, eject: true, updatePermissions: { validate: function(e4) {
  for (var t3 = 0, n3 = Object.entries(e4); t3 < n3.length; t3++) {
    var r4 = f(n3[t3], 2), i3 = r4[0], o4 = r4[1];
    switch (i3) {
      case "hasPresence":
        if ("boolean" != typeof o4)
          return false;
        break;
      case "canSend":
        if (o4 instanceof Set || o4 instanceof Array || Array.isArray(o4)) {
          var s3, a3 = ["video", "audio", "screenVideo", "screenAudio", "customVideo", "customAudio"], c3 = $a(o4);
          try {
            for (c3.s(); !(s3 = c3.n()).done; ) {
              var l3 = s3.value;
              if (!a3.includes(l3))
                return false;
            }
          } catch (e5) {
            c3.e(e5);
          } finally {
            c3.f();
          }
        } else if ("boolean" != typeof o4)
          return false;
        (o4 instanceof Array || Array.isArray(o4)) && (e4.canSend = new Set(o4));
        break;
      case "canReceive":
        var u3 = f(Na.validateJSONObject(o4), 2), d3 = u3[0], p3 = u3[1];
        if (!d3)
          return console.error(p3), false;
        break;
      case "canAdmin":
        if (o4 instanceof Set || o4 instanceof Array || Array.isArray(o4)) {
          var h4, v3 = ["participants", "streaming", "transcription"], g3 = $a(o4);
          try {
            for (g3.s(); !(h4 = g3.n()).done; ) {
              var m3 = h4.value;
              if (!v3.includes(m3))
                return false;
            }
          } catch (e5) {
            g3.e(e5);
          } finally {
            g3.f();
          }
        } else if ("boolean" != typeof o4)
          return false;
        (o4 instanceof Array || Array.isArray(o4)) && (e4.canAdmin = new Set(o4));
        break;
      default:
        return false;
    }
  }
  return true;
}, help: "updatePermissions can take hasPresence, canSend, canReceive, and canAdmin permissions. hasPresence must be a boolean. canSend can be a boolean or an Array or Set of media types (video, audio, screenVideo, screenAudio, customVideo, customAudio). canReceive must be an object specifying base, byUserId, and/or byParticipantId fields (see documentation for more details). canAdmin can be a boolean or an Array or Set of admin types (participants, streaming, transcription)." } };
Promise.any || (Promise.any = function() {
  var e4 = p(function* (e5) {
    return new Promise(function(t3, n3) {
      var r4 = [];
      e5.forEach(function(i3) {
        return Promise.resolve(i3).then(function(e6) {
          t3(e6);
        }).catch(function(t4) {
          r4.push(t4), r4.length === e5.length && n3(r4);
        });
      });
    });
  });
  return function(t3) {
    return e4.apply(this, arguments);
  };
}());
var ic = function() {
  function r4(e4) {
    var n3, i4, o4, c4, l3, d4, h5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t(this, r4), o4 = this, c4 = a(c4 = r4), u(i4 = s(o4, Ja() ? Reflect.construct(c4, l3 || [], a(o4).constructor) : c4.apply(o4, l3)), "startListeningForDeviceChanges", function() {
      Sa(i4.handleDeviceChange);
    }), u(i4, "stopListeningForDeviceChanges", function() {
      ka(i4.handleDeviceChange);
    }), u(i4, "handleDeviceChange", function(e5) {
      e5 = e5.map(function(e6) {
        return JSON.parse(JSON.stringify(e6));
      }), i4.emitDailyJSEvent({ action: "available-devices-updated", availableDevices: e5 });
    }), u(i4, "handleNativeAppStateChange", function() {
      var e5 = p(function* (e6) {
        if ("destroyed" === e6)
          return console.warn("App has been destroyed before leaving the meeting. Cleaning up all the resources!"), void (yield i4.destroy());
        var t3 = "active" === e6;
        i4.disableReactNativeAutoDeviceManagement("video") || (t3 ? i4.camUnmutedBeforeLosingNativeActiveState && i4.setLocalVideo(true) : (i4.camUnmutedBeforeLosingNativeActiveState = i4.localVideo(), i4.camUnmutedBeforeLosingNativeActiveState && i4.setLocalVideo(false)));
      });
      return function(t3) {
        return e5.apply(this, arguments);
      };
    }()), u(i4, "handleNativeAudioFocusChange", function(e5) {
      i4.disableReactNativeAutoDeviceManagement("audio") || (i4._hasNativeAudioFocus = e5, i4.toggleParticipantAudioBasedOnNativeAudioFocus(), i4._hasNativeAudioFocus ? i4.micUnmutedBeforeLosingNativeAudioFocus && i4.setLocalAudio(true) : (i4.micUnmutedBeforeLosingNativeAudioFocus = i4.localAudio(), i4.setLocalAudio(false)));
    }), u(i4, "handleNativeSystemScreenCaptureStop", function() {
      i4.stopScreenShare();
    }), i4.strictMode = void 0 === h5.strictMode || h5.strictMode, i4.allowMultipleCallInstances = null !== (n3 = h5.allowMultipleCallInstances) && void 0 !== n3 && n3, Object.keys(za).length && (i4._logDuplicateInstanceAttempt(), !i4.allowMultipleCallInstances)) {
      if (i4.strictMode)
        throw new Error("Duplicate DailyIframe instances are not allowed");
      console.warn("Using strictMode: false to allow multiple call instances is now deprecated. Set `allowMultipleCallInstances: true`");
    }
    if (window._daily || (window._daily = { pendings: [], instances: {} }), i4.callClientId = K(), za[(d4 = i4).callClientId] = d4, window._daily.instances[i4.callClientId] = {}, i4._sharedTracks = {}, window._daily.instances[i4.callClientId].tracks = i4._sharedTracks, h5.dailyJsVersion = r4.version(), i4._iframe = e4, i4._callObjectMode = "none" === h5.layout && !i4._iframe, i4._preloadCache = { subscribeToTracksAutomatically: true, outputDeviceId: null, inputSettings: null, sendSettings: null, videoTrackForNetworkConnectivityTest: null, videoTrackForConnectionQualityTest: null }, void 0 !== h5.showLocalVideo ? i4._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : i4._showLocalVideo = !!h5.showLocalVideo : i4._showLocalVideo = true, void 0 !== h5.showParticipantsBar ? i4._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : i4._showParticipantsBar = !!h5.showParticipantsBar : i4._showParticipantsBar = true, void 0 !== h5.customIntegrations ? i4._callObjectMode ? console.error("customIntegrations is not available in call object mode") : i4._customIntegrations = h5.customIntegrations : i4._customIntegrations = {}, void 0 !== h5.customTrayButtons ? i4._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : i4._customTrayButtons = h5.customTrayButtons : i4._customTrayButtons = {}, void 0 !== h5.activeSpeakerMode ? i4._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : i4._activeSpeakerMode = !!h5.activeSpeakerMode : i4._activeSpeakerMode = false, h5.receiveSettings ? i4._callObjectMode ? i4._receiveSettings = h5.receiveSettings : console.error("receiveSettings is only available in call object mode") : i4._receiveSettings = {}, i4.validateProperties(h5), i4.properties = Va({}, h5), i4._inputSettings || (i4._inputSettings = {}), i4._callObjectLoader = i4._callObjectMode ? new Ys(i4.callClientId) : null, i4._callState = vi, i4._isPreparingToJoin = false, i4._accessState = { access: Oi }, i4._meetingSessionSummary = {}, i4._finalSummaryOfPrevSession = {}, i4._meetingSessionState = jc(Ga, i4._callObjectMode), i4._nativeInCallAudioMode = Wa, i4._participants = {}, i4._isScreenSharing = false, i4._participantCounts = Qa, i4._rmpPlayerState = {}, i4._waitingParticipants = {}, i4._network = { threshold: "good", quality: 100, networkState: "unknown", stats: {} }, i4._activeSpeaker = {}, i4._localAudioLevel = 0, i4._isLocalAudioLevelObserverRunning = false, i4._remoteParticipantsAudioLevel = {}, i4._isRemoteParticipantsAudioLevelObserverRunning = false, i4._maxAppMessageSize = rs, i4._messageChannel = ys() ? new Js() : new Bs(), i4._iframe && (i4._iframe.requestFullscreen ? i4._iframe.addEventListener("fullscreenchange", function() {
      document.fullscreenElement === i4._iframe ? (i4.emitDailyJSEvent({ action: Wo }), i4.sendMessageToCallMachine({ action: Wo })) : (i4.emitDailyJSEvent({ action: Ho }), i4.sendMessageToCallMachine({ action: Ho }));
    }) : i4._iframe.webkitRequestFullscreen && i4._iframe.addEventListener("webkitfullscreenchange", function() {
      document.webkitFullscreenElement === i4._iframe ? (i4.emitDailyJSEvent({ action: Wo }), i4.sendMessageToCallMachine({ action: Wo })) : (i4.emitDailyJSEvent({ action: Ho }), i4.sendMessageToCallMachine({ action: Ho }));
    })), ys()) {
      var f3 = i4.nativeUtils();
      f3.addAudioFocusChangeListener && f3.removeAudioFocusChangeListener && f3.addAppStateChangeListener && f3.removeAppStateChangeListener && f3.addSystemScreenCaptureStopListener && f3.removeSystemScreenCaptureStopListener || console.warn("expected (add|remove)(AudioFocusChange|AppActiveStateChange|SystemScreenCaptureStop)Listener to be available in React Native"), i4._hasNativeAudioFocus = true, f3.addAudioFocusChangeListener(i4.handleNativeAudioFocusChange), f3.addAppStateChangeListener(i4.handleNativeAppStateChange), f3.addSystemScreenCaptureStopListener(i4.handleNativeSystemScreenCaptureStop);
    }
    return i4._callObjectMode && i4.startListeningForDeviceChanges(), i4._messageChannel.addListenerForMessagesFromCallMachine(i4.handleMessageFromCallMachine, i4.callClientId, i4), i4;
  }
  return l(r4, x), o(r4, [{ key: "destroy", value: (ee3 = p(function* () {
    var e4;
    try {
      yield this.leave();
    } catch (e5) {
    }
    var t3 = this._iframe;
    if (t3) {
      var n3 = t3.parentElement;
      n3 && n3.removeChild(t3);
    }
    if (this._messageChannel.removeListener(this.handleMessageFromCallMachine), ys()) {
      var r5 = this.nativeUtils();
      r5.removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), r5.removeAppStateChangeListener(this.handleNativeAppStateChange), r5.removeSystemScreenCaptureStopListener(this.handleNativeSystemScreenCaptureStop);
    }
    this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars(), this._destroyed = true, this.emitDailyJSEvent({ action: "call-instance-destroyed" }), delete za[this.callClientId], (null === (e4 = window) || void 0 === e4 || null === (e4 = e4._daily) || void 0 === e4 ? void 0 : e4.instances) && delete window._daily.instances[this.callClientId], this.strictMode && (this.callClientId = void 0);
  }), function() {
    return ee3.apply(this, arguments);
  }) }, { key: "isDestroyed", value: function() {
    return !!this._destroyed;
  } }, { key: "loadCss", value: function(e4) {
    var t3 = e4.bodyClass, n3 = e4.cssFile, r5 = e4.cssText;
    return hc(), this.sendMessageToCallMachine({ action: "load-css", cssFile: this.absoluteUrl(n3), bodyClass: t3, cssText: r5 }), this;
  } }, { key: "iframe", value: function() {
    return hc(), this._iframe;
  } }, { key: "meetingState", value: function() {
    return this._callState;
  } }, { key: "accessState", value: function() {
    return dc(this._callObjectMode, "accessState()"), this._accessState;
  } }, { key: "participants", value: function() {
    return this._participants;
  } }, { key: "participantCounts", value: function() {
    return this._participantCounts;
  } }, { key: "waitingParticipants", value: function() {
    return dc(this._callObjectMode, "waitingParticipants()"), this._waitingParticipants;
  } }, { key: "validateParticipantProperties", value: function(e4, t3) {
    for (var n3 in t3) {
      if (!rc[n3])
        throw new Error("unrecognized updateParticipant property ".concat(n3));
      if (rc[n3].validate && !rc[n3].validate(t3[n3], this, this._participants[e4]))
        throw new Error(rc[n3].help);
    }
  } }, { key: "updateParticipant", value: function(e4, t3) {
    return this._participants.local && this._participants.local.session_id === e4 && (e4 = "local"), e4 && t3 && (this.validateParticipantProperties(e4, t3), this.sendMessageToCallMachine({ action: "update-participant", id: e4, properties: t3 })), this;
  } }, { key: "updateParticipants", value: function(e4) {
    var t3 = this._participants.local && this._participants.local.session_id;
    for (var n3 in e4)
      n3 === t3 && (n3 = "local"), n3 && e4[n3] && this.validateParticipantProperties(n3, e4[n3]);
    return this.sendMessageToCallMachine({ action: "update-participants", participants: e4 }), this;
  } }, { key: "updateWaitingParticipant", value: (Y3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (dc(this._callObjectMode, "updateWaitingParticipant()"), sc(this._callState, "updateWaitingParticipant()"), "string" != typeof t3 || "object" !== n(r5))
      throw new Error("updateWaitingParticipant() must take an id string and a updates object");
    return new Promise(function(n3, i4) {
      e4.sendMessageToCallMachine({ action: "daily-method-update-waiting-participant", id: t3, updates: r5 }, function(e5) {
        e5.error && i4(e5.error), e5.id || i4(new Error("unknown error in updateWaitingParticipant()")), n3({ id: e5.id });
      });
    });
  }), function() {
    return Y3.apply(this, arguments);
  }) }, { key: "updateWaitingParticipants", value: (G3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (dc(this._callObjectMode, "updateWaitingParticipants()"), sc(this._callState, "updateWaitingParticipants()"), "object" !== n(t3))
      throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
    return new Promise(function(n3, r5) {
      e4.sendMessageToCallMachine({ action: "daily-method-update-waiting-participants", updatesById: t3 }, function(e5) {
        e5.error && r5(e5.error), e5.ids || r5(new Error("unknown error in updateWaitingParticipants()")), n3({ ids: e5.ids });
      });
    });
  }), function() {
    return G3.apply(this, arguments);
  }) }, { key: "requestAccess", value: (H3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n3 = t3.access, r5 = void 0 === n3 ? { level: Pi } : n3, i4 = t3.name, o4 = void 0 === i4 ? "" : i4;
    return dc(this._callObjectMode, "requestAccess()"), sc(this._callState, "requestAccess()"), new Promise(function(t4, n4) {
      e4.sendMessageToCallMachine({ action: "daily-method-request-access", access: r5, name: o4 }, function(e5) {
        e5.error && n4(e5.error), e5.access || n4(new Error("unknown error in requestAccess()")), t4({ access: e5.access, granted: e5.granted });
      });
    });
  }), function() {
    return H3.apply(this, arguments);
  }) }, { key: "localAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.audio.state) : null;
  } }, { key: "localVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.video.state) : null;
  } }, { key: "setLocalAudio", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return "forceDiscardTrack" in t3 && (ys() ? (console.warn("forceDiscardTrack option not supported in React Native; ignoring"), t3 = {}) : e4 && (console.warn("forceDiscardTrack option only supported when calling setLocalAudio(false); ignoring"), t3 = {})), this.sendMessageToCallMachine({ action: "local-audio", state: e4, options: t3 }), this;
  } }, { key: "localScreenAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenAudio.state) : null;
  } }, { key: "localScreenVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenVideo.state) : null;
  } }, { key: "updateScreenShare", value: function(e4) {
    if (this._isScreenSharing)
      return this.sendMessageToCallMachine({ action: "local-screen-update", options: e4 }), this;
    console.warn("There is no screen share in progress. Try calling startScreenShare first.");
  } }, { key: "setLocalVideo", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "local-video", state: e4 }), this;
  } }, { key: "_setAllowLocalAudio", value: function(e4) {
    if (this._preloadCache.allowLocalAudio = e4, this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-allow-local-audio", state: e4 }), this;
  } }, { key: "_setAllowLocalVideo", value: function(e4) {
    if (this._preloadCache.allowLocalVideo = e4, this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-allow-local-video", state: e4 }), this;
  } }, { key: "getReceiveSettings", value: (W3 = p(function* (e4) {
    var t3 = this, r5 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).showInheritedValues, i4 = void 0 !== r5 && r5;
    if (dc(this._callObjectMode, "getReceiveSettings()"), !this._callMachineInitialized)
      return this._receiveSettings;
    switch (n(e4)) {
      case "string":
        return new Promise(function(n3) {
          t3.sendMessageToCallMachine({ action: "get-single-participant-receive-settings", id: e4, showInheritedValues: i4 }, function(e5) {
            n3(e5.receiveSettings);
          });
        });
      case "undefined":
        return this._receiveSettings;
      default:
        throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
    }
  }), function(e4) {
    return W3.apply(this, arguments);
  }) }, { key: "updateReceiveSettings", value: (z3 = p(function* (e4) {
    var t3 = this;
    if (dc(this._callObjectMode, "updateReceiveSettings()"), !gc(e4, { allowAllParticipantsKey: true }))
      throw new Error(kc({ allowAllParticipantsKey: true }));
    return sc(this._callState, "updateReceiveSettings()", "To specify receive settings earlier, use the receiveSettings config property."), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "update-receive-settings", receiveSettings: e4 }, function(e5) {
        n3({ receiveSettings: e5.receiveSettings });
      });
    });
  }), function(e4) {
    return z3.apply(this, arguments);
  }) }, { key: "_prepInputSettingsForSharing", value: function(e4, t3) {
    if (e4) {
      var n3 = {};
      if (e4.audio) {
        var r5, i4, o4;
        e4.audio.settings && (!Object.keys(e4.audio.settings).length && t3 || (n3.audio = { settings: Va({}, e4.audio.settings) })), t3 && null !== (r5 = n3.audio) && void 0 !== r5 && null !== (r5 = r5.settings) && void 0 !== r5 && r5.customTrack && (n3.audio.settings = { customTrack: this._sharedTracks.audioTrack });
        var s3 = "none" === (null === (i4 = e4.audio.processor) || void 0 === i4 ? void 0 : i4.type) && (null === (o4 = e4.audio.processor) || void 0 === o4 ? void 0 : o4._isDefaultWhenNone);
        if (e4.audio.processor && !s3) {
          var a3 = Va({}, e4.audio.processor);
          delete a3._isDefaultWhenNone, n3.audio = Va(Va({}, n3.audio), {}, { processor: a3 });
        }
      }
      if (e4.video) {
        var c4, l3, u3;
        e4.video.settings && (!Object.keys(e4.video.settings).length && t3 || (n3.video = { settings: Va({}, e4.video.settings) })), t3 && null !== (c4 = n3.video) && void 0 !== c4 && null !== (c4 = c4.settings) && void 0 !== c4 && c4.customTrack && (n3.video.settings = { customTrack: this._sharedTracks.videoTrack });
        var d4 = "none" === (null === (l3 = e4.video.processor) || void 0 === l3 ? void 0 : l3.type) && (null === (u3 = e4.video.processor) || void 0 === u3 ? void 0 : u3._isDefaultWhenNone);
        if (e4.video.processor && !d4) {
          var p3 = Va({}, e4.video.processor);
          delete p3._isDefaultWhenNone, n3.video = Va(Va({}, n3.video), {}, { processor: p3 });
        }
      }
      return n3;
    }
  } }, { key: "getInputSettings", value: function() {
    var e4 = this;
    return hc(), new Promise(function(t3) {
      t3(e4._getInputSettings());
    });
  } }, { key: "_getInputSettings", value: function() {
    var e4, t3, n3, r5, i4, o4, s3 = { processor: { type: "none", _isDefaultWhenNone: true } };
    this._inputSettings ? (e4 = (null === (n3 = this._inputSettings) || void 0 === n3 ? void 0 : n3.video) || s3, t3 = (null === (r5 = this._inputSettings) || void 0 === r5 ? void 0 : r5.audio) || s3) : (e4 = (null === (i4 = this._preloadCache) || void 0 === i4 || null === (i4 = i4.inputSettings) || void 0 === i4 ? void 0 : i4.video) || s3, t3 = (null === (o4 = this._preloadCache) || void 0 === o4 || null === (o4 = o4.inputSettings) || void 0 === o4 ? void 0 : o4.audio) || s3);
    var a3 = { audio: t3, video: e4 };
    return this._prepInputSettingsForSharing(a3, true);
  } }, { key: "_updatePreloadCacheInputSettings", value: function(e4, t3) {
    var n3 = this._inputSettings || {}, r5 = {};
    if (e4.video) {
      var i4, o4, s3;
      if (r5.video = {}, e4.video.settings)
        r5.video.settings = {}, t3 || e4.video.settings.customTrack || null === (s3 = n3.video) || void 0 === s3 || !s3.settings ? r5.video.settings = e4.video.settings : r5.video.settings = Va(Va({}, n3.video.settings), e4.video.settings), Object.keys(r5.video.settings).length || delete r5.video.settings;
      else
        null !== (i4 = n3.video) && void 0 !== i4 && i4.settings && (r5.video.settings = n3.video.settings);
      e4.video.processor ? r5.video.processor = e4.video.processor : null !== (o4 = n3.video) && void 0 !== o4 && o4.processor && (r5.video.processor = n3.video.processor);
    } else
      n3.video && (r5.video = n3.video);
    if (e4.audio) {
      var a3, c4, l3;
      if (r5.audio = {}, e4.audio.settings)
        r5.audio.settings = {}, t3 || e4.audio.settings.customTrack || null === (l3 = n3.audio) || void 0 === l3 || !l3.settings ? r5.audio.settings = e4.audio.settings : r5.audio.settings = Va(Va({}, n3.audio.settings), e4.audio.settings), Object.keys(r5.audio.settings).length || delete r5.audio.settings;
      else
        null !== (a3 = n3.audio) && void 0 !== a3 && a3.settings && (r5.audio.settings = n3.audio.settings);
      e4.audio.processor ? r5.audio.processor = e4.audio.processor : null !== (c4 = n3.audio) && void 0 !== c4 && c4.processor && (r5.audio.processor = n3.audio.processor);
    } else
      n3.audio && (r5.audio = n3.audio);
    this._maybeUpdateInputSettings(r5);
  } }, { key: "_devicesFromInputSettings", value: function(e4) {
    var t3, n3, r5 = (null == e4 || null === (t3 = e4.video) || void 0 === t3 || null === (t3 = t3.settings) || void 0 === t3 ? void 0 : t3.deviceId) || null, i4 = (null == e4 || null === (n3 = e4.audio) || void 0 === n3 || null === (n3 = n3.settings) || void 0 === n3 ? void 0 : n3.deviceId) || null, o4 = this._preloadCache.outputDeviceId || null;
    return { camera: r5 ? { deviceId: r5 } : {}, mic: i4 ? { deviceId: i4 } : {}, speaker: o4 ? { deviceId: o4 } : {} };
  } }, { key: "updateInputSettings", value: (q3 = p(function* (e4) {
    var t3 = this;
    return hc(), mc(e4) ? e4.video || e4.audio ? (yc(e4, this.properties.dailyConfig, this._sharedTracks), this._callObjectMode && !this._callMachineInitialized ? (this._updatePreloadCacheInputSettings(e4, true), this._getInputSettings()) : new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "update-input-settings", inputSettings: e4 }, function(i4) {
        if (i4.error)
          r5(i4.error);
        else {
          if (i4.returnPreloadCache)
            return t3._updatePreloadCacheInputSettings(e4, true), void n3(t3._getInputSettings());
          t3._maybeUpdateInputSettings(i4.inputSettings), n3(t3._prepInputSettingsForSharing(i4.inputSettings, true));
        }
      });
    })) : this._getInputSettings() : (console.error(Sc()), Promise.reject(Sc()));
  }), function(e4) {
    return q3.apply(this, arguments);
  }) }, { key: "setBandwidth", value: function(e4) {
    var t3 = e4.kbs, n3 = e4.trackConstraints;
    if (hc(), this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-bandwidth", kbs: t3, trackConstraints: n3 }), this;
  } }, { key: "getDailyLang", value: function() {
    var e4 = this;
    if (hc(), this._callMachineInitialized)
      return new Promise(function(t3) {
        e4.sendMessageToCallMachine({ action: "get-daily-lang" }, function(e5) {
          delete e5.action, delete e5.callbackStamp, t3(e5);
        });
      });
  } }, { key: "setDailyLang", value: function(e4) {
    return hc(), this.sendMessageToCallMachine({ action: "set-daily-lang", lang: e4 }), this;
  } }, { key: "setProxyUrl", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "set-proxy-url", proxyUrl: e4 }), this;
  } }, { key: "setIceConfig", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "set-ice-config", iceConfig: e4 }), this;
  } }, { key: "meetingSessionSummary", value: function() {
    return [_i, wi].includes(this._callState) ? this._finalSummaryOfPrevSession : this._meetingSessionSummary;
  } }, { key: "getMeetingSession", value: ($3 = p(function* () {
    var e4 = this;
    return console.warn("getMeetingSession() is deprecated: use meetingSessionSummary(), which will return immediately"), sc(this._callState, "getMeetingSession()"), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-meeting-session" }, function(e5) {
        delete e5.action, delete e5.callbackStamp, t3(e5);
      });
    });
  }), function() {
    return $3.apply(this, arguments);
  }) }, { key: "meetingSessionState", value: function() {
    return sc(this._callState, "meetingSessionState"), this._meetingSessionState;
  } }, { key: "setMeetingSessionData", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "replace";
    dc(this._callObjectMode, "setMeetingSessionData()"), sc(this._callState, "setMeetingSessionData");
    try {
      !function(e5, t4) {
        new Ws({ data: e5, mergeStrategy: t4 });
      }(e4, t3);
    } catch (e5) {
      throw console.error(e5), e5;
    }
    try {
      this.sendMessageToCallMachine({ action: "set-session-data", data: e4, mergeStrategy: t3 });
    } catch (e5) {
      throw new Error("Error setting meeting session data: ".concat(e5));
    }
  } }, { key: "setUserName", value: function(e4, t3) {
    var n3 = this;
    return this.properties.userName = e4, new Promise(function(r5) {
      n3.sendMessageToCallMachine({ action: "set-user-name", name: null != e4 ? e4 : "", thisMeetingOnly: ys() || !!t3 && !!t3.thisMeetingOnly }, function(e5) {
        delete e5.action, delete e5.callbackStamp, r5(e5);
      });
    });
  } }, { key: "setUserData", value: (J3 = p(function* (e4) {
    var t3 = this;
    try {
      vc(e4);
    } catch (e5) {
      throw console.error(e5), e5;
    }
    if (this.properties.userData = e4, this._callMachineInitialized)
      return new Promise(function(n3) {
        try {
          t3.sendMessageToCallMachine({ action: "set-user-data", userData: e4 }, function(e5) {
            delete e5.action, delete e5.callbackStamp, n3(e5);
          });
        } catch (e5) {
          throw new Error("Error setting user data: ".concat(e5));
        }
      });
  }), function(e4) {
    return J3.apply(this, arguments);
  }) }, { key: "validateAudioLevelInterval", value: function(e4) {
    if (e4 && (e4 < 100 || "number" != typeof e4))
      throw new Error("The interval must be a number greater than or equal to 100 milliseconds.");
  } }, { key: "startLocalAudioLevelObserver", value: function(e4) {
    var t3 = this;
    if ("undefined" == typeof AudioWorkletNode && !ys())
      throw new Error("startLocalAudioLevelObserver() is not supported on this browser");
    if (this.validateAudioLevelInterval(e4), this._callMachineInitialized)
      return this._isLocalAudioLevelObserverRunning = true, new Promise(function(n3, r5) {
        t3.sendMessageToCallMachine({ action: "start-local-audio-level-observer", interval: e4 }, function(e5) {
          t3._isLocalAudioLevelObserverRunning = !e5.error, e5.error ? r5({ error: e5.error }) : n3();
        });
      });
    this._preloadCache.localAudioLevelObserver = { enabled: true, interval: e4 };
  } }, { key: "isLocalAudioLevelObserverRunning", value: function() {
    return this._isLocalAudioLevelObserverRunning;
  } }, { key: "stopLocalAudioLevelObserver", value: function() {
    this._preloadCache.localAudioLevelObserver = null, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-local-audio-level-observer" });
  } }, { key: "startRemoteParticipantsAudioLevelObserver", value: function(e4) {
    var t3 = this;
    if (this.validateAudioLevelInterval(e4), this._callMachineInitialized)
      return this._isRemoteParticipantsAudioLevelObserverRunning = true, new Promise(function(n3, r5) {
        t3.sendMessageToCallMachine({ action: "start-remote-participants-audio-level-observer", interval: e4 }, function(e5) {
          t3._isRemoteParticipantsAudioLevelObserverRunning = !e5.error, e5.error ? r5({ error: e5.error }) : n3();
        });
      });
    this._preloadCache.remoteParticipantsAudioLevelObserver = { enabled: true, interval: e4 };
  } }, { key: "isRemoteParticipantsAudioLevelObserverRunning", value: function() {
    return this._isRemoteParticipantsAudioLevelObserverRunning;
  } }, { key: "stopRemoteParticipantsAudioLevelObserver", value: function() {
    this._preloadCache.remoteParticipantsAudioLevelObserver = null, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-remote-participants-audio-level-observer" });
  } }, { key: "startCamera", value: (V3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (dc(this._callObjectMode, "startCamera()"), cc(this._callState, this._isPreparingToJoin, "startCamera()", "Did you mean to use setLocalAudio() and/or setLocalVideo() instead?"), this.needsLoad())
      try {
        yield this.load(t3);
      } catch (e5) {
        return Promise.reject(e5);
      }
    else {
      if (this._didPreAuth) {
        if (t3.url && t3.url !== this.properties.url)
          return console.error("url in startCamera() is different than the one used in preAuth()"), Promise.reject();
        if (t3.token && t3.token !== this.properties.token)
          return console.error("token in startCamera() is different than the one used in preAuth()"), Promise.reject();
      }
      this.validateProperties(t3), this.properties = Va(Va({}, this.properties), t3);
    }
    return new Promise(function(t4) {
      e4._preloadCache.inputSettings = e4._prepInputSettingsForSharing(e4._inputSettings, false), e4.sendMessageToCallMachine({ action: "start-camera", properties: oc(e4.properties, e4.callClientId), preloadCache: oc(e4._preloadCache, e4.callClientId) }, function(e5) {
        t4({ camera: e5.camera, mic: e5.mic, speaker: e5.speaker });
      });
    });
  }), function() {
    return V3.apply(this, arguments);
  }) }, { key: "validateCustomTrack", value: function(e4, t3, n3) {
    if (n3 && n3.length > 50)
      throw new Error("Custom track `trackName` must not be more than 50 characters");
    if (t3 && "music" !== t3 && "speech" !== t3 && !(t3 instanceof Object))
      throw new Error("Custom track `mode` must be either `music` | `speech` | `DailyMicAudioModeSettings` or `undefined`");
    if (!!n3 && ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo", "customVideoDefaults"].includes(n3))
      throw new Error("Custom track `trackName` must not match a track name already used by daily: cam-audio, cam-video, customVideoDefaults, screen-video, screen-audio, rmpAudio, rmpVideo");
    if (!(e4 instanceof MediaStreamTrack))
      throw new Error("Custom tracks provided must be instances of MediaStreamTrack");
  } }, { key: "startCustomTrack", value: function() {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { track, mode, trackName };
    return hc(), sc(this._callState, "startCustomTrack()"), this.validateCustomTrack(t3.track, t3.mode, t3.trackName), new Promise(function(n3, r5) {
      e4._sharedTracks.customTrack = t3.track, t3.track = ls, e4.sendMessageToCallMachine({ action: "start-custom-track", properties: t3 }, function(e5) {
        e5.error ? r5({ error: e5.error }) : n3(e5.mediaTag);
      });
    });
  } }, { key: "stopCustomTrack", value: function(e4) {
    var t3 = this;
    return hc(), sc(this._callState, "stopCustomTrack()"), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "stop-custom-track", mediaTag: e4 }, function(e5) {
        n3(e5.mediaTag);
      });
    });
  } }, { key: "setCamera", value: function(e4) {
    var t3 = this;
    return fc(), lc(this._callMachineInitialized, "setCamera()"), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "set-camera", cameraDeviceId: e4 }, function(e5) {
        n3({ device: e5.device });
      });
    });
  } }, { key: "setAudioDevice", value: (U3 = p(function* (e4) {
    return fc(), this.nativeUtils().setAudioDevice(e4), { deviceId: yield this.nativeUtils().getAudioDevice() };
  }), function(e4) {
    return U3.apply(this, arguments);
  }) }, { key: "cycleCamera", value: function() {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Promise(function(n3) {
      e4.sendMessageToCallMachine({ action: "cycle-camera", properties: t3 }, function(e5) {
        n3({ device: e5.device });
      });
    });
  } }, { key: "cycleMic", value: function() {
    var e4 = this;
    return hc(), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "cycle-mic" }, function(e5) {
        t3({ device: e5.device });
      });
    });
  } }, { key: "getCameraFacingMode", value: function() {
    var e4 = this;
    return fc(), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-camera-facing-mode" }, function(e5) {
        t3(e5.facingMode);
      });
    });
  } }, { key: "setInputDevicesAsync", value: (B3 = p(function* (e4) {
    var t3 = this, n3 = e4.audioDeviceId, r5 = e4.videoDeviceId, i4 = e4.audioSource, o4 = e4.videoSource;
    if (hc(), void 0 !== i4 && (n3 = i4), void 0 !== o4 && (r5 = o4), "boolean" == typeof n3 && (this._setAllowLocalAudio(n3), n3 = void 0), "boolean" == typeof r5 && (this._setAllowLocalVideo(r5), r5 = void 0), !n3 && !r5)
      return yield this.getInputDevices();
    var s3 = {};
    return n3 && (n3 instanceof MediaStreamTrack ? (this._sharedTracks.audioTrack = n3, n3 = ls, s3.audio = { settings: { customTrack: n3 } }) : (delete this._sharedTracks.audioTrack, s3.audio = { settings: { deviceId: n3 } })), r5 && (r5 instanceof MediaStreamTrack ? (this._sharedTracks.videoTrack = r5, r5 = ls, s3.video = { settings: { customTrack: r5 } }) : (delete this._sharedTracks.videoTrack, s3.video = { settings: { deviceId: r5 } })), this._callObjectMode && this.needsLoad() ? (this._updatePreloadCacheInputSettings(s3, false), this._devicesFromInputSettings(this._inputSettings)) : new Promise(function(e5) {
      t3.sendMessageToCallMachine({ action: "set-input-devices", audioDeviceId: n3, videoDeviceId: r5 }, function(n4) {
        if (delete n4.action, delete n4.callbackStamp, n4.returnPreloadCache)
          return t3._updatePreloadCacheInputSettings(s3, false), void e5(t3._devicesFromInputSettings(t3._inputSettings));
        e5(n4);
      });
    });
  }), function(e4) {
    return B3.apply(this, arguments);
  }) }, { key: "setOutputDeviceAsync", value: (F3 = p(function* (e4) {
    var t3 = this, n3 = e4.outputDeviceId;
    return hc(), n3 && (this._preloadCache.outputDeviceId = n3), this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(e5) {
      t3.sendMessageToCallMachine({ action: "set-output-device", outputDeviceId: n3 }, function(n4) {
        delete n4.action, delete n4.callbackStamp, n4.returnPreloadCache ? e5(t3._devicesFromInputSettings(t3._inputSettings)) : e5(n4);
      });
    });
  }), function(e4) {
    return F3.apply(this, arguments);
  }) }, { key: "getInputDevices", value: (R3 = p(function* () {
    var e4 = this;
    return this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-input-devices" }, function(n3) {
        n3.returnPreloadCache ? t3(e4._devicesFromInputSettings(e4._inputSettings)) : t3({ camera: n3.camera, mic: n3.mic, speaker: n3.speaker });
      });
    });
  }), function() {
    return R3.apply(this, arguments);
  }) }, { key: "nativeInCallAudioMode", value: function() {
    return fc(), this._nativeInCallAudioMode;
  } }, { key: "setNativeInCallAudioMode", value: function(e4) {
    if (fc(), [Wa, Ha].includes(e4)) {
      if (e4 !== this._nativeInCallAudioMode)
        return this._nativeInCallAudioMode = e4, !this.disableReactNativeAutoDeviceManagement("audio") && ac(this._callState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
    } else
      console.error("invalid in-call audio mode specified: ", e4);
  } }, { key: "preAuth", value: (D3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (dc(this._callObjectMode, "preAuth()"), cc(this._callState, this._isPreparingToJoin, "preAuth()"), this.needsLoad() && (yield this.load(t3)), !t3.url)
      throw new Error("preAuth() requires at least a url to be provided");
    return this.validateProperties(t3), this.properties = Va(Va({}, this.properties), t3), new Promise(function(t4, n3) {
      e4._preloadCache.inputSettings = e4._prepInputSettingsForSharing(e4._inputSettings, false), e4.sendMessageToCallMachine({ action: "daily-method-preauth", properties: oc(e4.properties, e4.callClientId), preloadCache: oc(e4._preloadCache, e4.callClientId) }, function(r5) {
        return r5.error ? n3(r5.error) : r5.access ? (e4._didPreAuth = true, void t4({ access: r5.access })) : n3(new Error("unknown error in preAuth()"));
      });
    });
  }), function() {
    return D3.apply(this, arguments);
  }) }, { key: "load", value: (L3 = p(function* (e4) {
    var t3 = this;
    if (this.needsLoad()) {
      if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode))
        throw new Error("Use after destroy");
      if (e4 && (this.validateProperties(e4), this.properties = Va(Va({}, this.properties), e4)), !this._callObjectMode && !this.properties.url)
        throw new Error("can't load iframe meeting because url property isn't set");
      return this._updateCallState(gi), this.emitDailyJSEvent({ action: to }), this._callObjectMode ? new Promise(function(e5, n3) {
        t3._callObjectLoader.cancel();
        var r5 = Date.now();
        t3._callObjectLoader.load(t3.properties.dailyConfig, function(n4) {
          t3._bundleLoadTime = n4 ? "no-op" : Date.now() - r5, t3._updateCallState(mi), n4 && t3.emitDailyJSEvent({ action: ro }), e5();
        }, function(e6, r6) {
          if (t3.emitDailyJSEvent({ action: no }), !r6) {
            t3._updateCallState(wi), t3.resetMeetingDependentVars();
            var i4 = { action: ns, errorMsg: e6.msg, error: { type: "connection-error", msg: "Failed to load call object bundle.", details: { on: "load", sourceError: e6, bundleUrl: Z(t3.properties.dailyConfig) } } };
            t3._maybeSendToSentry(i4), t3.emitDailyJSEvent(i4), n3(e6.msg);
          }
        });
      }) : (this._iframe.src = X(this.assembleMeetingUrl(), this.properties.dailyConfig), new Promise(function(e5, n3) {
        t3._loadedCallback = function(r5) {
          t3._callState !== wi ? (t3._updateCallState(mi), (t3.properties.cssFile || t3.properties.cssText) && t3.loadCss(t3.properties), e5()) : n3(r5);
        };
      }));
    }
  }), function(e4) {
    return L3.apply(this, arguments);
  }) }, { key: "join", value: (I3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this._testCallInProgress && this.stopTestCallQuality();
    var n3 = false;
    if (this.needsLoad()) {
      this.updateIsPreparingToJoin(true);
      try {
        yield this.load(t3);
      } catch (e5) {
        return this.updateIsPreparingToJoin(false), Promise.reject(e5);
      }
    } else {
      if (n3 = !(!this.properties.cssFile && !this.properties.cssText), this._didPreAuth) {
        if (t3.url && t3.url !== this.properties.url)
          return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
        if (t3.token && t3.token !== this.properties.token)
          return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
      }
      if (t3.url && !this._callObjectMode && t3.url && t3.url !== this.properties.url)
        return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t3.url, ")")), this.updateIsPreparingToJoin(false), Promise.reject();
      this.validateProperties(t3), this.properties = Va(Va({}, this.properties), t3);
    }
    return void 0 !== t3.showLocalVideo && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t3.showLocalVideo), void 0 !== t3.showParticipantsBar && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t3.showParticipantsBar), this._callState === bi || this._callState === yi ? (console.warn("already joined meeting, call leave() before joining again"), void this.updateIsPreparingToJoin(false)) : (this._updateCallState(yi, false), this.emitDailyJSEvent({ action: so }), this._preloadCache.inputSettings = this._prepInputSettingsForSharing(this._inputSettings || {}, false), this.sendMessageToCallMachine({ action: "join-meeting", properties: oc(this.properties, this.callClientId), preloadCache: oc(this._preloadCache, this.callClientId) }), new Promise(function(t4, r5) {
      e4._joinedCallback = function(i4, o4) {
        if (e4._callState !== wi) {
          if (e4._updateCallState(bi), i4)
            for (var s3 in i4) {
              if (e4._callObjectMode) {
                var a3 = e4._callMachine().store;
                ua(i4[s3], a3), da(i4[s3], a3), ha(i4[s3], e4._participants[s3], a3);
              }
              e4._participants[s3] = Va({}, i4[s3]), e4.toggleParticipantAudioBasedOnNativeAudioFocus();
            }
          n3 && e4.loadCss(e4.properties), t4(i4);
        } else
          r5(o4);
      };
    }));
  }), function() {
    return I3.apply(this, arguments);
  }) }, { key: "leave", value: (j3 = p(function* () {
    var e4 = this;
    return this._testCallInProgress && this.stopTestCallQuality(), new Promise(function(t3) {
      e4._callState === _i || e4._callState === wi ? t3() : e4._callObjectLoader && !e4._callObjectLoader.loaded ? (e4._callObjectLoader.cancel(), e4._updateCallState(_i), e4.resetMeetingDependentVars(), e4.emitDailyJSEvent({ action: _i }), t3()) : (e4._resolveLeave = t3, e4.sendMessageToCallMachine({ action: "leave-meeting" }));
    });
  }), function() {
    return j3.apply(this, arguments);
  }) }, { key: "startScreenShare", value: (A3 = p(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (lc(this._callMachineInitialized, "startScreenShare()"), t3.screenVideoSendSettings && this._validateVideoSendSettings("screenVideo", t3.screenVideoSendSettings), t3.mediaStream && (this._sharedTracks.screenMediaStream = t3.mediaStream, t3.mediaStream = ls), "undefined" != typeof DailyNativeUtils && void 0 !== DailyNativeUtils.isIOS && DailyNativeUtils.isIOS) {
      var n3 = this.nativeUtils();
      if (yield n3.isScreenBeingCaptured())
        return void this.emitDailyJSEvent({ action: ts, type: "screen-share-error", errorMsg: "Could not start the screen sharing. The screen is already been captured!" });
      n3.setSystemScreenCaptureStartCallback(function() {
        n3.setSystemScreenCaptureStartCallback(null), e4.sendMessageToCallMachine({ action: ss, captureOptions: t3 });
      }), n3.presentSystemScreenCapturePrompt();
    } else
      this.sendMessageToCallMachine({ action: ss, captureOptions: t3 });
  }), function() {
    return A3.apply(this, arguments);
  }) }, { key: "stopScreenShare", value: function() {
    lc(this._callMachineInitialized, "stopScreenShare()"), this.sendMessageToCallMachine({ action: "local-screen-stop" });
  } }, { key: "startRecording", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = e4.type;
    if (t3 && "cloud" !== t3 && "raw-tracks" !== t3 && "local" !== t3)
      throw new Error("invalid type: ".concat(t3, ", allowed values 'cloud', 'raw-tracks', or 'local'"));
    this.sendMessageToCallMachine(Va({ action: "local-recording-start" }, e4));
  } }, { key: "updateRecording", value: function(e4) {
    var t3 = e4.layout, n3 = void 0 === t3 ? { preset: "default" } : t3, r5 = e4.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-recording", layout: n3, instanceId: r5 });
  } }, { key: "stopRecording", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Va({ action: "local-recording-stop" }, e4));
  } }, { key: "startLiveStreaming", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Va({ action: "daily-method-start-live-streaming" }, e4));
  } }, { key: "updateLiveStreaming", value: function(e4) {
    var t3 = e4.layout, n3 = void 0 === t3 ? { preset: "default" } : t3, r5 = e4.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-live-streaming", layout: n3, instanceId: r5 });
  } }, { key: "addLiveStreamingEndpoints", value: function(e4) {
    var t3 = e4.endpoints, n3 = e4.instanceId;
    this.sendMessageToCallMachine({ action: as, endpointsOp: fs, endpoints: t3, instanceId: n3 });
  } }, { key: "removeLiveStreamingEndpoints", value: function(e4) {
    var t3 = e4.endpoints, n3 = e4.instanceId;
    this.sendMessageToCallMachine({ action: as, endpointsOp: vs, endpoints: t3, instanceId: n3 });
  } }, { key: "stopLiveStreaming", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Va({ action: "daily-method-stop-live-streaming" }, e4));
  } }, { key: "validateDailyConfig", value: function(e4) {
    e4.camSimulcastEncodings && (console.warn("camSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide camera simulcast settings."), this.validateSimulcastEncodings(e4.camSimulcastEncodings)), e4.screenSimulcastEncodings && console.warn("screenSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide screen simulcast settings."), Es() && e4.noAutoDefaultDeviceChange && console.warn("noAutoDefaultDeviceChange is not supported on Android, and will be ignored.");
  } }, { key: "validateSimulcastEncodings", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e4) {
      if (!(e4 instanceof Array || Array.isArray(e4)))
        throw new Error("encodings must be an Array");
      if (!Ac(e4.length, 1, 3))
        throw new Error("encodings must be an Array with between 1 to ".concat(3, " layers"));
      for (var r5 = 0; r5 < e4.length; r5++) {
        var i4 = e4[r5];
        for (var o4 in this._validateEncodingLayerHasValidProperties(i4), i4)
          if (Ya.includes(o4)) {
            if ("number" != typeof i4[o4])
              throw new Error("".concat(o4, " must be a number"));
            if (t3) {
              var s3 = t3[o4], a3 = s3.min, c4 = s3.max;
              if (!Ac(i4[o4], a3, c4))
                throw new Error("".concat(o4, " value not in range. valid range: ").concat(a3, " to ").concat(c4));
            }
          } else if (!["active", "scalabilityMode"].includes(o4))
            throw new Error("Invalid key ".concat(o4, ", valid keys are:") + Object.values(Ya));
        if (n3 && !i4.hasOwnProperty("maxBitrate"))
          throw new Error("maxBitrate is not specified");
      }
    }
  } }, { key: "startRemoteMediaPlayer", value: (P3 = p(function* (e4) {
    var t3 = this, n3 = e4.url, r5 = e4.settings, i4 = void 0 === r5 ? { state: ps.PLAY } : r5;
    try {
      !function(e5) {
        if ("string" != typeof e5)
          throw new Error('url parameter must be "string" type');
      }(n3), Pc(i4), function(e5) {
        for (var t4 in e5)
          if (!Xa.includes(t4))
            throw new Error("Invalid key ".concat(t4, ", valid keys are: ").concat(Xa));
        e5.simulcastEncodings && this.validateSimulcastEncodings(e5.simulcastEncodings, Ka, true);
      }(i4);
    } catch (e5) {
      throw console.error("invalid argument Error: ".concat(e5)), console.error('startRemoteMediaPlayer arguments must be of the form:\n  { url: "playback url",\n  settings?:\n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e5;
    }
    return new Promise(function(e5, r6) {
      t3.sendMessageToCallMachine({ action: "daily-method-start-remote-media-player", url: n3, settings: i4 }, function(t4) {
        t4.error ? r6({ error: t4.error, errorMsg: t4.errorMsg }) : e5({ session_id: t4.session_id, remoteMediaPlayerState: { state: t4.state, settings: t4.settings } });
      });
    });
  }), function(e4) {
    return P3.apply(this, arguments);
  }) }, { key: "stopRemoteMediaPlayer", value: (O3 = p(function* (e4) {
    var t3 = this;
    if ("string" != typeof e4)
      throw new Error(" remotePlayerID must be of type string");
    return new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "daily-method-stop-remote-media-player", session_id: e4 }, function(e5) {
        e5.error ? r5({ error: e5.error, errorMsg: e5.errorMsg }) : n3();
      });
    });
  }), function(e4) {
    return O3.apply(this, arguments);
  }) }, { key: "updateRemoteMediaPlayer", value: (T3 = p(function* (e4) {
    var t3 = this, n3 = e4.session_id, r5 = e4.settings;
    try {
      Pc(r5);
    } catch (e5) {
      throw console.error("invalid argument Error: ".concat(e5)), console.error('updateRemoteMediaPlayer arguments must be of the form:\n  session_id: "participant session",\n  { settings?: {state: "play"|"pause"} }'), e5;
    }
    return new Promise(function(e5, i4) {
      t3.sendMessageToCallMachine({ action: "daily-method-update-remote-media-player", session_id: n3, settings: r5 }, function(t4) {
        t4.error ? i4({ error: t4.error, errorMsg: t4.errorMsg }) : e5({ session_id: t4.session_id, remoteMediaPlayerState: { state: t4.state, settings: t4.settings } });
      });
    });
  }), function(e4) {
    return T3.apply(this, arguments);
  }) }, { key: "startTranscription", value: function(e4) {
    sc(this._callState, "startTranscription()"), this.sendMessageToCallMachine(Va({ action: "daily-method-start-transcription" }, e4));
  } }, { key: "updateTranscription", value: function(e4) {
    if (sc(this._callState, "updateTranscription()"), !e4)
      throw new Error("updateTranscription Error: options is mandatory");
    if ("object" !== n(e4))
      throw new Error("updateTranscription Error: options must be object type");
    if (e4.participants && !Array.isArray(e4.participants))
      throw new Error("updateTranscription Error: participants must be an array");
    this.sendMessageToCallMachine(Va({ action: "daily-method-update-transcription" }, e4));
  } }, { key: "stopTranscription", value: function(e4) {
    if (sc(this._callState, "stopTranscription()"), e4 && "object" !== n(e4))
      throw new Error("stopTranscription Error: options must be object type");
    if (e4 && !e4.instanceId)
      throw new Error('"instanceId" not provided');
    this.sendMessageToCallMachine(Va({ action: "daily-method-stop-transcription" }, e4));
  } }, { key: "startDialOut", value: (E3 = p(function* (e4) {
    var t3 = this;
    sc(this._callState, "startDialOut()");
    var n3 = function(e5) {
      if (e5) {
        if (!Array.isArray(e5))
          throw new Error("Error starting dial out: audio codec must be an array");
        if (e5.length <= 0)
          throw new Error("Error starting dial out: audio codec array specified but empty");
        e5.forEach(function(e6) {
          if ("string" != typeof e6)
            throw new Error("Error starting dial out: audio codec must be a string");
          if ("OPUS" !== e6 && "PCMU" !== e6 && "PCMA" !== e6 && "G722" !== e6)
            throw new Error("Error starting dial out: audio codec must be one of OPUS, PCMU, PCMA, G722");
        });
      }
    };
    if (!e4.sipUri && !e4.phoneNumber)
      throw new Error("Error starting dial out: either a sip uri or phone number must be provided");
    if (e4.sipUri && e4.phoneNumber)
      throw new Error("Error starting dial out: only one of sip uri or phone number must be provided");
    if (e4.sipUri) {
      if ("string" != typeof e4.sipUri)
        throw new Error("Error starting dial out: sipUri must be a string");
      if (!e4.sipUri.startsWith("sip:"))
        throw new Error("Error starting dial out: Invalid SIP URI, must start with 'sip:'");
      if (e4.video && "boolean" != typeof e4.video)
        throw new Error("Error starting dial out: video must be a boolean value");
      !function(e5) {
        if (e5 && (n3(e5.audio), e5.video)) {
          if (!Array.isArray(e5.video))
            throw new Error("Error starting dial out: video codec must be an array");
          if (e5.video.length <= 0)
            throw new Error("Error starting dial out: video codec array specified but empty");
          e5.video.forEach(function(e6) {
            if ("string" != typeof e6)
              throw new Error("Error starting dial out: video codec must be a string");
            if ("H264" !== e6 && "VP8" !== e6)
              throw new Error("Error starting dial out: video codec must be H264 or VP8");
          });
        }
      }(e4.codecs);
    }
    if (e4.phoneNumber) {
      if ("string" != typeof e4.phoneNumber)
        throw new Error("Error starting dial out: phoneNumber must be a string");
      if (!/^\+\d{1,}$/.test(e4.phoneNumber))
        throw new Error("Error starting dial out: Invalid phone number, must be valid phone number as per E.164");
      e4.codecs && n3(e4.codecs.audio);
    }
    if (e4.callerId) {
      if ("string" != typeof e4.callerId)
        throw new Error("Error starting dial out: callerId must be a string");
      if (e4.sipUri)
        throw new Error("Error starting dial out: callerId not allowed with sipUri");
    }
    if (e4.displayName) {
      if ("string" != typeof e4.displayName)
        throw new Error("Error starting dial out: displayName must be a string");
      if (e4.displayName.length >= 200)
        throw new Error("Error starting dial out: displayName length must be less than 200");
    }
    if (e4.userId) {
      if ("string" != typeof e4.userId)
        throw new Error("Error starting dial out: userId must be a string");
      if (e4.userId.length > 36)
        throw new Error("Error starting dial out: userId length must be less than or equal to 36");
    }
    return new Promise(function(n4, r5) {
      t3.sendMessageToCallMachine(Va({ action: "dialout-start" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n4(e5);
      });
    });
  }), function(e4) {
    return E3.apply(this, arguments);
  }) }, { key: "stopDialOut", value: function(e4) {
    var t3 = this;
    return sc(this._callState, "stopDialOut()"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(Va({ action: "dialout-stop" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  } }, { key: "sipCallTransfer", value: (C3 = p(function* (e4) {
    var t3 = this;
    if (sc(this._callState, "sipCallTransfer()"), !e4)
      throw new Error("sipCallTransfer() requires a sessionId and toEndPoint");
    return e4.useSipRefer = false, Oc(e4, "sipCallTransfer"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(Va({ action: gs }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return C3.apply(this, arguments);
  }) }, { key: "sipRefer", value: (M3 = p(function* (e4) {
    var t3 = this;
    if (sc(this._callState, "sipRefer()"), !e4)
      throw new Error("sessionId and toEndPoint are mandatory parameter");
    return e4.useSipRefer = true, Oc(e4, "sipRefer"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(Va({ action: gs }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return M3.apply(this, arguments);
  }) }, { key: "sendDTMF", value: (k3 = p(function* (e4) {
    var t3 = this;
    return sc(this._callState, "sendDTMF()"), function(e5) {
      var t4 = e5.sessionId, n3 = e5.tones;
      if (!t4 || !n3)
        throw new Error("sessionId and tones are mandatory parameter");
      if ("string" != typeof t4 || "string" != typeof n3)
        throw new Error("sessionId and tones should be of string type");
      if (n3.length > 20)
        throw new Error("tones string must be upto 20 characters");
      var r5 = /[^0-9A-D*#]/g, i4 = n3.match(r5);
      if (i4 && i4[0])
        throw new Error("".concat(i4[0], " is not valid DTMF tone"));
    }(e4), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(Va({ action: "send-dtmf" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return k3.apply(this, arguments);
  }) }, { key: "getNetworkStats", value: function() {
    var e4 = this;
    if (this._callState !== bi) {
      return Promise.resolve(Va({ stats: { latest: {} } }, this._network));
    }
    return new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-calc-stats" }, function(n3) {
        t3(Va(Va({}, e4._network), {}, { stats: n3.stats }));
      });
    });
  } }, { key: "testWebsocketConnectivity", value: (S3 = p(function* () {
    var e4 = this;
    if (uc(this._testCallInProgress, "testWebsocketConnectivity()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    return new Promise(function(t3, n3) {
      e4.sendMessageToCallMachine({ action: "test-websocket-connectivity" }, function(e5) {
        e5.error ? n3(e5.error) : t3(e5.results);
      });
    });
  }), function() {
    return S3.apply(this, arguments);
  }) }, { key: "abortTestWebsocketConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-websocket-connectivity" });
  } }, { key: "_validateVideoTrackForNetworkTests", value: function(e4) {
    return e4 ? e4 instanceof MediaStreamTrack ? !!Ea(e4, { isLocalScreenVideo: false }) || (console.error("Video track is not playable. This test needs a live video track."), false) : (console.error("Video track needs to be of type `MediaStreamTrack`."), false) : (console.error("Missing video track. You must provide a video track in order to run this test."), false);
  } }, { key: "testCallQuality", value: (w3 = p(function* () {
    var t3 = this;
    hc(), dc(this._callObjectMode, "testCallQuality()"), lc(this._callMachineInitialized, "testCallQuality()", null, true), cc(this._callState, this._isPreparingToJoin, "testCallQuality()");
    var n3 = this._testCallAlreadyInProgress, r5 = function(e4) {
      n3 || (t3._testCallInProgress = e4);
    };
    if (r5(true), this.needsLoad())
      try {
        var i4 = this._callState;
        yield this.load(), this._callState = i4;
      } catch (e4) {
        return r5(false), Promise.reject(e4);
      }
    return new Promise(function(n4) {
      t3.sendMessageToCallMachine({ action: "test-call-quality", dailyJsVersion: t3.properties.dailyJsVersion }, function(i5) {
        var o4 = i5.results, s3 = o4.result, a3 = e(o4, Fa);
        if ("failed" === s3) {
          var c4, l3 = Va({}, a3);
          null !== (c4 = a3.error) && void 0 !== c4 && c4.details ? (a3.error.details = JSON.parse(a3.error.details), l3.error = Va(Va({}, l3.error), {}, { details: Va({}, l3.error.details) }), l3.error.details.duringTest = "testCallQuality") : (l3.error = l3.error ? Va({}, l3.error) : {}, l3.error.details = { duringTest: "testCallQuality" }), t3._maybeSendToSentry(l3);
        }
        r5(false), n4(Va({ result: s3 }, a3));
      });
    });
  }), function() {
    return w3.apply(this, arguments);
  }) }, { key: "stopTestCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-call-quality" });
  } }, { key: "testConnectionQuality", value: (_4 = p(function* (e4) {
    var t3;
    ys() ? (console.warn("testConnectionQuality() is deprecated: use testPeerToPeerCallQuality() instead"), t3 = yield this.testPeerToPeerCallQuality(e4)) : (console.warn("testConnectionQuality() is deprecated: use testCallQuality() instead"), t3 = yield this.testCallQuality());
    var n3 = { result: t3.result, secondsElapsed: t3.secondsElapsed };
    return t3.data && (n3.data = { maxRTT: t3.data.maxRoundTripTime, packetLoss: t3.data.avgRecvPacketLoss }), n3;
  }), function(e4) {
    return _4.apply(this, arguments);
  }) }, { key: "testPeerToPeerCallQuality", value: (b3 = p(function* (e4) {
    var t3 = this;
    if (uc(this._testCallInProgress, "testPeerToPeerCallQuality()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    var n3 = e4.videoTrack, r5 = e4.duration;
    if (!this._validateVideoTrackForNetworkTests(n3))
      throw new Error("Video track error");
    return this._sharedTracks.videoTrackForConnectionQualityTest = n3, new Promise(function(e5, n4) {
      t3.sendMessageToCallMachine({ action: "test-p2p-call-quality", duration: r5 }, function(t4) {
        t4.error ? n4(t4.error) : e5(t4.results);
      });
    });
  }), function(e4) {
    return b3.apply(this, arguments);
  }) }, { key: "stopTestConnectionQuality", value: function() {
    ys() ? (console.warn("stopTestConnectionQuality() is deprecated: use testPeerToPeerCallQuality() and stopTestPeerToPeerCallQuality() instead"), this.stopTestPeerToPeerCallQuality()) : (console.warn("stopTestConnectionQuality() is deprecated: use testCallQuality() and stopTestCallQuality() instead"), this.stopTestCallQuality());
  } }, { key: "stopTestPeerToPeerCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-p2p-call-quality" });
  } }, { key: "testNetworkConnectivity", value: (y3 = p(function* (e4) {
    var t3 = this;
    if (uc(this._testCallInProgress, "testNetworkConnectivity()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    if (!this._validateVideoTrackForNetworkTests(e4))
      throw new Error("Video track error");
    return this._sharedTracks.videoTrackForNetworkConnectivityTest = e4, new Promise(function(e5, n3) {
      t3.sendMessageToCallMachine({ action: "test-network-connectivity" }, function(t4) {
        t4.error ? n3(t4.error) : e5(t4.results);
      });
    });
  }), function(e4) {
    return y3.apply(this, arguments);
  }) }, { key: "abortTestNetworkConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-network-connectivity" });
  } }, { key: "getCpuLoadStats", value: function() {
    var e4 = this;
    return new Promise(function(t3) {
      if (e4._callState === bi) {
        e4.sendMessageToCallMachine({ action: "get-cpu-load-stats" }, function(e5) {
          t3(e5.cpuStats);
        });
      } else
        t3({ cpuLoadState: void 0, cpuLoadStateReason: void 0, stats: {} });
    });
  } }, { key: "_validateEncodingLayerHasValidProperties", value: function(e4) {
    var t3;
    if (!((null === (t3 = Object.keys(e4)) || void 0 === t3 ? void 0 : t3.length) > 0))
      throw new Error("Empty encoding is not allowed. At least one of these valid keys should be specified:" + Object.values(Ya));
  } }, { key: "_validateVideoSendSettings", value: function(e4, t3) {
    var r5 = "screenVideo" === e4 ? ["default-screen-video", "detail-optimized", "motion-optimized", "motion-and-detail-balanced"] : ["default-video", "bandwidth-optimized", "bandwidth-and-quality-balanced", "quality-optimized", "adaptive-2-layers", "adaptive-3-layers"], i4 = "Video send settings should be either an object or one of the supported presets: ".concat(r5.join());
    if ("string" == typeof t3) {
      if (!r5.includes(t3))
        throw new Error(i4);
    } else {
      if ("object" !== n(t3))
        throw new Error(i4);
      if (!t3.maxQuality && !t3.encodings && void 0 === t3.allowAdaptiveLayers)
        throw new Error("Video send settings must contain at least maxQuality, allowAdaptiveLayers or encodings attribute");
      if (t3.maxQuality && -1 === ["low", "medium", "high"].indexOf(t3.maxQuality))
        throw new Error("maxQuality must be either low, medium or high");
      if (t3.encodings) {
        var o4 = false;
        switch (Object.keys(t3.encodings).length) {
          case 1:
            o4 = !t3.encodings.low;
            break;
          case 2:
            o4 = !t3.encodings.low || !t3.encodings.medium;
            break;
          case 3:
            o4 = !t3.encodings.low || !t3.encodings.medium || !t3.encodings.high;
            break;
          default:
            o4 = true;
        }
        if (o4)
          throw new Error("Encodings must be defined as: low, low and medium, or low, medium and high.");
        t3.encodings.low && this._validateEncodingLayerHasValidProperties(t3.encodings.low), t3.encodings.medium && this._validateEncodingLayerHasValidProperties(t3.encodings.medium), t3.encodings.high && this._validateEncodingLayerHasValidProperties(t3.encodings.high);
      }
    }
  } }, { key: "validateUpdateSendSettings", value: function(e4) {
    var t3 = this;
    if (!e4 || 0 === Object.keys(e4).length)
      throw new Error("Send settings must contain at least information for one track!");
    Object.entries(e4).forEach(function(e5) {
      var n3 = f(e5, 2), r5 = n3[0], i4 = n3[1];
      t3._validateVideoSendSettings(r5, i4);
    });
  } }, { key: "updateSendSettings", value: function(e4) {
    var t3 = this;
    return this.validateUpdateSendSettings(e4), this.needsLoad() ? (this._preloadCache.sendSettings = e4, { sendSettings: this._preloadCache.sendSettings }) : new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "update-send-settings", sendSettings: e4 }, function(e5) {
        e5.error ? r5(e5.error) : n3(e5.sendSettings);
      });
    });
  } }, { key: "getSendSettings", value: function() {
    return this._sendSettings || this._preloadCache.sendSettings;
  } }, { key: "getLocalAudioLevel", value: function() {
    return this._localAudioLevel;
  } }, { key: "getRemoteParticipantsAudioLevel", value: function() {
    return this._remoteParticipantsAudioLevel;
  } }, { key: "getActiveSpeaker", value: function() {
    return hc(), this._activeSpeaker;
  } }, { key: "setActiveSpeakerMode", value: function(e4) {
    return hc(), this.sendMessageToCallMachine({ action: "set-active-speaker-mode", enabled: e4 }), this;
  } }, { key: "activeSpeakerMode", value: function() {
    return hc(), this._activeSpeakerMode;
  } }, { key: "subscribeToTracksAutomatically", value: function() {
    return this._preloadCache.subscribeToTracksAutomatically;
  } }, { key: "setSubscribeToTracksAutomatically", value: function(e4) {
    return sc(this._callState, "setSubscribeToTracksAutomatically()", "Use the subscribeToTracksAutomatically configuration property."), this._preloadCache.subscribeToTracksAutomatically = e4, this.sendMessageToCallMachine({ action: "daily-method-subscribe-to-tracks-automatically", enabled: e4 }), this;
  } }, { key: "enumerateDevices", value: (m3 = p(function* () {
    var e4 = this;
    if (this._callObjectMode) {
      var t3 = yield navigator.mediaDevices.enumerateDevices();
      return "Firefox" === Os() && Ps().major > 115 && Ps().major < 123 && (t3 = t3.filter(function(e5) {
        return "audiooutput" !== e5.kind;
      })), { devices: t3.map(function(e5) {
        var t4 = JSON.parse(JSON.stringify(e5));
        if (!ys() && "videoinput" === e5.kind && e5.getCapabilities) {
          var n3, r5 = e5.getCapabilities();
          t4.facing = (null == r5 || null === (n3 = r5.facingMode) || void 0 === n3 ? void 0 : n3.length) >= 1 ? r5.facingMode[0] : void 0;
        }
        return t4;
      }) };
    }
    return new Promise(function(t4) {
      e4.sendMessageToCallMachine({ action: "enumerate-devices" }, function(e5) {
        t4({ devices: e5.devices });
      });
    });
  }), function() {
    return m3.apply(this, arguments);
  }) }, { key: "sendAppMessage", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "*";
    if (sc(this._callState, "sendAppMessage()"), JSON.stringify(e4).length > this._maxAppMessageSize)
      throw new Error("Message data too large. Max size is " + this._maxAppMessageSize);
    return this.sendMessageToCallMachine({ action: "app-msg", data: e4, to: t3 }), this;
  } }, { key: "addFakeParticipant", value: function(e4) {
    return hc(), sc(this._callState, "addFakeParticipant()"), this.sendMessageToCallMachine(Va({ action: "add-fake-participant" }, e4)), this;
  } }, { key: "setShowNamesMode", value: function(e4) {
    return pc(this._callObjectMode, "setShowNamesMode()"), hc(), e4 && "always" !== e4 && "never" !== e4 ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({ action: "set-show-names", mode: e4 }), this);
  } }, { key: "setShowLocalVideo", value: function() {
    var e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return pc(this._callObjectMode, "setShowLocalVideo()"), hc(), sc(this._callState, "setShowLocalVideo()"), "boolean" != typeof e4 ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-local-video", show: e4 }), this._showLocalVideo = e4, this);
  } }, { key: "showLocalVideo", value: function() {
    return pc(this._callObjectMode, "showLocalVideo()"), hc(), this._showLocalVideo;
  } }, { key: "setShowParticipantsBar", value: function() {
    var e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return pc(this._callObjectMode, "setShowParticipantsBar()"), hc(), sc(this._callState, "setShowParticipantsBar()"), "boolean" != typeof e4 ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-participants-bar", show: e4 }), this._showParticipantsBar = e4, this);
  } }, { key: "showParticipantsBar", value: function() {
    return pc(this._callObjectMode, "showParticipantsBar()"), hc(), this._showParticipantsBar;
  } }, { key: "customIntegrations", value: function() {
    return hc(), pc(this._callObjectMode, "customIntegrations()"), this._customIntegrations;
  } }, { key: "setCustomIntegrations", value: function(e4) {
    return hc(), pc(this._callObjectMode, "setCustomIntegrations()"), sc(this._callState, "setCustomIntegrations()"), Ec(e4) ? (this.sendMessageToCallMachine({ action: "set-custom-integrations", integrations: e4 }), this._customIntegrations = e4, this) : this;
  } }, { key: "startCustomIntegrations", value: function(e4) {
    var t3 = this;
    if (hc(), pc(this._callObjectMode, "startCustomIntegrations()"), sc(this._callState, "startCustomIntegrations()"), Array.isArray(e4) && e4.some(function(e5) {
      return "string" != typeof e5;
    }) || !Array.isArray(e4) && "string" != typeof e4)
      return console.error("startCustomIntegrations() only accepts string | string[]"), this;
    var n3 = "string" == typeof e4 ? [e4] : e4, r5 = n3.filter(function(e5) {
      return !(e5 in t3._customIntegrations);
    });
    return r5.length ? (console.error(`Can't find custom integration(s): "`.concat(r5.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "start-custom-integrations", ids: n3 }), this);
  } }, { key: "stopCustomIntegrations", value: function(e4) {
    var t3 = this;
    if (hc(), pc(this._callObjectMode, "stopCustomIntegrations()"), sc(this._callState, "stopCustomIntegrations()"), Array.isArray(e4) && e4.some(function(e5) {
      return "string" != typeof e5;
    }) || !Array.isArray(e4) && "string" != typeof e4)
      return console.error("stopCustomIntegrations() only accepts string | string[]"), this;
    var n3 = "string" == typeof e4 ? [e4] : e4, r5 = n3.filter(function(e5) {
      return !(e5 in t3._customIntegrations);
    });
    return r5.length ? (console.error(`Can't find custom integration(s): "`.concat(r5.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "stop-custom-integrations", ids: n3 }), this);
  } }, { key: "customTrayButtons", value: function() {
    return pc(this._callObjectMode, "customTrayButtons()"), hc(), this._customTrayButtons;
  } }, { key: "updateCustomTrayButtons", value: function(e4) {
    return pc(this._callObjectMode, "updateCustomTrayButtons()"), hc(), sc(this._callState, "updateCustomTrayButtons()"), Cc(e4) ? (this.sendMessageToCallMachine({ action: "update-custom-tray-buttons", btns: e4 }), this._customTrayButtons = e4, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify(ec))), this);
  } }, { key: "theme", value: function() {
    return pc(this._callObjectMode, "theme()"), this.properties.theme;
  } }, { key: "setTheme", value: function(e4) {
    var t3 = this;
    return pc(this._callObjectMode, "setTheme()"), new Promise(function(n3, r5) {
      try {
        t3.validateProperties({ theme: e4 }), t3.properties.theme = Va({}, e4), t3.sendMessageToCallMachine({ action: "set-theme", theme: t3.properties.theme });
        try {
          t3.emitDailyJSEvent({ action: eo, theme: t3.properties.theme });
        } catch (e5) {
          console.log("could not emit 'theme-updated'", e5);
        }
        n3(t3.properties.theme);
      } catch (e5) {
        r5(e5);
      }
    });
  } }, { key: "requestFullscreen", value: (g3 = p(function* () {
    if (hc(), this._iframe && !document.fullscreenElement && ws())
      try {
        (yield this._iframe.requestFullscreen) ? this._iframe.requestFullscreen() : this._iframe.webkitRequestFullscreen();
      } catch (e4) {
        console.log("could not make video call fullscreen", e4);
      }
  }), function() {
    return g3.apply(this, arguments);
  }) }, { key: "exitFullscreen", value: function() {
    hc(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
  } }, { key: "getSidebarView", value: (v3 = p(function* () {
    var e4 = this;
    return this._callObjectMode ? (console.error("getSidebarView is not available in callObject mode"), Promise.resolve(null)) : new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-sidebar-view" }, function(e5) {
        t3(e5.view);
      });
    });
  }), function() {
    return v3.apply(this, arguments);
  }) }, { key: "setSidebarView", value: function(e4) {
    return this._callObjectMode ? (console.error("setSidebarView is not available in callObject mode"), this) : (this.sendMessageToCallMachine({ action: "set-sidebar-view", view: e4 }), this);
  } }, { key: "room", value: (h4 = p(function* () {
    var e4 = this, t3 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeRoomConfigDefaults, n3 = void 0 === t3 || t3;
    return this._accessState.access === Oi || this.needsLoad() ? this.properties.url ? { roomUrlPendingJoin: this.properties.url } : null : new Promise(function(t4) {
      e4.sendMessageToCallMachine({ action: "lib-room-info", includeRoomConfigDefaults: n3 }, function(e5) {
        delete e5.action, delete e5.callbackStamp, t4(e5);
      });
    });
  }), function() {
    return h4.apply(this, arguments);
  }) }, { key: "geo", value: (d3 = p(function* () {
    try {
      var e4 = yield fetch("https://gs.daily.co/_ks_/x-swsl/:");
      return { current: (yield e4.json()).geo };
    } catch (e5) {
      return console.error("geo lookup failed", e5), { current: "" };
    }
  }), function() {
    return d3.apply(this, arguments);
  }) }, { key: "setNetworkTopology", value: (c3 = p(function* (e4) {
    var t3 = this;
    return hc(), sc(this._callState, "setNetworkTopology()"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "set-network-topology", opts: e4 }, function(e5) {
        e5.error ? r5({ error: e5.error }) : n3({ workerId: e5.workerId });
      });
    });
  }), function(e4) {
    return c3.apply(this, arguments);
  }) }, { key: "getNetworkTopology", value: (i3 = p(function* () {
    var e4 = this;
    return new Promise(function(t3, n3) {
      e4.needsLoad() && t3({ topology: "none" }), e4.sendMessageToCallMachine({ action: "get-network-topology" }, function(e5) {
        e5.error ? n3({ error: e5.error }) : t3({ topology: e5.topology });
      });
    });
  }), function() {
    return i3.apply(this, arguments);
  }) }, { key: "setPlayNewParticipantSound", value: function(e4) {
    if (hc(), "number" != typeof e4 && true !== e4 && false !== e4)
      throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e4));
    this.sendMessageToCallMachine({ action: "daily-method-set-play-ding", arg: e4 });
  } }, { key: "on", value: function(e4, t3) {
    return x.prototype.on.call(this, e4, t3);
  } }, { key: "once", value: function(e4, t3) {
    return x.prototype.once.call(this, e4, t3);
  } }, { key: "off", value: function(e4, t3) {
    return x.prototype.off.call(this, e4, t3);
  } }, { key: "validateProperties", value: function(e4) {
    var t3, n3;
    if (null != e4 && null !== (t3 = e4.dailyConfig) && void 0 !== t3 && t3.userMediaAudioConstraints) {
      var r5, i4;
      ys() || console.warn("userMediaAudioConstraints is deprecated. You can override constraints with inputSettings.audio.settings, found in DailyCallOptions.");
      var o4 = e4.inputSettings || {};
      o4.audio = (null === (r5 = e4.inputSettings) || void 0 === r5 ? void 0 : r5.audio) || {}, o4.audio.settings = (null === (i4 = e4.inputSettings) || void 0 === i4 || null === (i4 = i4.audio) || void 0 === i4 ? void 0 : i4.settings) || {}, o4.audio.settings = Va(Va({}, o4.audio.settings), e4.dailyConfig.userMediaAudioConstraints), e4.inputSettings = o4, delete e4.dailyConfig.userMediaAudioConstraints;
    }
    if (null != e4 && null !== (n3 = e4.dailyConfig) && void 0 !== n3 && n3.userMediaVideoConstraints) {
      var s3, a3;
      ys() || console.warn("userMediaVideoConstraints is deprecated. You can override constraints with inputSettings.video.settings, found in DailyCallOptions.");
      var c4 = e4.inputSettings || {};
      c4.video = (null === (s3 = e4.inputSettings) || void 0 === s3 ? void 0 : s3.video) || {}, c4.video.settings = (null === (a3 = e4.inputSettings) || void 0 === a3 || null === (a3 = a3.video) || void 0 === a3 ? void 0 : a3.settings) || {}, c4.video.settings = Va(Va({}, c4.video.settings), e4.dailyConfig.userMediaVideoConstraints), e4.inputSettings = c4, delete e4.dailyConfig.userMediaVideoConstraints;
    }
    for (var l3 in e4) {
      if (!nc[l3])
        throw new Error("unrecognized property '".concat(l3, "'"));
      if (nc[l3].validate && !nc[l3].validate(e4[l3], this))
        throw new Error("property '".concat(l3, "': ").concat(nc[l3].help));
    }
  } }, { key: "assembleMeetingUrl", value: function() {
    var e4, t3, n3 = Va(Va({}, this.properties), {}, { emb: this.callClientId, embHref: encodeURIComponent(window.location.href), proxy: null !== (e4 = this.properties.dailyConfig) && void 0 !== e4 && e4.proxyUrl ? encodeURIComponent(null === (t3 = this.properties.dailyConfig) || void 0 === t3 ? void 0 : t3.proxyUrl) : void 0 }), r5 = n3.url.match(/\?/) ? "&" : "?";
    return n3.url + r5 + Object.keys(nc).filter(function(e5) {
      return nc[e5].queryString && void 0 !== n3[e5];
    }).map(function(e5) {
      return "".concat(nc[e5].queryString, "=").concat(n3[e5]);
    }).join("&");
  } }, { key: "needsLoad", value: function() {
    return [vi, gi, _i, wi].includes(this._callState);
  } }, { key: "sendMessageToCallMachine", value: function(e4, t3) {
    if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode))
      throw new Error("Use after destroy");
    this._messageChannel.sendMessageToCallMachine(e4, t3, this.callClientId, this._iframe);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e4) {
    this._messageChannel.forwardPackagedMessageToCallMachine(e4, this._iframe, this.callClientId);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e4) {
    return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e4, this.callClientId);
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e4) {
    this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e4);
  } }, { key: "handleMessageFromCallMachine", value: function(t3) {
    switch (t3.action) {
      case Xi:
        this.sendMessageToCallMachine(Va({ action: Zi }, this.properties));
        break;
      case "call-machine-initialized":
        this._callMachineInitialized = true;
        var n3 = { action: cs, level: "log", code: 1011, stats: { event: "bundle load", time: "no-op" === this._bundleLoadTime ? 0 : this._bundleLoadTime, preLoaded: "no-op" === this._bundleLoadTime, url: Z(this.properties.dailyConfig) } };
        this.sendMessageToCallMachine(n3), this._delayDuplicateInstanceLog && this._logDuplicateInstanceAttempt();
        break;
      case ro:
        this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null), this.emitDailyJSEvent(t3);
        break;
      case ao:
        var r5, i4 = Va({}, t3);
        delete i4.internal, this._maxAppMessageSize = (null === (r5 = t3.internal) || void 0 === r5 ? void 0 : r5._maxAppMessageSize) || rs, this._joinedCallback && (this._joinedCallback(t3.participants), this._joinedCallback = null), this.emitDailyJSEvent(i4);
        break;
      case lo:
      case uo:
        if (this._callState === _i)
          return;
        if (t3.participant && t3.participant.session_id) {
          var o4 = t3.participant.local ? "local" : t3.participant.session_id;
          if (this._callObjectMode) {
            var s3 = this._callMachine().store;
            ua(t3.participant, s3), da(t3.participant, s3), ha(t3.participant, this._participants[o4], s3);
          }
          try {
            this.maybeParticipantTracksStopped(this._participants[o4], t3.participant), this.maybeParticipantTracksStarted(this._participants[o4], t3.participant), this.maybeEventRecordingStopped(this._participants[o4], t3.participant), this.maybeEventRecordingStarted(this._participants[o4], t3.participant);
          } catch (e4) {
            console.error("track events error", e4);
          }
          this.compareEqualForParticipantUpdateEvent(t3.participant, this._participants[o4]) || (this._participants[o4] = Va({}, t3.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus(), this.emitDailyJSEvent(t3));
        }
        break;
      case po:
        if (t3.participant && t3.participant.session_id) {
          var a3 = this._participants[t3.participant.session_id];
          a3 && this.maybeParticipantTracksStopped(a3, null), delete this._participants[t3.participant.session_id], this.emitDailyJSEvent(t3);
        }
        break;
      case ho:
        N(this._participantCounts, t3.participantCounts) || (this._participantCounts = t3.participantCounts, this.emitDailyJSEvent(t3));
        break;
      case fo:
        var c4 = { access: t3.access };
        t3.awaitingAccess && (c4.awaitingAccess = t3.awaitingAccess), N(this._accessState, c4) || (this._accessState = c4, this.emitDailyJSEvent(t3));
        break;
      case vo:
        if (t3.meetingSession) {
          this._meetingSessionSummary = t3.meetingSession, this.emitDailyJSEvent(t3);
          var l3 = Va(Va({}, t3), {}, { action: "meeting-session-updated" });
          this.emitDailyJSEvent(l3);
        }
        break;
      case ns:
        var u3;
        this._iframe && !t3.preserveIframe && (this._iframe.src = ""), this._updateCallState(wi), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(t3.errorMsg), this._loadedCallback = null), t3.preserveIframe;
        var d4 = e(t3, Ba);
        null != d4 && null !== (u3 = d4.error) && void 0 !== u3 && u3.details && (d4.error.details = JSON.parse(d4.error.details)), this._maybeSendToSentry(t3), this._joinedCallback && (this._joinedCallback(null, d4), this._joinedCallback = null), this.emitDailyJSEvent(d4);
        break;
      case co:
        this._callState !== wi && this._updateCallState(_i), this.resetMeetingDependentVars(), this._resolveLeave && (this._resolveLeave(), this._resolveLeave = null), this.emitDailyJSEvent(t3);
        break;
      case "selected-devices-updated":
        t3.devices && this.emitDailyJSEvent(t3);
        break;
      case Jo:
        var p3 = t3.state, h5 = t3.threshold, f3 = t3.quality, v5 = p3.state, g4 = p3.reasons;
        v5 === this._network.networkState && N(g4, this._network.networkStateReasons) && h5 === this._network.threshold && f3 === this._network.quality || (this._network.networkState = v5, this._network.networkStateReasons = g4, this._network.quality = f3, this._network.threshold = h5, t3.networkState = v5, g4.length && (t3.networkStateReasons = g4), delete t3.state, this.emitDailyJSEvent(t3));
        break;
      case qo:
        t3 && t3.cpuLoadState && this.emitDailyJSEvent(t3);
        break;
      case zo:
        t3 && void 0 !== t3.faceCounts && this.emitDailyJSEvent(t3);
        break;
      case Uo:
        var m4 = t3.activeSpeaker;
        this._activeSpeaker.peerId !== m4.peerId && (this._activeSpeaker.peerId = m4.peerId, this.emitDailyJSEvent({ action: t3.action, activeSpeaker: this._activeSpeaker }));
        break;
      case "show-local-video-changed":
        if (this._callObjectMode)
          return;
        var y4 = t3.show;
        this._showLocalVideo = y4, this.emitDailyJSEvent({ action: t3.action, show: y4 });
        break;
      case Vo:
        var b4 = t3.enabled;
        this._activeSpeakerMode !== b4 && (this._activeSpeakerMode = b4, this.emitDailyJSEvent({ action: t3.action, enabled: this._activeSpeakerMode }));
        break;
      case yo:
      case bo:
      case _o:
        this._waitingParticipants = t3.allWaitingParticipants, this.emitDailyJSEvent({ action: t3.action, participant: t3.participant });
        break;
      case Zo:
        N(this._receiveSettings, t3.receiveSettings) || (this._receiveSettings = t3.receiveSettings, this.emitDailyJSEvent({ action: t3.action, receiveSettings: t3.receiveSettings }));
        break;
      case es:
        this._maybeUpdateInputSettings(t3.inputSettings);
        break;
      case "send-settings-updated":
        N(this._sendSettings, t3.sendSettings) || (this._sendSettings = t3.sendSettings, this._preloadCache.sendSettings = null, this.emitDailyJSEvent({ action: t3.action, sendSettings: t3.sendSettings }));
        break;
      case "local-audio-level":
        this._localAudioLevel = t3.audioLevel, this._preloadCache.localAudioLevelObserver = null, this.emitDailyJSEvent(t3);
        break;
      case "remote-participants-audio-level":
        this._remoteParticipantsAudioLevel = t3.participantsAudioLevel, this._preloadCache.remoteParticipantsAudioLevelObserver = null, this.emitDailyJSEvent(t3);
        break;
      case Lo:
        var _5 = t3.session_id;
        this._rmpPlayerState[_5] = t3.playerState, this.emitDailyJSEvent(t3);
        break;
      case No:
        delete this._rmpPlayerState[t3.session_id], this.emitDailyJSEvent(t3);
        break;
      case Do:
        var w4 = t3.session_id, S4 = this._rmpPlayerState[w4];
        S4 && this.compareEqualForRMPUpdateEvent(S4, t3.remoteMediaPlayerState) || (this._rmpPlayerState[w4] = t3.remoteMediaPlayerState, this.emitDailyJSEvent(t3));
        break;
      case "custom-button-click":
      case "sidebar-view-changed":
        this.emitDailyJSEvent(t3);
        break;
      case go:
        var k4 = this._meetingSessionState.topology !== (t3.meetingSessionState && t3.meetingSessionState.topology);
        this._meetingSessionState = jc(t3.meetingSessionState, this._callObjectMode), (this._callObjectMode || k4) && this.emitDailyJSEvent(t3);
        break;
      case Ro:
        this._isScreenSharing = true, this.emitDailyJSEvent(t3);
        break;
      case Fo:
      case Bo:
        this._isScreenSharing = false, this.emitDailyJSEvent(t3);
        break;
      case Eo:
      case To:
      case Oo:
      case Po:
      case Ao:
      case ko:
      case Mo:
      case Co:
      case io:
      case oo:
      case Io:
      case xo:
      case "test-completed":
      case $o:
      case jo:
      case Go:
      case Qo:
      case Ko:
      case Yo:
      case ts:
      case Xo:
      case "dialin-ready":
      case "dialin-connected":
      case "dialin-error":
      case "dialin-stopped":
      case "dialin-warning":
      case "dialout-connected":
      case "dialout-answered":
      case "dialout-error":
      case "dialout-stopped":
      case "dialout-warning":
        this.emitDailyJSEvent(t3);
        break;
      case "request-fullscreen":
        this.requestFullscreen();
        break;
      case "request-exit-fullscreen":
        this.exitFullscreen();
    }
  } }, { key: "maybeEventRecordingStopped", value: function(e4, t3) {
    var n3 = "record";
    e4 && (t3.local || false !== t3[n3] || e4[n3] === t3[n3] || this.emitDailyJSEvent({ action: To }));
  } }, { key: "maybeEventRecordingStarted", value: function(e4, t3) {
    var n3 = "record";
    e4 && (t3.local || true !== t3[n3] || e4[n3] === t3[n3] || this.emitDailyJSEvent({ action: Eo }));
  } }, { key: "_trackStatePlayable", value: function(e4) {
    return !(!e4 || e4.state !== Ti);
  } }, { key: "_trackChanged", value: function(e4, t3) {
    return !((null == e4 ? void 0 : e4.id) === (null == t3 ? void 0 : t3.id));
  } }, { key: "maybeEventTrackStopped", value: function(e4, t3, n3) {
    var r5, i4, o4 = null !== (r5 = null == t3 ? void 0 : t3.tracks[e4]) && void 0 !== r5 ? r5 : null, s3 = null !== (i4 = null == n3 ? void 0 : n3.tracks[e4]) && void 0 !== i4 ? i4 : null, a3 = null == o4 ? void 0 : o4.track;
    if (a3) {
      var c4 = this._trackStatePlayable(o4), l3 = this._trackStatePlayable(s3), u3 = this._trackChanged(a3, null == s3 ? void 0 : s3.track);
      c4 && (l3 && !u3 || this.emitDailyJSEvent({ action: So, track: a3, participant: null != n3 ? n3 : t3, type: e4 }));
    }
  } }, { key: "maybeEventTrackStarted", value: function(e4, t3, n3) {
    var r5, i4, o4 = null !== (r5 = null == t3 ? void 0 : t3.tracks[e4]) && void 0 !== r5 ? r5 : null, s3 = null !== (i4 = null == n3 ? void 0 : n3.tracks[e4]) && void 0 !== i4 ? i4 : null, a3 = null == s3 ? void 0 : s3.track;
    if (a3) {
      var c4 = this._trackStatePlayable(o4), l3 = this._trackStatePlayable(s3), u3 = this._trackChanged(null == o4 ? void 0 : o4.track, a3);
      l3 && (c4 && !u3 || this.emitDailyJSEvent({ action: wo, track: a3, participant: n3, type: e4 }));
    }
  } }, { key: "maybeParticipantTracksStopped", value: function(e4, t3) {
    if (e4)
      for (var n3 in e4.tracks)
        this.maybeEventTrackStopped(n3, e4, t3);
  } }, { key: "maybeParticipantTracksStarted", value: function(e4, t3) {
    if (t3)
      for (var n3 in t3.tracks)
        this.maybeEventTrackStarted(n3, e4, t3);
  } }, { key: "compareEqualForRMPUpdateEvent", value: function(e4, t3) {
    var n3, r5;
    return e4.state === t3.state && (null === (n3 = e4.settings) || void 0 === n3 ? void 0 : n3.volume) === (null === (r5 = t3.settings) || void 0 === r5 ? void 0 : r5.volume);
  } }, { key: "emitDailyJSEvent", value: function(e4) {
    try {
      e4.callClientId = this.callClientId, this.emit(e4.action, e4);
    } catch (t3) {
      console.log("could not emit", e4, t3);
    }
  } }, { key: "compareEqualForParticipantUpdateEvent", value: function(e4, t3) {
    return !!N(e4, t3) && ((!e4.videoTrack || !t3.videoTrack || e4.videoTrack.id === t3.videoTrack.id && e4.videoTrack.muted === t3.videoTrack.muted && e4.videoTrack.enabled === t3.videoTrack.enabled) && (!e4.audioTrack || !t3.audioTrack || e4.audioTrack.id === t3.audioTrack.id && e4.audioTrack.muted === t3.audioTrack.muted && e4.audioTrack.enabled === t3.audioTrack.enabled));
  } }, { key: "nativeUtils", value: function() {
    return ys() ? "undefined" == typeof DailyNativeUtils ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
  } }, { key: "updateIsPreparingToJoin", value: function(e4) {
    this._updateCallState(this._callState, e4);
  } }, { key: "_updateCallState", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._isPreparingToJoin;
    if (e4 !== this._callState || t3 !== this._isPreparingToJoin) {
      var n3 = this._callState, r5 = this._isPreparingToJoin;
      this._callState = e4, this._isPreparingToJoin = t3;
      var i4 = this._callState === bi;
      this.updateShowAndroidOngoingMeetingNotification(i4);
      var o4 = ac(n3, r5), s3 = ac(this._callState, this._isPreparingToJoin);
      o4 !== s3 && (this.updateKeepDeviceAwake(s3), this.updateDeviceAudioMode(s3), this.updateNoOpRecordingEnsuringBackgroundContinuity(s3));
    }
  } }, { key: "resetMeetingDependentVars", value: function() {
    this._participants = {}, this._participantCounts = Qa, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = false, this._didPreAuth = false, this._accessState = { access: Oi }, this._finalSummaryOfPrevSession = this._meetingSessionSummary, this._meetingSessionSummary = {}, this._meetingSessionState = jc(Ga, this._callObjectMode), this._isScreenSharing = false, this._receiveSettings = {}, this._inputSettings = void 0, this._sendSettings = {}, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this._maxAppMessageSize = rs, this._callMachineInitialized = false, this._bundleLoadTime = void 0, this._preloadCache;
  } }, { key: "updateKeepDeviceAwake", value: function(e4) {
    ys() && this.nativeUtils().setKeepDeviceAwake(e4, this.callClientId);
  } }, { key: "updateDeviceAudioMode", value: function(e4) {
    if (ys() && !this.disableReactNativeAutoDeviceManagement("audio")) {
      var t3 = e4 ? this._nativeInCallAudioMode : "idle";
      this.nativeUtils().setAudioMode(t3);
    }
  } }, { key: "updateShowAndroidOngoingMeetingNotification", value: function(e4) {
    if (ys() && this.nativeUtils().setShowOngoingMeetingNotification) {
      var t3, n3, r5, i4;
      if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
        var o4 = this.properties.reactNativeConfig.androidInCallNotification;
        t3 = o4.title, n3 = o4.subtitle, r5 = o4.iconName, i4 = o4.disableForCustomOverride;
      }
      i4 && (e4 = false), this.nativeUtils().setShowOngoingMeetingNotification(e4, t3, n3, r5, this.callClientId);
    }
  } }, { key: "updateNoOpRecordingEnsuringBackgroundContinuity", value: function(e4) {
    ys() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e4);
  } }, { key: "toggleParticipantAudioBasedOnNativeAudioFocus", value: function() {
    var e4;
    if (ys()) {
      var t3 = null === (e4 = this._callMachine()) || void 0 === e4 || null === (e4 = e4.store) || void 0 === e4 ? void 0 : e4.getState();
      for (var n3 in null == t3 ? void 0 : t3.streams) {
        var r5 = t3.streams[n3];
        r5 && r5.pendingTrack && "audio" === r5.pendingTrack.kind && (r5.pendingTrack.enabled = this._hasNativeAudioFocus);
      }
    }
  } }, { key: "disableReactNativeAutoDeviceManagement", value: function(e4) {
    return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e4];
  } }, { key: "absoluteUrl", value: function(e4) {
    if (void 0 !== e4) {
      var t3 = document.createElement("a");
      return t3.href = e4, t3.href;
    }
  } }, { key: "sayHello", value: function() {
    var e4 = "hello, world.";
    return console.log(e4), e4;
  } }, { key: "_logUseAfterDestroy", value: function() {
    var e4 = Object.values(za)[0];
    if (this.needsLoad()) {
      if (e4 && !e4.needsLoad()) {
        var t3 = { action: cs, level: "error", code: this.strictMode ? 9995 : 9997 };
        e4.sendMessageToCallMachine(t3);
      } else if (!this.strictMode) {
        console.error("You are are attempting to use a call instance that was previously destroyed, which is unsupported. Please remove `strictMode: false` from your constructor properties to enable strict mode to track down and fix this unsupported usage.");
      }
    } else {
      var n3 = { action: cs, level: "error", code: this.strictMode ? 9995 : 9997 };
      this._messageChannel.sendMessageToCallMachine(n3, null, this.callClientId, this._iframe);
    }
  } }, { key: "_logDuplicateInstanceAttempt", value: function() {
    for (var e4 = 0, t3 = Object.values(za); e4 < t3.length; e4++) {
      var n3 = t3[e4];
      n3._callMachineInitialized ? (n3.sendMessageToCallMachine({ action: cs, level: "warn", code: this.allowMultipleCallInstances ? 9993 : 9992 }), n3._delayDuplicateInstanceLog = false) : n3._delayDuplicateInstanceLog = true;
    }
  } }, { key: "_maybeSendToSentry", value: function(e4) {
    var t3, n3, i4, o4;
    if (null !== (t3 = e4.error) && void 0 !== t3 && t3.type) {
      if (![$i, Vi, Bi].includes(e4.error.type))
        return;
      if (e4.error.type === Bi && e4.error.msg.includes("deleted"))
        return;
    }
    var s3 = null !== (n3 = this.properties) && void 0 !== n3 && n3.url ? new URL(this.properties.url) : void 0, a3 = "production";
    s3 && s3.host.includes(".staging.daily") && (a3 = "staging");
    var c4, l3, u3, d4, p3, h5 = function(e5) {
      const t4 = [Gn(), Wn(), ii(), ni(), ui(), fi(), rr(), hi()];
      return false !== e5.autoSessionTracking && t4.push(li()), t4;
    }({}).filter(function(e5) {
      return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(e5.name);
    }), f3 = new jr({ dsn: "https://f10f1c81e5d44a4098416c0867a8b740@o77906.ingest.sentry.io/168844", transport: Wr, stackParser: Zr, integrations: h5, environment: a3 }), v5 = new Mt();
    if (v5.setClient(f3), f3.init(), this.session_id && v5.setExtra("sessionId", this.session_id), this.properties) {
      var g4 = Va({}, this.properties);
      g4.userName = g4.userName ? "[Filtered]" : void 0, g4.userData = g4.userData ? "[Filtered]" : void 0, g4.token = g4.token ? "[Filtered]" : void 0, v5.setExtra("properties", g4);
    }
    if (s3) {
      var m4 = s3.searchParams.get("domain");
      if (!m4) {
        var y4 = s3.host.match(/(.*?)\./);
        m4 = y4 && y4[1] || "";
      }
      m4 && v5.setTag("domain", m4);
    }
    e4.error && (v5.setTag("fatalErrorType", e4.error.type), v5.setExtra("errorDetails", e4.error.details), (null === (c4 = e4.error.details) || void 0 === c4 ? void 0 : c4.uri) && v5.setTag("serverAddress", e4.error.details.uri), (null === (l3 = e4.error.details) || void 0 === l3 ? void 0 : l3.workerGroup) && v5.setTag("workerGroup", e4.error.details.workerGroup), (null === (u3 = e4.error.details) || void 0 === u3 ? void 0 : u3.geoGroup) && v5.setTag("geoGroup", e4.error.details.geoGroup), (null === (d4 = e4.error.details) || void 0 === d4 ? void 0 : d4.on) && v5.setTag("connectionAttempt", e4.error.details.on), null !== (p3 = e4.error.details) && void 0 !== p3 && p3.bundleUrl && (v5.setTag("bundleUrl", e4.error.details.bundleUrl), v5.setTag("bundleError", e4.error.details.sourceError.type)));
    v5.setTags({ callMode: this._callObjectMode ? ys() ? "reactNative" : null !== (i4 = this.properties) && void 0 !== i4 && null !== (i4 = i4.dailyConfig) && void 0 !== i4 && null !== (i4 = i4.callMode) && void 0 !== i4 && i4.includes("prebuilt") ? this.properties.dailyConfig.callMode : "custom" : "prebuilt-frame", version: r4.version() });
    var b4 = (null === (o4 = e4.error) || void 0 === o4 ? void 0 : o4.msg) || e4.errorMsg;
    v5.captureException(new Error(b4));
  } }, { key: "_callMachine", value: function() {
    var e4;
    return null === (e4 = window._daily) || void 0 === e4 || null === (e4 = e4.instances) || void 0 === e4 || null === (e4 = e4[this.callClientId]) || void 0 === e4 ? void 0 : e4.callMachine;
  } }, { key: "_maybeUpdateInputSettings", value: function(e4) {
    if (!N(this._inputSettings, e4)) {
      var t3 = this._getInputSettings();
      this._inputSettings = e4;
      var n3 = this._getInputSettings();
      N(t3, n3) || this.emitDailyJSEvent({ action: es, inputSettings: n3 });
    }
  } }], [{ key: "supportedBrowser", value: function() {
    if (ys())
      return { supported: true, mobile: true, name: "React Native", version: null, supportsScreenShare: true, supportsSfu: true, supportsVideoProcessing: false, supportsAudioProcessing: false };
    var e4 = Q.getParser(ms());
    return { supported: !!Cs(), mobile: "mobile" === e4.getPlatformType(), name: e4.getBrowserName(), version: e4.getBrowserVersion(), supportsFullscreen: !!ws(), supportsScreenShare: !!_s(), supportsSfu: !!Cs(), supportsVideoProcessing: ks(), supportsAudioProcessing: Ms() };
  } }, { key: "version", value: function() {
    return "0.77.0";
  } }, { key: "createCallObject", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return e4.layout = "none", new r4(null, e4);
  } }, { key: "wrap", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (hc(), !e4 || !e4.contentWindow || "string" != typeof e4.src)
      throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
    return t3.layout || (t3.customLayout ? t3.layout = "custom-v1" : t3.layout = "browser"), new r4(e4, t3);
  } }, { key: "createFrame", value: function(e4, t3) {
    var n3, i4;
    hc(), e4 && t3 ? (n3 = e4, i4 = t3) : e4 && e4.append ? (n3 = e4, i4 = {}) : (n3 = document.body, i4 = e4 || {});
    var o4 = i4.iframeStyle;
    o4 || (o4 = n3 === document.body ? { position: "fixed", border: "1px solid black", backgroundColor: "white", width: "375px", height: "450px", right: "1em", bottom: "1em" } : { border: 0, width: "100%", height: "100%" });
    var s3 = document.createElement("iframe");
    window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? s3.allow = "microphone, camera" : s3.allow = "microphone; camera; autoplay; display-capture; screen-wake-lock", s3.style.visibility = "hidden", n3.appendChild(s3), s3.style.visibility = null, Object.keys(o4).forEach(function(e5) {
      return s3.style[e5] = o4[e5];
    }), i4.layout || (i4.customLayout ? i4.layout = "custom-v1" : i4.layout = "browser");
    try {
      return new r4(s3, i4);
    } catch (e5) {
      throw n3.removeChild(s3), e5;
    }
  } }, { key: "createTransparentFrame", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    hc();
    var t3 = document.createElement("iframe");
    return t3.allow = "microphone; camera; autoplay", t3.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t3), e4.layout || (e4.layout = "custom-v1"), r4.wrap(t3, e4);
  } }, { key: "getCallInstance", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    return e4 ? za[e4] : Object.values(za)[0];
  } }]);
  var i3, c3, d3, h4, v3, g3, m3, y3, b3, _4, w3, S3, k3, M3, C3, E3, T3, O3, P3, A3, j3, I3, L3, D3, R3, F3, B3, U3, V3, J3, $3, q3, z3, W3, H3, G3, Y3, ee3;
}();
function oc(e4, t3) {
  var n3 = {};
  for (var r4 in e4)
    if (e4[r4] instanceof MediaStreamTrack)
      console.warn("MediaStreamTrack found in props or cache.", r4), n3[r4] = ls;
    else if ("dailyConfig" === r4) {
      if (e4[r4].modifyLocalSdpHook) {
        var i3 = window._daily.instances[t3].customCallbacks || {};
        i3.modifyLocalSdpHook = e4[r4].modifyLocalSdpHook, window._daily.instances[t3].customCallbacks = i3, delete e4[r4].modifyLocalSdpHook;
      }
      if (e4[r4].modifyRemoteSdpHook) {
        var o4 = window._daily.instances[t3].customCallbacks || {};
        o4.modifyRemoteSdpHook = e4[r4].modifyRemoteSdpHook, window._daily.instances[t3].customCallbacks = o4, delete e4[r4].modifyRemoteSdpHook;
      }
      n3[r4] = e4[r4];
    } else
      n3[r4] = e4[r4];
  return n3;
}
function sc(e4) {
  var t3 = arguments.length > 2 ? arguments[2] : void 0;
  if (e4 !== bi) {
    var n3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " only supported after join.");
    throw t3 && (n3 += " ".concat(t3)), console.error(n3), new Error(n3);
  }
}
function ac(e4, t3) {
  return [yi, bi].includes(e4) || t3;
}
function cc(e4, t3) {
  var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "This daily-js method", r4 = arguments.length > 3 ? arguments[3] : void 0;
  if (ac(e4, t3)) {
    var i3 = "".concat(n3, " not supported after joining a meeting.");
    throw r4 && (i3 += " ".concat(r4)), console.error(i3), new Error(i3);
  }
}
function lc(e4) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", n3 = arguments.length > 2 ? arguments[2] : void 0;
  if (!e4) {
    var r4 = "".concat(t3, arguments.length > 3 && void 0 !== arguments[3] && arguments[3] ? " requires preAuth() or startCamera() to initialize call state." : " requires preAuth(), startCamera(), or join() to initialize call state.");
    throw n3 && (r4 += " ".concat(n3)), console.error(r4), new Error(r4);
  }
}
function uc(e4) {
  if (e4) {
    var t3 = "A pre-call quality test is in progress. Please try ".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " again once testing has completed. Use stopTestCallQuality() to end it early.");
    throw console.error(t3), new Error(t3);
  }
}
function dc(e4) {
  if (!e4) {
    var t3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported on custom callObject instances");
    throw console.error(t3), new Error(t3);
  }
}
function pc(e4) {
  if (e4) {
    var t3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported as part of Daily's Prebuilt");
    throw console.error(t3), new Error(t3);
  }
}
function hc() {
  if (ys())
    throw new Error("This daily-js method is not currently supported in React Native");
}
function fc() {
  if (!ys())
    throw new Error("This daily-js method is only supported in React Native");
}
function vc(e4) {
  if (void 0 === e4)
    return true;
  var t3;
  if ("string" == typeof e4)
    t3 = e4;
  else
    try {
      t3 = JSON.stringify(e4), N(JSON.parse(t3), e4) || console.warn("The userData provided will be modified when serialized.");
    } catch (e5) {
      throw Error("userData must be serializable to JSON: ".concat(e5));
    }
  if (t3.length > 4096)
    throw Error("userData is too large (".concat(t3.length, " characters). Maximum size suppported is ").concat(4096, "."));
  return true;
}
function gc(e4, t3) {
  for (var n3 = t3.allowAllParticipantsKey, r4 = function(e5) {
    var t4 = ["local"];
    return n3 || t4.push("*"), e5 && !t4.includes(e5);
  }, i3 = function(e5) {
    return !!(void 0 === e5.layer || Number.isInteger(e5.layer) && e5.layer >= 0 || "inherit" === e5.layer);
  }, o4 = function(e5) {
    return !!e5 && (!(e5.video && !i3(e5.video)) && !(e5.screenVideo && !i3(e5.screenVideo)));
  }, s3 = 0, a3 = Object.entries(e4); s3 < a3.length; s3++) {
    var c3 = f(a3[s3], 2), l3 = c3[0], u3 = c3[1];
    if (!r4(l3) || !o4(u3))
      return false;
  }
  return true;
}
function mc(e4) {
  if ("object" !== n(e4))
    return false;
  for (var t3 = 0, r4 = Object.entries(e4); t3 < r4.length; t3++) {
    var i3 = f(r4[t3], 2), o4 = i3[0], s3 = i3[1];
    switch (o4) {
      case "video":
        if ("object" !== n(s3))
          return false;
        for (var a3 = 0, c3 = Object.entries(s3); a3 < c3.length; a3++) {
          var l3 = f(c3[a3], 2), u3 = l3[0], d3 = l3[1];
          switch (u3) {
            case "processor":
              if (!_c(d3))
                return false;
              break;
            case "settings":
              if (!wc(d3))
                return false;
              break;
            default:
              return false;
          }
        }
        break;
      case "audio":
        if ("object" !== n(s3))
          return false;
        for (var p3 = 0, h4 = Object.entries(s3); p3 < h4.length; p3++) {
          var v3 = f(h4[p3], 2), g3 = v3[0], m3 = v3[1];
          switch (g3) {
            case "processor":
              if (!bc(m3))
                return false;
              break;
            case "settings":
              if (!wc(m3))
                return false;
              break;
            default:
              return false;
          }
        }
        break;
      default:
        return false;
    }
  }
  return true;
}
function yc(e4, t3, n3) {
  var r4, i3 = [];
  e4.video && e4.video.processor && (ks(null !== (r4 = null == t3 ? void 0 : t3.useLegacyVideoProcessor) && void 0 !== r4 && r4) || (e4.video.settings ? delete e4.video.processor : delete e4.video, i3.push("video")));
  e4.audio && e4.audio.processor && (Ms() || (e4.audio.settings ? delete e4.audio.processor : delete e4.audio, i3.push("audio"))), i3.length > 0 && console.error("Ignoring settings for browser- or platform-unsupported input processor(s): ".concat(i3.join(", "))), e4.audio && e4.audio.settings && (e4.audio.settings.customTrack ? (n3.audioTrack = e4.audio.settings.customTrack, e4.audio.settings = { customTrack: ls }) : delete n3.audioTrack), e4.video && e4.video.settings && (e4.video.settings.customTrack ? (n3.videoTrack = e4.video.settings.customTrack, e4.video.settings = { customTrack: ls }) : delete n3.videoTrack);
}
function bc(e4) {
  if (ys())
    return console.warn("Video processing is not yet supported in React Native"), false;
  var t3 = ["type"];
  return !!e4 && ("object" === n(e4) && (Object.keys(e4).filter(function(e5) {
    return !t3.includes(e5);
  }).forEach(function(t4) {
    console.warn("invalid key inputSettings -> audio -> processor : ".concat(t4)), delete e4[t4];
  }), !!function(e5) {
    if ("string" != typeof e5)
      return false;
    if (!Object.values(ds).includes(e5))
      return console.error("inputSettings audio processor type invalid"), false;
    return true;
  }(e4.type)));
}
function _c(e4) {
  if (ys())
    return console.warn("Video processing is not yet supported in React Native"), false;
  var t3 = ["type", "config"];
  if (!e4)
    return false;
  if ("object" !== n(e4))
    return false;
  if (!function(e5) {
    if ("string" != typeof e5)
      return false;
    if (!Object.values(us).includes(e5))
      return console.error("inputSettings video processor type invalid"), false;
    return true;
  }(e4.type))
    return false;
  if (e4.config) {
    if ("object" !== n(e4.config))
      return false;
    if (!function(e5, t4) {
      var n3 = Object.keys(t4);
      if (0 === n3.length)
        return true;
      var r4 = "invalid object in inputSettings -> video -> processor -> config";
      switch (e5) {
        case us.BGBLUR:
          return n3.length > 1 || "strength" !== n3[0] ? (console.error(r4), false) : !("number" != typeof t4.strength || t4.strength <= 0 || t4.strength > 1 || isNaN(t4.strength)) || (console.error("".concat(r4, "; expected: {0 < strength <= 1}, got: ").concat(t4.strength)), false);
        case us.BGIMAGE:
          return !(void 0 !== t4.source && !function(e6) {
            if ("default" === e6.source)
              return e6.type = "default", true;
            if (e6.source instanceof ArrayBuffer)
              return true;
            if (ee(e6.source))
              return e6.type = "url", !!function(e7) {
                var t6 = new URL(e7), n5 = t6.pathname;
                if ("data:" === t6.protocol)
                  try {
                    var r5 = n5.substring(n5.indexOf(":") + 1, n5.indexOf(";")).split("/")[1];
                    return hs.includes(r5);
                  } catch (e8) {
                    return console.error("failed to deduce blob content type", e8), false;
                  }
                var i3 = n5.split(".").at(-1).toLowerCase().trim();
                return hs.includes(i3);
              }(e6.source) || (console.error("invalid image type; supported types: [".concat(hs.join(", "), "]")), false);
            return t5 = e6.source, n4 = Number(t5), isNaN(n4) || !Number.isInteger(n4) || n4 <= 0 || n4 > 10 ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(10)), false) : (e6.type = "daily-preselect", true);
            var t5, n4;
          }(t4));
        default:
          return true;
      }
    }(e4.type, e4.config))
      return false;
  }
  return Object.keys(e4).filter(function(e5) {
    return !t3.includes(e5);
  }).forEach(function(t4) {
    console.warn("invalid key inputSettings -> video -> processor : ".concat(t4)), delete e4[t4];
  }), true;
}
function wc(e4) {
  return "object" === n(e4) && (!e4.customTrack || e4.customTrack instanceof MediaStreamTrack);
}
function Sc() {
  var e4 = Object.values(us).join(" | "), t3 = Object.values(ds).join(" | ");
  return "inputSettings must be of the form: { video?: { processor?: { type: [ ".concat(e4, " ], config?: {} } }, audio?: { processor: {type: [ ").concat(t3, " ] } } }");
}
function kc(e4) {
  var t3 = e4.allowAllParticipantsKey;
  return "receiveSettings must be of the form { [<remote participant id> | ".concat(Ii).concat(t3 ? ' | "'.concat("*", '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
}
function Mc() {
  return "customIntegrations should be an object of type ".concat(JSON.stringify(tc), ".");
}
function Cc(e4) {
  if (e4 && "object" !== n(e4) || Array.isArray(e4))
    return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify(ec), ".")), false;
  if (e4)
    for (var t3 = 0, r4 = Object.entries(e4); t3 < r4.length; t3++)
      for (var i3 = f(r4[t3], 1)[0], o4 = 0, s3 = Object.entries(e4[i3]); o4 < s3.length; o4++) {
        var a3 = f(s3[o4], 2), c3 = a3[0], l3 = a3[1], u3 = ec.id[c3];
        if (!u3)
          return console.error("customTrayButton does not support key ".concat(c3)), false;
        switch (c3) {
          case "iconPath":
          case "iconPathDarkMode":
            if (!ee(l3))
              return console.error("customTrayButton ".concat(c3, " should be a url.")), false;
            break;
          case "visualState":
            if (!["default", "sidebar-open", "active"].includes(l3))
              return console.error("customTrayButton ".concat(c3, " should be ").concat(u3, ". Got: ").concat(l3)), false;
            break;
          default:
            if (n(l3) !== u3)
              return console.error("customTrayButton ".concat(c3, " should be a ").concat(u3, ".")), false;
        }
      }
  return true;
}
function Ec(e4) {
  if (!e4 || e4 && "object" !== n(e4) || Array.isArray(e4))
    return console.error(Mc()), false;
  for (var t3 = function(e5) {
    return "".concat(e5, " should be ").concat(tc.id[e5]);
  }, r4 = function(e5, t4) {
    return console.error("customIntegration ".concat(e5, ": ").concat(t4));
  }, i3 = 0, o4 = Object.entries(e4); i3 < o4.length; i3++) {
    var s3 = f(o4[i3], 1)[0];
    if (!("label" in e4[s3]))
      return r4(s3, "label is required"), false;
    if (!("location" in e4[s3]))
      return r4(s3, "location is required"), false;
    if (!("src" in e4[s3]) && !("srcdoc" in e4[s3]))
      return r4(s3, "src or srcdoc is required"), false;
    for (var a3 = 0, c3 = Object.entries(e4[s3]); a3 < c3.length; a3++) {
      var l3 = f(c3[a3], 2), u3 = l3[0], d3 = l3[1];
      switch (u3) {
        case "allow":
        case "csp":
        case "name":
        case "referrerPolicy":
        case "sandbox":
          if ("string" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        case "iconURL":
          if (!ee(d3))
            return r4(s3, "".concat(u3, " should be a url")), false;
          break;
        case "src":
          if ("srcdoc" in e4[s3])
            return r4(s3, "cannot have both src and srcdoc"), false;
          if (!ee(d3))
            return r4(s3, 'src "'.concat(d3, '" is not a valid URL')), false;
          break;
        case "srcdoc":
          if ("src" in e4[s3])
            return r4(s3, "cannot have both src and srcdoc"), false;
          if ("string" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        case "location":
          if (!["main", "sidebar"].includes(d3))
            return r4(s3, t3(u3)), false;
          break;
        case "controlledBy":
          if ("*" !== d3 && "owners" !== d3 && (!Array.isArray(d3) || d3.some(function(e5) {
            return "string" != typeof e5;
          })))
            return r4(s3, t3(u3)), false;
          break;
        case "shared":
          if ((!Array.isArray(d3) || d3.some(function(e5) {
            return "string" != typeof e5;
          })) && "owners" !== d3 && "boolean" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        default:
          if (!tc.id[u3])
            return console.error("customIntegration does not support key ".concat(u3)), false;
      }
    }
  }
  return true;
}
function Tc(e4, t3) {
  if (void 0 === t3)
    return false;
  switch (n(t3)) {
    case "string":
      return n(e4) === t3;
    case "object":
      if ("object" !== n(e4))
        return false;
      for (var r4 in e4)
        if (!Tc(e4[r4], t3[r4]))
          return false;
      return true;
    default:
      return false;
  }
}
function Oc(e4, t3) {
  var n3 = e4.sessionId, r4 = e4.toEndPoint, i3 = e4.callerId, o4 = e4.useSipRefer;
  if (!n3 || !r4)
    throw new Error("".concat(t3, "() requires a sessionId and toEndPoint"));
  if ("string" != typeof n3 || "string" != typeof r4)
    throw new Error("Invalid paramater: sessionId and toEndPoint must be of type string");
  if (o4 && !r4.startsWith("sip:"))
    throw new Error('"toEndPoint" must be a "sip" address');
  if (!r4.startsWith("sip:") && !r4.startsWith("+"))
    throw new Error("toEndPoint: ".concat(r4, ' must starts with either "sip:" or "+"'));
  if (i3 && "string" != typeof i3)
    throw new Error("callerId must be of type string");
  if (i3 && !r4.startsWith("+"))
    throw new Error("callerId is only valid when transferring to a PSTN number");
}
function Pc(e4) {
  if ("object" !== n(e4))
    throw new Error('RemoteMediaPlayerSettings: must be "object" type');
  if (e4.state && !Object.values(ps).includes(e4.state))
    throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(ps));
  if (e4.volume) {
    if ("number" != typeof e4.volume)
      throw new Error('RemoteMediaPlayerSettings.volume: must be "number" type');
    if (e4.volume < 0 || e4.volume > 2)
      throw new Error("RemoteMediaPlayerSettings.volume: must be between 0.0 - 2.0");
  }
}
function Ac(e4, t3, n3) {
  return !("number" != typeof e4 || e4 < t3 || e4 > n3);
}
function jc(e4, t3) {
  return e4 && !t3 && delete e4.data, e4;
}

// ../node_modules/@pipecat-ai/daily-transport/dist/index.module.js
function $parcel$interopDefault2(a3) {
  return a3 && a3.__esModule ? a3.default : a3;
}
function $parcel$export2(e4, n3, v3, s3) {
  Object.defineProperty(e4, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $683f111f61e07358$exports = {};
$parcel$export2($683f111f61e07358$exports, "DailyRTVIMessageType", () => $683f111f61e07358$export$ef180de88fd317cc);
$parcel$export2($683f111f61e07358$exports, "DailyTransport", () => $683f111f61e07358$export$b1ca982aa1e488c1);
var $6d4b7449a1e1544a$export$13afda237b1c9846 = class {
  /**
  * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format
  * @param {Float32Array} float32Array
  * @returns {ArrayBuffer}
  */
  static floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i3 = 0; i3 < float32Array.length; i3++, offset += 2) {
      let s3 = Math.max(-1, Math.min(1, float32Array[i3]));
      view.setInt16(offset, s3 < 0 ? s3 * 32768 : s3 * 32767, true);
    }
    return buffer;
  }
  /**
  * Concatenates two ArrayBuffers
  * @param {ArrayBuffer} leftBuffer
  * @param {ArrayBuffer} rightBuffer
  * @returns {ArrayBuffer}
  */
  static mergeBuffers(leftBuffer, rightBuffer) {
    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
    tmpArray.set(new Uint8Array(leftBuffer), 0);
    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
    return tmpArray.buffer;
  }
  /**
  * Packs data into an Int16 format
  * @private
  * @param {number} size 0 = 1x Int16, 1 = 2x Int16
  * @param {number} arg value to pack
  * @returns
  */
  _packData(size, arg) {
    return [
      new Uint8Array([
        arg,
        arg >> 8
      ]),
      new Uint8Array([
        arg,
        arg >> 8,
        arg >> 16,
        arg >> 24
      ])
    ][size];
  }
  /**
  * Packs audio into "audio/wav" Blob
  * @param {number} sampleRate
  * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio
  * @returns {WavPackerAudioType}
  */
  pack(sampleRate, audio) {
    if (!audio?.bitsPerSample)
      throw new Error(`Missing "bitsPerSample"`);
    else if (!audio?.channels)
      throw new Error(`Missing "channels"`);
    else if (!audio?.data)
      throw new Error(`Missing "data"`);
    const { bitsPerSample, channels, data } = audio;
    const output = [
      // Header
      "RIFF",
      this._packData(1, 52),
      "WAVE",
      // chunk 1
      "fmt ",
      this._packData(1, 16),
      this._packData(0, 1),
      this._packData(0, channels.length),
      this._packData(1, sampleRate),
      this._packData(1, sampleRate * channels.length * bitsPerSample / 8),
      this._packData(0, channels.length * bitsPerSample / 8),
      this._packData(0, bitsPerSample),
      // chunk 2
      "data",
      this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),
      data
    ];
    const blob = new Blob(output, {
      type: "audio/mpeg"
    });
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      channelCount: channels.length,
      sampleRate,
      duration: data.byteLength / (channels.length * sampleRate * 2)
    };
  }
};
globalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c9846;
var $03f71ce85e00ada6$var$octave8Frequencies = [
  4186.01,
  4434.92,
  4698.63,
  4978.03,
  5274.04,
  5587.65,
  5919.91,
  6271.93,
  6644.88,
  7040,
  7458.62,
  7902.13
];
var $03f71ce85e00ada6$var$octave8FrequencyLabels = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
var $03f71ce85e00ada6$export$776c63898ae5b636 = [];
var $03f71ce85e00ada6$export$facd167cc27ea9b0 = [];
for (let i3 = 1; i3 <= 8; i3++)
  for (let f3 = 0; f3 < $03f71ce85e00ada6$var$octave8Frequencies.length; f3++) {
    const freq = $03f71ce85e00ada6$var$octave8Frequencies[f3];
    $03f71ce85e00ada6$export$776c63898ae5b636.push(freq / Math.pow(2, 8 - i3));
    $03f71ce85e00ada6$export$facd167cc27ea9b0.push($03f71ce85e00ada6$var$octave8FrequencyLabels[f3] + i3);
  }
var $03f71ce85e00ada6$var$voiceFrequencyRange = [
  32,
  2e3
];
var $03f71ce85e00ada6$export$dbc1581ed2cfa183 = $03f71ce85e00ada6$export$776c63898ae5b636.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b636[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];
});
var $03f71ce85e00ada6$export$30a6f2881311088f = $03f71ce85e00ada6$export$facd167cc27ea9b0.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b636[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange[0] && $03f71ce85e00ada6$export$776c63898ae5b636[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange[1];
});
var $f32f064564ee62f6$export$2c3136da0bf130f9 = class _$f32f064564ee62f6$export$2c3136da0bf130f9 {
  /**
  * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range
  * returns human-readable formatting and labels
  * @param {AnalyserNode} analyser
  * @param {number} sampleRate
  * @param {Float32Array} [fftResult]
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  static getFrequencies(analyser, sampleRate, fftResult, analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!fftResult) {
      fftResult = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(fftResult);
    }
    const nyquistFrequency = sampleRate / 2;
    const frequencyStep = 1 / fftResult.length * nyquistFrequency;
    let outputValues;
    let frequencies;
    let labels;
    if (analysisType === "music" || analysisType === "voice") {
      const useFrequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);
      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);
      for (let i3 = 0; i3 < fftResult.length; i3++) {
        const frequency = i3 * frequencyStep;
        const amplitude = fftResult[i3];
        for (let n3 = useFrequencies.length - 1; n3 >= 0; n3--)
          if (frequency > useFrequencies[n3]) {
            aggregateOutput[n3] = Math.max(aggregateOutput[n3], amplitude);
            break;
          }
      }
      outputValues = aggregateOutput;
      frequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa183) : (0, $03f71ce85e00ada6$export$776c63898ae5b636);
      labels = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$30a6f2881311088f) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b0);
    } else {
      outputValues = Array.from(fftResult);
      frequencies = outputValues.map((_4, i3) => frequencyStep * i3);
      labels = frequencies.map((f3) => `${f3.toFixed(2)} Hz`);
    }
    const normalizedOutput = outputValues.map((v3) => {
      return Math.max(0, Math.min((v3 - minDecibels) / (maxDecibels - minDecibels), 1));
    });
    const values = new Float32Array(normalizedOutput);
    return {
      values,
      frequencies,
      labels
    };
  }
  /**
  * Creates a new AudioAnalysis instance for an HTMLAudioElement
  * @param {HTMLAudioElement} audioElement
  * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer
  * @returns {AudioAnalysis}
  */
  constructor(audioElement, audioBuffer = null) {
    this.fftResults = [];
    if (audioBuffer) {
      const { length, sampleRate } = audioBuffer;
      const offlineAudioContext = new OfflineAudioContext({
        length,
        sampleRate
      });
      const source = offlineAudioContext.createBufferSource();
      source.buffer = audioBuffer;
      const analyser = offlineAudioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);
      const renderQuantumInSeconds = 1 / 60;
      const durationInSeconds = length / sampleRate;
      const analyze = (index) => {
        const suspendTime = renderQuantumInSeconds * index;
        if (suspendTime < durationInSeconds)
          offlineAudioContext.suspend(suspendTime).then(() => {
            const fftResult = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(fftResult);
            this.fftResults.push(fftResult);
            analyze(index + 1);
          });
        if (index === 1)
          offlineAudioContext.startRendering();
        else
          offlineAudioContext.resume();
      };
      source.start(0);
      analyze(1);
      this.audio = audioElement;
      this.context = offlineAudioContext;
      this.analyser = analyser;
      this.sampleRate = sampleRate;
      this.audioBuffer = audioBuffer;
    } else {
      const audioContext = new AudioContext();
      const track2 = audioContext.createMediaElementSource(audioElement);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      track2.connect(analyser);
      analyser.connect(audioContext.destination);
      this.audio = audioElement;
      this.context = audioContext;
      this.analyser = analyser;
      this.sampleRate = this.context.sampleRate;
      this.audioBuffer = null;
    }
  }
  /**
  * Gets the current frequency domain data from the playing audio track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    let fftResult = null;
    if (this.audioBuffer && this.fftResults.length) {
      const pct = this.audio.currentTime / this.audio.duration;
      const index = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);
      fftResult = this.fftResults[index];
    }
    return _$f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Resume the internal AudioContext if it was suspended due to the lack of
  * user interaction when the AudioAnalysis was instantiated.
  * @returns {Promise<true>}
  */
  async resumeIfSuspended() {
    if (this.context.state === "suspended")
      await this.context.resume();
    return true;
  }
};
globalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f9;
var $29a8a70a9466b14f$export$50b76700e2b15e9 = `
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`;
var $29a8a70a9466b14f$var$script = new Blob([
  $29a8a70a9466b14f$export$50b76700e2b15e9
], {
  type: "application/javascript"
});
var $29a8a70a9466b14f$var$src = URL.createObjectURL($29a8a70a9466b14f$var$script);
var $29a8a70a9466b14f$export$bfa8c596114d74df = $29a8a70a9466b14f$var$src;
var $d0a969833958d9e7$export$9698d62c78b8f366 = class {
  /**
  * Creates a new WavStreamPlayer instance
  * @param {{sampleRate?: number}} options
  * @returns {WavStreamPlayer}
  */
  constructor({ sampleRate = 44100 } = {}) {
    this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df);
    this.sampleRate = sampleRate;
    this.context = null;
    this.stream = null;
    this.analyser = null;
    this.trackSampleOffsets = {};
    this.interruptedTrackIds = {};
  }
  /**
  * Connects the audio context and enables output to speakers
  * @returns {Promise<true>}
  */
  async connect() {
    this.context = new AudioContext({
      sampleRate: this.sampleRate
    });
    if (this._speakerID)
      this.context.setSinkId(this._speakerID);
    if (this.context.state === "suspended")
      await this.context.resume();
    try {
      await this.context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const analyser = this.context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    this.analyser = analyser;
    return true;
  }
  /**
  * Gets the current frequency domain data from the playing track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.analyser)
      throw new Error("Not connected, please call .connect() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * @param {string} speaker deviceId
  */
  async updateSpeaker(speaker) {
    const _prevSpeaker = this._speakerID;
    this._speakerID = speaker;
    if (this.context)
      try {
        if (speaker === "default")
          await this.context.setSinkId();
        else
          await this.context.setSinkId(speaker);
      } catch (e4) {
        console.error(`Could not set sinkId to ${speaker}: ${e4}`);
        this._speakerID = _prevSpeaker;
      }
  }
  /**
  * Starts audio streaming
  * @private
  * @returns {Promise<true>}
  */
  _start() {
    const streamNode = new AudioWorkletNode(this.context, "stream_processor");
    streamNode.connect(this.context.destination);
    streamNode.port.onmessage = (e4) => {
      const { event } = e4.data;
      if (event === "stop") {
        streamNode.disconnect();
        this.stream = null;
      } else if (event === "offset") {
        const { requestId, trackId, offset } = e4.data;
        const currentTime = offset / this.sampleRate;
        this.trackSampleOffsets[requestId] = {
          trackId,
          offset,
          currentTime
        };
      }
    };
    this.analyser.disconnect();
    streamNode.connect(this.analyser);
    this.stream = streamNode;
    return true;
  }
  /**
  * Adds 16BitPCM data to the currently playing audio stream
  * You can add chunks beyond the current play point and they will be queued for play
  * @param {ArrayBuffer|Int16Array} arrayBuffer
  * @param {string} [trackId]
  * @returns {Int16Array}
  */
  add16BitPCM(arrayBuffer, trackId = "default") {
    if (typeof trackId !== "string")
      throw new Error(`trackId must be a string`);
    else if (this.interruptedTrackIds[trackId])
      return;
    if (!this.stream)
      this._start();
    let buffer;
    if (arrayBuffer instanceof Int16Array)
      buffer = arrayBuffer;
    else if (arrayBuffer instanceof ArrayBuffer)
      buffer = new Int16Array(arrayBuffer);
    else
      throw new Error(`argument must be Int16Array or ArrayBuffer`);
    this.stream.port.postMessage({
      event: "write",
      buffer,
      trackId
    });
    return buffer;
  }
  /**
  * Gets the offset (sample count) of the currently playing stream
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async getTrackSampleOffset(interrupt = false) {
    if (!this.stream)
      return null;
    const requestId = crypto.randomUUID();
    this.stream.port.postMessage({
      event: interrupt ? "interrupt" : "offset",
      requestId
    });
    let trackSampleOffset;
    while (!trackSampleOffset) {
      trackSampleOffset = this.trackSampleOffsets[requestId];
      await new Promise((r4) => setTimeout(() => r4(), 1));
    }
    const { trackId } = trackSampleOffset;
    if (interrupt && trackId)
      this.interruptedTrackIds[trackId] = true;
    return trackSampleOffset;
  }
  /**
  * Strips the current stream and returns the sample offset of the audio
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async interrupt() {
    return this.getTrackSampleOffset(true);
  }
};
globalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f366;
var $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet = `
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`;
var $8e1d1e6ff08f6fb5$var$script = new Blob([
  $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet
], {
  type: "application/javascript"
});
var $8e1d1e6ff08f6fb5$var$src = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script);
var $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c = $8e1d1e6ff08f6fb5$var$src;
var $62bc376044a05513$export$439b217ca659a877 = class {
  /**
  * Create a new WavRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {WavRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this._deviceChangeCallback = null;
    this._devices = [];
    this.deviceSelection = null;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer
  * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData
  * @param {number} sampleRate
  * @param {number} fromSampleRate
  * @returns {Promise<DecodedAudioType>}
  */
  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {
    const context = new AudioContext({
      sampleRate
    });
    let arrayBuffer;
    let blob;
    if (audioData instanceof Blob) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from Blob`);
      blob = audioData;
      arrayBuffer = await blob.arrayBuffer();
    } else if (audioData instanceof ArrayBuffer) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from ArrayBuffer`);
      arrayBuffer = audioData;
      blob = new Blob([
        arrayBuffer
      ], {
        type: "audio/wav"
      });
    } else {
      let float32Array;
      let data;
      if (audioData instanceof Int16Array) {
        data = audioData;
        float32Array = new Float32Array(audioData.length);
        for (let i3 = 0; i3 < audioData.length; i3++)
          float32Array[i3] = audioData[i3] / 32768;
      } else if (audioData instanceof Float32Array)
        float32Array = audioData;
      else if (audioData instanceof Array)
        float32Array = new Float32Array(audioData);
      else
        throw new Error(`"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);
      if (fromSampleRate === -1)
        throw new Error(`Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array`);
      else if (fromSampleRate < 3e3)
        throw new Error(`Minimum "fromSampleRate" is 3000 (3kHz)`);
      if (!data)
        data = (0, $6d4b7449a1e1544a$export$13afda237b1c9846).floatTo16BitPCM(float32Array);
      const audio = {
        bitsPerSample: 16,
        channels: [
          float32Array
        ],
        data
      };
      const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
      const result = packer.pack(fromSampleRate, audio);
      blob = result.blob;
      arrayBuffer = await blob.arrayBuffer();
    }
    const audioBuffer = await context.decodeAudioData(arrayBuffer);
    const values = audioBuffer.getChannelData(0);
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      values,
      audioBuffer
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Sets device change callback, remove if callback provided is `null`
  * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback
  * @returns {true}
  */
  listenForDeviceChange(callback) {
    if (callback === null && this._deviceChangeCallback) {
      navigator.mediaDevices.removeEventListener("devicechange", this._deviceChangeCallback);
      this._deviceChangeCallback = null;
    } else if (callback !== null) {
      let lastId = 0;
      let lastDevices = [];
      const serializeDevices = (devices) => devices.map((d3) => d3.deviceId).sort().join(",");
      const cb = async () => {
        let id = ++lastId;
        const devices = await this.listDevices();
        if (id === lastId) {
          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {
            lastDevices = devices;
            callback(devices.slice());
          }
        }
      };
      navigator.mediaDevices.addEventListener("devicechange", cb);
      cb();
      this._deviceChangeCallback = cb;
    }
    return true;
  }
  /**
  * Manually request permission to use the microphone
  * @returns {Promise<true>}
  */
  async requestPermission() {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone"
    });
    if (permissionStatus.state === "denied")
      window.alert("You must grant microphone access to use this feature.");
    else if (permissionStatus.state === "prompt")
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        const tracks = stream.getTracks();
        tracks.forEach((track2) => track2.stop());
      } catch (e4) {
        window.alert("You must grant microphone access to use this feature.");
      }
    return true;
  }
  /**
  * List all eligible devices for recording, will request permission to use microphone
  * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}
  */
  async listDevices() {
    if (!navigator.mediaDevices || !("enumerateDevices" in navigator.mediaDevices))
      throw new Error("Could not request user devices");
    await this.requestPermission();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter((device) => device.kind === "audioinput");
    return audioDevices;
  }
  /**
  * Begins a recording session and requests microphone permissions if not already granted
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {string} [deviceId] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(deviceId) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!navigator.mediaDevices || !("getUserMedia" in navigator.mediaDevices))
      throw new Error("Could not request user media");
    deviceId = deviceId ?? this.deviceSelection?.deviceId;
    try {
      const config = {
        audio: true
      };
      if (deviceId)
        config.audio = {
          deviceId: {
            exact: deviceId
          }
        };
      this.stream = await navigator.mediaDevices.getUserMedia(config);
    } catch (err) {
      throw new Error("Could not start media stream");
    }
    this.listDevices().then((devices) => {
      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;
      console.log("find current device", devices, deviceId, this.stream.getAudioTracks()[0].getSettings());
      this.deviceSelection = devices.find((d3) => d3.deviceId === deviceId);
      console.log("current device", this.deviceSelection);
    });
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    console.log("begin completed");
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    const tracks = this.stream.getTracks();
    tracks.forEach((track2) => track2.stop());
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    this.deviceSelection = null;
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a877;
var $5fc11d7bc0d20724$export$2934cf2d25c67a48 = class {
  /**
  * Create a new MediaStreamRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {MediaStreamRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Begins a recording session for the given audioTrack
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(audioTrack) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!audioTrack || audioTrack.kind !== "audio")
      throw new Error("No audio track provided");
    this.stream = new MediaStream([
      audioTrack
    ]);
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c9846).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f9).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: HELLO please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c9846)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = WavRecorder;
var $58d19ff082af5e5c$exports = {};
$58d19ff082af5e5c$exports = JSON.parse('{"name":"@pipecat-ai/daily-transport","version":"0.4.0","license":"BSD-2-Clause","main":"dist/index.js","module":"dist/index.module.js","types":"dist/index.d.ts","source":"src/index.ts","repository":{"type":"git","url":"git+https://github.com/pipecat-ai/pipecat-client-web-transports.git"},"files":["dist","package.json","README.md"],"scripts":{"build":"parcel build --no-cache","dev":"parcel watch","lint":"eslint . --ext ts --report-unused-disable-directives --max-warnings 0"},"devDependencies":{"@pipecat-ai/client-js":"^0.4.0","eslint":"9.11.1","eslint-config-prettier":"^9.1.0","eslint-plugin-simple-import-sort":"^12.1.1"},"peerDependencies":{"@pipecat-ai/client-js":"~0.4.0"},"dependencies":{"@daily-co/daily-js":"^0.77.0"},"description":"Pipecat Daily Transport Package","author":"Daily.co","bugs":{"url":"https://github.com/pipecat-ai/pipecat-client-web-transports/issues"},"homepage":"https://github.com/pipecat-ai/pipecat-client-web-transports/blob/main/transports/daily-webrtc/README.md"}');
var $683f111f61e07358$export$ef180de88fd317cc;
(function(DailyRTVIMessageType) {
  DailyRTVIMessageType["AUDIO_BUFFERING_STARTED"] = "audio-buffering-started";
  DailyRTVIMessageType["AUDIO_BUFFERING_STOPPED"] = "audio-buffering-stopped";
})($683f111f61e07358$export$ef180de88fd317cc || ($683f111f61e07358$export$ef180de88fd317cc = {}));
var $683f111f61e07358$var$DailyCallWrapper = class {
  constructor(daily) {
    this._daily = daily;
    this._proxy = new Proxy(this._daily, {
      get: (target, prop, receiver) => {
        if (typeof target[prop] === "function") {
          let errMsg;
          switch (String(prop)) {
            case "preAuth":
              errMsg = `Calls to preAuth() are disabled. Please use Transport.preAuth()`;
              break;
            case "startCamera":
              errMsg = `Calls to startCamera() are disabled. Please use RTVIClient.initDevices()`;
              break;
            case "join":
              errMsg = `Calls to join() are disabled. Please use RTVIClient.connect()`;
              break;
            case "leave":
              errMsg = `Calls to leave() are disabled. Please use RTVIClient.disconnect()`;
              break;
            case "destroy":
              errMsg = `Calls to destroy() are disabled.`;
              break;
          }
          if (errMsg)
            return () => {
              throw new Error(errMsg);
            };
          return (...args) => {
            return target[prop](...args);
          };
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  get proxy() {
    return this._proxy;
  }
};
var $683f111f61e07358$export$b1ca982aa1e488c1 = class _$683f111f61e07358$export$b1ca982aa1e488c1 extends (0, $4086f06442fcb7d7$export$86495b081fef8e52) {
  constructor({ dailyFactoryOptions = {}, bufferLocalAudioUntilBotReady = false } = {}) {
    super();
    this._botId = "";
    this._selectedCam = {};
    this._selectedMic = {};
    this._selectedSpeaker = {};
    this._currentAudioTrack = null;
    this._audioQueue = [];
    this._callbacks = {};
    this._dailyFactoryOptions = dailyFactoryOptions;
    this._bufferLocalAudioUntilBotReady = bufferLocalAudioUntilBotReady;
    this._daily = (0, ic).createCallObject({
      ...this._dailyFactoryOptions,
      allowMultipleCallInstances: true
    });
    this._dailyWrapper = new $683f111f61e07358$var$DailyCallWrapper(this._daily);
  }
  setupRecorder() {
    this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a48)({
      sampleRate: _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE
    });
  }
  handleUserAudioStream(data) {
    this._audioQueue.push(data);
  }
  flushAudioQueue() {
    const batchSize = 10;
    if (this._audioQueue.length === 0)
      return;
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Will flush audio queue: ${this._audioQueue.length}`);
    while (this._audioQueue.length > 0) {
      const batch = [];
      while (batch.length < batchSize && this._audioQueue.length > 0) {
        const queuedData = this._audioQueue.shift();
        if (queuedData)
          batch.push(queuedData);
      }
      if (batch.length > 0)
        this._sendAudioBatch(batch);
    }
  }
  _sendAudioBatch(dataBatch) {
    const encodedBatch = dataBatch.map((data) => {
      const pcmByteArray = new Uint8Array(data);
      return btoa(String.fromCharCode(...pcmByteArray));
    });
    const rtviMessage = {
      id: "raw-audio-batch",
      label: "rtvi-ai",
      type: "raw-audio-batch",
      data: {
        base64AudioBatch: encodedBatch,
        sampleRate: _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE,
        numChannels: 1
      }
    };
    this.sendMessage(rtviMessage);
  }
  initialize(options, messageHandler) {
    if (this._bufferLocalAudioUntilBotReady)
      this.setupRecorder();
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    if (this._dailyFactoryOptions.startVideoOff == null || options.enableCam != null)
      this._dailyFactoryOptions.startVideoOff = !(options.enableCam ?? false);
    if (this._dailyFactoryOptions.startAudioOff == null || options.enableMic != null)
      this._dailyFactoryOptions.startAudioOff = !(options.enableMic ?? true);
    this.attachEventListeners();
    this.state = "disconnected";
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Transport] Initialized", (0, /* @__PURE__ */ $parcel$interopDefault2($58d19ff082af5e5c$exports)).version);
  }
  get dailyCallClient() {
    return this._dailyWrapper.proxy;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    if (this._state === state)
      return;
    this._state = state;
    this._callbacks.onTransportStateChanged?.(state);
  }
  async getAllCams() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d3) => d3.kind === "videoinput");
  }
  updateCam(camId) {
    this._daily.setInputDevicesAsync({
      videoDeviceId: camId
    }).then((infos) => {
      this._selectedCam = infos.camera;
    });
  }
  get selectedCam() {
    return this._selectedCam;
  }
  async getAllMics() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d3) => d3.kind === "audioinput");
  }
  updateMic(micId) {
    this._daily.setInputDevicesAsync({
      audioDeviceId: micId
    }).then((infos) => {
      this._selectedMic = infos.mic;
    });
  }
  get selectedMic() {
    return this._selectedMic;
  }
  async getAllSpeakers() {
    const { devices } = await this._daily.enumerateDevices();
    return devices.filter((d3) => d3.kind === "audiooutput");
  }
  updateSpeaker(speakerId) {
    this._daily.setOutputDeviceAsync({
      outputDeviceId: speakerId
    }).then((infos) => {
      this._selectedSpeaker = infos.speaker;
    });
  }
  get selectedSpeaker() {
    return this._selectedSpeaker;
  }
  enableMic(enable) {
    this._daily.setLocalAudio(enable);
  }
  get isMicEnabled() {
    return this._daily.localAudio();
  }
  enableCam(enable) {
    this._daily.setLocalVideo(enable);
  }
  get isCamEnabled() {
    return this._daily.localVideo();
  }
  enableScreenShare(enable) {
    if (enable)
      this._daily.startScreenShare();
    else
      this._daily.stopScreenShare();
  }
  get isSharingScreen() {
    return this._daily.localScreenAudio() || this._daily.localScreenVideo();
  }
  tracks() {
    const participants = this._daily.participants() ?? {};
    const bot = participants?.[this._botId];
    const tracks = {
      local: {
        audio: participants?.local?.tracks?.audio?.persistentTrack,
        screenAudio: participants?.local?.tracks?.screenAudio?.persistentTrack,
        screenVideo: participants?.local?.tracks?.screenVideo?.persistentTrack,
        video: participants?.local?.tracks?.video?.persistentTrack
      }
    };
    if (bot)
      tracks.bot = {
        audio: bot?.tracks?.audio?.persistentTrack,
        video: bot?.tracks?.video?.persistentTrack
      };
    return tracks;
  }
  async startRecording() {
    try {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).info("[RTVI Transport] Initializing recording");
      await this._mediaStreamRecorder.record((data) => {
        this.handleUserAudioStream(data.mono);
      }, _$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE);
      this._onMessage({
        type: $683f111f61e07358$export$ef180de88fd317cc.AUDIO_BUFFERING_STARTED,
        data: {}
      });
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).info("[RTVI Transport] Recording Initialized");
    } catch (e4) {
      const err = e4;
      if (!err.message.includes("Already recording"))
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Error starting recording", e4);
    }
  }
  async preAuth(dailyFactoryOptions) {
    this._dailyFactoryOptions = dailyFactoryOptions;
    await this._daily.preAuth(dailyFactoryOptions);
  }
  async initDevices() {
    if (!this._daily)
      throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)("Transport instance not initialized");
    this.state = "initializing";
    const infos = await this._daily.startCamera(this._dailyFactoryOptions);
    const { devices } = await this._daily.enumerateDevices();
    const cams = devices.filter((d3) => d3.kind === "videoinput");
    const mics = devices.filter((d3) => d3.kind === "audioinput");
    const speakers = devices.filter((d3) => d3.kind === "audiooutput");
    this._selectedCam = infos.camera;
    this._selectedMic = infos.mic;
    this._selectedSpeaker = infos.speaker;
    this._callbacks.onAvailableCamsUpdated?.(cams);
    this._callbacks.onAvailableMicsUpdated?.(mics);
    this._callbacks.onAvailableSpeakersUpdated?.(speakers);
    this._callbacks.onCamUpdated?.(infos.camera);
    this._callbacks.onMicUpdated?.(infos.mic);
    this._callbacks.onSpeakerUpdated?.(infos.speaker);
    if (!this._daily.isLocalAudioLevelObserverRunning())
      await this._daily.startLocalAudioLevelObserver(100);
    if (!this._daily.isRemoteParticipantsAudioLevelObserverRunning())
      await this._daily.startRemoteParticipantsAudioLevelObserver(100);
    this.state = "initialized";
  }
  async connect(authBundle, abortController) {
    if (!this._daily)
      throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)("Transport instance not initialized");
    if (abortController.signal.aborted)
      return;
    this.state = "connecting";
    const opts = this._dailyFactoryOptions;
    opts.url = authBundle.room_url ?? opts.url;
    if (authBundle.token != null)
      opts.token = authBundle.token;
    try {
      await this._daily.join(opts);
      const room = await this._daily.room();
      if (room && "id" in room)
        this._expiry = room.config?.exp;
    } catch (e4) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Failed to join room", e4);
      this.state = "error";
      throw new (0, $8ead7b33b8402751$export$e0624a511a2c4e9)();
    }
    if (abortController.signal.aborted)
      return;
    this.state = "connected";
    this._callbacks.onConnected?.();
  }
  async sendReadyMessage() {
    return new Promise((resolve) => {
      const isIOS = () => {
        const userAgent = navigator.userAgent;
        return /iPad|iPhone|iPod/.test(userAgent) || /Macintosh/.test(userAgent) && "ontouchend" in document;
      };
      const sendReadyMessage = () => {
        this.state = "ready";
        this.flushAudioQueue();
        this.sendMessage((0, $b48f893ed1354c1e$export$69aa9ab0334b212).clientReady());
        this.stopRecording();
        resolve();
      };
      const readyHandler = (ev) => {
        if (!ev.participant?.local) {
          this._daily.off("track-started", readyHandler);
          if (isIOS()) {
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Transport] iOS device detected, adding 0.5 second delay before sending ready message");
            setTimeout(sendReadyMessage, 500);
          } else
            sendReadyMessage();
        }
      };
      this._daily.on("track-started", readyHandler);
    });
  }
  stopRecording() {
    if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() !== "ended") {
      this._mediaStreamRecorder.end();
      this._onMessage({
        type: $683f111f61e07358$export$ef180de88fd317cc.AUDIO_BUFFERING_STOPPED,
        data: {}
      });
    }
  }
  attachEventListeners() {
    this._daily.on("available-devices-updated", this.handleAvailableDevicesUpdated.bind(this));
    this._daily.on("selected-devices-updated", this.handleSelectedDevicesUpdated.bind(this));
    this._daily.on("track-started", this.handleTrackStarted.bind(this));
    this._daily.on("track-stopped", this.handleTrackStopped.bind(this));
    this._daily.on("participant-joined", this.handleParticipantJoined.bind(this));
    this._daily.on("participant-left", this.handleParticipantLeft.bind(this));
    this._daily.on("local-audio-level", this.handleLocalAudioLevel.bind(this));
    this._daily.on("remote-participants-audio-level", this.handleRemoteAudioLevel.bind(this));
    this._daily.on("app-message", this.handleAppMessage.bind(this));
    this._daily.on("left-meeting", this.handleLeftMeeting.bind(this));
    this._daily.on("error", this.handleFatalError.bind(this));
    this._daily.on("nonfatal-error", this.handleNonFatalError.bind(this));
  }
  async disconnect() {
    this.state = "disconnecting";
    this._daily.stopLocalAudioLevelObserver();
    this._daily.stopRemoteParticipantsAudioLevelObserver();
    this._audioQueue = [];
    this._currentAudioTrack = null;
    this.stopRecording();
    await this._daily.leave();
  }
  sendMessage(message) {
    this._daily.sendAppMessage(message, "*");
  }
  handleAppMessage(ev) {
    if (ev.data.label === "rtvi-ai")
      this._onMessage({
        id: ev.data.id,
        type: ev.data.type,
        data: ev.data.data
      });
  }
  handleAvailableDevicesUpdated(ev) {
    this._callbacks.onAvailableCamsUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "videoinput"));
    this._callbacks.onAvailableMicsUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "audioinput"));
    this._callbacks.onAvailableSpeakersUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "audiooutput"));
  }
  handleSelectedDevicesUpdated(ev) {
    if (this._selectedCam?.deviceId !== ev.devices.camera) {
      this._selectedCam = ev.devices.camera;
      this._callbacks.onCamUpdated?.(ev.devices.camera);
    }
    if (this._selectedMic?.deviceId !== ev.devices.mic) {
      this._selectedMic = ev.devices.mic;
      this._callbacks.onMicUpdated?.(ev.devices.mic);
    }
    if (this._selectedSpeaker?.deviceId !== ev.devices.speaker) {
      this._selectedSpeaker = ev.devices.speaker;
      this._callbacks.onSpeakerUpdated?.(ev.devices.speaker);
    }
  }
  async handleLocalAudioTrack(track2) {
    if (this.state == "ready" || !this._bufferLocalAudioUntilBotReady)
      return;
    const status = this._mediaStreamRecorder.getStatus();
    switch (status) {
      case "ended":
        await this._mediaStreamRecorder.begin(track2);
        await this.startRecording();
        break;
      case "paused":
        await this.startRecording();
        break;
      case "recording":
      default:
        if (this._currentAudioTrack !== track2) {
          await this._mediaStreamRecorder.end();
          await this._mediaStreamRecorder.begin(track2);
          await this.startRecording();
        } else
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn("track-started event received for current track and already recording");
        break;
    }
    this._currentAudioTrack = track2;
  }
  handleTrackStarted(ev) {
    if (ev.type === "screenAudio" || ev.type === "screenVideo")
      this._callbacks.onScreenTrackStarted?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    else {
      if (ev.participant?.local && ev.track.kind === "audio")
        this.handleLocalAudioTrack(ev.track);
      this._callbacks.onTrackStarted?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    }
  }
  handleTrackStopped(ev) {
    if (ev.type === "screenAudio" || ev.type === "screenVideo")
      this._callbacks.onScreenTrackStopped?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
    else
      this._callbacks.onTrackStopped?.(ev.track, ev.participant ? $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant) : void 0);
  }
  handleParticipantJoined(ev) {
    const p3 = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);
    this._callbacks.onParticipantJoined?.(p3);
    if (p3.local)
      return;
    this._botId = ev.participant.session_id;
    this._callbacks.onBotConnected?.(p3);
  }
  handleParticipantLeft(ev) {
    const p3 = $683f111f61e07358$var$dailyParticipantToParticipant(ev.participant);
    this._callbacks.onParticipantLeft?.(p3);
    if (p3.local)
      return;
    this._botId = "";
    this._callbacks.onBotDisconnected?.(p3);
  }
  handleLocalAudioLevel(ev) {
    this._callbacks.onLocalAudioLevel?.(ev.audioLevel);
  }
  handleRemoteAudioLevel(ev) {
    const participants = this._daily.participants();
    const ids = Object.keys(ev.participantsAudioLevel);
    for (let i3 = 0; i3 < ids.length; i3++) {
      const id = ids[i3];
      const level = ev.participantsAudioLevel[id];
      this._callbacks.onRemoteAudioLevel?.(level, $683f111f61e07358$var$dailyParticipantToParticipant(participants[id]));
    }
  }
  handleLeftMeeting() {
    this.state = "disconnected";
    this._botId = "";
    this._callbacks.onDisconnected?.();
  }
  handleFatalError(ev) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Daily fatal error", ev.errorMsg);
    this.state = "error";
    this._botId = "";
    this._callbacks.onError?.((0, $b48f893ed1354c1e$export$69aa9ab0334b212).error(ev.errorMsg, true));
  }
  handleNonFatalError(ev) {
    switch (ev.type) {
      case "screen-share-error":
        this._callbacks.onScreenShareError?.(ev.errorMsg);
        break;
    }
  }
};
$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_SAMPLE_RATE = 16e3;
$683f111f61e07358$export$b1ca982aa1e488c1.RECORDER_CHUNK_SIZE = 512;
var $683f111f61e07358$var$dailyParticipantToParticipant = (p3) => ({
  id: p3.user_id,
  local: p3.local,
  name: p3.user_name
});

// ../node_modules/@pipecat-ai/small-webrtc-transport/dist/index.module.js
function $parcel$export3(e4, n3, v3, s3) {
  Object.defineProperty(e4, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $b31644dc78dca54a$exports = {};
$parcel$export3($b31644dc78dca54a$exports, "SmallWebRTCTransport", () => $b31644dc78dca54a$export$62043589d053a879);
var $6d4b7449a1e1544a$export$13afda237b1c98462 = class {
  /**
  * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format
  * @param {Float32Array} float32Array
  * @returns {ArrayBuffer}
  */
  static floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i3 = 0; i3 < float32Array.length; i3++, offset += 2) {
      let s3 = Math.max(-1, Math.min(1, float32Array[i3]));
      view.setInt16(offset, s3 < 0 ? s3 * 32768 : s3 * 32767, true);
    }
    return buffer;
  }
  /**
  * Concatenates two ArrayBuffers
  * @param {ArrayBuffer} leftBuffer
  * @param {ArrayBuffer} rightBuffer
  * @returns {ArrayBuffer}
  */
  static mergeBuffers(leftBuffer, rightBuffer) {
    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
    tmpArray.set(new Uint8Array(leftBuffer), 0);
    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
    return tmpArray.buffer;
  }
  /**
  * Packs data into an Int16 format
  * @private
  * @param {number} size 0 = 1x Int16, 1 = 2x Int16
  * @param {number} arg value to pack
  * @returns
  */
  _packData(size, arg) {
    return [
      new Uint8Array([
        arg,
        arg >> 8
      ]),
      new Uint8Array([
        arg,
        arg >> 8,
        arg >> 16,
        arg >> 24
      ])
    ][size];
  }
  /**
  * Packs audio into "audio/wav" Blob
  * @param {number} sampleRate
  * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio
  * @returns {WavPackerAudioType}
  */
  pack(sampleRate, audio) {
    if (!audio?.bitsPerSample)
      throw new Error(`Missing "bitsPerSample"`);
    else if (!audio?.channels)
      throw new Error(`Missing "channels"`);
    else if (!audio?.data)
      throw new Error(`Missing "data"`);
    const { bitsPerSample, channels, data } = audio;
    const output = [
      // Header
      "RIFF",
      this._packData(1, 52),
      "WAVE",
      // chunk 1
      "fmt ",
      this._packData(1, 16),
      this._packData(0, 1),
      this._packData(0, channels.length),
      this._packData(1, sampleRate),
      this._packData(1, sampleRate * channels.length * bitsPerSample / 8),
      this._packData(0, channels.length * bitsPerSample / 8),
      this._packData(0, bitsPerSample),
      // chunk 2
      "data",
      this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),
      data
    ];
    const blob = new Blob(output, {
      type: "audio/mpeg"
    });
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      channelCount: channels.length,
      sampleRate,
      duration: data.byteLength / (channels.length * sampleRate * 2)
    };
  }
};
globalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c98462;
var $03f71ce85e00ada6$var$octave8Frequencies2 = [
  4186.01,
  4434.92,
  4698.63,
  4978.03,
  5274.04,
  5587.65,
  5919.91,
  6271.93,
  6644.88,
  7040,
  7458.62,
  7902.13
];
var $03f71ce85e00ada6$var$octave8FrequencyLabels2 = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
var $03f71ce85e00ada6$export$776c63898ae5b6362 = [];
var $03f71ce85e00ada6$export$facd167cc27ea9b02 = [];
for (let i3 = 1; i3 <= 8; i3++)
  for (let f3 = 0; f3 < $03f71ce85e00ada6$var$octave8Frequencies2.length; f3++) {
    const freq = $03f71ce85e00ada6$var$octave8Frequencies2[f3];
    $03f71ce85e00ada6$export$776c63898ae5b6362.push(freq / Math.pow(2, 8 - i3));
    $03f71ce85e00ada6$export$facd167cc27ea9b02.push($03f71ce85e00ada6$var$octave8FrequencyLabels2[f3] + i3);
  }
var $03f71ce85e00ada6$var$voiceFrequencyRange2 = [
  32,
  2e3
];
var $03f71ce85e00ada6$export$dbc1581ed2cfa1832 = $03f71ce85e00ada6$export$776c63898ae5b6362.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6362[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange2[0] && $03f71ce85e00ada6$export$776c63898ae5b6362[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange2[1];
});
var $03f71ce85e00ada6$export$30a6f2881311088f2 = $03f71ce85e00ada6$export$facd167cc27ea9b02.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6362[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange2[0] && $03f71ce85e00ada6$export$776c63898ae5b6362[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange2[1];
});
var $f32f064564ee62f6$export$2c3136da0bf130f92 = class _$f32f064564ee62f6$export$2c3136da0bf130f9 {
  /**
  * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range
  * returns human-readable formatting and labels
  * @param {AnalyserNode} analyser
  * @param {number} sampleRate
  * @param {Float32Array} [fftResult]
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  static getFrequencies(analyser, sampleRate, fftResult, analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!fftResult) {
      fftResult = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(fftResult);
    }
    const nyquistFrequency = sampleRate / 2;
    const frequencyStep = 1 / fftResult.length * nyquistFrequency;
    let outputValues;
    let frequencies;
    let labels;
    if (analysisType === "music" || analysisType === "voice") {
      const useFrequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1832) : (0, $03f71ce85e00ada6$export$776c63898ae5b6362);
      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);
      for (let i3 = 0; i3 < fftResult.length; i3++) {
        const frequency = i3 * frequencyStep;
        const amplitude = fftResult[i3];
        for (let n3 = useFrequencies.length - 1; n3 >= 0; n3--)
          if (frequency > useFrequencies[n3]) {
            aggregateOutput[n3] = Math.max(aggregateOutput[n3], amplitude);
            break;
          }
      }
      outputValues = aggregateOutput;
      frequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1832) : (0, $03f71ce85e00ada6$export$776c63898ae5b6362);
      labels = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$30a6f2881311088f2) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b02);
    } else {
      outputValues = Array.from(fftResult);
      frequencies = outputValues.map((_4, i3) => frequencyStep * i3);
      labels = frequencies.map((f3) => `${f3.toFixed(2)} Hz`);
    }
    const normalizedOutput = outputValues.map((v3) => {
      return Math.max(0, Math.min((v3 - minDecibels) / (maxDecibels - minDecibels), 1));
    });
    const values = new Float32Array(normalizedOutput);
    return {
      values,
      frequencies,
      labels
    };
  }
  /**
  * Creates a new AudioAnalysis instance for an HTMLAudioElement
  * @param {HTMLAudioElement} audioElement
  * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer
  * @returns {AudioAnalysis}
  */
  constructor(audioElement, audioBuffer = null) {
    this.fftResults = [];
    if (audioBuffer) {
      const { length, sampleRate } = audioBuffer;
      const offlineAudioContext = new OfflineAudioContext({
        length,
        sampleRate
      });
      const source = offlineAudioContext.createBufferSource();
      source.buffer = audioBuffer;
      const analyser = offlineAudioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);
      const renderQuantumInSeconds = 1 / 60;
      const durationInSeconds = length / sampleRate;
      const analyze = (index) => {
        const suspendTime = renderQuantumInSeconds * index;
        if (suspendTime < durationInSeconds)
          offlineAudioContext.suspend(suspendTime).then(() => {
            const fftResult = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(fftResult);
            this.fftResults.push(fftResult);
            analyze(index + 1);
          });
        if (index === 1)
          offlineAudioContext.startRendering();
        else
          offlineAudioContext.resume();
      };
      source.start(0);
      analyze(1);
      this.audio = audioElement;
      this.context = offlineAudioContext;
      this.analyser = analyser;
      this.sampleRate = sampleRate;
      this.audioBuffer = audioBuffer;
    } else {
      const audioContext = new AudioContext();
      const track2 = audioContext.createMediaElementSource(audioElement);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      track2.connect(analyser);
      analyser.connect(audioContext.destination);
      this.audio = audioElement;
      this.context = audioContext;
      this.analyser = analyser;
      this.sampleRate = this.context.sampleRate;
      this.audioBuffer = null;
    }
  }
  /**
  * Gets the current frequency domain data from the playing audio track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    let fftResult = null;
    if (this.audioBuffer && this.fftResults.length) {
      const pct = this.audio.currentTime / this.audio.duration;
      const index = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);
      fftResult = this.fftResults[index];
    }
    return _$f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Resume the internal AudioContext if it was suspended due to the lack of
  * user interaction when the AudioAnalysis was instantiated.
  * @returns {Promise<true>}
  */
  async resumeIfSuspended() {
    if (this.context.state === "suspended")
      await this.context.resume();
    return true;
  }
};
globalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f92;
var $29a8a70a9466b14f$export$50b76700e2b15e92 = `
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`;
var $29a8a70a9466b14f$var$script2 = new Blob([
  $29a8a70a9466b14f$export$50b76700e2b15e92
], {
  type: "application/javascript"
});
var $29a8a70a9466b14f$var$src2 = URL.createObjectURL($29a8a70a9466b14f$var$script2);
var $29a8a70a9466b14f$export$bfa8c596114d74df2 = $29a8a70a9466b14f$var$src2;
var $d0a969833958d9e7$export$9698d62c78b8f3662 = class {
  /**
  * Creates a new WavStreamPlayer instance
  * @param {{sampleRate?: number}} options
  * @returns {WavStreamPlayer}
  */
  constructor({ sampleRate = 44100 } = {}) {
    this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df2);
    this.sampleRate = sampleRate;
    this.context = null;
    this.stream = null;
    this.analyser = null;
    this.trackSampleOffsets = {};
    this.interruptedTrackIds = {};
  }
  /**
  * Connects the audio context and enables output to speakers
  * @returns {Promise<true>}
  */
  async connect() {
    this.context = new AudioContext({
      sampleRate: this.sampleRate
    });
    if (this._speakerID)
      this.context.setSinkId(this._speakerID);
    if (this.context.state === "suspended")
      await this.context.resume();
    try {
      await this.context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const analyser = this.context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    this.analyser = analyser;
    return true;
  }
  /**
  * Gets the current frequency domain data from the playing track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.analyser)
      throw new Error("Not connected, please call .connect() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * @param {string} speaker deviceId
  */
  async updateSpeaker(speaker) {
    const _prevSpeaker = this._speakerID;
    this._speakerID = speaker;
    if (this.context)
      try {
        if (speaker === "default")
          await this.context.setSinkId();
        else
          await this.context.setSinkId(speaker);
      } catch (e4) {
        console.error(`Could not set sinkId to ${speaker}: ${e4}`);
        this._speakerID = _prevSpeaker;
      }
  }
  /**
  * Starts audio streaming
  * @private
  * @returns {Promise<true>}
  */
  _start() {
    const streamNode = new AudioWorkletNode(this.context, "stream_processor");
    streamNode.connect(this.context.destination);
    streamNode.port.onmessage = (e4) => {
      const { event } = e4.data;
      if (event === "stop") {
        streamNode.disconnect();
        this.stream = null;
      } else if (event === "offset") {
        const { requestId, trackId, offset } = e4.data;
        const currentTime = offset / this.sampleRate;
        this.trackSampleOffsets[requestId] = {
          trackId,
          offset,
          currentTime
        };
      }
    };
    this.analyser.disconnect();
    streamNode.connect(this.analyser);
    this.stream = streamNode;
    return true;
  }
  /**
  * Adds 16BitPCM data to the currently playing audio stream
  * You can add chunks beyond the current play point and they will be queued for play
  * @param {ArrayBuffer|Int16Array} arrayBuffer
  * @param {string} [trackId]
  * @returns {Int16Array}
  */
  add16BitPCM(arrayBuffer, trackId = "default") {
    if (typeof trackId !== "string")
      throw new Error(`trackId must be a string`);
    else if (this.interruptedTrackIds[trackId])
      return;
    if (!this.stream)
      this._start();
    let buffer;
    if (arrayBuffer instanceof Int16Array)
      buffer = arrayBuffer;
    else if (arrayBuffer instanceof ArrayBuffer)
      buffer = new Int16Array(arrayBuffer);
    else
      throw new Error(`argument must be Int16Array or ArrayBuffer`);
    this.stream.port.postMessage({
      event: "write",
      buffer,
      trackId
    });
    return buffer;
  }
  /**
  * Gets the offset (sample count) of the currently playing stream
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async getTrackSampleOffset(interrupt = false) {
    if (!this.stream)
      return null;
    const requestId = crypto.randomUUID();
    this.stream.port.postMessage({
      event: interrupt ? "interrupt" : "offset",
      requestId
    });
    let trackSampleOffset;
    while (!trackSampleOffset) {
      trackSampleOffset = this.trackSampleOffsets[requestId];
      await new Promise((r4) => setTimeout(() => r4(), 1));
    }
    const { trackId } = trackSampleOffset;
    if (interrupt && trackId)
      this.interruptedTrackIds[trackId] = true;
    return trackSampleOffset;
  }
  /**
  * Strips the current stream and returns the sample offset of the audio
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async interrupt() {
    return this.getTrackSampleOffset(true);
  }
};
globalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f3662;
var $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet2 = `
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`;
var $8e1d1e6ff08f6fb5$var$script2 = new Blob([
  $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet2
], {
  type: "application/javascript"
});
var $8e1d1e6ff08f6fb5$var$src2 = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script2);
var $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2 = $8e1d1e6ff08f6fb5$var$src2;
var $62bc376044a05513$export$439b217ca659a8772 = class {
  /**
  * Create a new WavRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {WavRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this._deviceChangeCallback = null;
    this._devices = [];
    this.deviceSelection = null;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer
  * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData
  * @param {number} sampleRate
  * @param {number} fromSampleRate
  * @returns {Promise<DecodedAudioType>}
  */
  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {
    const context = new AudioContext({
      sampleRate
    });
    let arrayBuffer;
    let blob;
    if (audioData instanceof Blob) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from Blob`);
      blob = audioData;
      arrayBuffer = await blob.arrayBuffer();
    } else if (audioData instanceof ArrayBuffer) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from ArrayBuffer`);
      arrayBuffer = audioData;
      blob = new Blob([
        arrayBuffer
      ], {
        type: "audio/wav"
      });
    } else {
      let float32Array;
      let data;
      if (audioData instanceof Int16Array) {
        data = audioData;
        float32Array = new Float32Array(audioData.length);
        for (let i3 = 0; i3 < audioData.length; i3++)
          float32Array[i3] = audioData[i3] / 32768;
      } else if (audioData instanceof Float32Array)
        float32Array = audioData;
      else if (audioData instanceof Array)
        float32Array = new Float32Array(audioData);
      else
        throw new Error(`"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);
      if (fromSampleRate === -1)
        throw new Error(`Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array`);
      else if (fromSampleRate < 3e3)
        throw new Error(`Minimum "fromSampleRate" is 3000 (3kHz)`);
      if (!data)
        data = (0, $6d4b7449a1e1544a$export$13afda237b1c98462).floatTo16BitPCM(float32Array);
      const audio = {
        bitsPerSample: 16,
        channels: [
          float32Array
        ],
        data
      };
      const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
      const result = packer.pack(fromSampleRate, audio);
      blob = result.blob;
      arrayBuffer = await blob.arrayBuffer();
    }
    const audioBuffer = await context.decodeAudioData(arrayBuffer);
    const values = audioBuffer.getChannelData(0);
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      values,
      audioBuffer
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Sets device change callback, remove if callback provided is `null`
  * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback
  * @returns {true}
  */
  listenForDeviceChange(callback) {
    if (callback === null && this._deviceChangeCallback) {
      navigator.mediaDevices.removeEventListener("devicechange", this._deviceChangeCallback);
      this._deviceChangeCallback = null;
    } else if (callback !== null) {
      let lastId = 0;
      let lastDevices = [];
      const serializeDevices = (devices) => devices.map((d3) => d3.deviceId).sort().join(",");
      const cb = async () => {
        let id = ++lastId;
        const devices = await this.listDevices();
        if (id === lastId) {
          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {
            lastDevices = devices;
            callback(devices.slice());
          }
        }
      };
      navigator.mediaDevices.addEventListener("devicechange", cb);
      cb();
      this._deviceChangeCallback = cb;
    }
    return true;
  }
  /**
  * Manually request permission to use the microphone
  * @returns {Promise<true>}
  */
  async requestPermission() {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone"
    });
    if (permissionStatus.state === "denied")
      window.alert("You must grant microphone access to use this feature.");
    else if (permissionStatus.state === "prompt")
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        const tracks = stream.getTracks();
        tracks.forEach((track2) => track2.stop());
      } catch (e4) {
        window.alert("You must grant microphone access to use this feature.");
      }
    return true;
  }
  /**
  * List all eligible devices for recording, will request permission to use microphone
  * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}
  */
  async listDevices() {
    if (!navigator.mediaDevices || !("enumerateDevices" in navigator.mediaDevices))
      throw new Error("Could not request user devices");
    await this.requestPermission();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter((device) => device.kind === "audioinput");
    return audioDevices;
  }
  /**
  * Begins a recording session and requests microphone permissions if not already granted
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {string} [deviceId] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(deviceId) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!navigator.mediaDevices || !("getUserMedia" in navigator.mediaDevices))
      throw new Error("Could not request user media");
    deviceId = deviceId ?? this.deviceSelection?.deviceId;
    try {
      const config = {
        audio: true
      };
      if (deviceId)
        config.audio = {
          deviceId: {
            exact: deviceId
          }
        };
      this.stream = await navigator.mediaDevices.getUserMedia(config);
    } catch (err) {
      throw new Error("Could not start media stream");
    }
    this.listDevices().then((devices) => {
      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;
      console.log("find current device", devices, deviceId, this.stream.getAudioTracks()[0].getSettings());
      this.deviceSelection = devices.find((d3) => d3.deviceId === deviceId);
      console.log("current device", this.deviceSelection);
    });
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    console.log("begin completed");
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    const tracks = this.stream.getTracks();
    tracks.forEach((track2) => track2.stop());
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    this.deviceSelection = null;
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a8772;
var $5fc11d7bc0d20724$export$2934cf2d25c67a482 = class {
  /**
  * Create a new MediaStreamRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {MediaStreamRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c2);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Begins a recording session for the given audioTrack
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(audioTrack) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!audioTrack || audioTrack.kind !== "audio")
      throw new Error("No audio track provided");
    this.stream = new MediaStream([
      audioTrack
    ]);
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98462).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f92).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: HELLO please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98462)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = WavRecorder;
var $fc49a56cd8739127$var$__extends = function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var $fc49a56cd8739127$var$__awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $fc49a56cd8739127$var$__generator = function(thisArg, body) {
  var _4 = {
    label: 0,
    sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    },
    trys: [],
    ops: []
  }, f3, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([
        n3,
        v3
      ]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_4 = 0)), _4)
      try {
        if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [
            op[0] & 2,
            t3.value
          ];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _4.label++;
            y3 = op[1];
            op = [
              0
            ];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e4) {
        op = [
          6,
          e4
        ];
        y3 = 0;
      } finally {
        f3 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $fc49a56cd8739127$export$4a0c46dbbe2ddb67 = (
  /** @class */
  function() {
    function MediaManager() {
      this._callbacks = {};
      this._micEnabled = true;
      this._camEnabled = false;
    }
    MediaManager.prototype.setUserAudioCallback = function(userAudioCallback) {
      this._userAudioCallback = userAudioCallback;
    };
    MediaManager.prototype.setRTVIOptions = function(options, override) {
      var _a3, _b, _c3;
      if (override === void 0)
        override = false;
      if (this._options && !override)
        return;
      this._options = options;
      this._callbacks = (_a3 = options.callbacks) !== null && _a3 !== void 0 ? _a3 : {};
      this._micEnabled = (_b = options.enableMic) !== null && _b !== void 0 ? _b : true;
      this._camEnabled = (_c3 = options.enableCam) !== null && _c3 !== void 0 ? _c3 : false;
    };
    return MediaManager;
  }()
);
var $fc49a56cd8739127$export$45c5b9bfba2f6304 = (
  /** @class */
  function(_super) {
    $fc49a56cd8739127$var$__extends(WavMediaManager, _super);
    function WavMediaManager(recorderChunkSize, recorderSampleRate) {
      if (recorderChunkSize === void 0)
        recorderChunkSize = void 0;
      if (recorderSampleRate === void 0)
        recorderSampleRate = 24e3;
      var _this = _super.call(this) || this;
      _this._initialized = false;
      _this._recorderChunkSize = void 0;
      _this._recorderChunkSize = recorderChunkSize;
      _this._wavRecorder = new (0, $62bc376044a05513$export$439b217ca659a8772)({
        sampleRate: recorderSampleRate
      });
      _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3662)({
        sampleRate: 24e3
      });
      return _this;
    }
    WavMediaManager.prototype.initialize = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._wavRecorder.begin()
              ];
            case 1:
              _a3.sent();
              this._wavRecorder.listenForDeviceChange(null);
              this._wavRecorder.listenForDeviceChange(this._handleAvailableDevicesUpdated.bind(this));
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 2:
              _a3.sent();
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.connect = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var isAlreadyRecording;
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!!this._initialized)
                return [
                  3,
                  2
                ];
              return [
                4,
                this.initialize()
              ];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              isAlreadyRecording = this._wavRecorder.getStatus() == "recording";
              if (!(this._micEnabled && !isAlreadyRecording))
                return [
                  3,
                  4
                ];
              return [
                4,
                this._startRecording()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.disconnect = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!this._initialized)
                return [
                  2
                  /*return*/
                ];
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _a3.sent();
              return [
                4,
                this._wavStreamPlayer.interrupt()
              ];
            case 2:
              _a3.sent();
              this._initialized = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.userStartedSpeaking = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          return [
            2,
            this._wavStreamPlayer.interrupt()
          ];
        });
      });
    };
    WavMediaManager.prototype.bufferBotAudio = function(data, id) {
      return this._wavStreamPlayer.add16BitPCM(data, id);
    };
    WavMediaManager.prototype.getAllMics = function() {
      return this._wavRecorder.listDevices();
    };
    WavMediaManager.prototype.getAllCams = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.getAllSpeakers = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.updateMic = function(micId) {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var prevMic, curMic;
        var _a3, _b;
        return $fc49a56cd8739127$var$__generator(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              prevMic = this._wavRecorder.deviceSelection;
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _c3.sent();
              return [
                4,
                this._wavRecorder.begin(micId)
              ];
            case 2:
              _c3.sent();
              if (!this._micEnabled)
                return [
                  3,
                  4
                ];
              return [
                4,
                this._startRecording()
              ];
            case 3:
              _c3.sent();
              _c3.label = 4;
            case 4:
              curMic = this._wavRecorder.deviceSelection;
              if (curMic && prevMic && prevMic.label !== curMic.label)
                (_b = (_a3 = this._callbacks).onMicUpdated) === null || _b === void 0 || _b.call(_a3, curMic);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.updateCam = function(camId) {
    };
    WavMediaManager.prototype.updateSpeaker = function(speakerId) {
    };
    Object.defineProperty(WavMediaManager.prototype, "selectedMic", {
      get: function() {
        var _a3;
        return (_a3 = this._wavRecorder.deviceSelection) !== null && _a3 !== void 0 ? _a3 : {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedCam", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.enableMic = function(enable) {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, Promise, function() {
        var _this = this;
        return $fc49a56cd8739127$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._micEnabled = enable;
              if (!this._wavRecorder.stream)
                return [
                  2
                  /*return*/
                ];
              this._wavRecorder.stream.getAudioTracks().forEach(function(track2) {
                var _a4, _b;
                track2.enabled = enable;
                if (!enable)
                  (_b = (_a4 = _this._callbacks).onTrackStopped) === null || _b === void 0 || _b.call(_a4, track2, $fc49a56cd8739127$var$localParticipant());
              });
              if (!enable)
                return [
                  3,
                  2
                ];
              return [
                4,
                this._startRecording()
              ];
            case 1:
              _a3.sent();
              return [
                3,
                4
              ];
            case 2:
              return [
                4,
                this._wavRecorder.pause()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.enableCam = function(enable) {
    };
    Object.defineProperty(WavMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._micEnabled;
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.tracks = function() {
      var _a3;
      var tracks = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getTracks()[0];
      return {
        local: tracks ? {
          audio: tracks
        } : {}
      };
    };
    WavMediaManager.prototype._startRecording = function() {
      return $fc49a56cd8739127$var$__awaiter(this, void 0, void 0, function() {
        var track2;
        var _this = this;
        var _a3, _b, _c3;
        return $fc49a56cd8739127$var$__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [
                4,
                this._wavRecorder.record(function(data) {
                  _this._userAudioCallback(data.mono);
                }, this._recorderChunkSize)
              ];
            case 1:
              _d.sent();
              track2 = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getAudioTracks()[0];
              if (track2)
                (_c3 = (_b = this._callbacks).onTrackStarted) === null || _c3 === void 0 || _c3.call(_b, track2, $fc49a56cd8739127$var$localParticipant());
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype._handleAvailableDevicesUpdated = function(devices) {
      var _a3, _b, _c3, _d;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, devices.filter(function(d3) {
        return d3.kind === "videoinput";
      }));
      (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, devices.filter(function(d3) {
        return d3.kind === "audioinput";
      }));
      var defaultDevice = devices.find(function(d3) {
        return d3.deviceId === "default";
      });
      var currentDevice = this._wavRecorder.deviceSelection;
      if (currentDevice && (!devices.some(function(d3) {
        return d3.deviceId === currentDevice.deviceId;
      }) || currentDevice.deviceId === "default" && currentDevice.label !== (defaultDevice === null || defaultDevice === void 0 ? void 0 : defaultDevice.label)))
        this.updateMic("");
    };
    return WavMediaManager;
  }($fc49a56cd8739127$export$4a0c46dbbe2ddb67)
);
var $fc49a56cd8739127$var$localParticipant = function() {
  return {
    id: "local",
    name: "",
    local: true
  };
};
var $22ece045290c996a$var$__extends = function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var $22ece045290c996a$var$__awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $22ece045290c996a$var$__generator = function(thisArg, body) {
  var _4 = {
    label: 0,
    sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    },
    trys: [],
    ops: []
  }, f3, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([
        n3,
        v3
      ]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_4 = 0)), _4)
      try {
        if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [
            op[0] & 2,
            t3.value
          ];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _4.label++;
            y3 = op[1];
            op = [
              0
            ];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e4) {
        op = [
          6,
          e4
        ];
        y3 = 0;
      } finally {
        f3 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $22ece045290c996a$export$c95c65abc5f47125 = (
  /** @class */
  function(_super) {
    $22ece045290c996a$var$__extends(DailyMediaManager, _super);
    function DailyMediaManager(enablePlayer, enableRecording, onTrackStartedCallback, onTrackStoppedCallback, recorderChunkSize, recorderSampleRate) {
      if (enablePlayer === void 0)
        enablePlayer = true;
      if (enableRecording === void 0)
        enableRecording = true;
      if (recorderChunkSize === void 0)
        recorderChunkSize = void 0;
      if (recorderSampleRate === void 0)
        recorderSampleRate = 24e3;
      var _a3;
      var _this = _super.call(this) || this;
      _this._selectedCam = {};
      _this._selectedMic = {};
      _this._selectedSpeaker = {};
      _this._remoteAudioLevelInterval = null;
      _this._recorderChunkSize = void 0;
      _this._initialized = false;
      _this._connected = false;
      _this._currentAudioTrack = null;
      _this._connectResolve = null;
      _this.onTrackStartedCallback = onTrackStartedCallback;
      _this.onTrackStoppedCallback = onTrackStoppedCallback;
      _this._recorderChunkSize = recorderChunkSize;
      _this._daily = (_a3 = (0, ic).getCallInstance()) !== null && _a3 !== void 0 ? _a3 : (0, ic).createCallObject();
      if (enableRecording)
        _this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a482)({
          sampleRate: recorderSampleRate
        });
      if (enablePlayer)
        _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3662)({
          sampleRate: 24e3
        });
      _this._daily.on("track-started", _this.handleTrackStarted.bind(_this));
      _this._daily.on("track-stopped", _this.handleTrackStopped.bind(_this));
      _this._daily.on("available-devices-updated", _this._handleAvailableDevicesUpdated.bind(_this));
      _this._daily.on("selected-devices-updated", _this._handleSelectedDevicesUpdated.bind(_this));
      _this._daily.on("local-audio-level", _this._handleLocalAudioLevel.bind(_this));
      return _this;
    }
    DailyMediaManager.prototype.initialize = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var infos, devices, cams, mics, speakers;
        var _this = this;
        var _a3, _b, _c3, _d, _e3, _f, _g, _h, _j, _k, _l, _m;
        return $22ece045290c996a$var$__generator(this, function(_o3) {
          switch (_o3.label) {
            case 0:
              if (this._initialized) {
                console.warn("DailyMediaManager already initialized");
                return [
                  2
                  /*return*/
                ];
              }
              return [
                4,
                this._daily.startCamera({
                  startVideoOff: !this._camEnabled,
                  startAudioOff: !this._micEnabled
                })
              ];
            case 1:
              infos = _o3.sent();
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 2:
              devices = _o3.sent().devices;
              cams = devices.filter(function(d3) {
                return d3.kind === "videoinput";
              });
              mics = devices.filter(function(d3) {
                return d3.kind === "audioinput";
              });
              speakers = devices.filter(function(d3) {
                return d3.kind === "audiooutput";
              });
              (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, cams);
              (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, mics);
              (_f = (_e3 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e3, speakers);
              this._selectedCam = infos.camera;
              (_h = (_g = this._callbacks).onCamUpdated) === null || _h === void 0 || _h.call(_g, infos.camera);
              this._selectedMic = infos.mic;
              (_k = (_j = this._callbacks).onMicUpdated) === null || _k === void 0 || _k.call(_j, infos.mic);
              this._selectedSpeaker = infos.speaker;
              (_m = (_l = this._callbacks).onSpeakerUpdated) === null || _m === void 0 || _m.call(_l, infos.speaker);
              if (!!this._daily.isLocalAudioLevelObserverRunning())
                return [
                  3,
                  4
                ];
              return [
                4,
                this._daily.startLocalAudioLevelObserver(100)
              ];
            case 3:
              _o3.sent();
              _o3.label = 4;
            case 4:
              if (!this._wavStreamPlayer)
                return [
                  3,
                  6
                ];
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 5:
              _o3.sent();
              if (!this._remoteAudioLevelInterval)
                this._remoteAudioLevelInterval = setInterval(function() {
                  var _a4;
                  var frequencies = _this._wavStreamPlayer.getFrequencies();
                  var aveVal = 0;
                  if ((_a4 = frequencies.values) === null || _a4 === void 0 ? void 0 : _a4.length)
                    aveVal = frequencies.values.reduce(function(a3, c3) {
                      return a3 + c3;
                    }, 0) / frequencies.values.length;
                  _this._handleRemoteAudioLevel(aveVal);
                }, 100);
              _o3.label = 6;
            case 6:
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.connect = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _this = this;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          if (this._connected) {
            console.warn("DailyMediaManager already connected");
            return [
              2
              /*return*/
            ];
          }
          this._connected = true;
          if (!this._initialized)
            return [
              2,
              new Promise(function(resolve) {
                (function() {
                  return $22ece045290c996a$var$__awaiter(_this, void 0, void 0, function() {
                    return $22ece045290c996a$var$__generator(this, function(_a4) {
                      switch (_a4.label) {
                        case 0:
                          this._connectResolve = resolve;
                          return [
                            4,
                            this.initialize()
                          ];
                        case 1:
                          _a4.sent();
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                })();
              })
            ];
          if (this._micEnabled)
            this._startRecording();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.disconnect = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3, _b;
        return $22ece045290c996a$var$__generator(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              if (this._remoteAudioLevelInterval)
                clearInterval(this._remoteAudioLevelInterval);
              this._remoteAudioLevelInterval = null;
              this._daily.leave();
              this._currentAudioTrack = null;
              return [
                4,
                (_a3 = this._mediaStreamRecorder) === null || _a3 === void 0 ? void 0 : _a3.end()
              ];
            case 1:
              _c3.sent();
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.interrupt();
              this._initialized = false;
              this._connected = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.userStartedSpeaking = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator(this, function(_b) {
          return [
            2,
            (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.interrupt()
          ];
        });
      });
    };
    DailyMediaManager.prototype.bufferBotAudio = function(data, id) {
      var _a3;
      return (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.add16BitPCM(data, id);
    };
    DailyMediaManager.prototype.getAllMics = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audioinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllCams = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "videoinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllSpeakers = function() {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audiooutput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.updateMic = function(micId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        audioDeviceId: micId
      }).then(function(deviceInfo) {
        _this._selectedMic = deviceInfo.mic;
      });
    };
    DailyMediaManager.prototype.updateCam = function(camId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        videoDeviceId: camId
      }).then(function(deviceInfo) {
        _this._selectedCam = deviceInfo.camera;
      });
    };
    DailyMediaManager.prototype.updateSpeaker = function(speakerId) {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var sID, speakers, defaultSpeaker_1, defaultSpeakerCp;
        var _this = this;
        var _a3, _b;
        return $22ece045290c996a$var$__generator(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              if (speakerId !== "default" && this._selectedSpeaker.deviceId === speakerId)
                return [
                  2
                  /*return*/
                ];
              sID = speakerId;
              if (!(sID === "default"))
                return [
                  3,
                  2
                ];
              return [
                4,
                this.getAllSpeakers()
              ];
            case 1:
              speakers = _c3.sent();
              defaultSpeaker_1 = speakers.find(function(s3) {
                return s3.deviceId === "default";
              });
              if (!defaultSpeaker_1) {
                console.warn("No default speaker found");
                return [
                  2
                  /*return*/
                ];
              }
              speakers.splice(speakers.indexOf(defaultSpeaker_1), 1);
              defaultSpeakerCp = speakers.find(function(s3) {
                return defaultSpeaker_1.label.includes(s3.label);
              });
              sID = (_a3 = defaultSpeakerCp === null || defaultSpeakerCp === void 0 ? void 0 : defaultSpeakerCp.deviceId) !== null && _a3 !== void 0 ? _a3 : speakerId;
              _c3.label = 2;
            case 2:
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.updateSpeaker(sID).then(function() {
                var _a4, _b2;
                _this._selectedSpeaker = {
                  deviceId: speakerId
                };
                (_b2 = (_a4 = _this._callbacks).onSpeakerUpdated) === null || _b2 === void 0 || _b2.call(_a4, _this._selectedSpeaker);
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Object.defineProperty(DailyMediaManager.prototype, "selectedMic", {
      get: function() {
        return this._selectedMic;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedCam", {
      get: function() {
        return this._selectedCam;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return this._selectedSpeaker;
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.enableMic = function(enable) {
      return $22ece045290c996a$var$__awaiter(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator(this, function(_b) {
          this._micEnabled = enable;
          if (!((_a3 = this._daily.participants()) === null || _a3 === void 0 ? void 0 : _a3.local))
            return [
              2
              /*return*/
            ];
          this._daily.setLocalAudio(enable);
          if (this._mediaStreamRecorder) {
            if (enable) {
              if (this._mediaStreamRecorder.getStatus() === "paused")
                this._startRecording();
            } else if (this._mediaStreamRecorder.getStatus() === "recording")
              this._mediaStreamRecorder.pause();
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.enableCam = function(enable) {
      this._camEnabled = enable;
      this._daily.setLocalVideo(enable);
    };
    Object.defineProperty(DailyMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return this._daily.localVideo();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._daily.localAudio();
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.tracks = function() {
      var _a3, _b, _c3, _d, _e3, _f;
      var participants = this._daily.participants();
      return {
        local: {
          audio: (_c3 = (_b = (_a3 = participants === null || participants === void 0 ? void 0 : participants.local) === null || _a3 === void 0 ? void 0 : _a3.tracks) === null || _b === void 0 ? void 0 : _b.audio) === null || _c3 === void 0 ? void 0 : _c3.persistentTrack,
          video: (_f = (_e3 = (_d = participants === null || participants === void 0 ? void 0 : participants.local) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e3 === void 0 ? void 0 : _e3.video) === null || _f === void 0 ? void 0 : _f.persistentTrack
        }
      };
    };
    DailyMediaManager.prototype._startRecording = function() {
      var _this = this;
      if (!this._connected || !this._mediaStreamRecorder)
        return;
      try {
        this._mediaStreamRecorder.record(function(data) {
          _this._userAudioCallback(data.mono);
        }, this._recorderChunkSize);
      } catch (e4) {
        var err = e4;
        if (!err.message.includes("Already recording"))
          console.error("Error starting recording", e4);
      }
    };
    DailyMediaManager.prototype._handleAvailableDevicesUpdated = function(event) {
      var _a3, _b, _c3, _d, _e3, _f;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, event.availableDevices.filter(function(d3) {
        return d3.kind === "videoinput";
      }));
      (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, event.availableDevices.filter(function(d3) {
        return d3.kind === "audioinput";
      }));
      (_f = (_e3 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e3, event.availableDevices.filter(function(d3) {
        return d3.kind === "audiooutput";
      }));
      if (this._selectedSpeaker.deviceId === "default")
        this.updateSpeaker("default");
    };
    DailyMediaManager.prototype._handleSelectedDevicesUpdated = function(event) {
      var _a3, _b, _c3, _d, _e3, _f;
      if (((_a3 = this._selectedCam) === null || _a3 === void 0 ? void 0 : _a3.deviceId) !== event.devices.camera) {
        this._selectedCam = event.devices.camera;
        (_c3 = (_b = this._callbacks).onCamUpdated) === null || _c3 === void 0 || _c3.call(_b, event.devices.camera);
      }
      if (((_d = this._selectedMic) === null || _d === void 0 ? void 0 : _d.deviceId) !== event.devices.mic) {
        this._selectedMic = event.devices.mic;
        (_f = (_e3 = this._callbacks).onMicUpdated) === null || _f === void 0 || _f.call(_e3, event.devices.mic);
      }
    };
    DailyMediaManager.prototype._handleLocalAudioLevel = function(ev) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onLocalAudioLevel) === null || _b === void 0 || _b.call(_a3, ev.audioLevel);
    };
    DailyMediaManager.prototype._handleRemoteAudioLevel = function(audioLevel) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onRemoteAudioLevel) === null || _b === void 0 || _b.call(_a3, audioLevel, $22ece045290c996a$var$botParticipant());
    };
    DailyMediaManager.prototype.handleTrackStarted = function(event) {
      return $22ece045290c996a$var$__awaiter(this, void 0, void 0, function() {
        var status, _a3;
        var _b, _c3, _d, _e3;
        return $22ece045290c996a$var$__generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              if (!((_b = event.participant) === null || _b === void 0 ? void 0 : _b.local))
                return [
                  2
                  /*return*/
                ];
              if (!(event.track.kind === "audio"))
                return [
                  3,
                  10
                ];
              if (!this._mediaStreamRecorder)
                return [
                  3,
                  9
                ];
              status = this._mediaStreamRecorder.getStatus();
              _a3 = status;
              switch (_a3) {
                case "ended":
                  return [
                    3,
                    1
                  ];
                case "paused":
                  return [
                    3,
                    3
                  ];
                case "recording":
                  return [
                    3,
                    4
                  ];
              }
              return [
                3,
                4
              ];
            case 1:
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 2:
              _f.sent();
              if (this._connected) {
                this._startRecording();
                if (this._connectResolve) {
                  this._connectResolve();
                  this._connectResolve = null;
                }
              }
              return [
                3,
                9
              ];
            case 3:
              this._startRecording();
              return [
                3,
                9
              ];
            case 4:
              if (!(this._currentAudioTrack !== event.track))
                return [
                  3,
                  7
                ];
              return [
                4,
                this._mediaStreamRecorder.end()
              ];
            case 5:
              _f.sent();
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 6:
              _f.sent();
              this._startRecording();
              return [
                3,
                8
              ];
            case 7:
              console.warn("track-started event received for current track and already recording");
              _f.label = 8;
            case 8:
              return [
                3,
                9
              ];
            case 9:
              this._currentAudioTrack = event.track;
              _f.label = 10;
            case 10:
              (_d = (_c3 = this._callbacks).onTrackStarted) === null || _d === void 0 || _d.call(_c3, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : void 0);
              (_e3 = this.onTrackStartedCallback) === null || _e3 === void 0 || _e3.call(this, event);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.handleTrackStopped = function(event) {
      var _a3, _b, _c3, _d;
      if (!((_a3 = event.participant) === null || _a3 === void 0 ? void 0 : _a3.local))
        return;
      if (event.track.kind === "audio") {
        if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() === "recording")
          this._mediaStreamRecorder.pause();
      }
      (_c3 = (_b = this._callbacks).onTrackStopped) === null || _c3 === void 0 || _c3.call(_b, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant(event.participant) : void 0);
      (_d = this.onTrackStoppedCallback) === null || _d === void 0 || _d.call(this, event);
    };
    return DailyMediaManager;
  }((0, $fc49a56cd8739127$export$4a0c46dbbe2ddb67))
);
var $22ece045290c996a$var$dailyParticipantToParticipant = function(p3) {
  return {
    id: p3.user_id,
    local: p3.local,
    name: p3.user_name
  };
};
var $22ece045290c996a$var$botParticipant = function() {
  return {
    id: "bot",
    local: false,
    name: "Bot"
  };
};
var $b31644dc78dca54a$var$TrackStatusMessage = class {
  constructor(receiver_index, enabled) {
    this.type = "trackStatus";
    this.receiver_index = receiver_index;
    this.enabled = enabled;
  }
};
var $b31644dc78dca54a$var$RENEGOTIATE_TYPE = "renegotiate";
var $b31644dc78dca54a$var$PEER_LEFT_TYPE = "peerLeft";
var $b31644dc78dca54a$var$SIGNALLING_TYPE = "signalling";
var $b31644dc78dca54a$var$SignallingMessageObject = class {
  constructor(message) {
    this.type = $b31644dc78dca54a$var$SIGNALLING_TYPE;
    this.message = message;
  }
};
var $b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX = 0;
var $b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX = 1;
var $b31644dc78dca54a$export$62043589d053a879 = class _$b31644dc78dca54a$export$62043589d053a879 extends (0, $4086f06442fcb7d7$export$86495b081fef8e52) {
  constructor({ iceServers = [], waitForICEGathering = false } = {}) {
    super();
    this._connectResolved = null;
    this._connectFailed = null;
    this.pc = null;
    this.dc = null;
    this.audioCodec = null;
    this.videoCodec = null;
    this.pc_id = null;
    this.reconnectionAttempts = 0;
    this.maxReconnectionAttempts = 3;
    this.isReconnecting = false;
    this.keepAliveInterval = null;
    this._iceServers = [];
    this._iceServers = iceServers;
    this._waitForICEGathering = waitForICEGathering;
    this.mediaManager = new (0, $22ece045290c996a$export$c95c65abc5f47125)(false, false, async (event) => {
      if (!this.pc)
        return;
      if (event.type == "audio") {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).info("SmallWebRTCMediaManager replacing audio track");
        await this.getAudioTransceiver().sender.replaceTrack(event.track);
      } else if (event.type == "video") {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).info("SmallWebRTCMediaManager replacing video track");
        await this.getVideoTransceiver().sender.replaceTrack(event.track);
      }
    }, (event) => (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("SmallWebRTCMediaManager Track stopped:", event));
  }
  initialize(options, messageHandler) {
    this._options = options;
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    this.mediaManager.setRTVIOptions(options);
    if (this._options.params.config?.length || false) {
      let config = this._options.params.config[0];
      if (config.service == _$b31644dc78dca54a$export$62043589d053a879.SERVICE_NAME && config.options.length > 0)
        config.options.forEach((option) => {
          if (option.name == "audioCodec")
            this.audioCodec = option.value;
          else if (option.name == "videoCodec")
            this.videoCodec = option.value;
        });
    }
    this.state = "disconnected";
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[RTVI Transport] Initialized");
  }
  async initDevices() {
    this.state = "initializing";
    await this.mediaManager.initialize();
    this.state = "initialized";
  }
  setAudioCodec(audioCodec) {
    this.audioCodec = audioCodec;
  }
  setVideoCodec(videoCodec) {
    this.videoCodec = videoCodec;
  }
  async connect(authBundle, abortController) {
    if (abortController.signal.aborted)
      return;
    this.state = "connecting";
    await this.mediaManager.connect();
    await this.startNewPeerConnection();
    if (abortController.signal.aborted)
      return;
    await new Promise((resolve, reject) => {
      this._connectResolved = resolve;
      this._connectFailed = reject;
    });
    this.state = "connected";
    this._callbacks.onConnected?.();
  }
  syncTrackStatus() {
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX, this.mediaManager.isMicEnabled));
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX, this.mediaManager.isCamEnabled));
  }
  sendReadyMessage() {
    this.state = "ready";
    this.sendMessage((0, $b48f893ed1354c1e$export$69aa9ab0334b212).clientReady());
  }
  sendMessage(message) {
    if (!this.dc || this.dc.readyState !== "open") {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn(`Datachannel is not ready. Message not sent: ${message}`);
      return;
    }
    this.dc?.send(JSON.stringify(message));
  }
  sendSignallingMessage(message) {
    if (!this.dc || this.dc.readyState !== "open") {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn(`Datachannel is not ready. Message not sent: ${message}`);
      return;
    }
    const signallingMessage = new $b31644dc78dca54a$var$SignallingMessageObject(message);
    this.dc?.send(JSON.stringify(signallingMessage));
  }
  async disconnect() {
    this.state = "disconnecting";
    await this.stop();
    this.state = "disconnected";
  }
  createPeerConnection() {
    const config = {
      iceServers: this._iceServers
    };
    let pc3 = new RTCPeerConnection(config);
    pc3.addEventListener("icegatheringstatechange", () => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`iceGatheringState: ${this.pc.iceGatheringState}`);
    });
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`iceGatheringState: ${pc3.iceGatheringState}`);
    pc3.addEventListener("iceconnectionstatechange", () => this.handleICEConnectionStateChange());
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`iceConnectionState: ${pc3.iceConnectionState}`);
    pc3.addEventListener("signalingstatechange", () => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`signalingState: ${this.pc.signalingState}`);
      if (this.pc.signalingState == "stable")
        this.handleReconnectionCompleted();
    });
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`signalingState: ${pc3.signalingState}`);
    pc3.addEventListener("track", (evt) => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Received new track ${evt.track.kind}`);
      this._callbacks.onTrackStarted?.(evt.track);
    });
    return pc3;
  }
  handleICEConnectionStateChange() {
    if (!this.pc)
      return;
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`ICE Connection State: ${this.pc.iceConnectionState}`);
    if (this.pc.iceConnectionState === "failed") {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("ICE connection failed, attempting restart.");
      this.attemptReconnection(true);
    } else if (this.pc.iceConnectionState === "disconnected")
      setTimeout(() => {
        if (this.pc?.iceConnectionState === "disconnected") {
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Still disconnected, attempting reconnection.");
          this.attemptReconnection(true);
        }
      }, 5e3);
  }
  handleReconnectionCompleted() {
    this.reconnectionAttempts = 0;
    this.isReconnecting = false;
  }
  async attemptReconnection(recreatePeerConnection = false) {
    if (this.isReconnecting) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Reconnection already in progress, skipping.");
      return;
    }
    if (this.reconnectionAttempts >= this.maxReconnectionAttempts) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Max reconnection attempts reached. Stopping transport.");
      await this.stop();
      return;
    }
    this.isReconnecting = true;
    this.reconnectionAttempts++;
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Reconnection attempt ${this.reconnectionAttempts}...`);
    if (recreatePeerConnection) {
      const oldPC = this.pc;
      await this.startNewPeerConnection(recreatePeerConnection);
      if (oldPC) {
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("closing old peer connection");
        this.closePeerConnection(oldPC);
      }
    } else
      await this.negotiate();
  }
  async negotiate(recreatePeerConnection = false) {
    if (!this.pc)
      return Promise.reject("Peer connection is not initialized");
    try {
      const offer = await this.pc.createOffer();
      await this.pc.setLocalDescription(offer);
      if (this._waitForICEGathering)
        await new Promise((resolve) => {
          if (this.pc.iceGatheringState === "complete")
            resolve();
          else {
            const checkState = () => {
              if (this.pc.iceGatheringState === "complete") {
                this.pc.removeEventListener("icegatheringstatechange", checkState);
                resolve();
              }
            };
            this.pc.addEventListener("icegatheringstatechange", checkState);
          }
        });
      let offerSdp = this.pc.localDescription;
      if (this.audioCodec && this.audioCodec !== "default")
        offerSdp.sdp = this.sdpFilterCodec("audio", this.audioCodec, offerSdp.sdp);
      if (this.videoCodec && this.videoCodec !== "default")
        offerSdp.sdp = this.sdpFilterCodec("video", this.videoCodec, offerSdp.sdp);
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Will create offer for peerId: ${this.pc_id}`);
      const url = `${this._options.params.baseUrl}${this._options.params.endpoints?.connect || ""}`;
      const response = await fetch(url, {
        body: JSON.stringify({
          sdp: offerSdp.sdp,
          type: offerSdp.type,
          pc_id: this.pc_id,
          restart_pc: recreatePeerConnection
        }),
        headers: {
          "Content-Type": "application/json"
        },
        method: "POST"
      });
      const answer = await response.json();
      this.pc_id = answer.pc_id;
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Received answer for peer connection id ${answer.pc_id}`);
      await this.pc.setRemoteDescription(answer);
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Remote candidate supports trickle ice: ${this.pc.canTrickleIceCandidates}`);
    } catch (e4) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`Reconnection attempt ${this.reconnectionAttempts} failed: ${e4}`);
      this.isReconnecting = false;
      setTimeout(() => this.attemptReconnection(true), 2e3);
    }
  }
  addInitialTransceivers() {
    this.pc.addTransceiver("audio", {
      direction: "sendrecv"
    });
    this.pc.addTransceiver("video", {
      direction: "sendrecv"
    });
  }
  getAudioTransceiver() {
    return this.pc.getTransceivers()[$b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX];
  }
  getVideoTransceiver() {
    return this.pc.getTransceivers()[$b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX];
  }
  async startNewPeerConnection(recreatePeerConnection = false) {
    this.pc = this.createPeerConnection();
    this.addInitialTransceivers();
    this.dc = this.createDataChannel("chat", {
      ordered: true
    });
    await this.addUserMedia();
    await this.negotiate(recreatePeerConnection);
  }
  async addUserMedia() {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`addUserMedia this.tracks(): ${this.tracks()}`);
    let audioTrack = this.tracks().local.audio;
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`addUserMedia audioTrack: ${audioTrack}`);
    if (audioTrack)
      await this.getAudioTransceiver().sender.replaceTrack(audioTrack);
    let videoTrack = this.tracks().local.video;
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`addUserMedia videoTrack: ${videoTrack}`);
    if (videoTrack)
      await this.getVideoTransceiver().sender.replaceTrack(videoTrack);
  }
  // Method to handle a general message (this can be expanded for other types of messages)
  handleMessage(message) {
    try {
      const messageObj = JSON.parse(message);
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("received message:", messageObj);
      if (messageObj.type === $b31644dc78dca54a$var$SIGNALLING_TYPE)
        this.handleSignallingMessage(messageObj);
      else if (messageObj.label === "rtvi-ai")
        this._onMessage({
          id: messageObj.id,
          type: messageObj.type,
          data: messageObj.data
        });
    } catch (error) {
      console.error("Failed to parse JSON message:", error);
    }
  }
  // Method to handle signalling messages specifically
  async handleSignallingMessage(messageObj) {
    const signallingMessage = messageObj;
    switch (signallingMessage.message.type) {
      case $b31644dc78dca54a$var$RENEGOTIATE_TYPE:
        this.attemptReconnection(false);
        break;
      case $b31644dc78dca54a$var$PEER_LEFT_TYPE:
        this.disconnect();
        break;
      default:
        console.warn("Unknown signalling message:", signallingMessage.message);
    }
  }
  createDataChannel(label, options) {
    const dc3 = this.pc.createDataChannel(label, options);
    dc3.addEventListener("close", () => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("datachannel closed");
      if (this.keepAliveInterval) {
        clearInterval(this.keepAliveInterval);
        this.keepAliveInterval = null;
      }
    });
    dc3.addEventListener("open", () => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("datachannel opened");
      if (this._connectResolved) {
        this.syncTrackStatus();
        this._connectResolved();
        this._connectResolved = null;
        this._connectFailed = null;
      }
      this.keepAliveInterval = setInterval(() => {
        const message = "ping: " + (/* @__PURE__ */ new Date()).getTime();
        dc3.send(message);
      }, 1e3);
    });
    dc3.addEventListener("message", (evt) => {
      let message = evt.data;
      this.handleMessage(message);
    });
    return dc3;
  }
  closePeerConnection(pc3) {
    pc3.getTransceivers().forEach((transceiver) => {
      if (transceiver.stop)
        transceiver.stop();
    });
    pc3.getSenders().forEach((sender) => {
      sender.track?.stop();
    });
    pc3.close();
  }
  async stop() {
    if (!this.pc) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("Peer connection is already closed or null.");
      return;
    }
    if (this.dc)
      this.dc.close();
    this.closePeerConnection(this.pc);
    this.pc = null;
    await this.mediaManager.disconnect();
    this.pc_id = null;
    this.reconnectionAttempts = 0;
    this.isReconnecting = false;
    this._callbacks.onDisconnected?.();
    if (this._connectFailed)
      this._connectFailed();
    this._connectFailed = null;
    this._connectResolved = null;
  }
  getAllMics() {
    return this.mediaManager.getAllMics();
  }
  getAllCams() {
    return this.mediaManager.getAllCams();
  }
  getAllSpeakers() {
    return this.mediaManager.getAllSpeakers();
  }
  async updateMic(micId) {
    return this.mediaManager.updateMic(micId);
  }
  updateCam(camId) {
    return this.mediaManager.updateCam(camId);
  }
  updateSpeaker(speakerId) {
    return this.mediaManager.updateSpeaker(speakerId);
  }
  get selectedMic() {
    return this.mediaManager.selectedMic;
  }
  get selectedCam() {
    return this.mediaManager.selectedCam;
  }
  get selectedSpeaker() {
    return this.mediaManager.selectedSpeaker;
  }
  set iceServers(iceServers) {
    this._iceServers = iceServers;
  }
  get iceServers() {
    return this._iceServers;
  }
  enableMic(enable) {
    this.mediaManager.enableMic(enable);
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$AUDIO_TRANSCEIVER_INDEX, enable));
  }
  enableCam(enable) {
    this.mediaManager.enableCam(enable);
    this.sendSignallingMessage(new $b31644dc78dca54a$var$TrackStatusMessage($b31644dc78dca54a$var$VIDEO_TRANSCEIVER_INDEX, enable));
  }
  get isCamEnabled() {
    return this.mediaManager.isCamEnabled;
  }
  get isMicEnabled() {
    return this.mediaManager.isMicEnabled;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    if (this._state === state)
      return;
    this._state = state;
    this._callbacks.onTransportStateChanged?.(state);
  }
  get expiry() {
    return this._expiry;
  }
  tracks() {
    return this.mediaManager.tracks();
  }
  // Not implemented
  enableScreenShare(enable) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("startScreenShare not implemented for SmallWebRTCTransport");
    throw new Error("Not implemented");
  }
  get isSharingScreen() {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("isSharingScreen not implemented for SmallWebRTCTransport");
    return false;
  }
  sdpFilterCodec(kind, codec, realSdp) {
    const allowed = [];
    const rtxRegex = new RegExp("a=fmtp:(\\d+) apt=(\\d+)\\r$");
    const codecRegex = new RegExp("a=rtpmap:([0-9]+) " + this.escapeRegExp(codec));
    const videoRegex = new RegExp("(m=" + kind + " .*?)( ([0-9]+))*\\s*$");
    const lines = realSdp.split("\n");
    let isKind = false;
    for (let i3 = 0; i3 < lines.length; i3++) {
      if (lines[i3].startsWith("m=" + kind + " "))
        isKind = true;
      else if (lines[i3].startsWith("m="))
        isKind = false;
      if (isKind) {
        const match = lines[i3].match(codecRegex);
        if (match)
          allowed.push(parseInt(match[1]));
        const matchRtx = lines[i3].match(rtxRegex);
        if (matchRtx && allowed.includes(parseInt(matchRtx[2])))
          allowed.push(parseInt(matchRtx[1]));
      }
    }
    const skipRegex = "a=(fmtp|rtcp-fb|rtpmap):([0-9]+)";
    let sdp2 = "";
    isKind = false;
    for (let i3 = 0; i3 < lines.length; i3++) {
      if (lines[i3].startsWith("m=" + kind + " "))
        isKind = true;
      else if (lines[i3].startsWith("m="))
        isKind = false;
      if (isKind) {
        const skipMatch = lines[i3].match(skipRegex);
        if (skipMatch && !allowed.includes(parseInt(skipMatch[2])))
          continue;
        else if (lines[i3].match(videoRegex))
          sdp2 += lines[i3].replace(videoRegex, "$1 " + allowed.join(" ")) + "\n";
        else
          sdp2 += lines[i3] + "\n";
      } else
        sdp2 += lines[i3] + "\n";
    }
    return sdp2;
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
$b31644dc78dca54a$export$62043589d053a879.SERVICE_NAME = "small-webrtc-transport";

// ../node_modules/@pipecat-ai/gemini-live-websocket-transport/node_modules/@daily-co/daily-js/dist/daily-esm.js
function e2(e4, t3) {
  if (null == e4)
    return {};
  var n3, r4, i3 = function(e5, t4) {
    if (null == e5)
      return {};
    var n4 = {};
    for (var r5 in e5)
      if ({}.hasOwnProperty.call(e5, r5)) {
        if (-1 !== t4.indexOf(r5))
          continue;
        n4[r5] = e5[r5];
      }
    return n4;
  }(e4, t3);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e4);
    for (r4 = 0; r4 < o4.length; r4++)
      n3 = o4[r4], -1 === t3.indexOf(n3) && {}.propertyIsEnumerable.call(e4, n3) && (i3[n3] = e4[n3]);
  }
  return i3;
}
function t2(e4, t3) {
  if (!(e4 instanceof t3))
    throw new TypeError("Cannot call a class as a function");
}
function n2(e4) {
  return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
    return typeof e5;
  } : function(e5) {
    return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
  }, n2(e4);
}
function r2(e4) {
  var t3 = function(e5, t4) {
    if ("object" != n2(e5) || !e5)
      return e5;
    var r4 = e5[Symbol.toPrimitive];
    if (void 0 !== r4) {
      var i3 = r4.call(e5, t4 || "default");
      if ("object" != n2(i3))
        return i3;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t4 ? String : Number)(e5);
  }(e4, "string");
  return "symbol" == n2(t3) ? t3 : t3 + "";
}
function i2(e4, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var i3 = t3[n3];
    i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e4, r2(i3.key), i3);
  }
}
function o2(e4, t3, n3) {
  return t3 && i2(e4.prototype, t3), n3 && i2(e4, n3), Object.defineProperty(e4, "prototype", { writable: false }), e4;
}
function s2(e4, t3) {
  if (t3 && ("object" == n2(t3) || "function" == typeof t3))
    return t3;
  if (void 0 !== t3)
    throw new TypeError("Derived constructors may only return object or undefined");
  return function(e5) {
    if (void 0 === e5)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e5;
  }(e4);
}
function a2(e4) {
  return a2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
    return e5.__proto__ || Object.getPrototypeOf(e5);
  }, a2(e4);
}
function c2(e4, t3) {
  return c2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t4) {
    return e5.__proto__ = t4, e5;
  }, c2(e4, t3);
}
function l2(e4, t3) {
  if ("function" != typeof t3 && null !== t3)
    throw new TypeError("Super expression must either be null or a function");
  e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t3 && c2(e4, t3);
}
function u2(e4, t3, n3) {
  return (t3 = r2(t3)) in e4 ? Object.defineProperty(e4, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e4[t3] = n3, e4;
}
function d2(e4, t3, n3, r4, i3, o4, s3) {
  try {
    var a3 = e4[o4](s3), c3 = a3.value;
  } catch (e5) {
    return void n3(e5);
  }
  a3.done ? t3(c3) : Promise.resolve(c3).then(r4, i3);
}
function h2(e4) {
  return function() {
    var t3 = this, n3 = arguments;
    return new Promise(function(r4, i3) {
      var o4 = e4.apply(t3, n3);
      function s3(e5) {
        d2(o4, r4, i3, s3, a3, "next", e5);
      }
      function a3(e5) {
        d2(o4, r4, i3, s3, a3, "throw", e5);
      }
      s3(void 0);
    });
  };
}
function p2(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
function f2(e4, t3) {
  return function(e5) {
    if (Array.isArray(e5))
      return e5;
  }(e4) || function(e5, t4) {
    var n3 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
    if (null != n3) {
      var r4, i3, o4, s3, a3 = [], c3 = true, l3 = false;
      try {
        if (o4 = (n3 = n3.call(e5)).next, 0 === t4) {
          if (Object(n3) !== n3)
            return;
          c3 = false;
        } else
          for (; !(c3 = (r4 = o4.call(n3)).done) && (a3.push(r4.value), a3.length !== t4); c3 = true)
            ;
      } catch (e6) {
        l3 = true, i3 = e6;
      } finally {
        try {
          if (!c3 && null != n3.return && (s3 = n3.return(), Object(s3) !== s3))
            return;
        } finally {
          if (l3)
            throw i3;
        }
      }
      return a3;
    }
  }(e4, t3) || function(e5, t4) {
    if (e5) {
      if ("string" == typeof e5)
        return p2(e5, t4);
      var n3 = {}.toString.call(e5).slice(8, -1);
      return "Object" === n3 && e5.constructor && (n3 = e5.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e5) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? p2(e5, t4) : void 0;
    }
  }(e4, t3) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function v2(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
var g2;
var m2 = { exports: {} };
var y2 = "object" == typeof Reflect ? Reflect : null;
var b2 = y2 && "function" == typeof y2.apply ? y2.apply : function(e4, t3, n3) {
  return Function.prototype.apply.call(e4, t3, n3);
};
g2 = y2 && "function" == typeof y2.ownKeys ? y2.ownKeys : Object.getOwnPropertySymbols ? function(e4) {
  return Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4));
} : function(e4) {
  return Object.getOwnPropertyNames(e4);
};
var _2 = Number.isNaN || function(e4) {
  return e4 != e4;
};
function w2() {
  w2.init.call(this);
}
m2.exports = w2, m2.exports.once = function(e4, t3) {
  return new Promise(function(n3, r4) {
    function i3(n4) {
      e4.removeListener(t3, o4), r4(n4);
    }
    function o4() {
      "function" == typeof e4.removeListener && e4.removeListener("error", i3), n3([].slice.call(arguments));
    }
    j2(e4, t3, o4, { once: true }), "error" !== t3 && function(e5, t4, n4) {
      "function" == typeof e5.on && j2(e5, "error", t4, n4);
    }(e4, i3, { once: true });
  });
}, w2.EventEmitter = w2, w2.prototype._events = void 0, w2.prototype._eventsCount = 0, w2.prototype._maxListeners = void 0;
var S2 = 10;
function k2(e4) {
  if ("function" != typeof e4)
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e4);
}
function M2(e4) {
  return void 0 === e4._maxListeners ? w2.defaultMaxListeners : e4._maxListeners;
}
function C2(e4, t3, n3, r4) {
  var i3, o4, s3, a3;
  if (k2(n3), void 0 === (o4 = e4._events) ? (o4 = e4._events = /* @__PURE__ */ Object.create(null), e4._eventsCount = 0) : (void 0 !== o4.newListener && (e4.emit("newListener", t3, n3.listener ? n3.listener : n3), o4 = e4._events), s3 = o4[t3]), void 0 === s3)
    s3 = o4[t3] = n3, ++e4._eventsCount;
  else if ("function" == typeof s3 ? s3 = o4[t3] = r4 ? [n3, s3] : [s3, n3] : r4 ? s3.unshift(n3) : s3.push(n3), (i3 = M2(e4)) > 0 && s3.length > i3 && !s3.warned) {
    s3.warned = true;
    var c3 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c3.name = "MaxListenersExceededWarning", c3.emitter = e4, c3.type = t3, c3.count = s3.length, a3 = c3, console && console.warn && console.warn(a3);
  }
  return e4;
}
function E2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function T2(e4, t3, n3) {
  var r4 = { fired: false, wrapFn: void 0, target: e4, type: t3, listener: n3 }, i3 = E2.bind(r4);
  return i3.listener = n3, r4.wrapFn = i3, i3;
}
function O2(e4, t3, n3) {
  var r4 = e4._events;
  if (void 0 === r4)
    return [];
  var i3 = r4[t3];
  return void 0 === i3 ? [] : "function" == typeof i3 ? n3 ? [i3.listener || i3] : [i3] : n3 ? function(e5) {
    for (var t4 = new Array(e5.length), n4 = 0; n4 < t4.length; ++n4)
      t4[n4] = e5[n4].listener || e5[n4];
    return t4;
  }(i3) : A2(i3, i3.length);
}
function P2(e4) {
  var t3 = this._events;
  if (void 0 !== t3) {
    var n3 = t3[e4];
    if ("function" == typeof n3)
      return 1;
    if (void 0 !== n3)
      return n3.length;
  }
  return 0;
}
function A2(e4, t3) {
  for (var n3 = new Array(t3), r4 = 0; r4 < t3; ++r4)
    n3[r4] = e4[r4];
  return n3;
}
function j2(e4, t3, n3, r4) {
  if ("function" == typeof e4.on)
    r4.once ? e4.once(t3, n3) : e4.on(t3, n3);
  else {
    if ("function" != typeof e4.addEventListener)
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e4);
    e4.addEventListener(t3, function i3(o4) {
      r4.once && e4.removeEventListener(t3, i3), n3(o4);
    });
  }
}
Object.defineProperty(w2, "defaultMaxListeners", { enumerable: true, get: function() {
  return S2;
}, set: function(e4) {
  if ("number" != typeof e4 || e4 < 0 || _2(e4))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e4 + ".");
  S2 = e4;
} }), w2.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, w2.prototype.setMaxListeners = function(e4) {
  if ("number" != typeof e4 || e4 < 0 || _2(e4))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e4 + ".");
  return this._maxListeners = e4, this;
}, w2.prototype.getMaxListeners = function() {
  return M2(this);
}, w2.prototype.emit = function(e4) {
  for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
    t3.push(arguments[n3]);
  var r4 = "error" === e4, i3 = this._events;
  if (void 0 !== i3)
    r4 = r4 && void 0 === i3.error;
  else if (!r4)
    return false;
  if (r4) {
    var o4;
    if (t3.length > 0 && (o4 = t3[0]), o4 instanceof Error)
      throw o4;
    var s3 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
    throw s3.context = o4, s3;
  }
  var a3 = i3[e4];
  if (void 0 === a3)
    return false;
  if ("function" == typeof a3)
    b2(a3, this, t3);
  else {
    var c3 = a3.length, l3 = A2(a3, c3);
    for (n3 = 0; n3 < c3; ++n3)
      b2(l3[n3], this, t3);
  }
  return true;
}, w2.prototype.addListener = function(e4, t3) {
  return C2(this, e4, t3, false);
}, w2.prototype.on = w2.prototype.addListener, w2.prototype.prependListener = function(e4, t3) {
  return C2(this, e4, t3, true);
}, w2.prototype.once = function(e4, t3) {
  return k2(t3), this.on(e4, T2(this, e4, t3)), this;
}, w2.prototype.prependOnceListener = function(e4, t3) {
  return k2(t3), this.prependListener(e4, T2(this, e4, t3)), this;
}, w2.prototype.removeListener = function(e4, t3) {
  var n3, r4, i3, o4, s3;
  if (k2(t3), void 0 === (r4 = this._events))
    return this;
  if (void 0 === (n3 = r4[e4]))
    return this;
  if (n3 === t3 || n3.listener === t3)
    0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r4[e4], r4.removeListener && this.emit("removeListener", e4, n3.listener || t3));
  else if ("function" != typeof n3) {
    for (i3 = -1, o4 = n3.length - 1; o4 >= 0; o4--)
      if (n3[o4] === t3 || n3[o4].listener === t3) {
        s3 = n3[o4].listener, i3 = o4;
        break;
      }
    if (i3 < 0)
      return this;
    0 === i3 ? n3.shift() : function(e5, t4) {
      for (; t4 + 1 < e5.length; t4++)
        e5[t4] = e5[t4 + 1];
      e5.pop();
    }(n3, i3), 1 === n3.length && (r4[e4] = n3[0]), void 0 !== r4.removeListener && this.emit("removeListener", e4, s3 || t3);
  }
  return this;
}, w2.prototype.off = w2.prototype.removeListener, w2.prototype.removeAllListeners = function(e4) {
  var t3, n3, r4;
  if (void 0 === (n3 = this._events))
    return this;
  if (void 0 === n3.removeListener)
    return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e4] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e4]), this;
  if (0 === arguments.length) {
    var i3, o4 = Object.keys(n3);
    for (r4 = 0; r4 < o4.length; ++r4)
      "removeListener" !== (i3 = o4[r4]) && this.removeAllListeners(i3);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t3 = n3[e4]))
    this.removeListener(e4, t3);
  else if (void 0 !== t3)
    for (r4 = t3.length - 1; r4 >= 0; r4--)
      this.removeListener(e4, t3[r4]);
  return this;
}, w2.prototype.listeners = function(e4) {
  return O2(this, e4, true);
}, w2.prototype.rawListeners = function(e4) {
  return O2(this, e4, false);
}, w2.listenerCount = function(e4, t3) {
  return "function" == typeof e4.listenerCount ? e4.listenerCount(t3) : P2.call(e4, t3);
}, w2.prototype.listenerCount = P2, w2.prototype.eventNames = function() {
  return this._eventsCount > 0 ? g2(this._events) : [];
};
var I2 = m2.exports;
var x2 = v2(I2);
var L2 = Object.prototype.hasOwnProperty;
function D2(e4, t3, n3) {
  for (n3 of e4.keys())
    if (N2(n3, t3))
      return n3;
}
function N2(e4, t3) {
  var n3, r4, i3;
  if (e4 === t3)
    return true;
  if (e4 && t3 && (n3 = e4.constructor) === t3.constructor) {
    if (n3 === Date)
      return e4.getTime() === t3.getTime();
    if (n3 === RegExp)
      return e4.toString() === t3.toString();
    if (n3 === Array) {
      if ((r4 = e4.length) === t3.length)
        for (; r4-- && N2(e4[r4], t3[r4]); )
          ;
      return -1 === r4;
    }
    if (n3 === Set) {
      if (e4.size !== t3.size)
        return false;
      for (r4 of e4) {
        if ((i3 = r4) && "object" == typeof i3 && !(i3 = D2(t3, i3)))
          return false;
        if (!t3.has(i3))
          return false;
      }
      return true;
    }
    if (n3 === Map) {
      if (e4.size !== t3.size)
        return false;
      for (r4 of e4) {
        if ((i3 = r4[0]) && "object" == typeof i3 && !(i3 = D2(t3, i3)))
          return false;
        if (!N2(r4[1], t3.get(i3)))
          return false;
      }
      return true;
    }
    if (n3 === ArrayBuffer)
      e4 = new Uint8Array(e4), t3 = new Uint8Array(t3);
    else if (n3 === DataView) {
      if ((r4 = e4.byteLength) === t3.byteLength)
        for (; r4-- && e4.getInt8(r4) === t3.getInt8(r4); )
          ;
      return -1 === r4;
    }
    if (ArrayBuffer.isView(e4)) {
      if ((r4 = e4.byteLength) === t3.byteLength)
        for (; r4-- && e4[r4] === t3[r4]; )
          ;
      return -1 === r4;
    }
    if (!n3 || "object" == typeof e4) {
      for (n3 in r4 = 0, e4) {
        if (L2.call(e4, n3) && ++r4 && !L2.call(t3, n3))
          return false;
        if (!(n3 in t3) || !N2(e4[n3], t3[n3]))
          return false;
      }
      return Object.keys(t3).length === r4;
    }
  }
  return e4 != e4 && t3 != t3;
}
var R2 = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
var F2 = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
var B2 = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
var U2 = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
var V2 = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
var J2 = class _J {
  static getFirstMatch(e4, t3) {
    const n3 = t3.match(e4);
    return n3 && n3.length > 0 && n3[1] || "";
  }
  static getSecondMatch(e4, t3) {
    const n3 = t3.match(e4);
    return n3 && n3.length > 1 && n3[2] || "";
  }
  static matchAndReturnConst(e4, t3, n3) {
    if (e4.test(t3))
      return n3;
  }
  static getWindowsVersionName(e4) {
    switch (e4) {
      case "NT":
        return "NT";
      case "XP":
      case "NT 5.1":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(e4) {
    const t3 = e4.split(".").splice(0, 2).map((e5) => parseInt(e5, 10) || 0);
    if (t3.push(0), 10 === t3[0])
      switch (t3[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  static getAndroidVersionName(e4) {
    const t3 = e4.split(".").splice(0, 2).map((e5) => parseInt(e5, 10) || 0);
    if (t3.push(0), !(1 === t3[0] && t3[1] < 5))
      return 1 === t3[0] && t3[1] < 6 ? "Cupcake" : 1 === t3[0] && t3[1] >= 6 ? "Donut" : 2 === t3[0] && t3[1] < 2 ? "Eclair" : 2 === t3[0] && 2 === t3[1] ? "Froyo" : 2 === t3[0] && t3[1] > 2 ? "Gingerbread" : 3 === t3[0] ? "Honeycomb" : 4 === t3[0] && t3[1] < 1 ? "Ice Cream Sandwich" : 4 === t3[0] && t3[1] < 4 ? "Jelly Bean" : 4 === t3[0] && t3[1] >= 4 ? "KitKat" : 5 === t3[0] ? "Lollipop" : 6 === t3[0] ? "Marshmallow" : 7 === t3[0] ? "Nougat" : 8 === t3[0] ? "Oreo" : 9 === t3[0] ? "Pie" : void 0;
  }
  static getVersionPrecision(e4) {
    return e4.split(".").length;
  }
  static compareVersions(e4, t3, n3 = false) {
    const r4 = _J.getVersionPrecision(e4), i3 = _J.getVersionPrecision(t3);
    let o4 = Math.max(r4, i3), s3 = 0;
    const a3 = _J.map([e4, t3], (e5) => {
      const t4 = o4 - _J.getVersionPrecision(e5), n4 = e5 + new Array(t4 + 1).join(".0");
      return _J.map(n4.split("."), (e6) => new Array(20 - e6.length).join("0") + e6).reverse();
    });
    for (n3 && (s3 = o4 - Math.min(r4, i3)), o4 -= 1; o4 >= s3; ) {
      if (a3[0][o4] > a3[1][o4])
        return 1;
      if (a3[0][o4] === a3[1][o4]) {
        if (o4 === s3)
          return 0;
        o4 -= 1;
      } else if (a3[0][o4] < a3[1][o4])
        return -1;
    }
  }
  static map(e4, t3) {
    const n3 = [];
    let r4;
    if (Array.prototype.map)
      return Array.prototype.map.call(e4, t3);
    for (r4 = 0; r4 < e4.length; r4 += 1)
      n3.push(t3(e4[r4]));
    return n3;
  }
  static find(e4, t3) {
    let n3, r4;
    if (Array.prototype.find)
      return Array.prototype.find.call(e4, t3);
    for (n3 = 0, r4 = e4.length; n3 < r4; n3 += 1) {
      const r5 = e4[n3];
      if (t3(r5, n3))
        return r5;
    }
  }
  static assign(e4, ...t3) {
    const n3 = e4;
    let r4, i3;
    if (Object.assign)
      return Object.assign(e4, ...t3);
    for (r4 = 0, i3 = t3.length; r4 < i3; r4 += 1) {
      const e5 = t3[r4];
      if ("object" == typeof e5 && null !== e5) {
        Object.keys(e5).forEach((t4) => {
          n3[t4] = e5[t4];
        });
      }
    }
    return e4;
  }
  static getBrowserAlias(e4) {
    return R2[e4];
  }
  static getBrowserTypeByAlias(e4) {
    return F2[e4] || "";
  }
};
var $2 = /version\/(\d+(\.?_?\d+)+)/i;
var q2 = [{ test: [/googlebot/i], describe(e4) {
  const t3 = { name: "Googlebot" }, n3 = J2.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opera/i], describe(e4) {
  const t3 = { name: "Opera" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opr\/|opios/i], describe(e4) {
  const t3 = { name: "Opera" }, n3 = J2.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/SamsungBrowser/i], describe(e4) {
  const t3 = { name: "Samsung Internet for Android" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/Whale/i], describe(e4) {
  const t3 = { name: "NAVER Whale Browser" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/MZBrowser/i], describe(e4) {
  const t3 = { name: "MZ Browser" }, n3 = J2.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/focus/i], describe(e4) {
  const t3 = { name: "Focus" }, n3 = J2.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/swing/i], describe(e4) {
  const t3 = { name: "Swing" }, n3 = J2.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/coast/i], describe(e4) {
  const t3 = { name: "Opera Coast" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe(e4) {
  const t3 = { name: "Opera Touch" }, n3 = J2.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/yabrowser/i], describe(e4) {
  const t3 = { name: "Yandex Browser" }, n3 = J2.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/ucbrowser/i], describe(e4) {
  const t3 = { name: "UC Browser" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/Maxthon|mxios/i], describe(e4) {
  const t3 = { name: "Maxthon" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/epiphany/i], describe(e4) {
  const t3 = { name: "Epiphany" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/puffin/i], describe(e4) {
  const t3 = { name: "Puffin" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/sleipnir/i], describe(e4) {
  const t3 = { name: "Sleipnir" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/k-meleon/i], describe(e4) {
  const t3 = { name: "K-Meleon" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/micromessenger/i], describe(e4) {
  const t3 = { name: "WeChat" }, n3 = J2.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/qqbrowser/i], describe(e4) {
  const t3 = { name: /qqbrowserlite/i.test(e4) ? "QQ Browser Lite" : "QQ Browser" }, n3 = J2.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/msie|trident/i], describe(e4) {
  const t3 = { name: "Internet Explorer" }, n3 = J2.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/\sedg\//i], describe(e4) {
  const t3 = { name: "Microsoft Edge" }, n3 = J2.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/edg([ea]|ios)/i], describe(e4) {
  const t3 = { name: "Microsoft Edge" }, n3 = J2.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/vivaldi/i], describe(e4) {
  const t3 = { name: "Vivaldi" }, n3 = J2.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/seamonkey/i], describe(e4) {
  const t3 = { name: "SeaMonkey" }, n3 = J2.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/sailfish/i], describe(e4) {
  const t3 = { name: "Sailfish" }, n3 = J2.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/silk/i], describe(e4) {
  const t3 = { name: "Amazon Silk" }, n3 = J2.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/phantom/i], describe(e4) {
  const t3 = { name: "PhantomJS" }, n3 = J2.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/slimerjs/i], describe(e4) {
  const t3 = { name: "SlimerJS" }, n3 = J2.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e4) {
  const t3 = { name: "BlackBerry" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/(web|hpw)[o0]s/i], describe(e4) {
  const t3 = { name: "WebOS Browser" }, n3 = J2.getFirstMatch($2, e4) || J2.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/bada/i], describe(e4) {
  const t3 = { name: "Bada" }, n3 = J2.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/tizen/i], describe(e4) {
  const t3 = { name: "Tizen" }, n3 = J2.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/qupzilla/i], describe(e4) {
  const t3 = { name: "QupZilla" }, n3 = J2.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/firefox|iceweasel|fxios/i], describe(e4) {
  const t3 = { name: "Firefox" }, n3 = J2.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/electron/i], describe(e4) {
  const t3 = { name: "Electron" }, n3 = J2.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/MiuiBrowser/i], describe(e4) {
  const t3 = { name: "Miui" }, n3 = J2.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/chromium/i], describe(e4) {
  const t3 = { name: "Chromium" }, n3 = J2.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e4) || J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/chrome|crios|crmo/i], describe(e4) {
  const t3 = { name: "Chrome" }, n3 = J2.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/GSA/i], describe(e4) {
  const t3 = { name: "Google Search" }, n3 = J2.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test(e4) {
  const t3 = !e4.test(/like android/i), n3 = e4.test(/android/i);
  return t3 && n3;
}, describe(e4) {
  const t3 = { name: "Android Browser" }, n3 = J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/playstation 4/i], describe(e4) {
  const t3 = { name: "PlayStation 4" }, n3 = J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/safari|applewebkit/i], describe(e4) {
  const t3 = { name: "Safari" }, n3 = J2.getFirstMatch($2, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/.*/i], describe(e4) {
  const t3 = -1 !== e4.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
  return { name: J2.getFirstMatch(t3, e4), version: J2.getSecondMatch(t3, e4) };
} }];
var z2 = [{ test: [/Roku\/DVP/], describe(e4) {
  const t3 = J2.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e4);
  return { name: U2.Roku, version: t3 };
} }, { test: [/windows phone/i], describe(e4) {
  const t3 = J2.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e4);
  return { name: U2.WindowsPhone, version: t3 };
} }, { test: [/windows /i], describe(e4) {
  const t3 = J2.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e4), n3 = J2.getWindowsVersionName(t3);
  return { name: U2.Windows, version: t3, versionName: n3 };
} }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe(e4) {
  const t3 = { name: U2.iOS }, n3 = J2.getSecondMatch(/(Version\/)(\d[\d.]+)/, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/macintosh/i], describe(e4) {
  const t3 = J2.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e4).replace(/[_\s]/g, "."), n3 = J2.getMacOSVersionName(t3), r4 = { name: U2.MacOS, version: t3 };
  return n3 && (r4.versionName = n3), r4;
} }, { test: [/(ipod|iphone|ipad)/i], describe(e4) {
  const t3 = J2.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e4).replace(/[_\s]/g, ".");
  return { name: U2.iOS, version: t3 };
} }, { test(e4) {
  const t3 = !e4.test(/like android/i), n3 = e4.test(/android/i);
  return t3 && n3;
}, describe(e4) {
  const t3 = J2.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e4), n3 = J2.getAndroidVersionName(t3), r4 = { name: U2.Android, version: t3 };
  return n3 && (r4.versionName = n3), r4;
} }, { test: [/(web|hpw)[o0]s/i], describe(e4) {
  const t3 = J2.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e4), n3 = { name: U2.WebOS };
  return t3 && t3.length && (n3.version = t3), n3;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e4) {
  const t3 = J2.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e4) || J2.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e4) || J2.getFirstMatch(/\bbb(\d+)/i, e4);
  return { name: U2.BlackBerry, version: t3 };
} }, { test: [/bada/i], describe(e4) {
  const t3 = J2.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e4);
  return { name: U2.Bada, version: t3 };
} }, { test: [/tizen/i], describe(e4) {
  const t3 = J2.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e4);
  return { name: U2.Tizen, version: t3 };
} }, { test: [/linux/i], describe: () => ({ name: U2.Linux }) }, { test: [/CrOS/], describe: () => ({ name: U2.ChromeOS }) }, { test: [/PlayStation 4/], describe(e4) {
  const t3 = J2.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e4);
  return { name: U2.PlayStation4, version: t3 };
} }];
var W2 = [{ test: [/googlebot/i], describe: () => ({ type: "bot", vendor: "Google" }) }, { test: [/huawei/i], describe(e4) {
  const t3 = J2.getFirstMatch(/(can-l01)/i, e4) && "Nova", n3 = { type: B2.mobile, vendor: "Huawei" };
  return t3 && (n3.model = t3), n3;
} }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: () => ({ type: B2.tablet, vendor: "Nexus" }) }, { test: [/ipad/i], describe: () => ({ type: B2.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: () => ({ type: B2.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/kftt build/i], describe: () => ({ type: B2.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" }) }, { test: [/silk/i], describe: () => ({ type: B2.tablet, vendor: "Amazon" }) }, { test: [/tablet(?! pc)/i], describe: () => ({ type: B2.tablet }) }, { test(e4) {
  const t3 = e4.test(/ipod|iphone/i), n3 = e4.test(/like (ipod|iphone)/i);
  return t3 && !n3;
}, describe(e4) {
  const t3 = J2.getFirstMatch(/(ipod|iphone)/i, e4);
  return { type: B2.mobile, vendor: "Apple", model: t3 };
} }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: () => ({ type: B2.mobile, vendor: "Nexus" }) }, { test: [/[^-]mobi/i], describe: () => ({ type: B2.mobile }) }, { test: (e4) => "blackberry" === e4.getBrowserName(true), describe: () => ({ type: B2.mobile, vendor: "BlackBerry" }) }, { test: (e4) => "bada" === e4.getBrowserName(true), describe: () => ({ type: B2.mobile }) }, { test: (e4) => "windows phone" === e4.getBrowserName(), describe: () => ({ type: B2.mobile, vendor: "Microsoft" }) }, { test(e4) {
  const t3 = Number(String(e4.getOSVersion()).split(".")[0]);
  return "android" === e4.getOSName(true) && t3 >= 3;
}, describe: () => ({ type: B2.tablet }) }, { test: (e4) => "android" === e4.getOSName(true), describe: () => ({ type: B2.mobile }) }, { test: (e4) => "macos" === e4.getOSName(true), describe: () => ({ type: B2.desktop, vendor: "Apple" }) }, { test: (e4) => "windows" === e4.getOSName(true), describe: () => ({ type: B2.desktop }) }, { test: (e4) => "linux" === e4.getOSName(true), describe: () => ({ type: B2.desktop }) }, { test: (e4) => "playstation 4" === e4.getOSName(true), describe: () => ({ type: B2.tv }) }, { test: (e4) => "roku" === e4.getOSName(true), describe: () => ({ type: B2.tv }) }];
var H2 = [{ test: (e4) => "microsoft edge" === e4.getBrowserName(true), describe(e4) {
  if (/\sedg\//i.test(e4))
    return { name: V2.Blink };
  const t3 = J2.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e4);
  return { name: V2.EdgeHTML, version: t3 };
} }, { test: [/trident/i], describe(e4) {
  const t3 = { name: V2.Trident }, n3 = J2.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: (e4) => e4.test(/presto/i), describe(e4) {
  const t3 = { name: V2.Presto }, n3 = J2.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test(e4) {
  const t3 = e4.test(/gecko/i), n3 = e4.test(/like gecko/i);
  return t3 && !n3;
}, describe(e4) {
  const t3 = { name: V2.Gecko }, n3 = J2.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }, { test: [/(apple)?webkit\/537\.36/i], describe: () => ({ name: V2.Blink }) }, { test: [/(apple)?webkit/i], describe(e4) {
  const t3 = { name: V2.WebKit }, n3 = J2.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e4);
  return n3 && (t3.version = n3), t3;
} }];
var G2 = class {
  constructor(e4, t3 = false) {
    if (null == e4 || "" === e4)
      throw new Error("UserAgent parameter can't be empty");
    this._ua = e4, this.parsedResult = {}, true !== t3 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(e4) {
    return e4.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const e4 = J2.find(q2, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.browser = e4.describe(this.getUA())), this.parsedResult.browser;
  }
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  getBrowserName(e4) {
    return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const e4 = J2.find(z2, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.os = e4.describe(this.getUA())), this.parsedResult.os;
  }
  getOSName(e4) {
    const { name: t3 } = this.getOS();
    return e4 ? String(t3).toLowerCase() || "" : t3 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  getPlatformType(e4 = false) {
    const { type: t3 } = this.getPlatform();
    return e4 ? String(t3).toLowerCase() || "" : t3 || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const e4 = J2.find(W2, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.platform = e4.describe(this.getUA())), this.parsedResult.platform;
  }
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  getEngineName(e4) {
    return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const e4 = J2.find(H2, (e5) => {
      if ("function" == typeof e5.test)
        return e5.test(this);
      if (e5.test instanceof Array)
        return e5.test.some((e6) => this.test(e6));
      throw new Error("Browser's test function is not valid");
    });
    return e4 && (this.parsedResult.engine = e4.describe(this.getUA())), this.parsedResult.engine;
  }
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  getResult() {
    return J2.assign({}, this.parsedResult);
  }
  satisfies(e4) {
    const t3 = {};
    let n3 = 0;
    const r4 = {};
    let i3 = 0;
    if (Object.keys(e4).forEach((o4) => {
      const s3 = e4[o4];
      "string" == typeof s3 ? (r4[o4] = s3, i3 += 1) : "object" == typeof s3 && (t3[o4] = s3, n3 += 1);
    }), n3 > 0) {
      const e5 = Object.keys(t3), n4 = J2.find(e5, (e6) => this.isOS(e6));
      if (n4) {
        const e6 = this.satisfies(t3[n4]);
        if (void 0 !== e6)
          return e6;
      }
      const r5 = J2.find(e5, (e6) => this.isPlatform(e6));
      if (r5) {
        const e6 = this.satisfies(t3[r5]);
        if (void 0 !== e6)
          return e6;
      }
    }
    if (i3 > 0) {
      const e5 = Object.keys(r4), t4 = J2.find(e5, (e6) => this.isBrowser(e6, true));
      if (void 0 !== t4)
        return this.compareVersion(r4[t4]);
    }
  }
  isBrowser(e4, t3 = false) {
    const n3 = this.getBrowserName().toLowerCase();
    let r4 = e4.toLowerCase();
    const i3 = J2.getBrowserTypeByAlias(r4);
    return t3 && i3 && (r4 = i3.toLowerCase()), r4 === n3;
  }
  compareVersion(e4) {
    let t3 = [0], n3 = e4, r4 = false;
    const i3 = this.getBrowserVersion();
    if ("string" == typeof i3)
      return ">" === e4[0] || "<" === e4[0] ? (n3 = e4.substr(1), "=" === e4[1] ? (r4 = true, n3 = e4.substr(2)) : t3 = [], ">" === e4[0] ? t3.push(1) : t3.push(-1)) : "=" === e4[0] ? n3 = e4.substr(1) : "~" === e4[0] && (r4 = true, n3 = e4.substr(1)), t3.indexOf(J2.compareVersions(i3, n3, r4)) > -1;
  }
  isOS(e4) {
    return this.getOSName(true) === String(e4).toLowerCase();
  }
  isPlatform(e4) {
    return this.getPlatformType(true) === String(e4).toLowerCase();
  }
  isEngine(e4) {
    return this.getEngineName(true) === String(e4).toLowerCase();
  }
  is(e4, t3 = false) {
    return this.isBrowser(e4, t3) || this.isOS(e4) || this.isPlatform(e4);
  }
  some(e4 = []) {
    return e4.some((e5) => this.is(e5));
  }
};
var Q2 = class {
  static getParser(e4, t3 = false) {
    if ("string" != typeof e4)
      throw new Error("UserAgent should be a string");
    return new G2(e4, t3);
  }
  static parse(e4) {
    return new G2(e4).getResult();
  }
  static get BROWSER_MAP() {
    return F2;
  }
  static get ENGINE_MAP() {
    return V2;
  }
  static get OS_MAP() {
    return U2;
  }
  static get PLATFORMS_MAP() {
    return B2;
  }
};
function K2() {
  return Date.now() + Math.random().toString();
}
function Y2() {
  throw new Error("Method must be implemented in subclass");
}
function X2(e4, t3) {
  return null != t3 && t3.proxyUrl ? t3.proxyUrl + ("/" === t3.proxyUrl.slice(-1) ? "" : "/") + e4.substring(8) : e4;
}
function Z2(e4) {
  return null != e4 && e4.callObjectBundleUrlOverride ? e4.callObjectBundleUrlOverride : X2("https://c.daily.co/call-machine/versioned/".concat("0.79.0", "/static/call-machine-object-bundle.js"), e4);
}
function ee2(e4) {
  try {
    new URL(e4);
  } catch (e5) {
    return false;
  }
  return true;
}
var te2 = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var ne2 = "8.55.0";
var re2 = globalThis;
function ie2(e4, t3, n3) {
  const r4 = n3 || re2, i3 = r4.__SENTRY__ = r4.__SENTRY__ || {}, o4 = i3[ne2] = i3[ne2] || {};
  return o4[e4] || (o4[e4] = t3());
}
var oe2 = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var se2 = ["debug", "info", "warn", "error", "log", "assert", "trace"];
var ae2 = {};
function ce2(e4) {
  if (!("console" in re2))
    return e4();
  const t3 = re2.console, n3 = {}, r4 = Object.keys(ae2);
  r4.forEach((e5) => {
    const r5 = ae2[e5];
    n3[e5] = t3[e5], t3[e5] = r5;
  });
  try {
    return e4();
  } finally {
    r4.forEach((e5) => {
      t3[e5] = n3[e5];
    });
  }
}
var le2 = ie2("logger", function() {
  let e4 = false;
  const t3 = { enable: () => {
    e4 = true;
  }, disable: () => {
    e4 = false;
  }, isEnabled: () => e4 };
  return oe2 ? se2.forEach((n3) => {
    t3[n3] = (...t4) => {
      e4 && ce2(() => {
        re2.console[n3](`Sentry Logger [${n3}]:`, ...t4);
      });
    };
  }) : se2.forEach((e5) => {
    t3[e5] = () => {
    };
  }), t3;
});
var ue2 = "?";
var de2 = /\(error: (.*)\)/;
var he2 = /captureMessage|captureException/;
function pe2(e4) {
  return e4[e4.length - 1] || {};
}
var fe2 = "<anonymous>";
function ve2(e4) {
  try {
    return e4 && "function" == typeof e4 && e4.name || fe2;
  } catch (e5) {
    return fe2;
  }
}
function ge2(e4) {
  const t3 = e4.exception;
  if (t3) {
    const e5 = [];
    try {
      return t3.values.forEach((t4) => {
        t4.stacktrace.frames && e5.push(...t4.stacktrace.frames);
      }), e5;
    } catch (e6) {
      return;
    }
  }
}
var me2 = {};
var ye2 = {};
function be2(e4, t3) {
  me2[e4] = me2[e4] || [], me2[e4].push(t3);
}
function _e2(e4, t3) {
  if (!ye2[e4]) {
    ye2[e4] = true;
    try {
      t3();
    } catch (t4) {
      oe2 && le2.error(`Error while instrumenting ${e4}`, t4);
    }
  }
}
function we2(e4, t3) {
  const n3 = e4 && me2[e4];
  if (n3)
    for (const r4 of n3)
      try {
        r4(t3);
      } catch (t4) {
        oe2 && le2.error(`Error while triggering instrumentation handler.
Type: ${e4}
Name: ${ve2(r4)}
Error:`, t4);
      }
}
var Se2 = null;
function ke2() {
  Se2 = re2.onerror, re2.onerror = function(e4, t3, n3, r4, i3) {
    return we2("error", { column: r4, error: i3, line: n3, msg: e4, url: t3 }), !!Se2 && Se2.apply(this, arguments);
  }, re2.onerror.__SENTRY_INSTRUMENTED__ = true;
}
var Me2 = null;
function Ce2() {
  Me2 = re2.onunhandledrejection, re2.onunhandledrejection = function(e4) {
    return we2("unhandledrejection", e4), !Me2 || Me2.apply(this, arguments);
  }, re2.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
function Ee2() {
  return Te2(re2), re2;
}
function Te2(e4) {
  const t3 = e4.__SENTRY__ = e4.__SENTRY__ || {};
  return t3.version = t3.version || ne2, t3[ne2] = t3[ne2] || {};
}
var Oe2 = Object.prototype.toString;
function Pe2(e4) {
  switch (Oe2.call(e4)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return Be2(e4, Error);
  }
}
function Ae2(e4, t3) {
  return Oe2.call(e4) === `[object ${t3}]`;
}
function je2(e4) {
  return Ae2(e4, "ErrorEvent");
}
function Ie2(e4) {
  return Ae2(e4, "DOMError");
}
function xe2(e4) {
  return Ae2(e4, "String");
}
function Le2(e4) {
  return "object" == typeof e4 && null !== e4 && "__sentry_template_string__" in e4 && "__sentry_template_values__" in e4;
}
function De2(e4) {
  return null === e4 || Le2(e4) || "object" != typeof e4 && "function" != typeof e4;
}
function Ne2(e4) {
  return Ae2(e4, "Object");
}
function Re2(e4) {
  return "undefined" != typeof Event && Be2(e4, Event);
}
function Fe2(e4) {
  return Boolean(e4 && e4.then && "function" == typeof e4.then);
}
function Be2(e4, t3) {
  try {
    return e4 instanceof t3;
  } catch (e5) {
    return false;
  }
}
function Ue2(e4) {
  return !("object" != typeof e4 || null === e4 || !e4.__isVue && !e4._isVue);
}
var Ve2 = re2;
function Je2(e4, t3 = {}) {
  if (!e4)
    return "<unknown>";
  try {
    let n3 = e4;
    const r4 = 5, i3 = [];
    let o4 = 0, s3 = 0;
    const a3 = " > ", c3 = a3.length;
    let l3;
    const u3 = Array.isArray(t3) ? t3 : t3.keyAttrs, d3 = !Array.isArray(t3) && t3.maxStringLength || 80;
    for (; n3 && o4++ < r4 && (l3 = $e2(n3, u3), !("html" === l3 || o4 > 1 && s3 + i3.length * c3 + l3.length >= d3)); )
      i3.push(l3), s3 += l3.length, n3 = n3.parentNode;
    return i3.reverse().join(a3);
  } catch (e5) {
    return "<unknown>";
  }
}
function $e2(e4, t3) {
  const n3 = e4, r4 = [];
  if (!n3 || !n3.tagName)
    return "";
  if (Ve2.HTMLElement && n3 instanceof HTMLElement && n3.dataset) {
    if (n3.dataset.sentryComponent)
      return n3.dataset.sentryComponent;
    if (n3.dataset.sentryElement)
      return n3.dataset.sentryElement;
  }
  r4.push(n3.tagName.toLowerCase());
  const i3 = t3 && t3.length ? t3.filter((e5) => n3.getAttribute(e5)).map((e5) => [e5, n3.getAttribute(e5)]) : null;
  if (i3 && i3.length)
    i3.forEach((e5) => {
      r4.push(`[${e5[0]}="${e5[1]}"]`);
    });
  else {
    n3.id && r4.push(`#${n3.id}`);
    const e5 = n3.className;
    if (e5 && xe2(e5)) {
      const t4 = e5.split(/\s+/);
      for (const e6 of t4)
        r4.push(`.${e6}`);
    }
  }
  const o4 = ["aria-label", "type", "name", "title", "alt"];
  for (const e5 of o4) {
    const t4 = n3.getAttribute(e5);
    t4 && r4.push(`[${e5}="${t4}"]`);
  }
  return r4.join("");
}
function qe2(e4, t3 = 0) {
  return "string" != typeof e4 || 0 === t3 || e4.length <= t3 ? e4 : `${e4.slice(0, t3)}...`;
}
function ze2(e4, t3) {
  if (!Array.isArray(e4))
    return "";
  const n3 = [];
  for (let t4 = 0; t4 < e4.length; t4++) {
    const r4 = e4[t4];
    try {
      Ue2(r4) ? n3.push("[VueViewModel]") : n3.push(String(r4));
    } catch (e5) {
      n3.push("[value cannot be serialized]");
    }
  }
  return n3.join(t3);
}
function We2(e4, t3, n3 = false) {
  return !!xe2(e4) && (Ae2(t3, "RegExp") ? t3.test(e4) : !!xe2(t3) && (n3 ? e4 === t3 : e4.includes(t3)));
}
function He2(e4, t3 = [], n3 = false) {
  return t3.some((t4) => We2(e4, t4, n3));
}
function Ge2(e4, t3, n3) {
  if (!(t3 in e4))
    return;
  const r4 = e4[t3], i3 = n3(r4);
  "function" == typeof i3 && Ke2(i3, r4);
  try {
    e4[t3] = i3;
  } catch (n4) {
    oe2 && le2.log(`Failed to replace method "${t3}" in object`, e4);
  }
}
function Qe2(e4, t3, n3) {
  try {
    Object.defineProperty(e4, t3, { value: n3, writable: true, configurable: true });
  } catch (n4) {
    oe2 && le2.log(`Failed to add non-enumerable property "${t3}" to object`, e4);
  }
}
function Ke2(e4, t3) {
  try {
    const n3 = t3.prototype || {};
    e4.prototype = t3.prototype = n3, Qe2(e4, "__sentry_original__", t3);
  } catch (e5) {
  }
}
function Ye2(e4) {
  return e4.__sentry_original__;
}
function Xe2(e4) {
  if (Pe2(e4))
    return { message: e4.message, name: e4.name, stack: e4.stack, ...et2(e4) };
  if (Re2(e4)) {
    const t3 = { type: e4.type, target: Ze2(e4.target), currentTarget: Ze2(e4.currentTarget), ...et2(e4) };
    return "undefined" != typeof CustomEvent && Be2(e4, CustomEvent) && (t3.detail = e4.detail), t3;
  }
  return e4;
}
function Ze2(e4) {
  try {
    return t3 = e4, "undefined" != typeof Element && Be2(t3, Element) ? Je2(e4) : Object.prototype.toString.call(e4);
  } catch (e5) {
    return "<unknown>";
  }
  var t3;
}
function et2(e4) {
  if ("object" == typeof e4 && null !== e4) {
    const t3 = {};
    for (const n3 in e4)
      Object.prototype.hasOwnProperty.call(e4, n3) && (t3[n3] = e4[n3]);
    return t3;
  }
  return {};
}
function tt2(e4) {
  return nt2(e4, /* @__PURE__ */ new Map());
}
function nt2(e4, t3) {
  if (function(e5) {
    if (!Ne2(e5))
      return false;
    try {
      const t4 = Object.getPrototypeOf(e5).constructor.name;
      return !t4 || "Object" === t4;
    } catch (e6) {
      return true;
    }
  }(e4)) {
    const n3 = t3.get(e4);
    if (void 0 !== n3)
      return n3;
    const r4 = {};
    t3.set(e4, r4);
    for (const n4 of Object.getOwnPropertyNames(e4))
      void 0 !== e4[n4] && (r4[n4] = nt2(e4[n4], t3));
    return r4;
  }
  if (Array.isArray(e4)) {
    const n3 = t3.get(e4);
    if (void 0 !== n3)
      return n3;
    const r4 = [];
    return t3.set(e4, r4), e4.forEach((e5) => {
      r4.push(nt2(e5, t3));
    }), r4;
  }
  return e4;
}
function rt2() {
  return Date.now() / 1e3;
}
var it2 = function() {
  const { performance: e4 } = re2;
  if (!e4 || !e4.now)
    return rt2;
  const t3 = Date.now() - e4.now(), n3 = null == e4.timeOrigin ? t3 : e4.timeOrigin;
  return () => (n3 + e4.now()) / 1e3;
}();
function ot2() {
  const e4 = re2, t3 = e4.crypto || e4.msCrypto;
  let n3 = () => 16 * Math.random();
  try {
    if (t3 && t3.randomUUID)
      return t3.randomUUID().replace(/-/g, "");
    t3 && t3.getRandomValues && (n3 = () => {
      const e5 = new Uint8Array(1);
      return t3.getRandomValues(e5), e5[0];
    });
  } catch (e5) {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (e5) => (e5 ^ (15 & n3()) >> e5 / 4).toString(16));
}
function st2(e4) {
  return e4.exception && e4.exception.values ? e4.exception.values[0] : void 0;
}
function at2(e4) {
  const { message: t3, event_id: n3 } = e4;
  if (t3)
    return t3;
  const r4 = st2(e4);
  return r4 ? r4.type && r4.value ? `${r4.type}: ${r4.value}` : r4.type || r4.value || n3 || "<unknown>" : n3 || "<unknown>";
}
function ct2(e4, t3, n3) {
  const r4 = e4.exception = e4.exception || {}, i3 = r4.values = r4.values || [], o4 = i3[0] = i3[0] || {};
  o4.value || (o4.value = t3 || ""), o4.type || (o4.type = n3 || "Error");
}
function lt2(e4, t3) {
  const n3 = st2(e4);
  if (!n3)
    return;
  const r4 = n3.mechanism;
  if (n3.mechanism = { type: "generic", handled: true, ...r4, ...t3 }, t3 && "data" in t3) {
    const e5 = { ...r4 && r4.data, ...t3.data };
    n3.mechanism.data = e5;
  }
}
function ut2(e4) {
  if (function(e5) {
    try {
      return e5.__sentry_captured__;
    } catch (e6) {
    }
  }(e4))
    return true;
  try {
    Qe2(e4, "__sentry_captured__", true);
  } catch (e5) {
  }
  return false;
}
var dt2;
function ht2(e4) {
  return new ft2((t3) => {
    t3(e4);
  });
}
function pt2(e4) {
  return new ft2((t3, n3) => {
    n3(e4);
  });
}
(() => {
  const { performance: e4 } = re2;
  if (!e4 || !e4.now)
    return;
  const t3 = 36e5, n3 = e4.now(), r4 = Date.now(), i3 = e4.timeOrigin ? Math.abs(e4.timeOrigin + n3 - r4) : t3, o4 = i3 < t3, s3 = e4.timing && e4.timing.navigationStart, a3 = "number" == typeof s3 ? Math.abs(s3 + n3 - r4) : t3;
  (o4 || a3 < t3) && (i3 <= a3 && e4.timeOrigin);
})(), function(e4) {
  e4[e4.PENDING = 0] = "PENDING";
  e4[e4.RESOLVED = 1] = "RESOLVED";
  e4[e4.REJECTED = 2] = "REJECTED";
}(dt2 || (dt2 = {}));
var ft2 = class _ft {
  constructor(e4) {
    _ft.prototype.__init.call(this), _ft.prototype.__init2.call(this), _ft.prototype.__init3.call(this), _ft.prototype.__init4.call(this), this._state = dt2.PENDING, this._handlers = [];
    try {
      e4(this._resolve, this._reject);
    } catch (e5) {
      this._reject(e5);
    }
  }
  then(e4, t3) {
    return new _ft((n3, r4) => {
      this._handlers.push([false, (t4) => {
        if (e4)
          try {
            n3(e4(t4));
          } catch (e5) {
            r4(e5);
          }
        else
          n3(t4);
      }, (e5) => {
        if (t3)
          try {
            n3(t3(e5));
          } catch (e6) {
            r4(e6);
          }
        else
          r4(e5);
      }]), this._executeHandlers();
    });
  }
  catch(e4) {
    return this.then((e5) => e5, e4);
  }
  finally(e4) {
    return new _ft((t3, n3) => {
      let r4, i3;
      return this.then((t4) => {
        i3 = false, r4 = t4, e4 && e4();
      }, (t4) => {
        i3 = true, r4 = t4, e4 && e4();
      }).then(() => {
        i3 ? n3(r4) : t3(r4);
      });
    });
  }
  __init() {
    this._resolve = (e4) => {
      this._setResult(dt2.RESOLVED, e4);
    };
  }
  __init2() {
    this._reject = (e4) => {
      this._setResult(dt2.REJECTED, e4);
    };
  }
  __init3() {
    this._setResult = (e4, t3) => {
      this._state === dt2.PENDING && (Fe2(t3) ? t3.then(this._resolve, this._reject) : (this._state = e4, this._value = t3, this._executeHandlers()));
    };
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === dt2.PENDING)
        return;
      const e4 = this._handlers.slice();
      this._handlers = [], e4.forEach((e5) => {
        e5[0] || (this._state === dt2.RESOLVED && e5[1](this._value), this._state === dt2.REJECTED && e5[2](this._value), e5[0] = true);
      });
    };
  }
};
function vt2(e4) {
  const t3 = it2(), n3 = { sid: ot2(), init: true, timestamp: t3, started: t3, duration: 0, status: "ok", errors: 0, ignoreDuration: false, toJSON: () => function(e5) {
    return tt2({ sid: `${e5.sid}`, init: e5.init, started: new Date(1e3 * e5.started).toISOString(), timestamp: new Date(1e3 * e5.timestamp).toISOString(), status: e5.status, errors: e5.errors, did: "number" == typeof e5.did || "string" == typeof e5.did ? `${e5.did}` : void 0, duration: e5.duration, abnormal_mechanism: e5.abnormal_mechanism, attrs: { release: e5.release, environment: e5.environment, ip_address: e5.ipAddress, user_agent: e5.userAgent } });
  }(n3) };
  return e4 && gt2(n3, e4), n3;
}
function gt2(e4, t3 = {}) {
  if (t3.user && (!e4.ipAddress && t3.user.ip_address && (e4.ipAddress = t3.user.ip_address), e4.did || t3.did || (e4.did = t3.user.id || t3.user.email || t3.user.username)), e4.timestamp = t3.timestamp || it2(), t3.abnormal_mechanism && (e4.abnormal_mechanism = t3.abnormal_mechanism), t3.ignoreDuration && (e4.ignoreDuration = t3.ignoreDuration), t3.sid && (e4.sid = 32 === t3.sid.length ? t3.sid : ot2()), void 0 !== t3.init && (e4.init = t3.init), !e4.did && t3.did && (e4.did = `${t3.did}`), "number" == typeof t3.started && (e4.started = t3.started), e4.ignoreDuration)
    e4.duration = void 0;
  else if ("number" == typeof t3.duration)
    e4.duration = t3.duration;
  else {
    const t4 = e4.timestamp - e4.started;
    e4.duration = t4 >= 0 ? t4 : 0;
  }
  t3.release && (e4.release = t3.release), t3.environment && (e4.environment = t3.environment), !e4.ipAddress && t3.ipAddress && (e4.ipAddress = t3.ipAddress), !e4.userAgent && t3.userAgent && (e4.userAgent = t3.userAgent), "number" == typeof t3.errors && (e4.errors = t3.errors), t3.status && (e4.status = t3.status);
}
function mt2() {
  return ot2();
}
function yt2() {
  return ot2().substring(16);
}
function bt2(e4, t3, n3 = 2) {
  if (!t3 || "object" != typeof t3 || n3 <= 0)
    return t3;
  if (e4 && t3 && 0 === Object.keys(t3).length)
    return e4;
  const r4 = { ...e4 };
  for (const e5 in t3)
    Object.prototype.hasOwnProperty.call(t3, e5) && (r4[e5] = bt2(r4[e5], t3[e5], n3 - 1));
  return r4;
}
var _t2 = "_sentrySpan";
function wt2(e4, t3) {
  t3 ? Qe2(e4, _t2, t3) : delete e4[_t2];
}
function St2(e4) {
  return e4[_t2];
}
var kt2 = class _kt {
  constructor() {
    this._notifyingListeners = false, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = { traceId: mt2(), spanId: yt2() };
  }
  clone() {
    const e4 = new _kt();
    return e4._breadcrumbs = [...this._breadcrumbs], e4._tags = { ...this._tags }, e4._extra = { ...this._extra }, e4._contexts = { ...this._contexts }, this._contexts.flags && (e4._contexts.flags = { values: [...this._contexts.flags.values] }), e4._user = this._user, e4._level = this._level, e4._session = this._session, e4._transactionName = this._transactionName, e4._fingerprint = this._fingerprint, e4._eventProcessors = [...this._eventProcessors], e4._requestSession = this._requestSession, e4._attachments = [...this._attachments], e4._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e4._propagationContext = { ...this._propagationContext }, e4._client = this._client, e4._lastEventId = this._lastEventId, wt2(e4, St2(this)), e4;
  }
  setClient(e4) {
    this._client = e4;
  }
  setLastEventId(e4) {
    this._lastEventId = e4;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(e4) {
    this._scopeListeners.push(e4);
  }
  addEventProcessor(e4) {
    return this._eventProcessors.push(e4), this;
  }
  setUser(e4) {
    return this._user = e4 || { email: void 0, id: void 0, ip_address: void 0, username: void 0 }, this._session && gt2(this._session, { user: e4 }), this._notifyScopeListeners(), this;
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(e4) {
    return this._requestSession = e4, this;
  }
  setTags(e4) {
    return this._tags = { ...this._tags, ...e4 }, this._notifyScopeListeners(), this;
  }
  setTag(e4, t3) {
    return this._tags = { ...this._tags, [e4]: t3 }, this._notifyScopeListeners(), this;
  }
  setExtras(e4) {
    return this._extra = { ...this._extra, ...e4 }, this._notifyScopeListeners(), this;
  }
  setExtra(e4, t3) {
    return this._extra = { ...this._extra, [e4]: t3 }, this._notifyScopeListeners(), this;
  }
  setFingerprint(e4) {
    return this._fingerprint = e4, this._notifyScopeListeners(), this;
  }
  setLevel(e4) {
    return this._level = e4, this._notifyScopeListeners(), this;
  }
  setTransactionName(e4) {
    return this._transactionName = e4, this._notifyScopeListeners(), this;
  }
  setContext(e4, t3) {
    return null === t3 ? delete this._contexts[e4] : this._contexts[e4] = t3, this._notifyScopeListeners(), this;
  }
  setSession(e4) {
    return e4 ? this._session = e4 : delete this._session, this._notifyScopeListeners(), this;
  }
  getSession() {
    return this._session;
  }
  update(e4) {
    if (!e4)
      return this;
    const t3 = "function" == typeof e4 ? e4(this) : e4, [n3, r4] = t3 instanceof Mt2 ? [t3.getScopeData(), t3.getRequestSession()] : Ne2(t3) ? [e4, e4.requestSession] : [], { tags: i3, extra: o4, user: s3, contexts: a3, level: c3, fingerprint: l3 = [], propagationContext: u3 } = n3 || {};
    return this._tags = { ...this._tags, ...i3 }, this._extra = { ...this._extra, ...o4 }, this._contexts = { ...this._contexts, ...a3 }, s3 && Object.keys(s3).length && (this._user = s3), c3 && (this._level = c3), l3.length && (this._fingerprint = l3), u3 && (this._propagationContext = u3), r4 && (this._requestSession = r4), this;
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, wt2(this, void 0), this._attachments = [], this.setPropagationContext({ traceId: mt2() }), this._notifyScopeListeners(), this;
  }
  addBreadcrumb(e4, t3) {
    const n3 = "number" == typeof t3 ? t3 : 100;
    if (n3 <= 0)
      return this;
    const r4 = { timestamp: rt2(), ...e4 };
    return this._breadcrumbs.push(r4), this._breadcrumbs.length > n3 && (this._breadcrumbs = this._breadcrumbs.slice(-n3), this._client && this._client.recordDroppedEvent("buffer_overflow", "log_item")), this._notifyScopeListeners(), this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  addAttachment(e4) {
    return this._attachments.push(e4), this;
  }
  clearAttachments() {
    return this._attachments = [], this;
  }
  getScopeData() {
    return { breadcrumbs: this._breadcrumbs, attachments: this._attachments, contexts: this._contexts, tags: this._tags, extra: this._extra, user: this._user, level: this._level, fingerprint: this._fingerprint || [], eventProcessors: this._eventProcessors, propagationContext: this._propagationContext, sdkProcessingMetadata: this._sdkProcessingMetadata, transactionName: this._transactionName, span: St2(this) };
  }
  setSDKProcessingMetadata(e4) {
    return this._sdkProcessingMetadata = bt2(this._sdkProcessingMetadata, e4, 2), this;
  }
  setPropagationContext(e4) {
    return this._propagationContext = { spanId: yt2(), ...e4 }, this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(e4, t3) {
    const n3 = t3 && t3.event_id ? t3.event_id : ot2();
    if (!this._client)
      return le2.warn("No client configured on scope - will not capture exception!"), n3;
    const r4 = new Error("Sentry syntheticException");
    return this._client.captureException(e4, { originalException: e4, syntheticException: r4, ...t3, event_id: n3 }, this), n3;
  }
  captureMessage(e4, t3, n3) {
    const r4 = n3 && n3.event_id ? n3.event_id : ot2();
    if (!this._client)
      return le2.warn("No client configured on scope - will not capture message!"), r4;
    const i3 = new Error(e4);
    return this._client.captureMessage(e4, t3, { originalException: e4, syntheticException: i3, ...n3, event_id: r4 }, this), r4;
  }
  captureEvent(e4, t3) {
    const n3 = t3 && t3.event_id ? t3.event_id : ot2();
    return this._client ? (this._client.captureEvent(e4, { ...t3, event_id: n3 }, this), n3) : (le2.warn("No client configured on scope - will not capture event!"), n3);
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = true, this._scopeListeners.forEach((e4) => {
      e4(this);
    }), this._notifyingListeners = false);
  }
};
var Mt2 = kt2;
var Ct2 = class {
  constructor(e4, t3) {
    let n3, r4;
    n3 = e4 || new Mt2(), r4 = t3 || new Mt2(), this._stack = [{ scope: n3 }], this._isolationScope = r4;
  }
  withScope(e4) {
    const t3 = this._pushScope();
    let n3;
    try {
      n3 = e4(t3);
    } catch (e5) {
      throw this._popScope(), e5;
    }
    return Fe2(n3) ? n3.then((e5) => (this._popScope(), e5), (e5) => {
      throw this._popScope(), e5;
    }) : (this._popScope(), n3);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const e4 = this.getScope().clone();
    return this._stack.push({ client: this.getClient(), scope: e4 }), e4;
  }
  _popScope() {
    return !(this._stack.length <= 1) && !!this._stack.pop();
  }
};
function Et2() {
  const e4 = Te2(Ee2());
  return e4.stack = e4.stack || new Ct2(ie2("defaultCurrentScope", () => new Mt2()), ie2("defaultIsolationScope", () => new Mt2()));
}
function Tt2(e4) {
  return Et2().withScope(e4);
}
function Ot2(e4, t3) {
  const n3 = Et2();
  return n3.withScope(() => (n3.getStackTop().scope = e4, t3(e4)));
}
function Pt2(e4) {
  return Et2().withScope(() => e4(Et2().getIsolationScope()));
}
function At2(e4) {
  const t3 = Te2(e4);
  return t3.acs ? t3.acs : { withIsolationScope: Pt2, withScope: Tt2, withSetScope: Ot2, withSetIsolationScope: (e5, t4) => Pt2(t4), getCurrentScope: () => Et2().getScope(), getIsolationScope: () => Et2().getIsolationScope() };
}
function jt2() {
  return At2(Ee2()).getCurrentScope();
}
function It2() {
  return At2(Ee2()).getIsolationScope();
}
function xt2() {
  return jt2().getClient();
}
function Lt2(e4) {
  const t3 = e4.getPropagationContext(), { traceId: n3, spanId: r4, parentSpanId: i3 } = t3;
  return tt2({ trace_id: n3, span_id: r4, parent_span_id: i3 });
}
function Dt2(e4) {
  const t3 = e4._sentryMetrics;
  if (!t3)
    return;
  const n3 = {};
  for (const [, [e5, r4]] of t3) {
    (n3[e5] || (n3[e5] = [])).push(tt2(r4));
  }
  return n3;
}
var Nt2 = /^sentry-/;
function Rt2(e4) {
  const t3 = function(e5) {
    if (!e5 || !xe2(e5) && !Array.isArray(e5))
      return;
    if (Array.isArray(e5))
      return e5.reduce((e6, t4) => {
        const n4 = Ft2(t4);
        return Object.entries(n4).forEach(([t5, n5]) => {
          e6[t5] = n5;
        }), e6;
      }, {});
    return Ft2(e5);
  }(e4);
  if (!t3)
    return;
  const n3 = Object.entries(t3).reduce((e5, [t4, n4]) => {
    if (t4.match(Nt2)) {
      e5[t4.slice(7)] = n4;
    }
    return e5;
  }, {});
  return Object.keys(n3).length > 0 ? n3 : void 0;
}
function Ft2(e4) {
  return e4.split(",").map((e5) => e5.split("=").map((e6) => decodeURIComponent(e6.trim()))).reduce((e5, [t3, n3]) => (t3 && n3 && (e5[t3] = n3), e5), {});
}
var Bt2 = false;
function Ut2(e4) {
  const { spanId: t3, traceId: n3, isRemote: r4 } = e4.spanContext();
  return tt2({ parent_span_id: r4 ? t3 : $t2(e4).parent_span_id, span_id: r4 ? yt2() : t3, trace_id: n3 });
}
function Vt2(e4) {
  return "number" == typeof e4 ? Jt2(e4) : Array.isArray(e4) ? e4[0] + e4[1] / 1e9 : e4 instanceof Date ? Jt2(e4.getTime()) : it2();
}
function Jt2(e4) {
  return e4 > 9999999999 ? e4 / 1e3 : e4;
}
function $t2(e4) {
  if (function(e5) {
    return "function" == typeof e5.getSpanJSON;
  }(e4))
    return e4.getSpanJSON();
  try {
    const { spanId: t3, traceId: n3 } = e4.spanContext();
    if (function(e5) {
      const t4 = e5;
      return !!(t4.attributes && t4.startTime && t4.name && t4.endTime && t4.status);
    }(e4)) {
      const { attributes: r4, startTime: i3, name: o4, endTime: s3, parentSpanId: a3, status: c3 } = e4;
      return tt2({ span_id: t3, trace_id: n3, data: r4, description: o4, parent_span_id: a3, start_timestamp: Vt2(i3), timestamp: Vt2(s3) || void 0, status: qt2(c3), op: r4["sentry.op"], origin: r4["sentry.origin"], _metrics_summary: Dt2(e4) });
    }
    return { span_id: t3, trace_id: n3 };
  } catch (e5) {
    return {};
  }
}
function qt2(e4) {
  if (e4 && 0 !== e4.code)
    return 1 === e4.code ? "ok" : e4.message || "unknown_error";
}
function zt2(e4) {
  return e4._sentryRootSpan || e4;
}
function Wt2() {
  Bt2 || (ce2(() => {
    console.warn("[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly.");
  }), Bt2 = true);
}
var Ht2 = "production";
function Gt2(e4, t3) {
  const n3 = t3.getOptions(), { publicKey: r4 } = t3.getDsn() || {}, i3 = tt2({ environment: n3.environment || Ht2, release: n3.release, public_key: r4, trace_id: e4 });
  return t3.emit("createDsc", i3), i3;
}
function Qt2(e4) {
  const t3 = xt2();
  if (!t3)
    return {};
  const n3 = zt2(e4), r4 = n3._frozenDsc;
  if (r4)
    return r4;
  const i3 = n3.spanContext().traceState, o4 = i3 && i3.get("sentry.dsc"), s3 = o4 && Rt2(o4);
  if (s3)
    return s3;
  const a3 = Gt2(e4.spanContext().traceId, t3), c3 = $t2(n3), l3 = c3.data || {}, u3 = l3["sentry.sample_rate"];
  null != u3 && (a3.sample_rate = `${u3}`);
  const d3 = l3["sentry.source"], h4 = c3.description;
  return "url" !== d3 && h4 && (a3.transaction = h4), function(e5) {
    if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
      return false;
    const t4 = xt2(), n4 = e5 || t4 && t4.getOptions();
    return !!n4 && (n4.enableTracing || "tracesSampleRate" in n4 || "tracesSampler" in n4);
  }() && (a3.sampled = String(function(e5) {
    const { traceFlags: t4 } = e5.spanContext();
    return 1 === t4;
  }(n3))), t3.emit("createDsc", a3, n3), a3;
}
var Kt2 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Yt2(e4, t3 = false) {
  const { host: n3, path: r4, pass: i3, port: o4, projectId: s3, protocol: a3, publicKey: c3 } = e4;
  return `${a3}://${c3}${t3 && i3 ? `:${i3}` : ""}@${n3}${o4 ? `:${o4}` : ""}/${r4 ? `${r4}/` : r4}${s3}`;
}
function Xt2(e4) {
  return { protocol: e4.protocol, publicKey: e4.publicKey || "", pass: e4.pass || "", host: e4.host, port: e4.port || "", path: e4.path || "", projectId: e4.projectId };
}
function Zt2(e4) {
  const t3 = "string" == typeof e4 ? function(e5) {
    const t4 = Kt2.exec(e5);
    if (!t4)
      return void ce2(() => {
        console.error(`Invalid Sentry Dsn: ${e5}`);
      });
    const [n3, r4, i3 = "", o4 = "", s3 = "", a3 = ""] = t4.slice(1);
    let c3 = "", l3 = a3;
    const u3 = l3.split("/");
    if (u3.length > 1 && (c3 = u3.slice(0, -1).join("/"), l3 = u3.pop()), l3) {
      const e6 = l3.match(/^\d+/);
      e6 && (l3 = e6[0]);
    }
    return Xt2({ host: o4, pass: i3, path: c3, projectId: l3, port: s3, protocol: n3, publicKey: r4 });
  }(e4) : Xt2(e4);
  if (t3 && function(e5) {
    if (!oe2)
      return true;
    const { port: t4, projectId: n3, protocol: r4 } = e5;
    return !(["protocol", "publicKey", "host", "projectId"].find((t5) => !e5[t5] && (le2.error(`Invalid Sentry Dsn: ${t5} missing`), true)) || (n3.match(/^\d+$/) ? function(e6) {
      return "http" === e6 || "https" === e6;
    }(r4) ? t4 && isNaN(parseInt(t4, 10)) && (le2.error(`Invalid Sentry Dsn: Invalid port ${t4}`), 1) : (le2.error(`Invalid Sentry Dsn: Invalid protocol ${r4}`), 1) : (le2.error(`Invalid Sentry Dsn: Invalid projectId ${n3}`), 1)));
  }(t3))
    return t3;
}
function en2(e4, t3 = 100, n3 = 1 / 0) {
  try {
    return nn2("", e4, t3, n3);
  } catch (e5) {
    return { ERROR: `**non-serializable** (${e5})` };
  }
}
function tn2(e4, t3 = 3, n3 = 102400) {
  const r4 = en2(e4, t3);
  return i3 = r4, function(e5) {
    return ~-encodeURI(e5).split(/%..|./).length;
  }(JSON.stringify(i3)) > n3 ? tn2(e4, t3 - 1, n3) : r4;
  var i3;
}
function nn2(e4, t3, n3 = 1 / 0, r4 = 1 / 0, i3 = function() {
  const e5 = "function" == typeof WeakSet, t4 = e5 ? /* @__PURE__ */ new WeakSet() : [];
  return [function(n4) {
    if (e5)
      return !!t4.has(n4) || (t4.add(n4), false);
    for (let e6 = 0; e6 < t4.length; e6++)
      if (t4[e6] === n4)
        return true;
    return t4.push(n4), false;
  }, function(n4) {
    if (e5)
      t4.delete(n4);
    else
      for (let e6 = 0; e6 < t4.length; e6++)
        if (t4[e6] === n4) {
          t4.splice(e6, 1);
          break;
        }
  }];
}()) {
  const [o4, s3] = i3;
  if (null == t3 || ["boolean", "string"].includes(typeof t3) || "number" == typeof t3 && Number.isFinite(t3))
    return t3;
  const a3 = function(e5, t4) {
    try {
      if ("domain" === e5 && t4 && "object" == typeof t4 && t4._events)
        return "[Domain]";
      if ("domainEmitter" === e5)
        return "[DomainEmitter]";
      if ("undefined" != typeof global && t4 === global)
        return "[Global]";
      if ("undefined" != typeof window && t4 === window)
        return "[Window]";
      if ("undefined" != typeof document && t4 === document)
        return "[Document]";
      if (Ue2(t4))
        return "[VueViewModel]";
      if (Ne2(n4 = t4) && "nativeEvent" in n4 && "preventDefault" in n4 && "stopPropagation" in n4)
        return "[SyntheticEvent]";
      if ("number" == typeof t4 && !Number.isFinite(t4))
        return `[${t4}]`;
      if ("function" == typeof t4)
        return `[Function: ${ve2(t4)}]`;
      if ("symbol" == typeof t4)
        return `[${String(t4)}]`;
      if ("bigint" == typeof t4)
        return `[BigInt: ${String(t4)}]`;
      const r5 = function(e6) {
        const t5 = Object.getPrototypeOf(e6);
        return t5 ? t5.constructor.name : "null prototype";
      }(t4);
      return /^HTML(\w*)Element$/.test(r5) ? `[HTMLElement: ${r5}]` : `[object ${r5}]`;
    } catch (e6) {
      return `**non-serializable** (${e6})`;
    }
    var n4;
  }(e4, t3);
  if (!a3.startsWith("[object "))
    return a3;
  if (t3.__sentry_skip_normalization__)
    return t3;
  const c3 = "number" == typeof t3.__sentry_override_normalization_depth__ ? t3.__sentry_override_normalization_depth__ : n3;
  if (0 === c3)
    return a3.replace("object ", "");
  if (o4(t3))
    return "[Circular ~]";
  const l3 = t3;
  if (l3 && "function" == typeof l3.toJSON)
    try {
      return nn2("", l3.toJSON(), c3 - 1, r4, i3);
    } catch (e5) {
    }
  const u3 = Array.isArray(t3) ? [] : {};
  let d3 = 0;
  const h4 = Xe2(t3);
  for (const e5 in h4) {
    if (!Object.prototype.hasOwnProperty.call(h4, e5))
      continue;
    if (d3 >= r4) {
      u3[e5] = "[MaxProperties ~]";
      break;
    }
    const t4 = h4[e5];
    u3[e5] = nn2(e5, t4, c3 - 1, r4, i3), d3++;
  }
  return s3(t3), u3;
}
function rn2(e4, t3 = []) {
  return [e4, t3];
}
function on2(e4, t3) {
  const [n3, r4] = e4;
  return [n3, [...r4, t3]];
}
function sn2(e4, t3) {
  const n3 = e4[1];
  for (const e5 of n3) {
    if (t3(e5, e5[0].type))
      return true;
  }
  return false;
}
function an2(e4) {
  return re2.__SENTRY__ && re2.__SENTRY__.encodePolyfill ? re2.__SENTRY__.encodePolyfill(e4) : new TextEncoder().encode(e4);
}
function cn2(e4) {
  const [t3, n3] = e4;
  let r4 = JSON.stringify(t3);
  function i3(e5) {
    "string" == typeof r4 ? r4 = "string" == typeof e5 ? r4 + e5 : [an2(r4), e5] : r4.push("string" == typeof e5 ? an2(e5) : e5);
  }
  for (const e5 of n3) {
    const [t4, n4] = e5;
    if (i3(`
${JSON.stringify(t4)}
`), "string" == typeof n4 || n4 instanceof Uint8Array)
      i3(n4);
    else {
      let e6;
      try {
        e6 = JSON.stringify(n4);
      } catch (t5) {
        e6 = JSON.stringify(en2(n4));
      }
      i3(e6);
    }
  }
  return "string" == typeof r4 ? r4 : function(e5) {
    const t4 = e5.reduce((e6, t5) => e6 + t5.length, 0), n4 = new Uint8Array(t4);
    let r5 = 0;
    for (const t5 of e5)
      n4.set(t5, r5), r5 += t5.length;
    return n4;
  }(r4);
}
function ln2(e4) {
  const t3 = "string" == typeof e4.data ? an2(e4.data) : e4.data;
  return [tt2({ type: "attachment", length: t3.length, filename: e4.filename, content_type: e4.contentType, attachment_type: e4.attachmentType }), t3];
}
var un2 = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", profile_chunk: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor", feedback: "feedback", span: "span", statsd: "metric_bucket", raw_security: "security" };
function dn2(e4) {
  return un2[e4];
}
function hn2(e4) {
  if (!e4 || !e4.sdk)
    return;
  const { name: t3, version: n3 } = e4.sdk;
  return { name: t3, version: n3 };
}
function pn2(e4, t3, n3, r4) {
  const i3 = hn2(n3), o4 = e4.type && "replay_event" !== e4.type ? e4.type : "event";
  !function(e5, t4) {
    t4 && (e5.sdk = e5.sdk || {}, e5.sdk.name = e5.sdk.name || t4.name, e5.sdk.version = e5.sdk.version || t4.version, e5.sdk.integrations = [...e5.sdk.integrations || [], ...t4.integrations || []], e5.sdk.packages = [...e5.sdk.packages || [], ...t4.packages || []]);
  }(e4, n3 && n3.sdk);
  const s3 = function(e5, t4, n4, r5) {
    const i4 = e5.sdkProcessingMetadata && e5.sdkProcessingMetadata.dynamicSamplingContext;
    return { event_id: e5.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t4 && { sdk: t4 }, ...!!n4 && r5 && { dsn: Yt2(r5) }, ...i4 && { trace: tt2({ ...i4 }) } };
  }(e4, i3, r4, t3);
  delete e4.sdkProcessingMetadata;
  return rn2(s3, [[{ type: o4 }, e4]]);
}
function fn2(e4, t3, n3, r4 = 0) {
  return new ft2((i3, o4) => {
    const s3 = e4[r4];
    if (null === t3 || "function" != typeof s3)
      i3(t3);
    else {
      const a3 = s3({ ...t3 }, n3);
      te2 && s3.id && null === a3 && le2.log(`Event processor "${s3.id}" dropped event`), Fe2(a3) ? a3.then((t4) => fn2(e4, t4, n3, r4 + 1).then(i3)).then(null, o4) : fn2(e4, a3, n3, r4 + 1).then(i3).then(null, o4);
    }
  });
}
var vn2;
var gn2;
var mn2;
function yn2(e4, t3) {
  const { fingerprint: n3, span: r4, breadcrumbs: i3, sdkProcessingMetadata: o4 } = t3;
  !function(e5, t4) {
    const { extra: n4, tags: r5, user: i4, contexts: o5, level: s3, transactionName: a3 } = t4, c3 = tt2(n4);
    c3 && Object.keys(c3).length && (e5.extra = { ...c3, ...e5.extra });
    const l3 = tt2(r5);
    l3 && Object.keys(l3).length && (e5.tags = { ...l3, ...e5.tags });
    const u3 = tt2(i4);
    u3 && Object.keys(u3).length && (e5.user = { ...u3, ...e5.user });
    const d3 = tt2(o5);
    d3 && Object.keys(d3).length && (e5.contexts = { ...d3, ...e5.contexts });
    s3 && (e5.level = s3);
    a3 && "transaction" !== e5.type && (e5.transaction = a3);
  }(e4, t3), r4 && function(e5, t4) {
    e5.contexts = { trace: Ut2(t4), ...e5.contexts }, e5.sdkProcessingMetadata = { dynamicSamplingContext: Qt2(t4), ...e5.sdkProcessingMetadata };
    const n4 = zt2(t4), r5 = $t2(n4).description;
    r5 && !e5.transaction && "transaction" === e5.type && (e5.transaction = r5);
  }(e4, r4), function(e5, t4) {
    e5.fingerprint = e5.fingerprint ? Array.isArray(e5.fingerprint) ? e5.fingerprint : [e5.fingerprint] : [], t4 && (e5.fingerprint = e5.fingerprint.concat(t4));
    e5.fingerprint && !e5.fingerprint.length && delete e5.fingerprint;
  }(e4, n3), function(e5, t4) {
    const n4 = [...e5.breadcrumbs || [], ...t4];
    e5.breadcrumbs = n4.length ? n4 : void 0;
  }(e4, i3), function(e5, t4) {
    e5.sdkProcessingMetadata = { ...e5.sdkProcessingMetadata, ...t4 };
  }(e4, o4);
}
function bn2(e4, t3) {
  const { extra: n3, tags: r4, user: i3, contexts: o4, level: s3, sdkProcessingMetadata: a3, breadcrumbs: c3, fingerprint: l3, eventProcessors: u3, attachments: d3, propagationContext: h4, transactionName: p3, span: f3 } = t3;
  _n2(e4, "extra", n3), _n2(e4, "tags", r4), _n2(e4, "user", i3), _n2(e4, "contexts", o4), e4.sdkProcessingMetadata = bt2(e4.sdkProcessingMetadata, a3, 2), s3 && (e4.level = s3), p3 && (e4.transactionName = p3), f3 && (e4.span = f3), c3.length && (e4.breadcrumbs = [...e4.breadcrumbs, ...c3]), l3.length && (e4.fingerprint = [...e4.fingerprint, ...l3]), u3.length && (e4.eventProcessors = [...e4.eventProcessors, ...u3]), d3.length && (e4.attachments = [...e4.attachments, ...d3]), e4.propagationContext = { ...e4.propagationContext, ...h4 };
}
function _n2(e4, t3, n3) {
  e4[t3] = bt2(e4[t3], n3, 1);
}
function wn2(e4, t3, n3, r4, i3, o4) {
  const { normalizeDepth: s3 = 3, normalizeMaxBreadth: a3 = 1e3 } = e4, c3 = { ...t3, event_id: t3.event_id || n3.event_id || ot2(), timestamp: t3.timestamp || rt2() }, l3 = n3.integrations || e4.integrations.map((e5) => e5.name);
  !function(e5, t4) {
    const { environment: n4, release: r5, dist: i4, maxValueLength: o5 = 250 } = t4;
    e5.environment = e5.environment || n4 || Ht2, !e5.release && r5 && (e5.release = r5);
    !e5.dist && i4 && (e5.dist = i4);
    e5.message && (e5.message = qe2(e5.message, o5));
    const s4 = e5.exception && e5.exception.values && e5.exception.values[0];
    s4 && s4.value && (s4.value = qe2(s4.value, o5));
    const a4 = e5.request;
    a4 && a4.url && (a4.url = qe2(a4.url, o5));
  }(c3, e4), function(e5, t4) {
    t4.length > 0 && (e5.sdk = e5.sdk || {}, e5.sdk.integrations = [...e5.sdk.integrations || [], ...t4]);
  }(c3, l3), i3 && i3.emit("applyFrameMetadata", t3), void 0 === t3.type && function(e5, t4) {
    const n4 = function(e6) {
      const t5 = re2._sentryDebugIds;
      if (!t5)
        return {};
      const n5 = Object.keys(t5);
      return mn2 && n5.length === gn2 || (gn2 = n5.length, mn2 = n5.reduce((n6, r5) => {
        vn2 || (vn2 = {});
        const i4 = vn2[r5];
        if (i4)
          n6[i4[0]] = i4[1];
        else {
          const i5 = e6(r5);
          for (let e7 = i5.length - 1; e7 >= 0; e7--) {
            const o5 = i5[e7], s4 = o5 && o5.filename, a4 = t5[r5];
            if (s4 && a4) {
              n6[s4] = a4, vn2[r5] = [s4, a4];
              break;
            }
          }
        }
        return n6;
      }, {})), mn2;
    }(t4);
    try {
      e5.exception.values.forEach((e6) => {
        e6.stacktrace.frames.forEach((e7) => {
          n4 && e7.filename && (e7.debug_id = n4[e7.filename]);
        });
      });
    } catch (e6) {
    }
  }(c3, e4.stackParser);
  const u3 = function(e5, t4) {
    if (!t4)
      return e5;
    const n4 = e5 ? e5.clone() : new Mt2();
    return n4.update(t4), n4;
  }(r4, n3.captureContext);
  n3.mechanism && lt2(c3, n3.mechanism);
  const d3 = i3 ? i3.getEventProcessors() : [], h4 = ie2("globalScope", () => new Mt2()).getScopeData();
  if (o4) {
    bn2(h4, o4.getScopeData());
  }
  if (u3) {
    bn2(h4, u3.getScopeData());
  }
  const p3 = [...n3.attachments || [], ...h4.attachments];
  p3.length && (n3.attachments = p3), yn2(c3, h4);
  return fn2([...d3, ...h4.eventProcessors], c3, n3).then((e5) => (e5 && function(e6) {
    const t4 = {};
    try {
      e6.exception.values.forEach((e7) => {
        e7.stacktrace.frames.forEach((e8) => {
          e8.debug_id && (e8.abs_path ? t4[e8.abs_path] = e8.debug_id : e8.filename && (t4[e8.filename] = e8.debug_id), delete e8.debug_id);
        });
      });
    } catch (e7) {
    }
    if (0 === Object.keys(t4).length)
      return;
    e6.debug_meta = e6.debug_meta || {}, e6.debug_meta.images = e6.debug_meta.images || [];
    const n4 = e6.debug_meta.images;
    Object.entries(t4).forEach(([e7, t5]) => {
      n4.push({ type: "sourcemap", code_file: e7, debug_id: t5 });
    });
  }(e5), "number" == typeof s3 && s3 > 0 ? function(e6, t4, n4) {
    if (!e6)
      return null;
    const r5 = { ...e6, ...e6.breadcrumbs && { breadcrumbs: e6.breadcrumbs.map((e7) => ({ ...e7, ...e7.data && { data: en2(e7.data, t4, n4) } })) }, ...e6.user && { user: en2(e6.user, t4, n4) }, ...e6.contexts && { contexts: en2(e6.contexts, t4, n4) }, ...e6.extra && { extra: en2(e6.extra, t4, n4) } };
    e6.contexts && e6.contexts.trace && r5.contexts && (r5.contexts.trace = e6.contexts.trace, e6.contexts.trace.data && (r5.contexts.trace.data = en2(e6.contexts.trace.data, t4, n4)));
    e6.spans && (r5.spans = e6.spans.map((e7) => ({ ...e7, ...e7.data && { data: en2(e7.data, t4, n4) } })));
    e6.contexts && e6.contexts.flags && r5.contexts && (r5.contexts.flags = en2(e6.contexts.flags, 3, n4));
    return r5;
  }(e5, s3, a3) : e5));
}
function Sn2(e4) {
  if (e4)
    return function(e5) {
      return e5 instanceof Mt2 || "function" == typeof e5;
    }(e4) || function(e5) {
      return Object.keys(e5).some((e6) => kn2.includes(e6));
    }(e4) ? { captureContext: e4 } : e4;
}
var kn2 = ["user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext"];
function Mn2(e4, t3) {
  return jt2().captureEvent(e4, t3);
}
function Cn2(e4) {
  const t3 = xt2(), n3 = It2(), r4 = jt2(), { release: i3, environment: o4 = Ht2 } = t3 && t3.getOptions() || {}, { userAgent: s3 } = re2.navigator || {}, a3 = vt2({ release: i3, environment: o4, user: r4.getUser() || n3.getUser(), ...s3 && { userAgent: s3 }, ...e4 }), c3 = n3.getSession();
  return c3 && "ok" === c3.status && gt2(c3, { status: "exited" }), En2(), n3.setSession(a3), r4.setSession(a3), a3;
}
function En2() {
  const e4 = It2(), t3 = jt2(), n3 = t3.getSession() || e4.getSession();
  n3 && function(e5, t4) {
    let n4 = {};
    t4 ? n4 = { status: t4 } : "ok" === e5.status && (n4 = { status: "exited" }), gt2(e5, n4);
  }(n3), Tn2(), e4.setSession(), t3.setSession();
}
function Tn2() {
  const e4 = It2(), t3 = jt2(), n3 = xt2(), r4 = t3.getSession() || e4.getSession();
  r4 && n3 && n3.captureSession(r4);
}
function On2(e4 = false) {
  e4 ? En2() : Tn2();
}
function Pn2(e4, t3, n3) {
  return t3 || `${function(e5) {
    return `${function(e6) {
      const t4 = e6.protocol ? `${e6.protocol}:` : "", n4 = e6.port ? `:${e6.port}` : "";
      return `${t4}//${e6.host}${n4}${e6.path ? `/${e6.path}` : ""}/api/`;
    }(e5)}${e5.projectId}/envelope/`;
  }(e4)}?${function(e5, t4) {
    const n4 = { sentry_version: "7" };
    return e5.publicKey && (n4.sentry_key = e5.publicKey), t4 && (n4.sentry_client = `${t4.name}/${t4.version}`), new URLSearchParams(n4).toString();
  }(e4, n3)}`;
}
var An2 = [];
function jn2(e4, t3) {
  for (const n3 of t3)
    n3 && n3.afterAllSetup && n3.afterAllSetup(e4);
}
function In2(e4, t3, n3) {
  if (n3[t3.name])
    te2 && le2.log(`Integration skipped because it was already installed: ${t3.name}`);
  else {
    if (n3[t3.name] = t3, -1 === An2.indexOf(t3.name) && "function" == typeof t3.setupOnce && (t3.setupOnce(), An2.push(t3.name)), t3.setup && "function" == typeof t3.setup && t3.setup(e4), "function" == typeof t3.preprocessEvent) {
      const n4 = t3.preprocessEvent.bind(t3);
      e4.on("preprocessEvent", (t4, r4) => n4(t4, r4, e4));
    }
    if ("function" == typeof t3.processEvent) {
      const n4 = t3.processEvent.bind(t3), r4 = Object.assign((t4, r5) => n4(t4, r5, e4), { id: t3.name });
      e4.addEventProcessor(r4);
    }
    te2 && le2.log(`Integration installed: ${t3.name}`);
  }
}
var xn2 = class extends Error {
  constructor(e4, t3 = "warn") {
    super(e4), this.message = e4, this.logLevel = t3;
  }
};
var Ln2 = "Not capturing exception because it's already been captured.";
var Dn2 = class {
  constructor(e4) {
    if (this._options = e4, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e4.dsn ? this._dsn = Zt2(e4.dsn) : te2 && le2.warn("No DSN provided, client will not send events."), this._dsn) {
      const t4 = Pn2(this._dsn, e4.tunnel, e4._metadata ? e4._metadata.sdk : void 0);
      this._transport = e4.transport({ tunnel: this._options.tunnel, recordDroppedEvent: this.recordDroppedEvent.bind(this), ...e4.transportOptions, url: t4 });
    }
    const t3 = ["enableTracing", "tracesSampleRate", "tracesSampler"].find((t4) => t4 in e4 && null == e4[t4]);
    t3 && ce2(() => {
      console.warn(`[Sentry] Deprecation warning: \`${t3}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`);
    });
  }
  captureException(e4, t3, n3) {
    const r4 = ot2();
    if (ut2(e4))
      return te2 && le2.log(Ln2), r4;
    const i3 = { event_id: r4, ...t3 };
    return this._process(this.eventFromException(e4, i3).then((e5) => this._captureEvent(e5, i3, n3))), i3.event_id;
  }
  captureMessage(e4, t3, n3, r4) {
    const i3 = { event_id: ot2(), ...n3 }, o4 = Le2(e4) ? e4 : String(e4), s3 = De2(e4) ? this.eventFromMessage(o4, t3, i3) : this.eventFromException(e4, i3);
    return this._process(s3.then((e5) => this._captureEvent(e5, i3, r4))), i3.event_id;
  }
  captureEvent(e4, t3, n3) {
    const r4 = ot2();
    if (t3 && t3.originalException && ut2(t3.originalException))
      return te2 && le2.log(Ln2), r4;
    const i3 = { event_id: r4, ...t3 }, o4 = (e4.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e4, i3, o4 || n3)), i3.event_id;
  }
  captureSession(e4) {
    "string" != typeof e4.release ? te2 && le2.warn("Discarded session because of missing or non-string release") : (this.sendSession(e4), gt2(e4, { init: false }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(e4) {
    const t3 = this._transport;
    return t3 ? (this.emit("flush"), this._isClientDoneProcessing(e4).then((n3) => t3.flush(e4).then((e5) => n3 && e5))) : ht2(true);
  }
  close(e4) {
    return this.flush(e4).then((e5) => (this.getOptions().enabled = false, this.emit("close"), e5));
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e4) {
    this._eventProcessors.push(e4);
  }
  init() {
    (this._isEnabled() || this._options.integrations.some(({ name: e4 }) => e4.startsWith("Spotlight"))) && this._setupIntegrations();
  }
  getIntegrationByName(e4) {
    return this._integrations[e4];
  }
  addIntegration(e4) {
    const t3 = this._integrations[e4.name];
    In2(this, e4, this._integrations), t3 || jn2(this, [e4]);
  }
  sendEvent(e4, t3 = {}) {
    this.emit("beforeSendEvent", e4, t3);
    let n3 = pn2(e4, this._dsn, this._options._metadata, this._options.tunnel);
    for (const e5 of t3.attachments || [])
      n3 = on2(n3, ln2(e5));
    const r4 = this.sendEnvelope(n3);
    r4 && r4.then((t4) => this.emit("afterSendEvent", e4, t4), null);
  }
  sendSession(e4) {
    const t3 = function(e5, t4, n3, r4) {
      const i3 = hn2(n3);
      return rn2({ sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...i3 && { sdk: i3 }, ...!!r4 && t4 && { dsn: Yt2(t4) } }, ["aggregates" in e5 ? [{ type: "sessions" }, e5] : [{ type: "session" }, e5.toJSON()]]);
    }(e4, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(t3);
  }
  recordDroppedEvent(e4, t3, n3) {
    if (this._options.sendClientReports) {
      const r4 = "number" == typeof n3 ? n3 : 1, i3 = `${e4}:${t3}`;
      te2 && le2.log(`Recording outcome: "${i3}"${r4 > 1 ? ` (${r4} times)` : ""}`), this._outcomes[i3] = (this._outcomes[i3] || 0) + r4;
    }
  }
  on(e4, t3) {
    const n3 = this._hooks[e4] = this._hooks[e4] || [];
    return n3.push(t3), () => {
      const e5 = n3.indexOf(t3);
      e5 > -1 && n3.splice(e5, 1);
    };
  }
  emit(e4, ...t3) {
    const n3 = this._hooks[e4];
    n3 && n3.forEach((e5) => e5(...t3));
  }
  sendEnvelope(e4) {
    return this.emit("beforeEnvelope", e4), this._isEnabled() && this._transport ? this._transport.send(e4).then(null, (e5) => (te2 && le2.error("Error while sending envelope:", e5), e5)) : (te2 && le2.error("Transport disabled"), ht2({}));
  }
  _setupIntegrations() {
    const { integrations: e4 } = this._options;
    this._integrations = function(e5, t3) {
      const n3 = {};
      return t3.forEach((t4) => {
        t4 && In2(e5, t4, n3);
      }), n3;
    }(this, e4), jn2(this, e4);
  }
  _updateSessionFromEvent(e4, t3) {
    let n3 = "fatal" === t3.level, r4 = false;
    const i3 = t3.exception && t3.exception.values;
    if (i3) {
      r4 = true;
      for (const e5 of i3) {
        const t4 = e5.mechanism;
        if (t4 && false === t4.handled) {
          n3 = true;
          break;
        }
      }
    }
    const o4 = "ok" === e4.status;
    (o4 && 0 === e4.errors || o4 && n3) && (gt2(e4, { ...n3 && { status: "crashed" }, errors: e4.errors || Number(r4 || n3) }), this.captureSession(e4));
  }
  _isClientDoneProcessing(e4) {
    return new ft2((t3) => {
      let n3 = 0;
      const r4 = setInterval(() => {
        0 == this._numProcessing ? (clearInterval(r4), t3(true)) : (n3 += 1, e4 && n3 >= e4 && (clearInterval(r4), t3(false)));
      }, 1);
    });
  }
  _isEnabled() {
    return false !== this.getOptions().enabled && void 0 !== this._transport;
  }
  _prepareEvent(e4, t3, n3 = jt2(), r4 = It2()) {
    const i3 = this.getOptions(), o4 = Object.keys(this._integrations);
    return !t3.integrations && o4.length > 0 && (t3.integrations = o4), this.emit("preprocessEvent", e4, t3), e4.type || r4.setLastEventId(e4.event_id || t3.event_id), wn2(i3, e4, t3, n3, this, r4).then((e5) => {
      if (null === e5)
        return e5;
      e5.contexts = { trace: Lt2(n3), ...e5.contexts };
      const t4 = function(e6, t5) {
        const n4 = t5.getPropagationContext();
        return n4.dsc || Gt2(n4.traceId, e6);
      }(this, n3);
      return e5.sdkProcessingMetadata = { dynamicSamplingContext: t4, ...e5.sdkProcessingMetadata }, e5;
    });
  }
  _captureEvent(e4, t3 = {}, n3) {
    return this._processEvent(e4, t3, n3).then((e5) => e5.event_id, (e5) => {
      te2 && (e5 instanceof xn2 && "log" === e5.logLevel ? le2.log(e5.message) : le2.warn(e5));
    });
  }
  _processEvent(e4, t3, n3) {
    const r4 = this.getOptions(), { sampleRate: i3 } = r4, o4 = Rn2(e4), s3 = Nn2(e4), a3 = e4.type || "error", c3 = `before send for type \`${a3}\``, l3 = void 0 === i3 ? void 0 : function(e5) {
      if ("boolean" == typeof e5)
        return Number(e5);
      const t4 = "string" == typeof e5 ? parseFloat(e5) : e5;
      if (!("number" != typeof t4 || isNaN(t4) || t4 < 0 || t4 > 1))
        return t4;
      te2 && le2.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e5)} of type ${JSON.stringify(typeof e5)}.`);
    }(i3);
    if (s3 && "number" == typeof l3 && Math.random() > l3)
      return this.recordDroppedEvent("sample_rate", "error", e4), pt2(new xn2(`Discarding event because it's not included in the random sample (sampling rate = ${i3})`, "log"));
    const u3 = "replay_event" === a3 ? "replay" : a3, d3 = (e4.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e4, t3, n3, d3).then((n4) => {
      if (null === n4)
        throw this.recordDroppedEvent("event_processor", u3, e4), new xn2("An event processor returned `null`, will not send event.", "log");
      if (t3.data && true === t3.data.__sentry__)
        return n4;
      const i4 = function(e5, t4, n5, r5) {
        const { beforeSend: i5, beforeSendTransaction: o5, beforeSendSpan: s4 } = t4;
        if (Nn2(n5) && i5)
          return i5(n5, r5);
        if (Rn2(n5)) {
          if (n5.spans && s4) {
            const t5 = [];
            for (const r6 of n5.spans) {
              const n6 = s4(r6);
              n6 ? t5.push(n6) : (Wt2(), e5.recordDroppedEvent("before_send", "span"));
            }
            n5.spans = t5;
          }
          if (o5) {
            if (n5.spans) {
              const e6 = n5.spans.length;
              n5.sdkProcessingMetadata = { ...n5.sdkProcessingMetadata, spanCountBeforeProcessing: e6 };
            }
            return o5(n5, r5);
          }
        }
        return n5;
      }(this, r4, n4, t3);
      return function(e5, t4) {
        const n5 = `${t4} must return \`null\` or a valid event.`;
        if (Fe2(e5))
          return e5.then((e6) => {
            if (!Ne2(e6) && null !== e6)
              throw new xn2(n5);
            return e6;
          }, (e6) => {
            throw new xn2(`${t4} rejected with ${e6}`);
          });
        if (!Ne2(e5) && null !== e5)
          throw new xn2(n5);
        return e5;
      }(i4, c3);
    }).then((r5) => {
      if (null === r5) {
        if (this.recordDroppedEvent("before_send", u3, e4), o4) {
          const t4 = 1 + (e4.spans || []).length;
          this.recordDroppedEvent("before_send", "span", t4);
        }
        throw new xn2(`${c3} returned \`null\`, will not send event.`, "log");
      }
      const i4 = n3 && n3.getSession();
      if (!o4 && i4 && this._updateSessionFromEvent(i4, r5), o4) {
        const e5 = (r5.sdkProcessingMetadata && r5.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (r5.spans ? r5.spans.length : 0);
        e5 > 0 && this.recordDroppedEvent("before_send", "span", e5);
      }
      const s4 = r5.transaction_info;
      if (o4 && s4 && r5.transaction !== e4.transaction) {
        const e5 = "custom";
        r5.transaction_info = { ...s4, source: e5 };
      }
      return this.sendEvent(r5, t3), r5;
    }).then(null, (e5) => {
      if (e5 instanceof xn2)
        throw e5;
      throw this.captureException(e5, { data: { __sentry__: true }, originalException: e5 }), new xn2(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${e5}`);
    });
  }
  _process(e4) {
    this._numProcessing++, e4.then((e5) => (this._numProcessing--, e5), (e5) => (this._numProcessing--, e5));
  }
  _clearOutcomes() {
    const e4 = this._outcomes;
    return this._outcomes = {}, Object.entries(e4).map(([e5, t3]) => {
      const [n3, r4] = e5.split(":");
      return { reason: n3, category: r4, quantity: t3 };
    });
  }
  _flushOutcomes() {
    te2 && le2.log("Flushing outcomes...");
    const e4 = this._clearOutcomes();
    if (0 === e4.length)
      return void (te2 && le2.log("No outcomes to send"));
    if (!this._dsn)
      return void (te2 && le2.log("No dsn provided, will not send outcomes"));
    te2 && le2.log("Sending outcomes:", e4);
    const t3 = (n3 = e4, rn2((r4 = this._options.tunnel && Yt2(this._dsn)) ? { dsn: r4 } : {}, [[{ type: "client_report" }, { timestamp: i3 || rt2(), discarded_events: n3 }]]));
    var n3, r4, i3;
    this.sendEnvelope(t3);
  }
};
function Nn2(e4) {
  return void 0 === e4.type;
}
function Rn2(e4) {
  return "transaction" === e4.type;
}
function Fn2(e4) {
  const t3 = [];
  function n3(e5) {
    return t3.splice(t3.indexOf(e5), 1)[0] || Promise.resolve(void 0);
  }
  return { $: t3, add: function(r4) {
    if (!(void 0 === e4 || t3.length < e4))
      return pt2(new xn2("Not adding Promise because buffer limit was reached."));
    const i3 = r4();
    return -1 === t3.indexOf(i3) && t3.push(i3), i3.then(() => n3(i3)).then(null, () => n3(i3).then(null, () => {
    })), i3;
  }, drain: function(e5) {
    return new ft2((n4, r4) => {
      let i3 = t3.length;
      if (!i3)
        return n4(true);
      const o4 = setTimeout(() => {
        e5 && e5 > 0 && n4(false);
      }, e5);
      t3.forEach((e6) => {
        ht2(e6).then(() => {
          --i3 || (clearTimeout(o4), n4(true));
        }, r4);
      });
    });
  } };
}
function Bn2(e4, { statusCode: t3, headers: n3 }, r4 = Date.now()) {
  const i3 = { ...e4 }, o4 = n3 && n3["x-sentry-rate-limits"], s3 = n3 && n3["retry-after"];
  if (o4)
    for (const e5 of o4.trim().split(",")) {
      const [t4, n4, , , o5] = e5.split(":", 5), s4 = parseInt(t4, 10), a3 = 1e3 * (isNaN(s4) ? 60 : s4);
      if (n4)
        for (const e6 of n4.split(";"))
          "metric_bucket" === e6 && o5 && !o5.split(";").includes("custom") || (i3[e6] = r4 + a3);
      else
        i3.all = r4 + a3;
    }
  else
    s3 ? i3.all = r4 + function(e5, t4 = Date.now()) {
      const n4 = parseInt(`${e5}`, 10);
      if (!isNaN(n4))
        return 1e3 * n4;
      const r5 = Date.parse(`${e5}`);
      return isNaN(r5) ? 6e4 : r5 - t4;
    }(s3, r4) : 429 === t3 && (i3.all = r4 + 6e4);
  return i3;
}
function Un2(e4, t3, n3 = Fn2(e4.bufferSize || 64)) {
  let r4 = {};
  return { send: function(i3) {
    const o4 = [];
    if (sn2(i3, (t4, n4) => {
      const i4 = dn2(n4);
      if (function(e5, t5, n5 = Date.now()) {
        return function(e6, t6) {
          return e6[t6] || e6.all || 0;
        }(e5, t5) > n5;
      }(r4, i4)) {
        const r5 = Vn2(t4, n4);
        e4.recordDroppedEvent("ratelimit_backoff", i4, r5);
      } else
        o4.push(t4);
    }), 0 === o4.length)
      return ht2({});
    const s3 = rn2(i3[0], o4), a3 = (t4) => {
      sn2(s3, (n4, r5) => {
        const i4 = Vn2(n4, r5);
        e4.recordDroppedEvent(t4, dn2(r5), i4);
      });
    };
    return n3.add(() => t3({ body: cn2(s3) }).then((e5) => (void 0 !== e5.statusCode && (e5.statusCode < 200 || e5.statusCode >= 300) && te2 && le2.warn(`Sentry responded with status code ${e5.statusCode} to sent event.`), r4 = Bn2(r4, e5), e5), (e5) => {
      throw a3("network_error"), e5;
    })).then((e5) => e5, (e5) => {
      if (e5 instanceof xn2)
        return te2 && le2.error("Skipped sending event because buffer is full."), a3("queue_overflow"), ht2({});
      throw e5;
    });
  }, flush: (e5) => n3.drain(e5) };
}
function Vn2(e4, t3) {
  if ("event" === t3 || "transaction" === t3)
    return Array.isArray(e4) ? e4[1] : void 0;
}
var Jn2 = 100;
function $n2(e4, t3) {
  const n3 = xt2(), r4 = It2();
  if (!n3)
    return;
  const { beforeBreadcrumb: i3 = null, maxBreadcrumbs: o4 = Jn2 } = n3.getOptions();
  if (o4 <= 0)
    return;
  const s3 = { timestamp: rt2(), ...e4 }, a3 = i3 ? ce2(() => i3(s3, t3)) : s3;
  null !== a3 && (n3.emit && n3.emit("beforeAddBreadcrumb", a3, t3), r4.addBreadcrumb(a3, o4));
}
var qn2;
var zn2 = /* @__PURE__ */ new WeakMap();
var Wn2 = () => ({ name: "FunctionToString", setupOnce() {
  qn2 = Function.prototype.toString;
  try {
    Function.prototype.toString = function(...e4) {
      const t3 = Ye2(this), n3 = zn2.has(xt2()) && void 0 !== t3 ? t3 : this;
      return qn2.apply(n3, e4);
    };
  } catch (e4) {
  }
}, setup(e4) {
  zn2.set(e4, true);
} });
var Hn2 = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/];
var Gn2 = (e4 = {}) => ({ name: "InboundFilters", processEvent(t3, n3, r4) {
  const i3 = r4.getOptions(), o4 = function(e5 = {}, t4 = {}) {
    return { allowUrls: [...e5.allowUrls || [], ...t4.allowUrls || []], denyUrls: [...e5.denyUrls || [], ...t4.denyUrls || []], ignoreErrors: [...e5.ignoreErrors || [], ...t4.ignoreErrors || [], ...e5.disableErrorDefaults ? [] : Hn2], ignoreTransactions: [...e5.ignoreTransactions || [], ...t4.ignoreTransactions || []], ignoreInternal: void 0 === e5.ignoreInternal || e5.ignoreInternal };
  }(e4, i3);
  return function(e5, t4) {
    if (t4.ignoreInternal && function(e6) {
      try {
        return "SentryError" === e6.exception.values[0].type;
      } catch (e7) {
      }
      return false;
    }(e5))
      return te2 && le2.warn(`Event dropped due to being internal Sentry Error.
Event: ${at2(e5)}`), true;
    if (function(e6, t5) {
      if (e6.type || !t5 || !t5.length)
        return false;
      return function(e7) {
        const t6 = [];
        e7.message && t6.push(e7.message);
        let n4;
        try {
          n4 = e7.exception.values[e7.exception.values.length - 1];
        } catch (e8) {
        }
        n4 && n4.value && (t6.push(n4.value), n4.type && t6.push(`${n4.type}: ${n4.value}`));
        return t6;
      }(e6).some((e7) => He2(e7, t5));
    }(e5, t4.ignoreErrors))
      return te2 && le2.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${at2(e5)}`), true;
    if (function(e6) {
      if (e6.type)
        return false;
      if (!e6.exception || !e6.exception.values || 0 === e6.exception.values.length)
        return false;
      return !e6.message && !e6.exception.values.some((e7) => e7.stacktrace || e7.type && "Error" !== e7.type || e7.value);
    }(e5))
      return te2 && le2.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${at2(e5)}`), true;
    if (function(e6, t5) {
      if ("transaction" !== e6.type || !t5 || !t5.length)
        return false;
      const n4 = e6.transaction;
      return !!n4 && He2(n4, t5);
    }(e5, t4.ignoreTransactions))
      return te2 && le2.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${at2(e5)}`), true;
    if (function(e6, t5) {
      if (!t5 || !t5.length)
        return false;
      const n4 = Qn2(e6);
      return !!n4 && He2(n4, t5);
    }(e5, t4.denyUrls))
      return te2 && le2.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${at2(e5)}.
Url: ${Qn2(e5)}`), true;
    if (!function(e6, t5) {
      if (!t5 || !t5.length)
        return true;
      const n4 = Qn2(e6);
      return !n4 || He2(n4, t5);
    }(e5, t4.allowUrls))
      return te2 && le2.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${at2(e5)}.
Url: ${Qn2(e5)}`), true;
    return false;
  }(t3, o4) ? null : t3;
} });
function Qn2(e4) {
  try {
    let t3;
    try {
      t3 = e4.exception.values[0].stacktrace.frames;
    } catch (e5) {
    }
    return t3 ? function(e5 = []) {
      for (let t4 = e5.length - 1; t4 >= 0; t4--) {
        const n3 = e5[t4];
        if (n3 && "<anonymous>" !== n3.filename && "[native code]" !== n3.filename)
          return n3.filename || null;
      }
      return null;
    }(t3) : null;
  } catch (t3) {
    return te2 && le2.error(`Cannot extract url for event ${at2(e4)}`), null;
  }
}
function Kn2(e4, t3, n3 = 250, r4, i3, o4, s3) {
  if (!(o4.exception && o4.exception.values && s3 && Be2(s3.originalException, Error)))
    return;
  const a3 = o4.exception.values.length > 0 ? o4.exception.values[o4.exception.values.length - 1] : void 0;
  var c3, l3;
  a3 && (o4.exception.values = (c3 = Yn2(e4, t3, i3, s3.originalException, r4, o4.exception.values, a3, 0), l3 = n3, c3.map((e5) => (e5.value && (e5.value = qe2(e5.value, l3)), e5))));
}
function Yn2(e4, t3, n3, r4, i3, o4, s3, a3) {
  if (o4.length >= n3 + 1)
    return o4;
  let c3 = [...o4];
  if (Be2(r4[i3], Error)) {
    Xn2(s3, a3);
    const o5 = e4(t3, r4[i3]), l3 = c3.length;
    Zn2(o5, i3, l3, a3), c3 = Yn2(e4, t3, n3, r4[i3], i3, [o5, ...c3], o5, l3);
  }
  return Array.isArray(r4.errors) && r4.errors.forEach((r5, o5) => {
    if (Be2(r5, Error)) {
      Xn2(s3, a3);
      const l3 = e4(t3, r5), u3 = c3.length;
      Zn2(l3, `errors[${o5}]`, u3, a3), c3 = Yn2(e4, t3, n3, r5, i3, [l3, ...c3], l3, u3);
    }
  }), c3;
}
function Xn2(e4, t3) {
  e4.mechanism = e4.mechanism || { type: "generic", handled: true }, e4.mechanism = { ...e4.mechanism, ..."AggregateError" === e4.type && { is_exception_group: true }, exception_id: t3 };
}
function Zn2(e4, t3, n3, r4) {
  e4.mechanism = e4.mechanism || { type: "generic", handled: true }, e4.mechanism = { ...e4.mechanism, type: "chained", source: t3, exception_id: n3, parent_id: r4 };
}
function er2(e4) {
  if (!e4)
    return {};
  const t3 = e4.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t3)
    return {};
  const n3 = t3[6] || "", r4 = t3[8] || "";
  return { host: t3[4], path: t3[5], protocol: t3[2], search: n3, hash: r4, relative: t3[5] + n3 + r4 };
}
function tr2() {
  "console" in re2 && se2.forEach(function(e4) {
    e4 in re2.console && Ge2(re2.console, e4, function(t3) {
      return ae2[e4] = t3, function(...t4) {
        we2("console", { args: t4, level: e4 });
        const n3 = ae2[e4];
        n3 && n3.apply(re2.console, t4);
      };
    });
  });
}
function nr2(e4) {
  return "warn" === e4 ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(e4) ? e4 : "log";
}
var rr2 = () => {
  let e4;
  return { name: "Dedupe", processEvent(t3) {
    if (t3.type)
      return t3;
    try {
      if (function(e5, t4) {
        if (!t4)
          return false;
        if (function(e6, t5) {
          const n3 = e6.message, r4 = t5.message;
          if (!n3 && !r4)
            return false;
          if (n3 && !r4 || !n3 && r4)
            return false;
          if (n3 !== r4)
            return false;
          if (!or2(e6, t5))
            return false;
          if (!ir2(e6, t5))
            return false;
          return true;
        }(e5, t4))
          return true;
        if (function(e6, t5) {
          const n3 = sr2(t5), r4 = sr2(e6);
          if (!n3 || !r4)
            return false;
          if (n3.type !== r4.type || n3.value !== r4.value)
            return false;
          if (!or2(e6, t5))
            return false;
          if (!ir2(e6, t5))
            return false;
          return true;
        }(e5, t4))
          return true;
        return false;
      }(t3, e4))
        return te2 && le2.warn("Event dropped due to being a duplicate of previously captured event."), null;
    } catch (e5) {
    }
    return e4 = t3;
  } };
};
function ir2(e4, t3) {
  let n3 = ge2(e4), r4 = ge2(t3);
  if (!n3 && !r4)
    return true;
  if (n3 && !r4 || !n3 && r4)
    return false;
  if (r4.length !== n3.length)
    return false;
  for (let e5 = 0; e5 < r4.length; e5++) {
    const t4 = r4[e5], i3 = n3[e5];
    if (t4.filename !== i3.filename || t4.lineno !== i3.lineno || t4.colno !== i3.colno || t4.function !== i3.function)
      return false;
  }
  return true;
}
function or2(e4, t3) {
  let n3 = e4.fingerprint, r4 = t3.fingerprint;
  if (!n3 && !r4)
    return true;
  if (n3 && !r4 || !n3 && r4)
    return false;
  try {
    return !(n3.join("") !== r4.join(""));
  } catch (e5) {
    return false;
  }
}
function sr2(e4) {
  return e4.exception && e4.exception.values && e4.exception.values[0];
}
function ar2(e4) {
  return void 0 === e4 ? void 0 : e4 >= 400 && e4 < 500 ? "warning" : e4 >= 500 ? "error" : void 0;
}
var cr2 = re2;
function lr2(e4) {
  return e4 && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e4.toString());
}
function ur2() {
  if ("string" == typeof EdgeRuntime)
    return true;
  if (!function() {
    if (!("fetch" in cr2))
      return false;
    try {
      return new Headers(), new Request("http://www.example.com"), new Response(), true;
    } catch (e5) {
      return false;
    }
  }())
    return false;
  if (lr2(cr2.fetch))
    return true;
  let e4 = false;
  const t3 = cr2.document;
  if (t3 && "function" == typeof t3.createElement)
    try {
      const n3 = t3.createElement("iframe");
      n3.hidden = true, t3.head.appendChild(n3), n3.contentWindow && n3.contentWindow.fetch && (e4 = lr2(n3.contentWindow.fetch)), t3.head.removeChild(n3);
    } catch (e5) {
      oe2 && le2.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e5);
    }
  return e4;
}
function dr2(e4, t3) {
  const n3 = "fetch";
  be2(n3, e4), _e2(n3, () => function(e5, t4 = false) {
    if (t4 && !ur2())
      return;
    Ge2(re2, "fetch", function(t5) {
      return function(...n4) {
        const r4 = new Error(), { method: i3, url: o4 } = function(e6) {
          if (0 === e6.length)
            return { method: "GET", url: "" };
          if (2 === e6.length) {
            const [t7, n5] = e6;
            return { url: pr2(t7), method: hr2(n5, "method") ? String(n5.method).toUpperCase() : "GET" };
          }
          const t6 = e6[0];
          return { url: pr2(t6), method: hr2(t6, "method") ? String(t6.method).toUpperCase() : "GET" };
        }(n4), s3 = { args: n4, fetchData: { method: i3, url: o4 }, startTimestamp: 1e3 * it2(), virtualError: r4 };
        return e5 || we2("fetch", { ...s3 }), t5.apply(re2, n4).then(async (t6) => (e5 ? e5(t6) : we2("fetch", { ...s3, endTimestamp: 1e3 * it2(), response: t6 }), t6), (e6) => {
          throw we2("fetch", { ...s3, endTimestamp: 1e3 * it2(), error: e6 }), Pe2(e6) && void 0 === e6.stack && (e6.stack = r4.stack, Qe2(e6, "framesToPop", 1)), e6;
        });
      };
    });
  }(void 0, t3));
}
function hr2(e4, t3) {
  return !!e4 && "object" == typeof e4 && !!e4[t3];
}
function pr2(e4) {
  return "string" == typeof e4 ? e4 : e4 ? hr2(e4, "url") ? e4.url : e4.toString ? e4.toString() : "" : "";
}
var fr2 = re2;
var vr2 = re2;
var gr2 = 0;
function mr2() {
  return gr2 > 0;
}
function yr2(e4, t3 = {}) {
  if (!function(e5) {
    return "function" == typeof e5;
  }(e4))
    return e4;
  try {
    const t4 = e4.__sentry_wrapped__;
    if (t4)
      return "function" == typeof t4 ? t4 : e4;
    if (Ye2(e4))
      return e4;
  } catch (t4) {
    return e4;
  }
  const n3 = function(...n4) {
    try {
      const r4 = n4.map((e5) => yr2(e5, t3));
      return e4.apply(this, r4);
    } catch (e5) {
      throw gr2++, setTimeout(() => {
        gr2--;
      }), function(...e6) {
        const t4 = At2(Ee2());
        if (2 === e6.length) {
          const [n5, r4] = e6;
          return n5 ? t4.withSetScope(n5, r4) : t4.withScope(r4);
        }
        t4.withScope(e6[0]);
      }((r4) => {
        var i3, o4;
        r4.addEventProcessor((e6) => (t3.mechanism && (ct2(e6, void 0, void 0), lt2(e6, t3.mechanism)), e6.extra = { ...e6.extra, arguments: n4 }, e6)), i3 = e5, jt2().captureException(i3, Sn2(o4));
      }), e5;
    }
  };
  try {
    for (const t4 in e4)
      Object.prototype.hasOwnProperty.call(e4, t4) && (n3[t4] = e4[t4]);
  } catch (e5) {
  }
  Ke2(n3, e4), Qe2(e4, "__sentry_wrapped__", n3);
  try {
    Object.getOwnPropertyDescriptor(n3, "name").configurable && Object.defineProperty(n3, "name", { get: () => e4.name });
  } catch (e5) {
  }
  return n3;
}
var br2 = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
function _r2(e4, t3) {
  const n3 = kr2(e4, t3), r4 = { type: Er2(t3), value: Tr2(t3) };
  return n3.length && (r4.stacktrace = { frames: n3 }), void 0 === r4.type && "" === r4.value && (r4.value = "Unrecoverable error caught"), r4;
}
function wr2(e4, t3, n3, r4) {
  const i3 = xt2(), o4 = i3 && i3.getOptions().normalizeDepth, s3 = function(e5) {
    for (const t4 in e5)
      if (Object.prototype.hasOwnProperty.call(e5, t4)) {
        const n4 = e5[t4];
        if (n4 instanceof Error)
          return n4;
      }
    return;
  }(t3), a3 = { __serialized__: tn2(t3, o4) };
  if (s3)
    return { exception: { values: [_r2(e4, s3)] }, extra: a3 };
  const c3 = { exception: { values: [{ type: Re2(t3) ? t3.constructor.name : r4 ? "UnhandledRejection" : "Error", value: Ar2(t3, { isUnhandledRejection: r4 }) }] }, extra: a3 };
  if (n3) {
    const t4 = kr2(e4, n3);
    t4.length && (c3.exception.values[0].stacktrace = { frames: t4 });
  }
  return c3;
}
function Sr2(e4, t3) {
  return { exception: { values: [_r2(e4, t3)] } };
}
function kr2(e4, t3) {
  const n3 = t3.stacktrace || t3.stack || "", r4 = function(e5) {
    if (e5 && Mr2.test(e5.message))
      return 1;
    return 0;
  }(t3), i3 = function(e5) {
    if ("number" == typeof e5.framesToPop)
      return e5.framesToPop;
    return 0;
  }(t3);
  try {
    return e4(n3, r4, i3);
  } catch (e5) {
  }
  return [];
}
var Mr2 = /Minified React error #\d+;/i;
function Cr2(e4) {
  return "undefined" != typeof WebAssembly && void 0 !== WebAssembly.Exception && e4 instanceof WebAssembly.Exception;
}
function Er2(e4) {
  const t3 = e4 && e4.name;
  if (!t3 && Cr2(e4)) {
    return e4.message && Array.isArray(e4.message) && 2 == e4.message.length ? e4.message[0] : "WebAssembly.Exception";
  }
  return t3;
}
function Tr2(e4) {
  const t3 = e4 && e4.message;
  return t3 ? t3.error && "string" == typeof t3.error.message ? t3.error.message : Cr2(e4) && Array.isArray(e4.message) && 2 == e4.message.length ? e4.message[1] : t3 : "No error message";
}
function Or2(e4, t3, n3, r4, i3) {
  let o4;
  if (je2(t3) && t3.error) {
    return Sr2(e4, t3.error);
  }
  if (Ie2(t3) || Ae2(t3, "DOMException")) {
    const i4 = t3;
    if ("stack" in t3)
      o4 = Sr2(e4, t3);
    else {
      const t4 = i4.name || (Ie2(i4) ? "DOMError" : "DOMException"), s3 = i4.message ? `${t4}: ${i4.message}` : t4;
      o4 = Pr2(e4, s3, n3, r4), ct2(o4, s3);
    }
    return "code" in i4 && (o4.tags = { ...o4.tags, "DOMException.code": `${i4.code}` }), o4;
  }
  if (Pe2(t3))
    return Sr2(e4, t3);
  if (Ne2(t3) || Re2(t3)) {
    return o4 = wr2(e4, t3, n3, i3), lt2(o4, { synthetic: true }), o4;
  }
  return o4 = Pr2(e4, t3, n3, r4), ct2(o4, `${t3}`, void 0), lt2(o4, { synthetic: true }), o4;
}
function Pr2(e4, t3, n3, r4) {
  const i3 = {};
  if (r4 && n3) {
    const r5 = kr2(e4, n3);
    r5.length && (i3.exception = { values: [{ value: t3, stacktrace: { frames: r5 } }] }), lt2(i3, { synthetic: true });
  }
  if (Le2(t3)) {
    const { __sentry_template_string__: e5, __sentry_template_values__: n4 } = t3;
    return i3.logentry = { message: e5, params: n4 }, i3;
  }
  return i3.message = t3, i3;
}
function Ar2(e4, { isUnhandledRejection: t3 }) {
  const n3 = function(e5, t4 = 40) {
    const n4 = Object.keys(Xe2(e5));
    n4.sort();
    const r5 = n4[0];
    if (!r5)
      return "[object has no keys]";
    if (r5.length >= t4)
      return qe2(r5, t4);
    for (let e6 = n4.length; e6 > 0; e6--) {
      const r6 = n4.slice(0, e6).join(", ");
      if (!(r6.length > t4))
        return e6 === n4.length ? r6 : qe2(r6, t4);
    }
    return "";
  }(e4), r4 = t3 ? "promise rejection" : "exception";
  if (je2(e4))
    return `Event \`ErrorEvent\` captured as ${r4} with message \`${e4.message}\``;
  if (Re2(e4)) {
    return `Event \`${function(e5) {
      try {
        const t4 = Object.getPrototypeOf(e5);
        return t4 ? t4.constructor.name : void 0;
      } catch (e6) {
      }
    }(e4)}\` (type=${e4.type}) captured as ${r4}`;
  }
  return `Object captured as ${r4} with keys: ${n3}`;
}
var jr2 = class extends Dn2 {
  constructor(e4) {
    const t3 = { parentSpanIsAlwaysRootSpan: true, ...e4 };
    !function(e5, t4, n3 = [t4], r4 = "npm") {
      const i3 = e5._metadata || {};
      i3.sdk || (i3.sdk = { name: `sentry.javascript.${t4}`, packages: n3.map((e6) => ({ name: `${r4}:@sentry/${e6}`, version: ne2 })), version: ne2 }), e5._metadata = i3;
    }(t3, "browser", ["browser"], vr2.SENTRY_SDK_SOURCE || "npm"), super(t3), t3.sendClientReports && vr2.document && vr2.document.addEventListener("visibilitychange", () => {
      "hidden" === vr2.document.visibilityState && this._flushOutcomes();
    });
  }
  eventFromException(e4, t3) {
    return function(e5, t4, n3, r4) {
      const i3 = Or2(e5, t4, n3 && n3.syntheticException || void 0, r4);
      return lt2(i3), i3.level = "error", n3 && n3.event_id && (i3.event_id = n3.event_id), ht2(i3);
    }(this._options.stackParser, e4, t3, this._options.attachStacktrace);
  }
  eventFromMessage(e4, t3 = "info", n3) {
    return function(e5, t4, n4 = "info", r4, i3) {
      const o4 = Pr2(e5, t4, r4 && r4.syntheticException || void 0, i3);
      return o4.level = n4, r4 && r4.event_id && (o4.event_id = r4.event_id), ht2(o4);
    }(this._options.stackParser, e4, t3, n3, this._options.attachStacktrace);
  }
  captureUserFeedback(e4) {
    if (!this._isEnabled())
      return void (br2 && le2.warn("SDK not enabled, will not capture user feedback."));
    const t3 = function(e5, { metadata: t4, tunnel: n3, dsn: r4 }) {
      const i3 = { event_id: e5.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t4 && t4.sdk && { sdk: { name: t4.sdk.name, version: t4.sdk.version } }, ...!!n3 && !!r4 && { dsn: Yt2(r4) } }, o4 = function(e6) {
        return [{ type: "user_report" }, e6];
      }(e5);
      return rn2(i3, [o4]);
    }(e4, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel });
    this.sendEnvelope(t3);
  }
  _prepareEvent(e4, t3, n3) {
    return e4.platform = e4.platform || "javascript", super._prepareEvent(e4, t3, n3);
  }
};
var Ir2 = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
var xr2 = re2;
var Lr2;
var Dr2;
var Nr2;
var Rr2;
function Fr2() {
  if (!xr2.document)
    return;
  const e4 = we2.bind(null, "dom"), t3 = Br2(e4, true);
  xr2.document.addEventListener("click", t3, false), xr2.document.addEventListener("keypress", t3, false), ["EventTarget", "Node"].forEach((t4) => {
    const n3 = xr2[t4], r4 = n3 && n3.prototype;
    r4 && r4.hasOwnProperty && r4.hasOwnProperty("addEventListener") && (Ge2(r4, "addEventListener", function(t5) {
      return function(n4, r5, i3) {
        if ("click" === n4 || "keypress" == n4)
          try {
            const r6 = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}, o4 = r6[n4] = r6[n4] || { refCount: 0 };
            if (!o4.handler) {
              const r7 = Br2(e4);
              o4.handler = r7, t5.call(this, n4, r7, i3);
            }
            o4.refCount++;
          } catch (e5) {
          }
        return t5.call(this, n4, r5, i3);
      };
    }), Ge2(r4, "removeEventListener", function(e5) {
      return function(t5, n4, r5) {
        if ("click" === t5 || "keypress" == t5)
          try {
            const n5 = this.__sentry_instrumentation_handlers__ || {}, i3 = n5[t5];
            i3 && (i3.refCount--, i3.refCount <= 0 && (e5.call(this, t5, i3.handler, r5), i3.handler = void 0, delete n5[t5]), 0 === Object.keys(n5).length && delete this.__sentry_instrumentation_handlers__);
          } catch (e6) {
          }
        return e5.call(this, t5, n4, r5);
      };
    }));
  });
}
function Br2(e4, t3 = false) {
  return (n3) => {
    if (!n3 || n3._sentryCaptured)
      return;
    const r4 = function(e5) {
      try {
        return e5.target;
      } catch (e6) {
        return null;
      }
    }(n3);
    if (function(e5, t4) {
      return "keypress" === e5 && (!t4 || !t4.tagName || "INPUT" !== t4.tagName && "TEXTAREA" !== t4.tagName && !t4.isContentEditable);
    }(n3.type, r4))
      return;
    Qe2(n3, "_sentryCaptured", true), r4 && !r4._sentryId && Qe2(r4, "_sentryId", ot2());
    const i3 = "keypress" === n3.type ? "input" : n3.type;
    if (!function(e5) {
      if (e5.type !== Dr2)
        return false;
      try {
        if (!e5.target || e5.target._sentryId !== Nr2)
          return false;
      } catch (e6) {
      }
      return true;
    }(n3)) {
      e4({ event: n3, name: i3, global: t3 }), Dr2 = n3.type, Nr2 = r4 ? r4._sentryId : void 0;
    }
    clearTimeout(Lr2), Lr2 = xr2.setTimeout(() => {
      Nr2 = void 0, Dr2 = void 0;
    }, 1e3);
  };
}
function Ur2(e4) {
  const t3 = "history";
  be2(t3, e4), _e2(t3, Vr2);
}
function Vr2() {
  if (!function() {
    const e5 = fr2.chrome, t4 = e5 && e5.app && e5.app.runtime, n3 = "history" in fr2 && !!fr2.history.pushState && !!fr2.history.replaceState;
    return !t4 && n3;
  }())
    return;
  const e4 = xr2.onpopstate;
  function t3(e5) {
    return function(...t4) {
      const n3 = t4.length > 2 ? t4[2] : void 0;
      if (n3) {
        const e6 = Rr2, t5 = String(n3);
        Rr2 = t5;
        we2("history", { from: e6, to: t5 });
      }
      return e5.apply(this, t4);
    };
  }
  xr2.onpopstate = function(...t4) {
    const n3 = xr2.location.href, r4 = Rr2;
    Rr2 = n3;
    if (we2("history", { from: r4, to: n3 }), e4)
      try {
        return e4.apply(this, t4);
      } catch (e5) {
      }
  }, Ge2(xr2.history, "pushState", t3), Ge2(xr2.history, "replaceState", t3);
}
var Jr2 = {};
function $r2(e4) {
  Jr2[e4] = void 0;
}
var qr2 = "__sentry_xhr_v3__";
function zr2() {
  if (!xr2.XMLHttpRequest)
    return;
  const e4 = XMLHttpRequest.prototype;
  e4.open = new Proxy(e4.open, { apply(e5, t3, n3) {
    const r4 = new Error(), i3 = 1e3 * it2(), o4 = xe2(n3[0]) ? n3[0].toUpperCase() : void 0, s3 = function(e6) {
      if (xe2(e6))
        return e6;
      try {
        return e6.toString();
      } catch (e7) {
      }
      return;
    }(n3[1]);
    if (!o4 || !s3)
      return e5.apply(t3, n3);
    t3[qr2] = { method: o4, url: s3, request_headers: {} }, "POST" === o4 && s3.match(/sentry_key/) && (t3.__sentry_own_request__ = true);
    const a3 = () => {
      const e6 = t3[qr2];
      if (e6 && 4 === t3.readyState) {
        try {
          e6.status_code = t3.status;
        } catch (e7) {
        }
        we2("xhr", { endTimestamp: 1e3 * it2(), startTimestamp: i3, xhr: t3, virtualError: r4 });
      }
    };
    return "onreadystatechange" in t3 && "function" == typeof t3.onreadystatechange ? t3.onreadystatechange = new Proxy(t3.onreadystatechange, { apply: (e6, t4, n4) => (a3(), e6.apply(t4, n4)) }) : t3.addEventListener("readystatechange", a3), t3.setRequestHeader = new Proxy(t3.setRequestHeader, { apply(e6, t4, n4) {
      const [r5, i4] = n4, o5 = t4[qr2];
      return o5 && xe2(r5) && xe2(i4) && (o5.request_headers[r5.toLowerCase()] = i4), e6.apply(t4, n4);
    } }), e5.apply(t3, n3);
  } }), e4.send = new Proxy(e4.send, { apply(e5, t3, n3) {
    const r4 = t3[qr2];
    if (!r4)
      return e5.apply(t3, n3);
    void 0 !== n3[0] && (r4.body = n3[0]);
    return we2("xhr", { startTimestamp: 1e3 * it2(), xhr: t3 }), e5.apply(t3, n3);
  } });
}
function Wr2(e4, t3 = function(e5) {
  const t4 = Jr2[e5];
  if (t4)
    return t4;
  let n3 = xr2[e5];
  if (lr2(n3))
    return Jr2[e5] = n3.bind(xr2);
  const r4 = xr2.document;
  if (r4 && "function" == typeof r4.createElement)
    try {
      const t5 = r4.createElement("iframe");
      t5.hidden = true, r4.head.appendChild(t5);
      const i3 = t5.contentWindow;
      i3 && i3[e5] && (n3 = i3[e5]), r4.head.removeChild(t5);
    } catch (t5) {
      Ir2 && le2.warn(`Could not create sandbox iframe for ${e5} check, bailing to window.${e5}: `, t5);
    }
  return n3 ? Jr2[e5] = n3.bind(xr2) : n3;
}("fetch")) {
  let n3 = 0, r4 = 0;
  return Un2(e4, function(i3) {
    const o4 = i3.body.length;
    n3 += o4, r4++;
    const s3 = { body: i3.body, method: "POST", referrerPolicy: "origin", headers: e4.headers, keepalive: n3 <= 6e4 && r4 < 15, ...e4.fetchOptions };
    if (!t3)
      return $r2("fetch"), pt2("No fetch implementation available");
    try {
      return t3(e4.url, s3).then((e5) => (n3 -= o4, r4--, { statusCode: e5.status, headers: { "x-sentry-rate-limits": e5.headers.get("X-Sentry-Rate-Limits"), "retry-after": e5.headers.get("Retry-After") } }));
    } catch (e5) {
      return $r2("fetch"), n3 -= o4, r4--, pt2(e5);
    }
  });
}
function Hr2(e4, t3, n3, r4) {
  const i3 = { filename: e4, function: "<anonymous>" === t3 ? ue2 : t3, in_app: true };
  return void 0 !== n3 && (i3.lineno = n3), void 0 !== r4 && (i3.colno = r4), i3;
}
var Gr2 = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
var Qr2 = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var Kr2 = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var Yr2 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var Xr2 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var Zr2 = function(...e4) {
  const t3 = e4.sort((e5, t4) => e5[0] - t4[0]).map((e5) => e5[1]);
  return (e5, n3 = 0, r4 = 0) => {
    const i3 = [], o4 = e5.split("\n");
    for (let e6 = n3; e6 < o4.length; e6++) {
      const n4 = o4[e6];
      if (n4.length > 1024)
        continue;
      const s3 = de2.test(n4) ? n4.replace(de2, "$1") : n4;
      if (!s3.match(/\S*Error: /)) {
        for (const e7 of t3) {
          const t4 = e7(s3);
          if (t4) {
            i3.push(t4);
            break;
          }
        }
        if (i3.length >= 50 + r4)
          break;
      }
    }
    return function(e6) {
      if (!e6.length)
        return [];
      const t4 = Array.from(e6);
      /sentryWrapped/.test(pe2(t4).function || "") && t4.pop();
      t4.reverse(), he2.test(pe2(t4).function || "") && (t4.pop(), he2.test(pe2(t4).function || "") && t4.pop());
      return t4.slice(0, 50).map((e7) => ({ ...e7, filename: e7.filename || pe2(t4).filename, function: e7.function || ue2 }));
    }(i3.slice(r4));
  };
}(...[[30, (e4) => {
  const t3 = Gr2.exec(e4);
  if (t3) {
    const [, e5, n4, r4] = t3;
    return Hr2(e5, ue2, +n4, +r4);
  }
  const n3 = Qr2.exec(e4);
  if (n3) {
    if (n3[2] && 0 === n3[2].indexOf("eval")) {
      const e6 = Kr2.exec(n3[2]);
      e6 && (n3[2] = e6[1], n3[3] = e6[2], n3[4] = e6[3]);
    }
    const [e5, t4] = ei2(n3[1] || ue2, n3[2]);
    return Hr2(t4, e5, n3[3] ? +n3[3] : void 0, n3[4] ? +n3[4] : void 0);
  }
}], [50, (e4) => {
  const t3 = Yr2.exec(e4);
  if (t3) {
    if (t3[3] && t3[3].indexOf(" > eval") > -1) {
      const e6 = Xr2.exec(t3[3]);
      e6 && (t3[1] = t3[1] || "eval", t3[3] = e6[1], t3[4] = e6[2], t3[5] = "");
    }
    let e5 = t3[3], n3 = t3[1] || ue2;
    return [n3, e5] = ei2(n3, e5), Hr2(e5, n3, t3[4] ? +t3[4] : void 0, t3[5] ? +t3[5] : void 0);
  }
}]]);
var ei2 = (e4, t3) => {
  const n3 = -1 !== e4.indexOf("safari-extension"), r4 = -1 !== e4.indexOf("safari-web-extension");
  return n3 || r4 ? [-1 !== e4.indexOf("@") ? e4.split("@")[0] : ue2, n3 ? `safari-extension:${t3}` : `safari-web-extension:${t3}`] : [e4, t3];
};
var ti2 = 1024;
var ni2 = (e4 = {}) => {
  const t3 = { console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true, ...e4 };
  return { name: "Breadcrumbs", setup(e5) {
    var n3;
    t3.console && function(e6) {
      const t4 = "console";
      be2(t4, e6), _e2(t4, tr2);
    }(function(e6) {
      return function(t4) {
        if (xt2() !== e6)
          return;
        const n4 = { category: "console", data: { arguments: t4.args, logger: "console" }, level: nr2(t4.level), message: ze2(t4.args, " ") };
        if ("assert" === t4.level) {
          if (false !== t4.args[0])
            return;
          n4.message = `Assertion failed: ${ze2(t4.args.slice(1), " ") || "console.assert"}`, n4.data.arguments = t4.args.slice(1);
        }
        $n2(n4, { input: t4.args, level: t4.level });
      };
    }(e5)), t3.dom && (n3 = function(e6, t4) {
      return function(n4) {
        if (xt2() !== e6)
          return;
        let r4, i3, o4 = "object" == typeof t4 ? t4.serializeAttribute : void 0, s3 = "object" == typeof t4 && "number" == typeof t4.maxStringLength ? t4.maxStringLength : void 0;
        s3 && s3 > ti2 && (br2 && le2.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${s3} was configured. Sentry will use 1024 instead.`), s3 = ti2), "string" == typeof o4 && (o4 = [o4]);
        try {
          const e7 = n4.event, t5 = function(e8) {
            return !!e8 && !!e8.target;
          }(e7) ? e7.target : e7;
          r4 = Je2(t5, { keyAttrs: o4, maxStringLength: s3 }), i3 = function(e8) {
            if (!Ve2.HTMLElement)
              return null;
            let t6 = e8;
            for (let e9 = 0; e9 < 5; e9++) {
              if (!t6)
                return null;
              if (t6 instanceof HTMLElement) {
                if (t6.dataset.sentryComponent)
                  return t6.dataset.sentryComponent;
                if (t6.dataset.sentryElement)
                  return t6.dataset.sentryElement;
              }
              t6 = t6.parentNode;
            }
            return null;
          }(t5);
        } catch (e7) {
          r4 = "<unknown>";
        }
        if (0 === r4.length)
          return;
        const a3 = { category: `ui.${n4.name}`, message: r4 };
        i3 && (a3.data = { "ui.component_name": i3 }), $n2(a3, { event: n4.event, name: n4.name, global: n4.global });
      };
    }(e5, t3.dom), be2("dom", n3), _e2("dom", Fr2)), t3.xhr && function(e6) {
      be2("xhr", e6), _e2("xhr", zr2);
    }(function(e6) {
      return function(t4) {
        if (xt2() !== e6)
          return;
        const { startTimestamp: n4, endTimestamp: r4 } = t4, i3 = t4.xhr[qr2];
        if (!n4 || !r4 || !i3)
          return;
        const { method: o4, url: s3, status_code: a3, body: c3 } = i3, l3 = { method: o4, url: s3, status_code: a3 }, u3 = { xhr: t4.xhr, input: c3, startTimestamp: n4, endTimestamp: r4 };
        $n2({ category: "xhr", data: l3, type: "http", level: ar2(a3) }, u3);
      };
    }(e5)), t3.fetch && dr2(function(e6) {
      return function(t4) {
        if (xt2() !== e6)
          return;
        const { startTimestamp: n4, endTimestamp: r4 } = t4;
        if (r4 && (!t4.fetchData.url.match(/sentry_key/) || "POST" !== t4.fetchData.method))
          if (t4.error) {
            $n2({ category: "fetch", data: t4.fetchData, level: "error", type: "http" }, { data: t4.error, input: t4.args, startTimestamp: n4, endTimestamp: r4 });
          } else {
            const e7 = t4.response, i3 = { ...t4.fetchData, status_code: e7 && e7.status }, o4 = { input: t4.args, response: e7, startTimestamp: n4, endTimestamp: r4 };
            $n2({ category: "fetch", data: i3, type: "http", level: ar2(i3.status_code) }, o4);
          }
      };
    }(e5)), t3.history && Ur2(function(e6) {
      return function(t4) {
        if (xt2() !== e6)
          return;
        let n4 = t4.from, r4 = t4.to;
        const i3 = er2(vr2.location.href);
        let o4 = n4 ? er2(n4) : void 0;
        const s3 = er2(r4);
        o4 && o4.path || (o4 = i3), i3.protocol === s3.protocol && i3.host === s3.host && (r4 = s3.relative), i3.protocol === o4.protocol && i3.host === o4.host && (n4 = o4.relative), $n2({ category: "navigation", data: { from: n4, to: r4 } });
      };
    }(e5)), t3.sentry && e5.on("beforeSendEvent", function(e6) {
      return function(t4) {
        xt2() === e6 && $n2({ category: "sentry." + ("transaction" === t4.type ? "transaction" : "event"), event_id: t4.event_id, level: t4.level, message: at2(t4) }, { event: t4 });
      };
    }(e5));
  } };
};
var ri2 = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
var ii2 = (e4 = {}) => {
  const t3 = { XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true, ...e4 };
  return { name: "BrowserApiErrors", setupOnce() {
    t3.setTimeout && Ge2(vr2, "setTimeout", oi2), t3.setInterval && Ge2(vr2, "setInterval", oi2), t3.requestAnimationFrame && Ge2(vr2, "requestAnimationFrame", si2), t3.XMLHttpRequest && "XMLHttpRequest" in vr2 && Ge2(XMLHttpRequest.prototype, "send", ai2);
    const e5 = t3.eventTarget;
    if (e5) {
      (Array.isArray(e5) ? e5 : ri2).forEach(ci2);
    }
  } };
};
function oi2(e4) {
  return function(...t3) {
    const n3 = t3[0];
    return t3[0] = yr2(n3, { mechanism: { data: { function: ve2(e4) }, handled: false, type: "instrument" } }), e4.apply(this, t3);
  };
}
function si2(e4) {
  return function(t3) {
    return e4.apply(this, [yr2(t3, { mechanism: { data: { function: "requestAnimationFrame", handler: ve2(e4) }, handled: false, type: "instrument" } })]);
  };
}
function ai2(e4) {
  return function(...t3) {
    const n3 = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((e5) => {
      e5 in n3 && "function" == typeof n3[e5] && Ge2(n3, e5, function(t4) {
        const n4 = { mechanism: { data: { function: e5, handler: ve2(t4) }, handled: false, type: "instrument" } }, r4 = Ye2(t4);
        return r4 && (n4.mechanism.data.handler = ve2(r4)), yr2(t4, n4);
      });
    }), e4.apply(this, t3);
  };
}
function ci2(e4) {
  const t3 = vr2[e4], n3 = t3 && t3.prototype;
  n3 && n3.hasOwnProperty && n3.hasOwnProperty("addEventListener") && (Ge2(n3, "addEventListener", function(t4) {
    return function(n4, r4, i3) {
      try {
        "function" == typeof r4.handleEvent && (r4.handleEvent = yr2(r4.handleEvent, { mechanism: { data: { function: "handleEvent", handler: ve2(r4), target: e4 }, handled: false, type: "instrument" } }));
      } catch (e5) {
      }
      return t4.apply(this, [n4, yr2(r4, { mechanism: { data: { function: "addEventListener", handler: ve2(r4), target: e4 }, handled: false, type: "instrument" } }), i3]);
    };
  }), Ge2(n3, "removeEventListener", function(e5) {
    return function(t4, n4, r4) {
      try {
        const i3 = n4.__sentry_wrapped__;
        i3 && e5.call(this, t4, i3, r4);
      } catch (e6) {
      }
      return e5.call(this, t4, n4, r4);
    };
  }));
}
var li2 = () => ({ name: "BrowserSession", setupOnce() {
  void 0 !== vr2.document ? (Cn2({ ignoreDuration: true }), On2(), Ur2(({ from: e4, to: t3 }) => {
    void 0 !== e4 && e4 !== t3 && (Cn2({ ignoreDuration: true }), On2());
  })) : br2 && le2.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
} });
var ui2 = (e4 = {}) => {
  const t3 = { onerror: true, onunhandledrejection: true, ...e4 };
  return { name: "GlobalHandlers", setupOnce() {
    Error.stackTraceLimit = 50;
  }, setup(e5) {
    t3.onerror && (!function(e6) {
      !function(e7) {
        const t4 = "error";
        be2(t4, e7), _e2(t4, ke2);
      }((t4) => {
        const { stackParser: n3, attachStacktrace: r4 } = hi2();
        if (xt2() !== e6 || mr2())
          return;
        const { msg: i3, url: o4, line: s3, column: a3, error: c3 } = t4, l3 = function(e7, t5, n4, r5) {
          const i4 = e7.exception = e7.exception || {}, o5 = i4.values = i4.values || [], s4 = o5[0] = o5[0] || {}, a4 = s4.stacktrace = s4.stacktrace || {}, c4 = a4.frames = a4.frames || [], l4 = r5, u3 = n4, d3 = xe2(t5) && t5.length > 0 ? t5 : function() {
            try {
              return Ve2.document.location.href;
            } catch (e8) {
              return "";
            }
          }();
          0 === c4.length && c4.push({ colno: l4, filename: d3, function: ue2, in_app: true, lineno: u3 });
          return e7;
        }(Or2(n3, c3 || i3, void 0, r4, false), o4, s3, a3);
        l3.level = "error", Mn2(l3, { originalException: c3, mechanism: { handled: false, type: "onerror" } });
      });
    }(e5), di2("onerror")), t3.onunhandledrejection && (!function(e6) {
      !function(e7) {
        const t4 = "unhandledrejection";
        be2(t4, e7), _e2(t4, Ce2);
      }((t4) => {
        const { stackParser: n3, attachStacktrace: r4 } = hi2();
        if (xt2() !== e6 || mr2())
          return;
        const i3 = function(e7) {
          if (De2(e7))
            return e7;
          try {
            if ("reason" in e7)
              return e7.reason;
            if ("detail" in e7 && "reason" in e7.detail)
              return e7.detail.reason;
          } catch (e8) {
          }
          return e7;
        }(t4), o4 = De2(i3) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(i3)}` }] } } : Or2(n3, i3, void 0, r4, true);
        o4.level = "error", Mn2(o4, { originalException: i3, mechanism: { handled: false, type: "onunhandledrejection" } });
      });
    }(e5), di2("onunhandledrejection"));
  } };
};
function di2(e4) {
  br2 && le2.log(`Global Handler attached: ${e4}`);
}
function hi2() {
  const e4 = xt2();
  return e4 && e4.getOptions() || { stackParser: () => [], attachStacktrace: false };
}
var pi2 = () => ({ name: "HttpContext", preprocessEvent(e4) {
  if (!vr2.navigator && !vr2.location && !vr2.document)
    return;
  const t3 = e4.request && e4.request.url || vr2.location && vr2.location.href, { referrer: n3 } = vr2.document || {}, { userAgent: r4 } = vr2.navigator || {}, i3 = { ...e4.request && e4.request.headers, ...n3 && { Referer: n3 }, ...r4 && { "User-Agent": r4 } }, o4 = { ...e4.request, ...t3 && { url: t3 }, headers: i3 };
  e4.request = o4;
} });
var fi2 = (e4 = {}) => {
  const t3 = e4.limit || 5, n3 = e4.key || "cause";
  return { name: "LinkedErrors", preprocessEvent(e5, r4, i3) {
    const o4 = i3.getOptions();
    Kn2(_r2, o4.stackParser, o4.maxValueLength, n3, t3, e5, r4);
  } };
};
var vi2 = "new";
var gi2 = "loading";
var mi2 = "loaded";
var yi2 = "joining-meeting";
var bi2 = "joined-meeting";
var _i2 = "left-meeting";
var wi2 = "error";
var Ti2 = "playable";
var Oi2 = "unknown";
var Pi2 = "full";
var Ii2 = "base";
var Bi2 = "no-room";
var Vi2 = "end-of-life";
var $i2 = "connection-error";
var Xi2 = "iframe-ready-for-launch-config";
var Zi2 = "iframe-launch-config";
var eo2 = "theme-updated";
var to2 = "loading";
var no2 = "load-attempt-failed";
var ro2 = "loaded";
var io2 = "started-camera";
var oo2 = "camera-error";
var so2 = "joining-meeting";
var ao2 = "joined-meeting";
var co2 = "left-meeting";
var lo2 = "participant-joined";
var uo2 = "participant-updated";
var ho2 = "participant-left";
var po2 = "participant-counts-updated";
var fo2 = "access-state-updated";
var vo2 = "meeting-session-summary-updated";
var go2 = "meeting-session-state-updated";
var yo2 = "waiting-participant-added";
var bo2 = "waiting-participant-updated";
var _o2 = "waiting-participant-removed";
var wo2 = "track-started";
var So2 = "track-stopped";
var ko2 = "transcription-started";
var Mo2 = "transcription-stopped";
var Co2 = "transcription-error";
var Eo2 = "recording-started";
var To2 = "recording-stopped";
var Oo2 = "recording-stats";
var Po2 = "recording-error";
var Ao2 = "recording-upload-completed";
var jo2 = "recording-data";
var Io2 = "app-message";
var xo2 = "transcription-message";
var Lo2 = "remote-media-player-started";
var Do2 = "remote-media-player-updated";
var No2 = "remote-media-player-stopped";
var Ro2 = "local-screen-share-started";
var Fo2 = "local-screen-share-stopped";
var Bo2 = "local-screen-share-canceled";
var Uo2 = "active-speaker-change";
var Vo2 = "active-speaker-mode-change";
var Jo2 = "network-quality-change";
var $o2 = "network-connection";
var qo2 = "cpu-load-change";
var zo2 = "face-counts-updated";
var Wo2 = "fullscreen";
var Ho2 = "exited-fullscreen";
var Go2 = "live-streaming-started";
var Qo2 = "live-streaming-updated";
var Ko2 = "live-streaming-stopped";
var Yo2 = "live-streaming-error";
var Xo2 = "lang-updated";
var Zo2 = "receive-settings-updated";
var es2 = "input-settings-updated";
var ts2 = "nonfatal-error";
var ns2 = "error";
var rs2 = 4096;
var is2 = 102400;
var os2 = "iframe-call-message";
var ss2 = "local-screen-start";
var as2 = "daily-method-update-live-streaming-endpoints";
var cs2 = "transmit-log";
var ls2 = "daily-custom-track";
var us2 = { NONE: "none", BGBLUR: "background-blur", BGIMAGE: "background-image", FACE_DETECTION: "face-detection" };
var ds2 = { NONE: "none", NOISE_CANCELLATION: "noise-cancellation" };
var hs2 = { PLAY: "play", PAUSE: "pause" };
var ps2 = ["jpg", "png", "jpeg"];
var fs2 = "add-endpoints";
var vs2 = "remove-endpoints";
var gs2 = "sip-call-transfer";
function ms2() {
  return !ys2() && "undefined" != typeof window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
}
function ys2() {
  return "undefined" != typeof navigator && navigator.product && "ReactNative" === navigator.product;
}
function bs2() {
  return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
}
function _s2() {
  return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (function(e4, t3) {
    if (!e4 || !t3)
      return true;
    switch (e4) {
      case "Chrome":
        return t3.major >= 75;
      case "Safari":
        return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(13 === t3.major && 0 === t3.minor && 0 === t3.point);
      case "Firefox":
        return t3.major >= 67;
    }
    return true;
  }(js2(), Is2()) || ys2());
}
function ws2() {
  if (ys2())
    return false;
  if (!document)
    return false;
  var e4 = document.createElement("iframe");
  return !!e4.requestFullscreen || !!e4.webkitRequestFullscreen;
}
var Ss2 = "none";
var ks2 = "software";
var Ms2 = "hardware";
var Cs2 = function() {
  try {
    var e4, t3 = document.createElement("canvas"), n3 = false;
    (e4 = t3.getContext("webgl2", { failIfMajorPerformanceCaveat: true })) || (n3 = true, e4 = t3.getContext("webgl2"));
    var r4 = null != e4;
    return t3.remove(), r4 ? n3 ? ks2 : Ms2 : Ss2;
  } catch (e5) {
    return Ss2;
  }
}();
function Es2() {
  var e4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
  return !ys2() && (Cs2 !== Ss2 && (e4 ? function() {
    if (As2())
      return false;
    return ["Chrome", "Firefox"].includes(js2());
  }() : function() {
    if (As2())
      return false;
    var e5 = js2();
    if ("Safari" === e5) {
      var t3 = Ns2();
      if (t3.major < 15 || 15 === t3.major && t3.minor < 4)
        return false;
    }
    if ("Chrome" === e5) {
      return xs2().major >= 77;
    }
    if ("Firefox" === e5) {
      return Rs2().major >= 97;
    }
    return ["Chrome", "Firefox", "Safari"].includes(e5);
  }()));
}
function Ts2() {
  if (ys2())
    return false;
  if (Ps2())
    return false;
  if ("undefined" == typeof AudioWorkletNode)
    return false;
  switch (js2()) {
    case "Chrome":
    case "Firefox":
      return true;
    case "Safari":
      var e4 = Is2();
      return e4.major > 17 || 17 === e4.major && e4.minor >= 4;
  }
  return false;
}
function Os2() {
  return bs2() && !function() {
    var e4, t3 = js2();
    if (!ms2())
      return true;
    switch (t3) {
      case "Chrome":
        return (e4 = xs2()).major && e4.major > 0 && e4.major < 75;
      case "Firefox":
        return (e4 = Rs2()).major < 91;
      case "Safari":
        return (e4 = Ns2()).major < 13 || 13 === e4.major && e4.minor < 1;
      default:
        return true;
    }
  }();
}
function Ps2() {
  return ms2().match(/Linux; Android/);
}
function As2() {
  var e4, t3 = ms2(), n3 = t3.match(/Mac/) && (!ys2() && "undefined" != typeof window && null !== (e4 = window) && void 0 !== e4 && null !== (e4 = e4.navigator) && void 0 !== e4 && e4.maxTouchPoints ? window.navigator.maxTouchPoints : 0) >= 5;
  return !!(t3.match(/Mobi/) || t3.match(/Android/) || n3) || (!!ms2().match(/DailyAnd\//) || void 0);
}
function js2() {
  if ("undefined" != typeof window) {
    var e4 = ms2();
    return Ls2() ? "Safari" : e4.indexOf("Edge") > -1 ? "Edge" : e4.match(/Chrome\//) ? "Chrome" : e4.indexOf("Safari") > -1 || Ds2() ? "Safari" : e4.indexOf("Firefox") > -1 ? "Firefox" : e4.indexOf("MSIE") > -1 || e4.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
  }
}
function Is2() {
  switch (js2()) {
    case "Chrome":
      return xs2();
    case "Safari":
      return Ns2();
    case "Firefox":
      return Rs2();
    case "Edge":
      return function() {
        var e4 = 0, t3 = 0;
        if ("undefined" != typeof window) {
          var n3 = ms2().match(/Edge\/(\d+).(\d+)/);
          if (n3)
            try {
              e4 = parseInt(n3[1]), t3 = parseInt(n3[2]);
            } catch (e5) {
            }
        }
        return { major: e4, minor: t3 };
      }();
  }
}
function xs2() {
  var e4 = 0, t3 = 0, n3 = 0, r4 = 0, i3 = false;
  if ("undefined" != typeof window) {
    var o4 = ms2(), s3 = o4.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
    if (s3)
      try {
        e4 = parseInt(s3[1]), t3 = parseInt(s3[2]), n3 = parseInt(s3[3]), r4 = parseInt(s3[4]), i3 = o4.indexOf("OPR/") > -1;
      } catch (e5) {
      }
  }
  return { major: e4, minor: t3, build: n3, patch: r4, opera: i3 };
}
function Ls2() {
  return !!ms2().match(/iPad|iPhone|iPod/i) && bs2();
}
function Ds2() {
  return ms2().indexOf("AppleWebKit/605.1.15") > -1;
}
function Ns2() {
  var e4 = 0, t3 = 0, n3 = 0;
  if ("undefined" != typeof window) {
    var r4 = ms2().match(/Version\/(\d+).(\d+)(.(\d+))?/);
    if (r4)
      try {
        e4 = parseInt(r4[1]), t3 = parseInt(r4[2]), n3 = parseInt(r4[4]);
      } catch (e5) {
      }
    else
      (Ls2() || Ds2()) && (e4 = 14, t3 = 0, n3 = 3);
  }
  return { major: e4, minor: t3, point: n3 };
}
function Rs2() {
  var e4 = 0, t3 = 0;
  if ("undefined" != typeof window) {
    var n3 = ms2().match(/Firefox\/(\d+).(\d+)/);
    if (n3)
      try {
        e4 = parseInt(n3[1]), t3 = parseInt(n3[2]);
      } catch (e5) {
      }
  }
  return { major: e4, minor: t3 };
}
var Fs2 = function() {
  return o2(function e4() {
    t2(this, e4);
  }, [{ key: "addListenerForMessagesFromCallMachine", value: function(e4, t3, n3) {
    Y2();
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e4, t3, n3) {
    Y2();
  } }, { key: "sendMessageToCallMachine", value: function(e4, t3, n3, r4) {
    Y2();
  } }, { key: "sendMessageToDailyJs", value: function(e4, t3) {
    Y2();
  } }, { key: "removeListener", value: function(e4) {
    Y2();
  } }]);
}();
function Bs2(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function Us2(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? Bs2(Object(n3), true).forEach(function(t4) {
      u2(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Bs2(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
function Vs2() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Vs2 = function() {
    return !!e4;
  })();
}
var Js2 = function() {
  function e4() {
    var n3, r4, i3, o4;
    return t2(this, e4), r4 = this, i3 = a2(i3 = e4), (n3 = s2(r4, Vs2() ? Reflect.construct(i3, o4 || [], a2(r4).constructor) : i3.apply(r4, o4)))._wrappedListeners = {}, n3._messageCallbacks = {}, n3;
  }
  return l2(e4, Fs2), o2(e4, [{ key: "addListenerForMessagesFromCallMachine", value: function(e5, t3, n3) {
    var r4 = this, i3 = function(i4) {
      if (i4.data && "iframe-call-message" === i4.data.what && (!i4.data.callClientId || i4.data.callClientId === t3) && (!i4.data.from || "module" !== i4.data.from)) {
        var o4 = Us2({}, i4.data);
        if (delete o4.from, o4.callbackStamp && r4._messageCallbacks[o4.callbackStamp]) {
          var s3 = o4.callbackStamp;
          r4._messageCallbacks[s3].call(n3, o4), delete r4._messageCallbacks[s3];
        }
        delete o4.what, delete o4.callbackStamp, e5.call(n3, o4);
      }
    };
    this._wrappedListeners[e5] = i3, window.addEventListener("message", i3);
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e5, t3, n3) {
    var r4 = function(r5) {
      var i3;
      if (!(!r5.data || r5.data.what !== os2 || !r5.data.action || r5.data.from && "module" !== r5.data.from || r5.data.callClientId && t3 && r5.data.callClientId !== t3 || null != r5 && null !== (i3 = r5.data) && void 0 !== i3 && i3.callFrameId)) {
        var o4 = r5.data;
        e5.call(n3, o4);
      }
    };
    this._wrappedListeners[e5] = r4, window.addEventListener("message", r4);
  } }, { key: "sendMessageToCallMachine", value: function(e5, t3, n3, r4) {
    if (!n3)
      throw new Error("undefined callClientId. Are you trying to use a DailyCall instance previously destroyed?");
    var i3 = Us2({}, e5);
    if (i3.what = os2, i3.from = "module", i3.callClientId = n3, t3) {
      var o4 = K2();
      this._messageCallbacks[o4] = t3, i3.callbackStamp = o4;
    }
    var s3 = r4 ? r4.contentWindow : window, a3 = this._callMachineTargetOrigin(r4);
    a3 && s3.postMessage(i3, a3);
  } }, { key: "sendMessageToDailyJs", value: function(e5, t3) {
    e5.what = os2, e5.callClientId = t3, e5.from = "embedded", window.postMessage(e5, this._targetOriginFromWindowLocation());
  } }, { key: "removeListener", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (window.removeEventListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e5, t3, n3) {
    var r4 = Us2({}, e5);
    r4.callClientId = n3;
    var i3 = t3 ? t3.contentWindow : window, o4 = this._callMachineTargetOrigin(t3);
    o4 && i3.postMessage(r4, o4);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e5, t3) {
    var n3 = function(n4) {
      if (n4.data && "iframe-call-message" === n4.data.what && (!n4.data.callClientId || n4.data.callClientId === t3) && (!n4.data.from || "module" !== n4.data.from)) {
        var r4 = n4.data;
        e5(r4);
      }
    };
    return this._wrappedListeners[e5] = n3, window.addEventListener("message", n3), e5;
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (window.removeEventListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "_callMachineTargetOrigin", value: function(e5) {
    return e5 ? e5.src ? new URL(e5.src).origin : void 0 : this._targetOriginFromWindowLocation();
  } }, { key: "_targetOriginFromWindowLocation", value: function() {
    return "file:" === window.location.protocol ? "*" : window.location.origin;
  } }]);
}();
function $s2(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function qs2() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (qs2 = function() {
    return !!e4;
  })();
}
var zs2 = function() {
  function e4() {
    var n3, r4, i3, o4;
    return t2(this, e4), r4 = this, i3 = a2(i3 = e4), n3 = s2(r4, qs2() ? Reflect.construct(i3, o4 || [], a2(r4).constructor) : i3.apply(r4, o4)), global.callMachineToDailyJsEmitter = global.callMachineToDailyJsEmitter || new I2.EventEmitter(), global.dailyJsToCallMachineEmitter = global.dailyJsToCallMachineEmitter || new I2.EventEmitter(), n3._wrappedListeners = {}, n3._messageCallbacks = {}, n3;
  }
  return l2(e4, Fs2), o2(e4, [{ key: "addListenerForMessagesFromCallMachine", value: function(e5, t3, n3) {
    this._addListener(e5, global.callMachineToDailyJsEmitter, t3, n3, "received call machine message");
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e5, t3, n3) {
    this._addListener(e5, global.dailyJsToCallMachineEmitter, t3, n3, "received daily-js message");
  } }, { key: "sendMessageToCallMachine", value: function(e5, t3, n3) {
    this._sendMessage(e5, global.dailyJsToCallMachineEmitter, n3, t3, "sending message to call machine");
  } }, { key: "sendMessageToDailyJs", value: function(e5, t3) {
    this._sendMessage(e5, global.callMachineToDailyJsEmitter, t3, null, "sending message to daily-js");
  } }, { key: "removeListener", value: function(e5) {
    var t3 = this._wrappedListeners[e5];
    t3 && (global.callMachineToDailyJsEmitter.removeListener("message", t3), global.dailyJsToCallMachineEmitter.removeListener("message", t3), delete this._wrappedListeners[e5]);
  } }, { key: "_addListener", value: function(e5, t3, n3, r4, i3) {
    var o4 = this, s3 = function(t4) {
      if (t4.callClientId === n3) {
        if (t4.callbackStamp && o4._messageCallbacks[t4.callbackStamp]) {
          var i4 = t4.callbackStamp;
          o4._messageCallbacks[i4].call(r4, t4), delete o4._messageCallbacks[i4];
        }
        e5.call(r4, t4);
      }
    };
    this._wrappedListeners[e5] = s3, t3.addListener("message", s3);
  } }, { key: "_sendMessage", value: function(e5, t3, n3, r4, i3) {
    var o4 = function(e6) {
      for (var t4 = 1; t4 < arguments.length; t4++) {
        var n4 = null != arguments[t4] ? arguments[t4] : {};
        t4 % 2 ? $s2(Object(n4), true).forEach(function(t5) {
          u2(e6, t5, n4[t5]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(n4)) : $s2(Object(n4)).forEach(function(t5) {
          Object.defineProperty(e6, t5, Object.getOwnPropertyDescriptor(n4, t5));
        });
      }
      return e6;
    }({}, e5);
    if (o4.callClientId = n3, r4) {
      var s3 = K2();
      this._messageCallbacks[s3] = r4, o4.callbackStamp = s3;
    }
    t3.emit("message", o4);
  } }]);
}();
var Ws2 = "replace";
var Hs2 = "shallow-merge";
var Gs2 = [Ws2, Hs2];
var Qs2 = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.data, i3 = n3.mergeStrategy, o4 = void 0 === i3 ? Ws2 : i3;
    t2(this, e4), e4._validateMergeStrategy(o4), e4._validateData(r4, o4), this.mergeStrategy = o4, this.data = r4;
  }
  return o2(e4, [{ key: "isNoOp", value: function() {
    return e4.isNoOpUpdate(this.data, this.mergeStrategy);
  } }], [{ key: "isNoOpUpdate", value: function(e5, t3) {
    return 0 === Object.keys(e5).length && t3 === Hs2;
  } }, { key: "_validateMergeStrategy", value: function(e5) {
    if (!Gs2.includes(e5))
      throw Error("Unrecognized mergeStrategy provided. Options are: [".concat(Gs2, "]"));
  } }, { key: "_validateData", value: function(e5, t3) {
    if (!function(e6) {
      if (null == e6 || "object" !== n2(e6))
        return false;
      var t4 = Object.getPrototypeOf(e6);
      return null == t4 || t4 === Object.prototype;
    }(e5))
      throw Error("Meeting session data must be a plain (map-like) object");
    var r4;
    try {
      if (r4 = JSON.stringify(e5), t3 === Ws2) {
        var i3 = JSON.parse(r4);
        N2(i3, e5) || console.warn("The meeting session data provided will be modified when serialized.", i3, e5);
      } else if (t3 === Hs2) {
        for (var o4 in e5)
          if (Object.hasOwnProperty.call(e5, o4) && void 0 !== e5[o4]) {
            var s3 = JSON.parse(JSON.stringify(e5[o4]));
            N2(e5[o4], s3) || console.warn("At least one key in the meeting session data provided will be modified when serialized.", s3, e5[o4]);
          }
      }
    } catch (e6) {
      throw Error("Meeting session data must be serializable to JSON: ".concat(e6));
    }
    if (r4.length > is2)
      throw Error("Meeting session data is too large (".concat(r4.length, " characters). Maximum size suppported is ").concat(is2, "."));
  } }]);
}();
function Ks2() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Ks2 = function() {
    return !!e4;
  })();
}
function Ys2(e4) {
  var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return Ys2 = function(e5) {
    if (null === e5 || !function(e6) {
      try {
        return -1 !== Function.toString.call(e6).indexOf("[native code]");
      } catch (t4) {
        return "function" == typeof e6;
      }
    }(e5))
      return e5;
    if ("function" != typeof e5)
      throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t3) {
      if (t3.has(e5))
        return t3.get(e5);
      t3.set(e5, n3);
    }
    function n3() {
      return function(e6, t4, n4) {
        if (Ks2())
          return Reflect.construct.apply(null, arguments);
        var r4 = [null];
        r4.push.apply(r4, t4);
        var i3 = new (e6.bind.apply(e6, r4))();
        return n4 && c2(i3, n4.prototype), i3;
      }(e5, arguments, a2(this).constructor);
    }
    return n3.prototype = Object.create(e5.prototype, { constructor: { value: n3, enumerable: false, writable: true, configurable: true } }), c2(n3, e5);
  }, Ys2(e4);
}
function Xs2() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (Xs2 = function() {
    return !!e4;
  })();
}
function Zs2(e4) {
  var t3, n3 = null === (t3 = window._daily) || void 0 === t3 ? void 0 : t3.pendings;
  if (n3) {
    var r4 = n3.indexOf(e4);
    -1 !== r4 && n3.splice(r4, 1);
  }
}
var ea2 = function() {
  return o2(function e4(n3) {
    t2(this, e4), this._currentLoad = null, this._callClientId = n3;
  }, [{ key: "load", value: function() {
    var e4, t3 = this, n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = arguments.length > 1 ? arguments[1] : void 0, i3 = arguments.length > 2 ? arguments[2] : void 0;
    if (this.loaded)
      return window._daily.instances[this._callClientId].callMachine.reset(), void r4(true);
    e4 = this._callClientId, window._daily.pendings.push(e4), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new ta2(n3, function() {
      r4(false);
    }, function(e5, n4) {
      n4 || Zs2(t3._callClientId), i3(e5, n4);
    }), this._currentLoad.start();
  } }, { key: "cancel", value: function() {
    this._currentLoad && this._currentLoad.cancel(), Zs2(this._callClientId);
  } }, { key: "loaded", get: function() {
    return this._currentLoad && this._currentLoad.succeeded;
  } }]);
}();
var ta2 = function() {
  return o2(function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = arguments.length > 1 ? arguments[1] : void 0, i3 = arguments.length > 2 ? arguments[2] : void 0;
    t2(this, e4), this._attemptsRemaining = 3, this._currentAttempt = null, this._dailyConfig = n3, this._successCallback = r4, this._failureCallback = i3;
  }, [{ key: "start", value: function() {
    var e4 = this;
    if (!this._currentAttempt) {
      var t3 = function(n3) {
        e4._currentAttempt.cancelled || (e4._attemptsRemaining--, e4._failureCallback(n3, e4._attemptsRemaining > 0), e4._attemptsRemaining <= 0 || setTimeout(function() {
          e4._currentAttempt.cancelled || (e4._currentAttempt = new ia2(e4._dailyConfig, e4._successCallback, t3), e4._currentAttempt.start());
        }, 3e3));
      };
      this._currentAttempt = new ia2(this._dailyConfig, this._successCallback, t3), this._currentAttempt.start();
    }
  } }, { key: "cancel", value: function() {
    this._currentAttempt && this._currentAttempt.cancel();
  } }, { key: "cancelled", get: function() {
    return this._currentAttempt && this._currentAttempt.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._currentAttempt && this._currentAttempt.succeeded;
  } }]);
}();
var na2 = function() {
  function e4() {
    return t2(this, e4), n3 = this, i3 = arguments, r4 = a2(r4 = e4), s2(n3, Xs2() ? Reflect.construct(r4, i3 || [], a2(n3).constructor) : r4.apply(n3, i3));
    var n3, r4, i3;
  }
  return l2(e4, Ys2(Error)), o2(e4);
}();
var ra2 = 2e4;
var ia2 = function() {
  return o2(function e5(n3, r4, i3) {
    t2(this, e5), this._loadAttemptImpl = ys2() || !n3.avoidEval ? new oa2(n3, r4, i3) : new sa2(n3, r4, i3);
  }, [{ key: "start", value: (e4 = h2(function* () {
    return this._loadAttemptImpl.start();
  }), function() {
    return e4.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    this._loadAttemptImpl.cancel();
  } }, { key: "cancelled", get: function() {
    return this._loadAttemptImpl.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._loadAttemptImpl.succeeded;
  } }]);
  var e4;
}();
var oa2 = function() {
  return o2(function e5(n4, r5, i4) {
    t2(this, e5), this.cancelled = false, this.succeeded = false, this._networkTimedOut = false, this._networkTimeout = null, this._iosCache = "undefined" != typeof iOSCallObjectBundleCache && iOSCallObjectBundleCache, this._refetchHeaders = null, this._dailyConfig = n4, this._successCallback = r5, this._failureCallback = i4;
  }, [{ key: "start", value: (i3 = h2(function* () {
    var e5 = Z2(this._dailyConfig);
    !(yield this._tryLoadFromIOSCache(e5)) && this._loadFromNetwork(e5);
  }), function() {
    return i3.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    clearTimeout(this._networkTimeout), this.cancelled = true;
  } }, { key: "_tryLoadFromIOSCache", value: (r4 = h2(function* (e5) {
    if (!this._iosCache)
      return false;
    try {
      var t3 = yield this._iosCache.get(e5);
      return !!this.cancelled || !!t3 && (t3.code ? (Function('"use strict";' + t3.code)(), this.succeeded = true, this._successCallback(), true) : (this._refetchHeaders = t3.refetchHeaders, false));
    } catch (e6) {
      return false;
    }
  }), function(e5) {
    return r4.apply(this, arguments);
  }) }, { key: "_loadFromNetwork", value: (n3 = h2(function* (e5) {
    var t3 = this;
    this._networkTimeout = setTimeout(function() {
      t3._networkTimedOut = true, t3._failureCallback({ msg: "Timed out (>".concat(ra2, " ms) when loading call object bundle ").concat(e5), type: "timeout" });
    }, ra2);
    try {
      var n4 = this._refetchHeaders ? { headers: this._refetchHeaders } : {}, r5 = yield fetch(e5, n4);
      if (clearTimeout(this._networkTimeout), this.cancelled || this._networkTimedOut)
        throw new na2();
      var i4 = yield this._getBundleCodeFromResponse(e5, r5);
      if (this.cancelled)
        throw new na2();
      Function('"use strict";' + i4)(), this._iosCache && this._iosCache.set(e5, i4, r5.headers), this.succeeded = true, this._successCallback();
    } catch (t4) {
      if (clearTimeout(this._networkTimeout), t4 instanceof na2 || this.cancelled || this._networkTimedOut)
        return;
      this._failureCallback({ msg: "Failed to load call object bundle ".concat(e5, ": ").concat(t4), type: t4.message });
    }
  }), function(e5) {
    return n3.apply(this, arguments);
  }) }, { key: "_getBundleCodeFromResponse", value: (e4 = h2(function* (e5, t3) {
    if (t3.ok)
      return yield t3.text();
    if (this._iosCache && 304 === t3.status)
      return (yield this._iosCache.renew(e5, t3.headers)).code;
    throw new Error("Received ".concat(t3.status, " response"));
  }), function(t3, n4) {
    return e4.apply(this, arguments);
  }) }]);
  var e4, n3, r4, i3;
}();
var sa2 = function() {
  return o2(function e4(n3, r4, i3) {
    t2(this, e4), this.cancelled = false, this.succeeded = false, this._dailyConfig = n3, this._successCallback = r4, this._failureCallback = i3, this._attemptId = K2(), this._networkTimeout = null, this._scriptElement = null;
  }, [{ key: "start", value: function() {
    window._dailyCallMachineLoadWaitlist || (window._dailyCallMachineLoadWaitlist = /* @__PURE__ */ new Set());
    var e4 = Z2(this._dailyConfig);
    "object" === ("undefined" == typeof document ? "undefined" : n2(document)) ? this._startLoading(e4) : this._failureCallback({ msg: "Call object bundle must be loaded in a DOM/web context", type: "missing context" });
  } }, { key: "cancel", value: function() {
    this._stopLoading(), this.cancelled = true;
  } }, { key: "_startLoading", value: function(e4) {
    var t3 = this;
    this._signUpForCallMachineLoadWaitlist(), this._networkTimeout = setTimeout(function() {
      t3._stopLoading(), t3._failureCallback({ msg: "Timed out (>".concat(ra2, " ms) when loading call object bundle ").concat(e4), type: "timeout" });
    }, ra2);
    var n3 = document.getElementsByTagName("head")[0], r4 = document.createElement("script");
    this._scriptElement = r4, r4.onload = function() {
      t3._stopLoading(), t3.succeeded = true, t3._successCallback();
    }, r4.onerror = function(e5) {
      t3._stopLoading(), t3._failureCallback({ msg: "Failed to load call object bundle ".concat(e5.target.src), type: e5.message });
    }, r4.src = e4, n3.appendChild(r4);
  } }, { key: "_stopLoading", value: function() {
    this._withdrawFromCallMachineLoadWaitlist(), clearTimeout(this._networkTimeout), this._scriptElement && (this._scriptElement.onload = null, this._scriptElement.onerror = null);
  } }, { key: "_signUpForCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.add(this._attemptId);
  } }, { key: "_withdrawFromCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.delete(this._attemptId);
  } }]);
}();
var aa2 = function(e4, t3, n3) {
  return true === ua2(e4.local, t3, n3);
};
var ca2 = function(e4, t3, n3) {
  return e4.local.streams && e4.local.streams[t3] && e4.local.streams[t3].stream && e4.local.streams[t3].stream["get".concat("video" === n3 ? "Video" : "Audio", "Tracks")]()[0];
};
var la2 = function(e4, t3, n3, r4) {
  var i3 = da2(e4, t3, n3, r4);
  return i3 && i3.pendingTrack;
};
var ua2 = function(e4, t3, n3) {
  if (!e4)
    return false;
  var r4 = function(e5) {
    switch (e5) {
      case "avatar":
        return true;
      case "staged":
        return e5;
      default:
        return !!e5;
    }
  }, i3 = e4.public.subscribedTracks;
  return i3 && i3[t3] ? -1 === ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo"].indexOf(n3) && i3[t3].custom ? [true, "staged"].includes(i3[t3].custom) ? r4(i3[t3].custom) : r4(i3[t3].custom[n3]) : r4(i3[t3][n3]) : !i3 || r4(i3.ALL);
};
var da2 = function(e4, t3, n3, r4) {
  var i3 = Object.values(e4.streams || {}).filter(function(e5) {
    return e5.participantId === t3 && e5.type === n3 && e5.pendingTrack && e5.pendingTrack.kind === r4;
  }).sort(function(e5, t4) {
    return new Date(t4.starttime) - new Date(e5.starttime);
  });
  return i3 && i3[0];
};
var ha2 = function(e4, t3) {
  var n3 = e4.local.public.customTracks;
  if (n3 && n3[t3])
    return n3[t3].track;
};
function pa2(e4, t3) {
  for (var n3 = t3.getState(), r4 = 0, i3 = ["cam", "screen"]; r4 < i3.length; r4++)
    for (var o4 = i3[r4], s3 = 0, a3 = ["video", "audio"]; s3 < a3.length; s3++) {
      var c3 = a3[s3], l3 = "cam" === o4 ? c3 : "screen".concat(c3.charAt(0).toUpperCase() + c3.slice(1)), u3 = e4.tracks[l3];
      if (u3) {
        var d3 = e4.local ? ca2(n3, o4, c3) : la2(n3, e4.session_id, o4, c3);
        "playable" === u3.state && (u3.track = d3), u3.persistentTrack = d3;
      }
    }
}
function fa2(e4, t3) {
  try {
    var n3 = t3.getState();
    for (var r4 in e4.tracks)
      if (!va2(r4)) {
        var i3 = e4.tracks[r4].kind;
        if (i3) {
          var o4 = e4.tracks[r4];
          if (o4) {
            var s3 = e4.local ? ha2(n3, r4) : la2(n3, e4.session_id, r4, i3);
            "playable" === o4.state && (e4.tracks[r4].track = s3), o4.persistentTrack = s3;
          }
        } else
          console.error("unknown type for custom track");
      }
  } catch (e5) {
    console.error(e5);
  }
}
function va2(e4) {
  return ["video", "audio", "screenVideo", "screenAudio"].includes(e4);
}
function ga2(e4, t3, n3) {
  var r4 = n3.getState();
  if (e4.local) {
    if (e4.audio)
      try {
        e4.audioTrack = r4.local.streams.cam.stream.getAudioTracks()[0], e4.audioTrack || (e4.audio = false);
      } catch (e5) {
      }
    if (e4.video)
      try {
        e4.videoTrack = r4.local.streams.cam.stream.getVideoTracks()[0], e4.videoTrack || (e4.video = false);
      } catch (e5) {
      }
    if (e4.screen)
      try {
        e4.screenVideoTrack = r4.local.streams.screen.stream.getVideoTracks()[0], e4.screenAudioTrack = r4.local.streams.screen.stream.getAudioTracks()[0], e4.screenVideoTrack || e4.screenAudioTrack || (e4.screen = false);
      } catch (e5) {
      }
  } else {
    var i3 = true;
    try {
      var o4 = r4.participants[e4.session_id];
      o4 && o4.public && o4.public.rtcType && "peer-to-peer" === o4.public.rtcType.impl && o4.private && !["connected", "completed"].includes(o4.private.peeringState) && (i3 = false);
    } catch (e5) {
      console.error(e5);
    }
    if (!i3)
      return e4.audio = false, e4.audioTrack = false, e4.video = false, e4.videoTrack = false, e4.screen = false, void (e4.screenTrack = false);
    try {
      r4.streams;
      if (e4.audio && aa2(r4, e4.session_id, "cam-audio")) {
        var s3 = la2(r4, e4.session_id, "cam", "audio");
        s3 && (t3 && t3.audioTrack && t3.audioTrack.id === s3.id ? e4.audioTrack = s3 : s3.muted || (e4.audioTrack = s3)), e4.audioTrack || (e4.audio = false);
      }
      if (e4.video && aa2(r4, e4.session_id, "cam-video")) {
        var a3 = la2(r4, e4.session_id, "cam", "video");
        a3 && (t3 && t3.videoTrack && t3.videoTrack.id === a3.id ? e4.videoTrack = a3 : a3.muted || (e4.videoTrack = a3)), e4.videoTrack || (e4.video = false);
      }
      if (e4.screen && aa2(r4, e4.session_id, "screen-audio")) {
        var c3 = la2(r4, e4.session_id, "screen", "audio");
        c3 && (t3 && t3.screenAudioTrack && t3.screenAudioTrack.id === c3.id ? e4.screenAudioTrack = c3 : c3.muted || (e4.screenAudioTrack = c3));
      }
      if (e4.screen && aa2(r4, e4.session_id, "screen-video")) {
        var l3 = la2(r4, e4.session_id, "screen", "video");
        l3 && (t3 && t3.screenVideoTrack && t3.screenVideoTrack.id === l3.id ? e4.screenVideoTrack = l3 : l3.muted || (e4.screenVideoTrack = l3));
      }
      e4.screenVideoTrack || e4.screenAudioTrack || (e4.screen = false);
    } catch (e5) {
      console.error("unexpected error matching up tracks", e5);
    }
  }
}
function ma2(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return ya2(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? ya2(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function ya2(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var ba2 = /* @__PURE__ */ new Map();
var _a2 = null;
function wa2(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return Sa2(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? Sa2(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function Sa2(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var ka2 = /* @__PURE__ */ new Map();
var Ma2 = null;
function Ca2(e4) {
  Ta2() ? function(e5) {
    ba2.has(e5) || (ba2.set(e5, {}), navigator.mediaDevices.enumerateDevices().then(function(t3) {
      ba2.has(e5) && (ba2.get(e5).lastDevicesString = JSON.stringify(t3), _a2 || (_a2 = function() {
        var e6 = h2(function* () {
          var e7, t4 = yield navigator.mediaDevices.enumerateDevices(), n3 = ma2(ba2.keys());
          try {
            for (n3.s(); !(e7 = n3.n()).done; ) {
              var r4 = e7.value, i3 = JSON.stringify(t4);
              i3 !== ba2.get(r4).lastDevicesString && (ba2.get(r4).lastDevicesString = i3, r4(t4));
            }
          } catch (e8) {
            n3.e(e8);
          } finally {
            n3.f();
          }
        });
        return function() {
          return e6.apply(this, arguments);
        };
      }(), navigator.mediaDevices.addEventListener("devicechange", _a2)));
    }).catch(function() {
    }));
  }(e4) : function(e5) {
    ka2.has(e5) || (ka2.set(e5, {}), navigator.mediaDevices.enumerateDevices().then(function(t3) {
      ka2.has(e5) && (ka2.get(e5).lastDevicesString = JSON.stringify(t3), Ma2 || (Ma2 = setInterval(h2(function* () {
        var e6, t4 = yield navigator.mediaDevices.enumerateDevices(), n3 = wa2(ka2.keys());
        try {
          for (n3.s(); !(e6 = n3.n()).done; ) {
            var r4 = e6.value, i3 = JSON.stringify(t4);
            i3 !== ka2.get(r4).lastDevicesString && (ka2.get(r4).lastDevicesString = i3, r4(t4));
          }
        } catch (e7) {
          n3.e(e7);
        } finally {
          n3.f();
        }
      }), 3e3)));
    }));
  }(e4);
}
function Ea2(e4) {
  Ta2() ? function(e5) {
    ba2.has(e5) && (ba2.delete(e5), 0 === ba2.size && _a2 && (navigator.mediaDevices.removeEventListener("devicechange", _a2), _a2 = null));
  }(e4) : function(e5) {
    ka2.has(e5) && (ka2.delete(e5), 0 === ka2.size && Ma2 && (clearInterval(Ma2), Ma2 = null));
  }(e4);
}
function Ta2() {
  var e4;
  return ys2() || void 0 !== (null === (e4 = navigator.mediaDevices) || void 0 === e4 ? void 0 : e4.ondevicechange);
}
var Oa2 = /* @__PURE__ */ new Set();
function Pa2(e4, t3) {
  var n3 = t3.isLocalScreenVideo;
  return e4 && "live" === e4.readyState && !function(e5, t4) {
    return (!t4.isLocalScreenVideo || "Chrome" !== js2()) && e5.muted && !Oa2.has(e5.id);
  }(e4, { isLocalScreenVideo: n3 });
}
function Aa2(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function ja2(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? Aa2(Object(n3), true).forEach(function(t4) {
      u2(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : Aa2(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
var Ia2 = Object.freeze({ VIDEO: "video", AUDIO: "audio", SCREEN_VIDEO: "screenVideo", SCREEN_AUDIO: "screenAudio", CUSTOM_VIDEO: "customVideo", CUSTOM_AUDIO: "customAudio" });
var xa2 = Object.freeze({ PARTICIPANTS: "participants", STREAMING: "streaming", TRANSCRIPTION: "transcription" });
var La2 = Object.values(Ia2);
var Da2 = ["v", "a", "sv", "sa", "cv", "ca"];
Object.freeze(La2.reduce(function(e4, t3, n3) {
  return e4[t3] = Da2[n3], e4;
}, {})), Object.freeze(Da2.reduce(function(e4, t3, n3) {
  return e4[t3] = La2[n3], e4;
}, {}));
var Na2 = [Ia2.VIDEO, Ia2.AUDIO, Ia2.SCREEN_VIDEO, Ia2.SCREEN_AUDIO];
var Ra2 = Object.values(xa2);
var Fa2 = ["p", "s", "t"];
Object.freeze(Ra2.reduce(function(e4, t3, n3) {
  return e4[t3] = Fa2[n3], e4;
}, {})), Object.freeze(Fa2.reduce(function(e4, t3, n3) {
  return e4[t3] = Ra2[n3], e4;
}, {}));
var Ba2 = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.base, i3 = n3.byUserId, o4 = n3.byParticipantId;
    t2(this, e4), this.base = r4, this.byUserId = i3, this.byParticipantId = o4;
  }
  return o2(e4, [{ key: "clone", value: function() {
    var t3 = new e4();
    if (this.base instanceof Ua2 ? t3.base = this.base.clone() : t3.base = this.base, void 0 !== this.byUserId)
      for (var n3 in t3.byUserId = {}, this.byUserId) {
        var r4 = this.byUserId[n3];
        t3.byUserId[n3] = r4 instanceof Ua2 ? r4.clone() : r4;
      }
    if (void 0 !== this.byParticipantId)
      for (var i3 in t3.byParticipantId = {}, this.byParticipantId) {
        var o4 = this.byParticipantId[i3];
        t3.byParticipantId[i3] = o4 instanceof Ua2 ? o4.clone() : o4;
      }
    return t3;
  } }, { key: "toJSONObject", value: function() {
    var e5 = {};
    if ("boolean" == typeof this.base ? e5.base = this.base : this.base instanceof Ua2 && (e5.base = this.base.toJSONObject()), void 0 !== this.byUserId)
      for (var t3 in e5.byUserId = {}, this.byUserId) {
        var n3 = this.byUserId[t3];
        e5.byUserId[t3] = n3 instanceof Ua2 ? n3.toJSONObject() : n3;
      }
    if (void 0 !== this.byParticipantId)
      for (var r4 in e5.byParticipantId = {}, this.byParticipantId) {
        var i3 = this.byParticipantId[r4];
        e5.byParticipantId[r4] = i3 instanceof Ua2 ? i3.toJSONObject() : i3;
      }
    return e5;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e5 = {};
    if (void 0 !== this.base && ("boolean" == typeof this.base ? e5.b = this.base : e5.b = this.base.toMinifiedJSONObject()), void 0 !== this.byUserId)
      for (var t3 in e5.u = {}, this.byUserId) {
        var n3 = this.byUserId[t3];
        e5.u[t3] = "boolean" == typeof n3 ? n3 : n3.toMinifiedJSONObject();
      }
    if (void 0 !== this.byParticipantId)
      for (var r4 in e5.p = {}, this.byParticipantId) {
        var i3 = this.byParticipantId[r4];
        e5.p[r4] = "boolean" == typeof i3 ? i3 : i3.toMinifiedJSONObject();
      }
    return e5;
  } }, { key: "normalize", value: function() {
    return this.base instanceof Ua2 && (this.base = this.base.normalize()), this.byUserId && (this.byUserId = Object.fromEntries(Object.entries(this.byUserId).map(function(e5) {
      var t3 = f2(e5, 2), n3 = t3[0], r4 = t3[1];
      return [n3, r4 instanceof Ua2 ? r4.normalize() : r4];
    }))), this.byParticipantId && (this.byParticipantId = Object.fromEntries(Object.entries(this.byParticipantId).map(function(e5) {
      var t3 = f2(e5, 2), n3 = t3[0], r4 = t3[1];
      return [n3, r4 instanceof Ua2 ? r4.normalize() : r4];
    }))), this;
  } }], [{ key: "fromJSONObject", value: function(t3) {
    var n3, r4, i3;
    if (void 0 !== t3.base && (n3 = "boolean" == typeof t3.base ? t3.base : Ua2.fromJSONObject(t3.base)), void 0 !== t3.byUserId)
      for (var o4 in r4 = {}, t3.byUserId) {
        var s3 = t3.byUserId[o4];
        r4[o4] = "boolean" == typeof s3 ? s3 : Ua2.fromJSONObject(s3);
      }
    if (void 0 !== t3.byParticipantId)
      for (var a3 in i3 = {}, t3.byParticipantId) {
        var c3 = t3.byParticipantId[a3];
        i3[a3] = "boolean" == typeof c3 ? c3 : Ua2.fromJSONObject(c3);
      }
    return new e4({ base: n3, byUserId: r4, byParticipantId: i3 });
  } }, { key: "fromMinifiedJSONObject", value: function(t3) {
    var n3, r4, i3;
    if (void 0 !== t3.b && (n3 = "boolean" == typeof t3.b ? t3.b : Ua2.fromMinifiedJSONObject(t3.b)), void 0 !== t3.u)
      for (var o4 in r4 = {}, t3.u) {
        var s3 = t3.u[o4];
        r4[o4] = "boolean" == typeof s3 ? s3 : Ua2.fromMinifiedJSONObject(s3);
      }
    if (void 0 !== t3.p)
      for (var a3 in i3 = {}, t3.p) {
        var c3 = t3.p[a3];
        i3[a3] = "boolean" == typeof c3 ? c3 : Ua2.fromMinifiedJSONObject(c3);
      }
    return new e4({ base: n3, byUserId: r4, byParticipantId: i3 });
  } }, { key: "validateJSONObject", value: function(e5) {
    if ("object" !== n2(e5))
      return [false, "canReceive must be an object"];
    for (var t3 = ["base", "byUserId", "byParticipantId"], r4 = 0, i3 = Object.keys(e5); r4 < i3.length; r4++) {
      var o4 = i3[r4];
      if (!t3.includes(o4))
        return [false, "canReceive can only contain keys (".concat(t3.join(", "), ")")];
      if ("base" === o4) {
        var s3 = f2(Ua2.validateJSONObject(e5.base, true), 2), a3 = s3[0], c3 = s3[1];
        if (!a3)
          return [false, c3];
      } else {
        if ("object" !== n2(e5[o4]))
          return [false, "invalid (non-object) value for field '".concat(o4, "' in canReceive")];
        for (var l3 = 0, u3 = Object.values(e5[o4]); l3 < u3.length; l3++) {
          var d3 = u3[l3], h4 = f2(Ua2.validateJSONObject(d3), 2), p3 = h4[0], v3 = h4[1];
          if (!p3)
            return [false, v3];
        }
      }
    }
    return [true];
  } }]);
}();
var Ua2 = function() {
  function e4() {
    var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r4 = n3.video, i3 = n3.audio, o4 = n3.screenVideo, s3 = n3.screenAudio, a3 = n3.customVideo, c3 = n3.customAudio;
    t2(this, e4), this.video = r4, this.audio = i3, this.screenVideo = o4, this.screenAudio = s3, this.customVideo = a3, this.customAudio = c3;
  }
  return o2(e4, [{ key: "clone", value: function() {
    var t3 = new e4();
    return void 0 !== this.video && (t3.video = this.video), void 0 !== this.audio && (t3.audio = this.audio), void 0 !== this.screenVideo && (t3.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (t3.screenAudio = this.screenAudio), void 0 !== this.customVideo && (t3.customVideo = ja2({}, this.customVideo)), void 0 !== this.customAudio && (t3.customAudio = ja2({}, this.customAudio)), t3;
  } }, { key: "toJSONObject", value: function() {
    var e5 = {};
    return void 0 !== this.video && (e5.video = this.video), void 0 !== this.audio && (e5.audio = this.audio), void 0 !== this.screenVideo && (e5.screenVideo = this.screenVideo), void 0 !== this.screenAudio && (e5.screenAudio = this.screenAudio), void 0 !== this.customVideo && (e5.customVideo = ja2({}, this.customVideo)), void 0 !== this.customAudio && (e5.customAudio = ja2({}, this.customAudio)), e5;
  } }, { key: "toMinifiedJSONObject", value: function() {
    var e5 = {};
    return void 0 !== this.video && (e5.v = this.video), void 0 !== this.audio && (e5.a = this.audio), void 0 !== this.screenVideo && (e5.sv = this.screenVideo), void 0 !== this.screenAudio && (e5.sa = this.screenAudio), void 0 !== this.customVideo && (e5.cv = ja2({}, this.customVideo)), void 0 !== this.customAudio && (e5.ca = ja2({}, this.customAudio)), e5;
  } }, { key: "normalize", value: function() {
    function e5(e6, t3) {
      return e6 && 1 === Object.keys(e6).length && e6["*"] === t3;
    }
    return !(true !== this.video || true !== this.audio || true !== this.screenVideo || true !== this.screenAudio || !e5(this.customVideo, true) || !e5(this.customAudio, true)) || (false !== this.video || false !== this.audio || false !== this.screenVideo || false !== this.screenAudio || !e5(this.customVideo, false) || !e5(this.customAudio, false)) && this;
  } }], [{ key: "fromBoolean", value: function(t3) {
    return new e4({ video: t3, audio: t3, screenVideo: t3, screenAudio: t3, customVideo: { "*": t3 }, customAudio: { "*": t3 } });
  } }, { key: "fromJSONObject", value: function(t3) {
    return new e4({ video: t3.video, audio: t3.audio, screenVideo: t3.screenVideo, screenAudio: t3.screenAudio, customVideo: void 0 !== t3.customVideo ? ja2({}, t3.customVideo) : void 0, customAudio: void 0 !== t3.customAudio ? ja2({}, t3.customAudio) : void 0 });
  } }, { key: "fromMinifiedJSONObject", value: function(t3) {
    return new e4({ video: t3.v, audio: t3.a, screenVideo: t3.sv, screenAudio: t3.sa, customVideo: t3.cv, customAudio: t3.ca });
  } }, { key: "validateJSONObject", value: function(e5, t3) {
    if ("boolean" == typeof e5)
      return [true];
    if ("object" !== n2(e5))
      return [false, "invalid (non-object, non-boolean) value in canReceive"];
    for (var r4 = Object.keys(e5), i3 = 0, o4 = r4; i3 < o4.length; i3++) {
      var s3 = o4[i3];
      if (!La2.includes(s3))
        return [false, "invalid media type '".concat(s3, "' in canReceive")];
      if (Na2.includes(s3)) {
        if ("boolean" != typeof e5[s3])
          return [false, "invalid (non-boolean) value for media type '".concat(s3, "' in canReceive")];
      } else {
        if ("object" !== n2(e5[s3]))
          return [false, "invalid (non-object) value for media type '".concat(s3, "' in canReceive")];
        for (var a3 = 0, c3 = Object.values(e5[s3]); a3 < c3.length; a3++) {
          if ("boolean" != typeof c3[a3])
            return [false, "invalid (non-boolean) value for entry within '".concat(s3, "' in canReceive")];
        }
        if (t3 && void 0 === e5[s3]["*"])
          return [false, `canReceive "base" permission must specify "*" as an entry within '`.concat(s3, "'")];
      }
    }
    return t3 && r4.length !== La2.length ? [false, 'canReceive "base" permission must specify all media types: '.concat(La2.join(", "), " (or be set to a boolean shorthand)")] : [true];
  } }]);
}();
var Va2 = ["result"];
var Ja2 = ["preserveIframe"];
function $a2(e4, t3) {
  var n3 = Object.keys(e4);
  if (Object.getOwnPropertySymbols) {
    var r4 = Object.getOwnPropertySymbols(e4);
    t3 && (r4 = r4.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
    })), n3.push.apply(n3, r4);
  }
  return n3;
}
function qa2(e4) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var n3 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? $a2(Object(n3), true).forEach(function(t4) {
      u2(e4, t4, n3[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : $a2(Object(n3)).forEach(function(t4) {
      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
    });
  }
  return e4;
}
function za2() {
  try {
    var e4 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (e5) {
  }
  return (za2 = function() {
    return !!e4;
  })();
}
function Wa2(e4, t3) {
  var n3 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
  if (!n3) {
    if (Array.isArray(e4) || (n3 = function(e5, t4) {
      if (e5) {
        if ("string" == typeof e5)
          return Ha2(e5, t4);
        var n4 = {}.toString.call(e5).slice(8, -1);
        return "Object" === n4 && e5.constructor && (n4 = e5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(e5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? Ha2(e5, t4) : void 0;
      }
    }(e4)) || t3 && e4 && "number" == typeof e4.length) {
      n3 && (e4 = n3);
      var r4 = 0, i3 = function() {
      };
      return { s: i3, n: function() {
        return r4 >= e4.length ? { done: true } : { done: false, value: e4[r4++] };
      }, e: function(e5) {
        throw e5;
      }, f: i3 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, s3 = true, a3 = false;
  return { s: function() {
    n3 = n3.call(e4);
  }, n: function() {
    var e5 = n3.next();
    return s3 = e5.done, e5;
  }, e: function(e5) {
    a3 = true, o4 = e5;
  }, f: function() {
    try {
      s3 || null == n3.return || n3.return();
    } finally {
      if (a3)
        throw o4;
    }
  } };
}
function Ha2(e4, t3) {
  (null == t3 || t3 > e4.length) && (t3 = e4.length);
  for (var n3 = 0, r4 = Array(t3); n3 < t3; n3++)
    r4[n3] = e4[n3];
  return r4;
}
var Ga2 = {};
var Qa2 = "video";
var Ka2 = "voice";
var Ya2 = ys2() ? { data: {} } : { data: {}, topology: "none" };
var Xa2 = { present: 0, hidden: 0 };
var Za2 = { maxBitrate: { min: 1e5, max: 25e5 }, maxFramerate: { min: 1, max: 30 }, scaleResolutionDownBy: { min: 1, max: 8 } };
var ec2 = Object.keys(Za2);
var tc2 = ["state", "volume", "simulcastEncodings"];
var nc2 = { androidInCallNotification: { title: "string", subtitle: "string", iconName: "string", disableForCustomOverride: "boolean" }, disableAutoDeviceManagement: { audio: "boolean", video: "boolean" } };
var rc2 = { id: { iconPath: "string", iconPathDarkMode: "string", label: "string", tooltip: "string", visualState: "'default' | 'sidebar-open' | 'active'" } };
var ic2 = { id: { allow: "string", controlledBy: "'*' | 'owners' | string[]", csp: "string", iconURL: "string", label: "string", loading: "'eager' | 'lazy'", location: "'main' | 'sidebar'", name: "string", referrerPolicy: "string", sandbox: "string", src: "string", srcdoc: "string", shared: "string[] | 'owners' | boolean" } };
var oc2 = { customIntegrations: { validate: Pc2, help: Tc2() }, customTrayButtons: { validate: Oc2, help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify(rc2)) }, url: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "url should be a string" }, baseUrl: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "baseUrl should be a string" }, token: { validate: function(e4) {
  return "string" == typeof e4;
}, help: "token should be a string", queryString: "t" }, dailyConfig: { validate: function(e4, t3) {
  try {
    return t3.validateDailyConfig(e4), true;
  } catch (e5) {
    console.error("Failed to validate dailyConfig", e5);
  }
  return false;
}, help: "Unsupported dailyConfig. Check error logs for detailed info." }, reactNativeConfig: { validate: function(e4) {
  return Ac2(e4, nc2);
}, help: "reactNativeConfig should look like ".concat(JSON.stringify(nc2), ", all fields optional") }, lang: { validate: function(e4) {
  return ["da", "de", "en-us", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pl", "pt", "pt-BR", "ru", "sv", "tr", "user"].includes(e4);
}, help: "language not supported. Options are: da, de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, pt-BR, ru, sv, tr, user" }, userName: true, userData: { validate: function(e4) {
  try {
    return yc2(e4), true;
  } catch (e5) {
    return console.error(e5), false;
  }
}, help: "invalid userData type provided" }, startVideoOff: true, startAudioOff: true, allowLocalVideo: true, allowLocalAudio: true, activeSpeakerMode: true, showLeaveButton: true, showLocalVideo: true, showParticipantsBar: true, showFullscreenButton: true, showUserNameChangeUI: true, iframeStyle: true, customLayout: true, cssFile: true, cssText: true, bodyClass: true, videoSource: { validate: function(e4, t3) {
  if ("boolean" == typeof e4)
    return t3._preloadCache.allowLocalVideo = e4, true;
  var n3;
  if (e4 instanceof MediaStreamTrack)
    t3._sharedTracks.videoTrack = e4, n3 = { customTrack: ls2 };
  else {
    if (delete t3._sharedTracks.videoTrack, "string" != typeof e4)
      return console.error("videoSource must be a MediaStreamTrack, boolean, or a string"), false;
    n3 = { deviceId: e4 };
  }
  return t3._updatePreloadCacheInputSettings({ video: { settings: n3 } }, false), true;
} }, audioSource: { validate: function(e4, t3) {
  if ("boolean" == typeof e4)
    return t3._preloadCache.allowLocalAudio = e4, true;
  var n3;
  if (e4 instanceof MediaStreamTrack)
    t3._sharedTracks.audioTrack = e4, n3 = { customTrack: ls2 };
  else {
    if (delete t3._sharedTracks.audioTrack, "string" != typeof e4)
      return console.error("audioSource must be a MediaStreamTrack, boolean, or a string"), false;
    n3 = { deviceId: e4 };
  }
  return t3._updatePreloadCacheInputSettings({ audio: { settings: n3 } }, false), true;
} }, subscribeToTracksAutomatically: { validate: function(e4, t3) {
  return t3._preloadCache.subscribeToTracksAutomatically = e4, true;
} }, theme: { validate: function(e4) {
  var t3 = ["accent", "accentText", "background", "backgroundAccent", "baseText", "border", "mainAreaBg", "mainAreaBgAccent", "mainAreaText", "supportiveText"], r4 = function(e5) {
    for (var n3 = 0, r5 = Object.keys(e5); n3 < r5.length; n3++) {
      var i3 = r5[n3];
      if (!t3.includes(i3))
        return console.error('unsupported color "'.concat(i3, '". Valid colors: ').concat(t3.join(", "))), false;
      if (!e5[i3].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i))
        return console.error("".concat(i3, ' theme color should be provided in valid hex color format. Received: "').concat(e5[i3], '"')), false;
    }
    return true;
  };
  return "object" === n2(e4) && ("light" in e4 && "dark" in e4 || "colors" in e4) ? "light" in e4 && "dark" in e4 ? "colors" in e4.light ? "colors" in e4.dark ? r4(e4.light.colors) && r4(e4.dark.colors) : (console.error('Dark theme is missing "colors" property.', e4), false) : (console.error('Light theme is missing "colors" property.', e4), false) : r4(e4.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e4), false);
}, help: "unsupported theme configuration. Check error logs for detailed info." }, layoutConfig: { validate: function(e4) {
  if ("grid" in e4) {
    var t3 = e4.grid;
    if ("maxTilesPerPage" in t3) {
      if (!Number.isInteger(t3.maxTilesPerPage))
        return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t3.maxTilesPerPage, ".")), false;
      if (t3.maxTilesPerPage > 49)
        return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), false;
    }
    if ("minTilesPerPage" in t3) {
      if (!Number.isInteger(t3.minTilesPerPage))
        return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t3.minTilesPerPage, ".")), false;
      if (t3.minTilesPerPage < 1)
        return console.error("grid.minTilesPerPage can't be lower than 1."), false;
      if ("maxTilesPerPage" in t3 && t3.minTilesPerPage > t3.maxTilesPerPage)
        return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), false;
    }
  }
  return true;
}, help: "unsupported layoutConfig. Check error logs for detailed info." }, receiveSettings: { validate: function(e4) {
  return bc2(e4, { allowAllParticipantsKey: false });
}, help: Ec2({ allowAllParticipantsKey: false }) }, sendSettings: { validate: function(e4, t3) {
  return !!function(e5, t4) {
    try {
      return t4.validateUpdateSendSettings(e5), true;
    } catch (e6) {
      return console.error("Failed to validate send settings", e6), false;
    }
  }(e4, t3) && (t3._preloadCache.sendSettings = e4, true);
}, help: "Invalid sendSettings provided. Check error logs for detailed info." }, inputSettings: { validate: function(e4, t3) {
  var n3;
  return !!_c2(e4) && (t3._inputSettings || (t3._inputSettings = {}), wc2(e4, null === (n3 = t3.properties) || void 0 === n3 ? void 0 : n3.dailyConfig, t3._sharedTracks), t3._updatePreloadCacheInputSettings(e4, true), true);
}, help: Cc2() }, layout: { validate: function(e4) {
  return "custom-v1" === e4 || "browser" === e4 || "none" === e4;
}, help: 'layout may only be set to "custom-v1"', queryString: "layout" }, emb: { queryString: "emb" }, embHref: { queryString: "embHref" }, dailyJsVersion: { queryString: "dailyJsVersion" }, proxy: { queryString: "proxy" }, strictMode: true, allowMultipleCallInstances: true };
var sc2 = { styles: { validate: function(e4) {
  for (var t3 in e4)
    if ("cam" !== t3 && "screen" !== t3)
      return false;
  if (e4.cam) {
    for (var n3 in e4.cam)
      if ("div" !== n3 && "video" !== n3)
        return false;
  }
  if (e4.screen) {
    for (var r4 in e4.screen)
      if ("div" !== r4 && "video" !== r4)
        return false;
  }
  return true;
}, help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }" }, setSubscribedTracks: { validate: function(e4, t3) {
  if (t3._preloadCache.subscribeToTracksAutomatically)
    return false;
  var n3 = [true, false, "staged"];
  if (n3.includes(e4) || !ys2() && "avatar" === e4)
    return true;
  var r4 = ["audio", "video", "screenAudio", "screenVideo", "rmpAudio", "rmpVideo"], i3 = function(e5) {
    var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    for (var o4 in e5)
      if ("custom" === o4) {
        if (!n3.includes(e5[o4]) && !i3(e5[o4], true))
          return false;
      } else {
        var s3 = !t4 && !r4.includes(o4), a3 = !n3.includes(e5[o4]);
        if (s3 || a3)
          return false;
      }
    return true;
  };
  return i3(e4);
}, help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(ys2() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }") }, setAudio: true, setVideo: true, setScreenShare: { validate: function(e4) {
  return false === e4;
}, help: "setScreenShare must be false, as it's only meant for stopping remote participants' screen shares" }, eject: true, updatePermissions: { validate: function(e4) {
  for (var t3 = 0, n3 = Object.entries(e4); t3 < n3.length; t3++) {
    var r4 = f2(n3[t3], 2), i3 = r4[0], o4 = r4[1];
    switch (i3) {
      case "hasPresence":
        if ("boolean" != typeof o4)
          return false;
        break;
      case "canSend":
        if (o4 instanceof Set || o4 instanceof Array || Array.isArray(o4)) {
          var s3, a3 = ["video", "audio", "screenVideo", "screenAudio", "customVideo", "customAudio"], c3 = Wa2(o4);
          try {
            for (c3.s(); !(s3 = c3.n()).done; ) {
              var l3 = s3.value;
              if (!a3.includes(l3))
                return false;
            }
          } catch (e5) {
            c3.e(e5);
          } finally {
            c3.f();
          }
        } else if ("boolean" != typeof o4)
          return false;
        (o4 instanceof Array || Array.isArray(o4)) && (e4.canSend = new Set(o4));
        break;
      case "canReceive":
        var u3 = f2(Ba2.validateJSONObject(o4), 2), d3 = u3[0], h4 = u3[1];
        if (!d3)
          return console.error(h4), false;
        break;
      case "canAdmin":
        if (o4 instanceof Set || o4 instanceof Array || Array.isArray(o4)) {
          var p3, v3 = ["participants", "streaming", "transcription"], g3 = Wa2(o4);
          try {
            for (g3.s(); !(p3 = g3.n()).done; ) {
              var m3 = p3.value;
              if (!v3.includes(m3))
                return false;
            }
          } catch (e5) {
            g3.e(e5);
          } finally {
            g3.f();
          }
        } else if ("boolean" != typeof o4)
          return false;
        (o4 instanceof Array || Array.isArray(o4)) && (e4.canAdmin = new Set(o4));
        break;
      default:
        return false;
    }
  }
  return true;
}, help: "updatePermissions can take hasPresence, canSend, canReceive, and canAdmin permissions. hasPresence must be a boolean. canSend can be a boolean or an Array or Set of media types (video, audio, screenVideo, screenAudio, customVideo, customAudio). canReceive must be an object specifying base, byUserId, and/or byParticipantId fields (see documentation for more details). canAdmin can be a boolean or an Array or Set of admin types (participants, streaming, transcription)." } };
Promise.any || (Promise.any = function() {
  var e4 = h2(function* (e5) {
    return new Promise(function(t3, n3) {
      var r4 = [];
      e5.forEach(function(i3) {
        return Promise.resolve(i3).then(function(e6) {
          t3(e6);
        }).catch(function(t4) {
          r4.push(t4), r4.length === e5.length && n3(r4);
        });
      });
    });
  });
  return function(t3) {
    return e4.apply(this, arguments);
  };
}());
var ac2 = function() {
  function r4(e4) {
    var n3, i4, o4, c4, l3, d4, p4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t2(this, r4), o4 = this, c4 = a2(c4 = r4), u2(i4 = s2(o4, za2() ? Reflect.construct(c4, l3 || [], a2(o4).constructor) : c4.apply(o4, l3)), "startListeningForDeviceChanges", function() {
      Ca2(i4.handleDeviceChange);
    }), u2(i4, "stopListeningForDeviceChanges", function() {
      Ea2(i4.handleDeviceChange);
    }), u2(i4, "handleDeviceChange", function(e5) {
      e5 = e5.map(function(e6) {
        return JSON.parse(JSON.stringify(e6));
      }), i4.emitDailyJSEvent({ action: "available-devices-updated", availableDevices: e5 });
    }), u2(i4, "handleNativeAppStateChange", function() {
      var e5 = h2(function* (e6) {
        if ("destroyed" === e6)
          return console.warn("App has been destroyed before leaving the meeting. Cleaning up all the resources!"), void (yield i4.destroy());
        var t3 = "active" === e6;
        i4.disableReactNativeAutoDeviceManagement("video") || (t3 ? i4.camUnmutedBeforeLosingNativeActiveState && i4.setLocalVideo(true) : (i4.camUnmutedBeforeLosingNativeActiveState = i4.localVideo(), i4.camUnmutedBeforeLosingNativeActiveState && i4.setLocalVideo(false)));
      });
      return function(t3) {
        return e5.apply(this, arguments);
      };
    }()), u2(i4, "handleNativeAudioFocusChange", function(e5) {
      i4.disableReactNativeAutoDeviceManagement("audio") || (i4._hasNativeAudioFocus = e5, i4.toggleParticipantAudioBasedOnNativeAudioFocus(), i4._hasNativeAudioFocus ? i4.micUnmutedBeforeLosingNativeAudioFocus && i4.setLocalAudio(true) : (i4.micUnmutedBeforeLosingNativeAudioFocus = i4.localAudio(), i4.setLocalAudio(false)));
    }), u2(i4, "handleNativeSystemScreenCaptureStop", function() {
      i4.stopScreenShare();
    }), i4.strictMode = void 0 === p4.strictMode || p4.strictMode, i4.allowMultipleCallInstances = null !== (n3 = p4.allowMultipleCallInstances) && void 0 !== n3 && n3, Object.keys(Ga2).length && (i4._logDuplicateInstanceAttempt(), !i4.allowMultipleCallInstances)) {
      if (i4.strictMode)
        throw new Error("Duplicate DailyIframe instances are not allowed");
      console.warn("Using strictMode: false to allow multiple call instances is now deprecated. Set `allowMultipleCallInstances: true`");
    }
    if (window._daily || (window._daily = { pendings: [], instances: {} }), i4.callClientId = K2(), Ga2[(d4 = i4).callClientId] = d4, window._daily.instances[i4.callClientId] = {}, i4._sharedTracks = {}, window._daily.instances[i4.callClientId].tracks = i4._sharedTracks, p4.dailyJsVersion = r4.version(), i4._iframe = e4, i4._callObjectMode = "none" === p4.layout && !i4._iframe, i4._preloadCache = { subscribeToTracksAutomatically: true, outputDeviceId: null, inputSettings: null, sendSettings: null, videoTrackForNetworkConnectivityTest: null, videoTrackForConnectionQualityTest: null }, void 0 !== p4.showLocalVideo ? i4._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : i4._showLocalVideo = !!p4.showLocalVideo : i4._showLocalVideo = true, void 0 !== p4.showParticipantsBar ? i4._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : i4._showParticipantsBar = !!p4.showParticipantsBar : i4._showParticipantsBar = true, void 0 !== p4.customIntegrations ? i4._callObjectMode ? console.error("customIntegrations is not available in call object mode") : i4._customIntegrations = p4.customIntegrations : i4._customIntegrations = {}, void 0 !== p4.customTrayButtons ? i4._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : i4._customTrayButtons = p4.customTrayButtons : i4._customTrayButtons = {}, void 0 !== p4.activeSpeakerMode ? i4._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : i4._activeSpeakerMode = !!p4.activeSpeakerMode : i4._activeSpeakerMode = false, p4.receiveSettings ? i4._callObjectMode ? i4._receiveSettings = p4.receiveSettings : console.error("receiveSettings is only available in call object mode") : i4._receiveSettings = {}, i4.validateProperties(p4), i4.properties = qa2({}, p4), i4._inputSettings || (i4._inputSettings = {}), i4._callObjectLoader = i4._callObjectMode ? new ea2(i4.callClientId) : null, i4._callState = vi2, i4._isPreparingToJoin = false, i4._accessState = { access: Oi2 }, i4._meetingSessionSummary = {}, i4._finalSummaryOfPrevSession = {}, i4._meetingSessionState = Lc(Ya2, i4._callObjectMode), i4._nativeInCallAudioMode = Qa2, i4._participants = {}, i4._isScreenSharing = false, i4._participantCounts = Xa2, i4._rmpPlayerState = {}, i4._waitingParticipants = {}, i4._network = { threshold: "good", quality: 100, networkState: "unknown", stats: {} }, i4._activeSpeaker = {}, i4._localAudioLevel = 0, i4._isLocalAudioLevelObserverRunning = false, i4._remoteParticipantsAudioLevel = {}, i4._isRemoteParticipantsAudioLevelObserverRunning = false, i4._maxAppMessageSize = rs2, i4._messageChannel = ys2() ? new zs2() : new Js2(), i4._iframe && (i4._iframe.requestFullscreen ? i4._iframe.addEventListener("fullscreenchange", function() {
      document.fullscreenElement === i4._iframe ? (i4.emitDailyJSEvent({ action: Wo2 }), i4.sendMessageToCallMachine({ action: Wo2 })) : (i4.emitDailyJSEvent({ action: Ho2 }), i4.sendMessageToCallMachine({ action: Ho2 }));
    }) : i4._iframe.webkitRequestFullscreen && i4._iframe.addEventListener("webkitfullscreenchange", function() {
      document.webkitFullscreenElement === i4._iframe ? (i4.emitDailyJSEvent({ action: Wo2 }), i4.sendMessageToCallMachine({ action: Wo2 })) : (i4.emitDailyJSEvent({ action: Ho2 }), i4.sendMessageToCallMachine({ action: Ho2 }));
    })), ys2()) {
      var f3 = i4.nativeUtils();
      f3.addAudioFocusChangeListener && f3.removeAudioFocusChangeListener && f3.addAppStateChangeListener && f3.removeAppStateChangeListener && f3.addSystemScreenCaptureStopListener && f3.removeSystemScreenCaptureStopListener || console.warn("expected (add|remove)(AudioFocusChange|AppActiveStateChange|SystemScreenCaptureStop)Listener to be available in React Native"), i4._hasNativeAudioFocus = true, f3.addAudioFocusChangeListener(i4.handleNativeAudioFocusChange), f3.addAppStateChangeListener(i4.handleNativeAppStateChange), f3.addSystemScreenCaptureStopListener(i4.handleNativeSystemScreenCaptureStop);
    }
    return i4._callObjectMode && i4.startListeningForDeviceChanges(), i4._messageChannel.addListenerForMessagesFromCallMachine(i4.handleMessageFromCallMachine, i4.callClientId, i4), i4;
  }
  return l2(r4, x2), o2(r4, [{ key: "destroy", value: (ee3 = h2(function* () {
    var e4;
    try {
      yield this.leave();
    } catch (e5) {
    }
    var t3 = this._iframe;
    if (t3) {
      var n3 = t3.parentElement;
      n3 && n3.removeChild(t3);
    }
    if (this._messageChannel.removeListener(this.handleMessageFromCallMachine), ys2()) {
      var r5 = this.nativeUtils();
      r5.removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), r5.removeAppStateChangeListener(this.handleNativeAppStateChange), r5.removeSystemScreenCaptureStopListener(this.handleNativeSystemScreenCaptureStop);
    }
    this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars(), this._destroyed = true, this.emitDailyJSEvent({ action: "call-instance-destroyed" }), delete Ga2[this.callClientId], (null === (e4 = window) || void 0 === e4 || null === (e4 = e4._daily) || void 0 === e4 ? void 0 : e4.instances) && delete window._daily.instances[this.callClientId], this.strictMode && (this.callClientId = void 0);
  }), function() {
    return ee3.apply(this, arguments);
  }) }, { key: "isDestroyed", value: function() {
    return !!this._destroyed;
  } }, { key: "loadCss", value: function(e4) {
    var t3 = e4.bodyClass, n3 = e4.cssFile, r5 = e4.cssText;
    return gc2(), this.sendMessageToCallMachine({ action: "load-css", cssFile: this.absoluteUrl(n3), bodyClass: t3, cssText: r5 }), this;
  } }, { key: "iframe", value: function() {
    return gc2(), this._iframe;
  } }, { key: "meetingState", value: function() {
    return this._callState;
  } }, { key: "accessState", value: function() {
    return fc2(this._callObjectMode, "accessState()"), this._accessState;
  } }, { key: "participants", value: function() {
    return this._participants;
  } }, { key: "participantCounts", value: function() {
    return this._participantCounts;
  } }, { key: "waitingParticipants", value: function() {
    return fc2(this._callObjectMode, "waitingParticipants()"), this._waitingParticipants;
  } }, { key: "validateParticipantProperties", value: function(e4, t3) {
    for (var n3 in t3) {
      if (!sc2[n3])
        throw new Error("unrecognized updateParticipant property ".concat(n3));
      if (sc2[n3].validate && !sc2[n3].validate(t3[n3], this, this._participants[e4]))
        throw new Error(sc2[n3].help);
    }
  } }, { key: "updateParticipant", value: function(e4, t3) {
    return this._participants.local && this._participants.local.session_id === e4 && (e4 = "local"), e4 && t3 && (this.validateParticipantProperties(e4, t3), this.sendMessageToCallMachine({ action: "update-participant", id: e4, properties: t3 })), this;
  } }, { key: "updateParticipants", value: function(e4) {
    var t3 = this._participants.local && this._participants.local.session_id;
    for (var n3 in e4)
      n3 === t3 && (n3 = "local"), n3 && e4[n3] && this.validateParticipantProperties(n3, e4[n3]);
    return this.sendMessageToCallMachine({ action: "update-participants", participants: e4 }), this;
  } }, { key: "updateWaitingParticipant", value: (Y3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (fc2(this._callObjectMode, "updateWaitingParticipant()"), lc2(this._callState, "updateWaitingParticipant()"), "string" != typeof t3 || "object" !== n2(r5))
      throw new Error("updateWaitingParticipant() must take an id string and a updates object");
    return new Promise(function(n3, i4) {
      e4.sendMessageToCallMachine({ action: "daily-method-update-waiting-participant", id: t3, updates: r5 }, function(e5) {
        e5.error && i4(e5.error), e5.id || i4(new Error("unknown error in updateWaitingParticipant()")), n3({ id: e5.id });
      });
    });
  }), function() {
    return Y3.apply(this, arguments);
  }) }, { key: "updateWaitingParticipants", value: (G3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (fc2(this._callObjectMode, "updateWaitingParticipants()"), lc2(this._callState, "updateWaitingParticipants()"), "object" !== n2(t3))
      throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
    return new Promise(function(n3, r5) {
      e4.sendMessageToCallMachine({ action: "daily-method-update-waiting-participants", updatesById: t3 }, function(e5) {
        e5.error && r5(e5.error), e5.ids || r5(new Error("unknown error in updateWaitingParticipants()")), n3({ ids: e5.ids });
      });
    });
  }), function() {
    return G3.apply(this, arguments);
  }) }, { key: "requestAccess", value: (H3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n3 = t3.access, r5 = void 0 === n3 ? { level: Pi2 } : n3, i4 = t3.name, o4 = void 0 === i4 ? "" : i4;
    return fc2(this._callObjectMode, "requestAccess()"), lc2(this._callState, "requestAccess()"), new Promise(function(t4, n4) {
      e4.sendMessageToCallMachine({ action: "daily-method-request-access", access: r5, name: o4 }, function(e5) {
        e5.error && n4(e5.error), e5.access || n4(new Error("unknown error in requestAccess()")), t4({ access: e5.access, granted: e5.granted });
      });
    });
  }), function() {
    return H3.apply(this, arguments);
  }) }, { key: "localAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.audio.state) : null;
  } }, { key: "localVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.video.state) : null;
  } }, { key: "setLocalAudio", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return "forceDiscardTrack" in t3 && (ys2() ? (console.warn("forceDiscardTrack option not supported in React Native; ignoring"), t3 = {}) : e4 && (console.warn("forceDiscardTrack option only supported when calling setLocalAudio(false); ignoring"), t3 = {})), this.sendMessageToCallMachine({ action: "local-audio", state: e4, options: t3 }), this;
  } }, { key: "localScreenAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenAudio.state) : null;
  } }, { key: "localScreenVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenVideo.state) : null;
  } }, { key: "updateScreenShare", value: function(e4) {
    if (this._isScreenSharing)
      return this.sendMessageToCallMachine({ action: "local-screen-update", options: e4 }), this;
    console.warn("There is no screen share in progress. Try calling startScreenShare first.");
  } }, { key: "setLocalVideo", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "local-video", state: e4 }), this;
  } }, { key: "_setAllowLocalAudio", value: function(e4) {
    if (this._preloadCache.allowLocalAudio = e4, this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-allow-local-audio", state: e4 }), this;
  } }, { key: "_setAllowLocalVideo", value: function(e4) {
    if (this._preloadCache.allowLocalVideo = e4, this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-allow-local-video", state: e4 }), this;
  } }, { key: "getReceiveSettings", value: (W3 = h2(function* (e4) {
    var t3 = this, r5 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).showInheritedValues, i4 = void 0 !== r5 && r5;
    if (fc2(this._callObjectMode, "getReceiveSettings()"), !this._callMachineInitialized)
      return this._receiveSettings;
    switch (n2(e4)) {
      case "string":
        return new Promise(function(n3) {
          t3.sendMessageToCallMachine({ action: "get-single-participant-receive-settings", id: e4, showInheritedValues: i4 }, function(e5) {
            n3(e5.receiveSettings);
          });
        });
      case "undefined":
        return this._receiveSettings;
      default:
        throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
    }
  }), function(e4) {
    return W3.apply(this, arguments);
  }) }, { key: "updateReceiveSettings", value: (z3 = h2(function* (e4) {
    var t3 = this;
    if (fc2(this._callObjectMode, "updateReceiveSettings()"), !bc2(e4, { allowAllParticipantsKey: true }))
      throw new Error(Ec2({ allowAllParticipantsKey: true }));
    return lc2(this._callState, "updateReceiveSettings()", "To specify receive settings earlier, use the receiveSettings config property."), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "update-receive-settings", receiveSettings: e4 }, function(e5) {
        n3({ receiveSettings: e5.receiveSettings });
      });
    });
  }), function(e4) {
    return z3.apply(this, arguments);
  }) }, { key: "_prepInputSettingsForSharing", value: function(e4, t3) {
    if (e4) {
      var n3 = {};
      if (e4.audio) {
        var r5, i4, o4;
        e4.audio.settings && (!Object.keys(e4.audio.settings).length && t3 || (n3.audio = { settings: qa2({}, e4.audio.settings) })), t3 && null !== (r5 = n3.audio) && void 0 !== r5 && null !== (r5 = r5.settings) && void 0 !== r5 && r5.customTrack && (n3.audio.settings = { customTrack: this._sharedTracks.audioTrack });
        var s3 = "none" === (null === (i4 = e4.audio.processor) || void 0 === i4 ? void 0 : i4.type) && (null === (o4 = e4.audio.processor) || void 0 === o4 ? void 0 : o4._isDefaultWhenNone);
        if (e4.audio.processor && !s3) {
          var a3 = qa2({}, e4.audio.processor);
          delete a3._isDefaultWhenNone, n3.audio = qa2(qa2({}, n3.audio), {}, { processor: a3 });
        }
      }
      if (e4.video) {
        var c4, l3, u3;
        e4.video.settings && (!Object.keys(e4.video.settings).length && t3 || (n3.video = { settings: qa2({}, e4.video.settings) })), t3 && null !== (c4 = n3.video) && void 0 !== c4 && null !== (c4 = c4.settings) && void 0 !== c4 && c4.customTrack && (n3.video.settings = { customTrack: this._sharedTracks.videoTrack });
        var d4 = "none" === (null === (l3 = e4.video.processor) || void 0 === l3 ? void 0 : l3.type) && (null === (u3 = e4.video.processor) || void 0 === u3 ? void 0 : u3._isDefaultWhenNone);
        if (e4.video.processor && !d4) {
          var h4 = qa2({}, e4.video.processor);
          delete h4._isDefaultWhenNone, n3.video = qa2(qa2({}, n3.video), {}, { processor: h4 });
        }
      }
      return n3;
    }
  } }, { key: "getInputSettings", value: function() {
    var e4 = this;
    return gc2(), new Promise(function(t3) {
      t3(e4._getInputSettings());
    });
  } }, { key: "_getInputSettings", value: function() {
    var e4, t3, n3, r5, i4, o4, s3 = { processor: { type: "none", _isDefaultWhenNone: true } };
    this._inputSettings ? (e4 = (null === (n3 = this._inputSettings) || void 0 === n3 ? void 0 : n3.video) || s3, t3 = (null === (r5 = this._inputSettings) || void 0 === r5 ? void 0 : r5.audio) || s3) : (e4 = (null === (i4 = this._preloadCache) || void 0 === i4 || null === (i4 = i4.inputSettings) || void 0 === i4 ? void 0 : i4.video) || s3, t3 = (null === (o4 = this._preloadCache) || void 0 === o4 || null === (o4 = o4.inputSettings) || void 0 === o4 ? void 0 : o4.audio) || s3);
    var a3 = { audio: t3, video: e4 };
    return this._prepInputSettingsForSharing(a3, true);
  } }, { key: "_updatePreloadCacheInputSettings", value: function(e4, t3) {
    var n3 = this._inputSettings || {}, r5 = {};
    if (e4.video) {
      var i4, o4, s3;
      if (r5.video = {}, e4.video.settings)
        r5.video.settings = {}, t3 || e4.video.settings.customTrack || null === (s3 = n3.video) || void 0 === s3 || !s3.settings ? r5.video.settings = e4.video.settings : r5.video.settings = qa2(qa2({}, n3.video.settings), e4.video.settings), Object.keys(r5.video.settings).length || delete r5.video.settings;
      else
        null !== (i4 = n3.video) && void 0 !== i4 && i4.settings && (r5.video.settings = n3.video.settings);
      e4.video.processor ? r5.video.processor = e4.video.processor : null !== (o4 = n3.video) && void 0 !== o4 && o4.processor && (r5.video.processor = n3.video.processor);
    } else
      n3.video && (r5.video = n3.video);
    if (e4.audio) {
      var a3, c4, l3;
      if (r5.audio = {}, e4.audio.settings)
        r5.audio.settings = {}, t3 || e4.audio.settings.customTrack || null === (l3 = n3.audio) || void 0 === l3 || !l3.settings ? r5.audio.settings = e4.audio.settings : r5.audio.settings = qa2(qa2({}, n3.audio.settings), e4.audio.settings), Object.keys(r5.audio.settings).length || delete r5.audio.settings;
      else
        null !== (a3 = n3.audio) && void 0 !== a3 && a3.settings && (r5.audio.settings = n3.audio.settings);
      e4.audio.processor ? r5.audio.processor = e4.audio.processor : null !== (c4 = n3.audio) && void 0 !== c4 && c4.processor && (r5.audio.processor = n3.audio.processor);
    } else
      n3.audio && (r5.audio = n3.audio);
    this._maybeUpdateInputSettings(r5);
  } }, { key: "_devicesFromInputSettings", value: function(e4) {
    var t3, n3, r5 = (null == e4 || null === (t3 = e4.video) || void 0 === t3 || null === (t3 = t3.settings) || void 0 === t3 ? void 0 : t3.deviceId) || null, i4 = (null == e4 || null === (n3 = e4.audio) || void 0 === n3 || null === (n3 = n3.settings) || void 0 === n3 ? void 0 : n3.deviceId) || null, o4 = this._preloadCache.outputDeviceId || null;
    return { camera: r5 ? { deviceId: r5 } : {}, mic: i4 ? { deviceId: i4 } : {}, speaker: o4 ? { deviceId: o4 } : {} };
  } }, { key: "updateInputSettings", value: (q3 = h2(function* (e4) {
    var t3 = this;
    return gc2(), _c2(e4) ? e4.video || e4.audio ? (wc2(e4, this.properties.dailyConfig, this._sharedTracks), this._callObjectMode && !this._callMachineInitialized ? (this._updatePreloadCacheInputSettings(e4, true), this._getInputSettings()) : new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "update-input-settings", inputSettings: e4 }, function(i4) {
        if (i4.error)
          r5(i4.error);
        else {
          if (i4.returnPreloadCache)
            return t3._updatePreloadCacheInputSettings(e4, true), void n3(t3._getInputSettings());
          t3._maybeUpdateInputSettings(i4.inputSettings), n3(t3._prepInputSettingsForSharing(i4.inputSettings, true));
        }
      });
    })) : this._getInputSettings() : (console.error(Cc2()), Promise.reject(Cc2()));
  }), function(e4) {
    return q3.apply(this, arguments);
  }) }, { key: "setBandwidth", value: function(e4) {
    var t3 = e4.kbs, n3 = e4.trackConstraints;
    if (gc2(), this._callMachineInitialized)
      return this.sendMessageToCallMachine({ action: "set-bandwidth", kbs: t3, trackConstraints: n3 }), this;
  } }, { key: "getDailyLang", value: function() {
    var e4 = this;
    if (gc2(), this._callMachineInitialized)
      return new Promise(function(t3) {
        e4.sendMessageToCallMachine({ action: "get-daily-lang" }, function(e5) {
          delete e5.action, delete e5.callbackStamp, t3(e5);
        });
      });
  } }, { key: "setDailyLang", value: function(e4) {
    return gc2(), this.sendMessageToCallMachine({ action: "set-daily-lang", lang: e4 }), this;
  } }, { key: "setProxyUrl", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "set-proxy-url", proxyUrl: e4 }), this;
  } }, { key: "setIceConfig", value: function(e4) {
    return this.sendMessageToCallMachine({ action: "set-ice-config", iceConfig: e4 }), this;
  } }, { key: "meetingSessionSummary", value: function() {
    return [_i2, wi2].includes(this._callState) ? this._finalSummaryOfPrevSession : this._meetingSessionSummary;
  } }, { key: "getMeetingSession", value: ($3 = h2(function* () {
    var e4 = this;
    return console.warn("getMeetingSession() is deprecated: use meetingSessionSummary(), which will return immediately"), lc2(this._callState, "getMeetingSession()"), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-meeting-session" }, function(e5) {
        delete e5.action, delete e5.callbackStamp, t3(e5);
      });
    });
  }), function() {
    return $3.apply(this, arguments);
  }) }, { key: "meetingSessionState", value: function() {
    return lc2(this._callState, "meetingSessionState"), this._meetingSessionState;
  } }, { key: "setMeetingSessionData", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "replace";
    fc2(this._callObjectMode, "setMeetingSessionData()"), lc2(this._callState, "setMeetingSessionData");
    try {
      !function(e5, t4) {
        new Qs2({ data: e5, mergeStrategy: t4 });
      }(e4, t3);
    } catch (e5) {
      throw console.error(e5), e5;
    }
    try {
      this.sendMessageToCallMachine({ action: "set-session-data", data: e4, mergeStrategy: t3 });
    } catch (e5) {
      throw new Error("Error setting meeting session data: ".concat(e5));
    }
  } }, { key: "setUserName", value: function(e4, t3) {
    var n3 = this;
    return this.properties.userName = e4, new Promise(function(r5) {
      n3.sendMessageToCallMachine({ action: "set-user-name", name: null != e4 ? e4 : "", thisMeetingOnly: ys2() || !!t3 && !!t3.thisMeetingOnly }, function(e5) {
        delete e5.action, delete e5.callbackStamp, r5(e5);
      });
    });
  } }, { key: "setUserData", value: (J3 = h2(function* (e4) {
    var t3 = this;
    try {
      yc2(e4);
    } catch (e5) {
      throw console.error(e5), e5;
    }
    if (this.properties.userData = e4, this._callMachineInitialized)
      return new Promise(function(n3) {
        try {
          t3.sendMessageToCallMachine({ action: "set-user-data", userData: e4 }, function(e5) {
            delete e5.action, delete e5.callbackStamp, n3(e5);
          });
        } catch (e5) {
          throw new Error("Error setting user data: ".concat(e5));
        }
      });
  }), function(e4) {
    return J3.apply(this, arguments);
  }) }, { key: "validateAudioLevelInterval", value: function(e4) {
    if (e4 && (e4 < 100 || "number" != typeof e4))
      throw new Error("The interval must be a number greater than or equal to 100 milliseconds.");
  } }, { key: "startLocalAudioLevelObserver", value: function(e4) {
    var t3 = this;
    if ("undefined" == typeof AudioWorkletNode && !ys2())
      throw new Error("startLocalAudioLevelObserver() is not supported on this browser");
    if (this.validateAudioLevelInterval(e4), this._callMachineInitialized)
      return this._isLocalAudioLevelObserverRunning = true, new Promise(function(n3, r5) {
        t3.sendMessageToCallMachine({ action: "start-local-audio-level-observer", interval: e4 }, function(e5) {
          t3._isLocalAudioLevelObserverRunning = !e5.error, e5.error ? r5({ error: e5.error }) : n3();
        });
      });
    this._preloadCache.localAudioLevelObserver = { enabled: true, interval: e4 };
  } }, { key: "isLocalAudioLevelObserverRunning", value: function() {
    return this._isLocalAudioLevelObserverRunning;
  } }, { key: "stopLocalAudioLevelObserver", value: function() {
    this._preloadCache.localAudioLevelObserver = null, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-local-audio-level-observer" });
  } }, { key: "startRemoteParticipantsAudioLevelObserver", value: function(e4) {
    var t3 = this;
    if (this.validateAudioLevelInterval(e4), this._callMachineInitialized)
      return this._isRemoteParticipantsAudioLevelObserverRunning = true, new Promise(function(n3, r5) {
        t3.sendMessageToCallMachine({ action: "start-remote-participants-audio-level-observer", interval: e4 }, function(e5) {
          t3._isRemoteParticipantsAudioLevelObserverRunning = !e5.error, e5.error ? r5({ error: e5.error }) : n3();
        });
      });
    this._preloadCache.remoteParticipantsAudioLevelObserver = { enabled: true, interval: e4 };
  } }, { key: "isRemoteParticipantsAudioLevelObserverRunning", value: function() {
    return this._isRemoteParticipantsAudioLevelObserverRunning;
  } }, { key: "stopRemoteParticipantsAudioLevelObserver", value: function() {
    this._preloadCache.remoteParticipantsAudioLevelObserver = null, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-remote-participants-audio-level-observer" });
  } }, { key: "startCamera", value: (V3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (fc2(this._callObjectMode, "startCamera()"), dc2(this._callState, this._isPreparingToJoin, "startCamera()", "Did you mean to use setLocalAudio() and/or setLocalVideo() instead?"), this.needsLoad())
      try {
        yield this.load(t3);
      } catch (e5) {
        return Promise.reject(e5);
      }
    else {
      if (this._didPreAuth) {
        if (t3.url && t3.url !== this.properties.url)
          return console.error("url in startCamera() is different than the one used in preAuth()"), Promise.reject();
        if (t3.token && t3.token !== this.properties.token)
          return console.error("token in startCamera() is different than the one used in preAuth()"), Promise.reject();
      }
      this.validateProperties(t3), this.properties = qa2(qa2({}, this.properties), t3);
    }
    return new Promise(function(t4) {
      e4._preloadCache.inputSettings = e4._prepInputSettingsForSharing(e4._inputSettings, false), e4.sendMessageToCallMachine({ action: "start-camera", properties: cc2(e4.properties, e4.callClientId), preloadCache: cc2(e4._preloadCache, e4.callClientId) }, function(e5) {
        t4({ camera: e5.camera, mic: e5.mic, speaker: e5.speaker });
      });
    });
  }), function() {
    return V3.apply(this, arguments);
  }) }, { key: "validateCustomTrack", value: function(e4, t3, n3) {
    if (n3 && n3.length > 50)
      throw new Error("Custom track `trackName` must not be more than 50 characters");
    if (t3 && "music" !== t3 && "speech" !== t3 && !(t3 instanceof Object))
      throw new Error("Custom track `mode` must be either `music` | `speech` | `DailyMicAudioModeSettings` or `undefined`");
    if (!!n3 && ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo", "customVideoDefaults"].includes(n3))
      throw new Error("Custom track `trackName` must not match a track name already used by daily: cam-audio, cam-video, customVideoDefaults, screen-video, screen-audio, rmpAudio, rmpVideo");
    if (!(e4 instanceof MediaStreamTrack))
      throw new Error("Custom tracks provided must be instances of MediaStreamTrack");
  } }, { key: "startCustomTrack", value: function() {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { track, mode, trackName };
    return gc2(), lc2(this._callState, "startCustomTrack()"), this.validateCustomTrack(t3.track, t3.mode, t3.trackName), new Promise(function(n3, r5) {
      e4._sharedTracks.customTrack = t3.track, t3.track = ls2, e4.sendMessageToCallMachine({ action: "start-custom-track", properties: t3 }, function(e5) {
        e5.error ? r5({ error: e5.error }) : n3(e5.mediaTag);
      });
    });
  } }, { key: "stopCustomTrack", value: function(e4) {
    var t3 = this;
    return gc2(), lc2(this._callState, "stopCustomTrack()"), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "stop-custom-track", mediaTag: e4 }, function(e5) {
        n3(e5.mediaTag);
      });
    });
  } }, { key: "setCamera", value: function(e4) {
    var t3 = this;
    return mc2(), hc2(this._callMachineInitialized, "setCamera()"), new Promise(function(n3) {
      t3.sendMessageToCallMachine({ action: "set-camera", cameraDeviceId: e4 }, function(e5) {
        n3({ device: e5.device });
      });
    });
  } }, { key: "setAudioDevice", value: (U3 = h2(function* (e4) {
    return mc2(), this.nativeUtils().setAudioDevice(e4), { deviceId: yield this.nativeUtils().getAudioDevice() };
  }), function(e4) {
    return U3.apply(this, arguments);
  }) }, { key: "cycleCamera", value: function() {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Promise(function(n3) {
      e4.sendMessageToCallMachine({ action: "cycle-camera", properties: t3 }, function(e5) {
        n3({ device: e5.device });
      });
    });
  } }, { key: "cycleMic", value: function() {
    var e4 = this;
    return gc2(), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "cycle-mic" }, function(e5) {
        t3({ device: e5.device });
      });
    });
  } }, { key: "getCameraFacingMode", value: function() {
    var e4 = this;
    return mc2(), new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-camera-facing-mode" }, function(e5) {
        t3(e5.facingMode);
      });
    });
  } }, { key: "setInputDevicesAsync", value: (B3 = h2(function* (e4) {
    var t3 = this, n3 = e4.audioDeviceId, r5 = e4.videoDeviceId, i4 = e4.audioSource, o4 = e4.videoSource;
    if (gc2(), void 0 !== i4 && (n3 = i4), void 0 !== o4 && (r5 = o4), "boolean" == typeof n3 && (this._setAllowLocalAudio(n3), n3 = void 0), "boolean" == typeof r5 && (this._setAllowLocalVideo(r5), r5 = void 0), !n3 && !r5)
      return yield this.getInputDevices();
    var s3 = {};
    return n3 && (n3 instanceof MediaStreamTrack ? (this._sharedTracks.audioTrack = n3, n3 = ls2, s3.audio = { settings: { customTrack: n3 } }) : (delete this._sharedTracks.audioTrack, s3.audio = { settings: { deviceId: n3 } })), r5 && (r5 instanceof MediaStreamTrack ? (this._sharedTracks.videoTrack = r5, r5 = ls2, s3.video = { settings: { customTrack: r5 } }) : (delete this._sharedTracks.videoTrack, s3.video = { settings: { deviceId: r5 } })), this._callObjectMode && this.needsLoad() ? (this._updatePreloadCacheInputSettings(s3, false), this._devicesFromInputSettings(this._inputSettings)) : new Promise(function(e5) {
      t3.sendMessageToCallMachine({ action: "set-input-devices", audioDeviceId: n3, videoDeviceId: r5 }, function(n4) {
        if (delete n4.action, delete n4.callbackStamp, n4.returnPreloadCache)
          return t3._updatePreloadCacheInputSettings(s3, false), void e5(t3._devicesFromInputSettings(t3._inputSettings));
        e5(n4);
      });
    });
  }), function(e4) {
    return B3.apply(this, arguments);
  }) }, { key: "setOutputDeviceAsync", value: (F3 = h2(function* (e4) {
    var t3 = this, n3 = e4.outputDeviceId;
    return gc2(), n3 && (this._preloadCache.outputDeviceId = n3), this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(e5) {
      t3.sendMessageToCallMachine({ action: "set-output-device", outputDeviceId: n3 }, function(n4) {
        delete n4.action, delete n4.callbackStamp, n4.returnPreloadCache ? e5(t3._devicesFromInputSettings(t3._inputSettings)) : e5(n4);
      });
    });
  }), function(e4) {
    return F3.apply(this, arguments);
  }) }, { key: "getInputDevices", value: (R3 = h2(function* () {
    var e4 = this;
    return this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-input-devices" }, function(n3) {
        n3.returnPreloadCache ? t3(e4._devicesFromInputSettings(e4._inputSettings)) : t3({ camera: n3.camera, mic: n3.mic, speaker: n3.speaker });
      });
    });
  }), function() {
    return R3.apply(this, arguments);
  }) }, { key: "nativeInCallAudioMode", value: function() {
    return mc2(), this._nativeInCallAudioMode;
  } }, { key: "setNativeInCallAudioMode", value: function(e4) {
    if (mc2(), [Qa2, Ka2].includes(e4)) {
      if (e4 !== this._nativeInCallAudioMode)
        return this._nativeInCallAudioMode = e4, !this.disableReactNativeAutoDeviceManagement("audio") && uc2(this._callState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
    } else
      console.error("invalid in-call audio mode specified: ", e4);
  } }, { key: "preAuth", value: (D3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (fc2(this._callObjectMode, "preAuth()"), dc2(this._callState, this._isPreparingToJoin, "preAuth()"), this.needsLoad() && (yield this.load(t3)), !t3.url)
      throw new Error("preAuth() requires at least a url to be provided");
    return this.validateProperties(t3), this.properties = qa2(qa2({}, this.properties), t3), new Promise(function(t4, n3) {
      e4._preloadCache.inputSettings = e4._prepInputSettingsForSharing(e4._inputSettings, false), e4.sendMessageToCallMachine({ action: "daily-method-preauth", properties: cc2(e4.properties, e4.callClientId), preloadCache: cc2(e4._preloadCache, e4.callClientId) }, function(r5) {
        return r5.error ? n3(r5.error) : r5.access ? (e4._didPreAuth = true, void t4({ access: r5.access })) : n3(new Error("unknown error in preAuth()"));
      });
    });
  }), function() {
    return D3.apply(this, arguments);
  }) }, { key: "load", value: (L3 = h2(function* (e4) {
    var t3 = this;
    if (this.needsLoad()) {
      if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode))
        throw new Error("Use after destroy");
      if (e4 && (this.validateProperties(e4), this.properties = qa2(qa2({}, this.properties), e4)), !this._callObjectMode && !this.properties.url)
        throw new Error("can't load iframe meeting because url property isn't set");
      return this._updateCallState(gi2), this.emitDailyJSEvent({ action: to2 }), this._callObjectMode ? new Promise(function(e5, n3) {
        t3._callObjectLoader.cancel();
        var r5 = Date.now();
        t3._callObjectLoader.load(t3.properties.dailyConfig, function(n4) {
          t3._bundleLoadTime = n4 ? "no-op" : Date.now() - r5, t3._updateCallState(mi2), n4 && t3.emitDailyJSEvent({ action: ro2 }), e5();
        }, function(e6, r6) {
          if (t3.emitDailyJSEvent({ action: no2 }), !r6) {
            t3._updateCallState(wi2), t3.resetMeetingDependentVars();
            var i4 = { action: ns2, errorMsg: e6.msg, error: { type: "connection-error", msg: "Failed to load call object bundle.", details: { on: "load", sourceError: e6, bundleUrl: Z2(t3.properties.dailyConfig) } } };
            t3._maybeSendToSentry(i4), t3.emitDailyJSEvent(i4), n3(e6.msg);
          }
        });
      }) : (this._iframe.src = X2(this.assembleMeetingUrl(), this.properties.dailyConfig), new Promise(function(e5, n3) {
        t3._loadedCallback = function(r5) {
          t3._callState !== wi2 ? (t3._updateCallState(mi2), (t3.properties.cssFile || t3.properties.cssText) && t3.loadCss(t3.properties), e5()) : n3(r5);
        };
      }));
    }
  }), function(e4) {
    return L3.apply(this, arguments);
  }) }, { key: "join", value: (I3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this._testCallInProgress && this.stopTestCallQuality();
    var n3 = false;
    if (this.needsLoad()) {
      this.updateIsPreparingToJoin(true);
      try {
        yield this.load(t3);
      } catch (e5) {
        return this.updateIsPreparingToJoin(false), Promise.reject(e5);
      }
    } else {
      if (n3 = !(!this.properties.cssFile && !this.properties.cssText), this._didPreAuth) {
        if (t3.url && t3.url !== this.properties.url)
          return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
        if (t3.token && t3.token !== this.properties.token)
          return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
      }
      if (t3.url && !this._callObjectMode && t3.url && t3.url !== this.properties.url)
        return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t3.url, ")")), this.updateIsPreparingToJoin(false), Promise.reject();
      this.validateProperties(t3), this.properties = qa2(qa2({}, this.properties), t3);
    }
    return void 0 !== t3.showLocalVideo && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t3.showLocalVideo), void 0 !== t3.showParticipantsBar && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t3.showParticipantsBar), this._callState === bi2 || this._callState === yi2 ? (console.warn("already joined meeting, call leave() before joining again"), void this.updateIsPreparingToJoin(false)) : (this._updateCallState(yi2, false), this.emitDailyJSEvent({ action: so2 }), this._preloadCache.inputSettings = this._prepInputSettingsForSharing(this._inputSettings || {}, false), this.sendMessageToCallMachine({ action: "join-meeting", properties: cc2(this.properties, this.callClientId), preloadCache: cc2(this._preloadCache, this.callClientId) }), new Promise(function(t4, r5) {
      e4._joinedCallback = function(i4, o4) {
        if (e4._callState !== wi2) {
          if (e4._updateCallState(bi2), i4)
            for (var s3 in i4) {
              if (e4._callObjectMode) {
                var a3 = e4._callMachine().store;
                pa2(i4[s3], a3), fa2(i4[s3], a3), ga2(i4[s3], e4._participants[s3], a3);
              }
              e4._participants[s3] = qa2({}, i4[s3]), e4.toggleParticipantAudioBasedOnNativeAudioFocus();
            }
          n3 && e4.loadCss(e4.properties), t4(i4);
        } else
          r5(o4);
      };
    }));
  }), function() {
    return I3.apply(this, arguments);
  }) }, { key: "leave", value: (j3 = h2(function* () {
    var e4 = this;
    return this._testCallInProgress && this.stopTestCallQuality(), new Promise(function(t3) {
      e4._callState === _i2 || e4._callState === wi2 ? t3() : e4._callObjectLoader && !e4._callObjectLoader.loaded ? (e4._callObjectLoader.cancel(), e4._updateCallState(_i2), e4.resetMeetingDependentVars(), e4.emitDailyJSEvent({ action: _i2 }), t3()) : (e4._resolveLeave = t3, e4.sendMessageToCallMachine({ action: "leave-meeting" }));
    });
  }), function() {
    return j3.apply(this, arguments);
  }) }, { key: "startScreenShare", value: (A3 = h2(function* () {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (hc2(this._callMachineInitialized, "startScreenShare()"), t3.screenVideoSendSettings && this._validateVideoSendSettings("screenVideo", t3.screenVideoSendSettings), t3.mediaStream && (this._sharedTracks.screenMediaStream = t3.mediaStream, t3.mediaStream = ls2), "undefined" != typeof DailyNativeUtils && void 0 !== DailyNativeUtils.isIOS && DailyNativeUtils.isIOS) {
      var n3 = this.nativeUtils();
      if (yield n3.isScreenBeingCaptured())
        return void this.emitDailyJSEvent({ action: ts2, type: "screen-share-error", errorMsg: "Could not start the screen sharing. The screen is already been captured!" });
      n3.setSystemScreenCaptureStartCallback(function() {
        n3.setSystemScreenCaptureStartCallback(null), e4.sendMessageToCallMachine({ action: ss2, captureOptions: t3 });
      }), n3.presentSystemScreenCapturePrompt();
    } else
      this.sendMessageToCallMachine({ action: ss2, captureOptions: t3 });
  }), function() {
    return A3.apply(this, arguments);
  }) }, { key: "stopScreenShare", value: function() {
    hc2(this._callMachineInitialized, "stopScreenShare()"), this.sendMessageToCallMachine({ action: "local-screen-stop" });
  } }, { key: "startRecording", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = e4.type;
    if (t3 && "cloud" !== t3 && "raw-tracks" !== t3 && "local" !== t3)
      throw new Error("invalid type: ".concat(t3, ", allowed values 'cloud', 'raw-tracks', or 'local'"));
    this.sendMessageToCallMachine(qa2({ action: "local-recording-start" }, e4));
  } }, { key: "updateRecording", value: function(e4) {
    var t3 = e4.layout, n3 = void 0 === t3 ? { preset: "default" } : t3, r5 = e4.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-recording", layout: n3, instanceId: r5 });
  } }, { key: "stopRecording", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(qa2({ action: "local-recording-stop" }, e4));
  } }, { key: "startLiveStreaming", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(qa2({ action: "daily-method-start-live-streaming" }, e4));
  } }, { key: "updateLiveStreaming", value: function(e4) {
    var t3 = e4.layout, n3 = void 0 === t3 ? { preset: "default" } : t3, r5 = e4.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-live-streaming", layout: n3, instanceId: r5 });
  } }, { key: "addLiveStreamingEndpoints", value: function(e4) {
    var t3 = e4.endpoints, n3 = e4.instanceId;
    this.sendMessageToCallMachine({ action: as2, endpointsOp: fs2, endpoints: t3, instanceId: n3 });
  } }, { key: "removeLiveStreamingEndpoints", value: function(e4) {
    var t3 = e4.endpoints, n3 = e4.instanceId;
    this.sendMessageToCallMachine({ action: as2, endpointsOp: vs2, endpoints: t3, instanceId: n3 });
  } }, { key: "stopLiveStreaming", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(qa2({ action: "daily-method-stop-live-streaming" }, e4));
  } }, { key: "validateDailyConfig", value: function(e4) {
    e4.camSimulcastEncodings && (console.warn("camSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide camera simulcast settings."), this.validateSimulcastEncodings(e4.camSimulcastEncodings)), e4.screenSimulcastEncodings && console.warn("screenSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide screen simulcast settings."), Ps2() && e4.noAutoDefaultDeviceChange && console.warn("noAutoDefaultDeviceChange is not supported on Android, and will be ignored.");
  } }, { key: "validateSimulcastEncodings", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e4) {
      if (!(e4 instanceof Array || Array.isArray(e4)))
        throw new Error("encodings must be an Array");
      if (!xc(e4.length, 1, 3))
        throw new Error("encodings must be an Array with between 1 to ".concat(3, " layers"));
      for (var r5 = 0; r5 < e4.length; r5++) {
        var i4 = e4[r5];
        for (var o4 in this._validateEncodingLayerHasValidProperties(i4), i4)
          if (ec2.includes(o4)) {
            if ("number" != typeof i4[o4])
              throw new Error("".concat(o4, " must be a number"));
            if (t3) {
              var s3 = t3[o4], a3 = s3.min, c4 = s3.max;
              if (!xc(i4[o4], a3, c4))
                throw new Error("".concat(o4, " value not in range. valid range: ").concat(a3, " to ").concat(c4));
            }
          } else if (!["active", "scalabilityMode"].includes(o4))
            throw new Error("Invalid key ".concat(o4, ", valid keys are:") + Object.values(ec2));
        if (n3 && !i4.hasOwnProperty("maxBitrate"))
          throw new Error("maxBitrate is not specified");
      }
    }
  } }, { key: "startRemoteMediaPlayer", value: (P3 = h2(function* (e4) {
    var t3 = this, n3 = e4.url, r5 = e4.settings, i4 = void 0 === r5 ? { state: hs2.PLAY } : r5;
    try {
      !function(e5) {
        if ("string" != typeof e5)
          throw new Error('url parameter must be "string" type');
      }(n3), Ic(i4), function(e5) {
        for (var t4 in e5)
          if (!tc2.includes(t4))
            throw new Error("Invalid key ".concat(t4, ", valid keys are: ").concat(tc2));
        e5.simulcastEncodings && this.validateSimulcastEncodings(e5.simulcastEncodings, Za2, true);
      }(i4);
    } catch (e5) {
      throw console.error("invalid argument Error: ".concat(e5)), console.error('startRemoteMediaPlayer arguments must be of the form:\n  { url: "playback url",\n  settings?:\n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e5;
    }
    return new Promise(function(e5, r6) {
      t3.sendMessageToCallMachine({ action: "daily-method-start-remote-media-player", url: n3, settings: i4 }, function(t4) {
        t4.error ? r6({ error: t4.error, errorMsg: t4.errorMsg }) : e5({ session_id: t4.session_id, remoteMediaPlayerState: { state: t4.state, settings: t4.settings } });
      });
    });
  }), function(e4) {
    return P3.apply(this, arguments);
  }) }, { key: "stopRemoteMediaPlayer", value: (O3 = h2(function* (e4) {
    var t3 = this;
    if ("string" != typeof e4)
      throw new Error(" remotePlayerID must be of type string");
    return new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "daily-method-stop-remote-media-player", session_id: e4 }, function(e5) {
        e5.error ? r5({ error: e5.error, errorMsg: e5.errorMsg }) : n3();
      });
    });
  }), function(e4) {
    return O3.apply(this, arguments);
  }) }, { key: "updateRemoteMediaPlayer", value: (T3 = h2(function* (e4) {
    var t3 = this, n3 = e4.session_id, r5 = e4.settings;
    try {
      Ic(r5);
    } catch (e5) {
      throw console.error("invalid argument Error: ".concat(e5)), console.error('updateRemoteMediaPlayer arguments must be of the form:\n  session_id: "participant session",\n  { settings?: {state: "play"|"pause"} }'), e5;
    }
    return new Promise(function(e5, i4) {
      t3.sendMessageToCallMachine({ action: "daily-method-update-remote-media-player", session_id: n3, settings: r5 }, function(t4) {
        t4.error ? i4({ error: t4.error, errorMsg: t4.errorMsg }) : e5({ session_id: t4.session_id, remoteMediaPlayerState: { state: t4.state, settings: t4.settings } });
      });
    });
  }), function(e4) {
    return T3.apply(this, arguments);
  }) }, { key: "startTranscription", value: function(e4) {
    lc2(this._callState, "startTranscription()"), this.sendMessageToCallMachine(qa2({ action: "daily-method-start-transcription" }, e4));
  } }, { key: "updateTranscription", value: function(e4) {
    if (lc2(this._callState, "updateTranscription()"), !e4)
      throw new Error("updateTranscription Error: options is mandatory");
    if ("object" !== n2(e4))
      throw new Error("updateTranscription Error: options must be object type");
    if (e4.participants && !Array.isArray(e4.participants))
      throw new Error("updateTranscription Error: participants must be an array");
    this.sendMessageToCallMachine(qa2({ action: "daily-method-update-transcription" }, e4));
  } }, { key: "stopTranscription", value: function(e4) {
    if (lc2(this._callState, "stopTranscription()"), e4 && "object" !== n2(e4))
      throw new Error("stopTranscription Error: options must be object type");
    if (e4 && !e4.instanceId)
      throw new Error('"instanceId" not provided');
    this.sendMessageToCallMachine(qa2({ action: "daily-method-stop-transcription" }, e4));
  } }, { key: "startDialOut", value: (E3 = h2(function* (e4) {
    var t3 = this;
    lc2(this._callState, "startDialOut()");
    var n3 = function(e5) {
      if (e5) {
        if (!Array.isArray(e5))
          throw new Error("Error starting dial out: audio codec must be an array");
        if (e5.length <= 0)
          throw new Error("Error starting dial out: audio codec array specified but empty");
        e5.forEach(function(e6) {
          if ("string" != typeof e6)
            throw new Error("Error starting dial out: audio codec must be a string");
          if ("OPUS" !== e6 && "PCMU" !== e6 && "PCMA" !== e6 && "G722" !== e6)
            throw new Error("Error starting dial out: audio codec must be one of OPUS, PCMU, PCMA, G722");
        });
      }
    };
    if (!e4.sipUri && !e4.phoneNumber)
      throw new Error("Error starting dial out: either a sip uri or phone number must be provided");
    if (e4.sipUri && e4.phoneNumber)
      throw new Error("Error starting dial out: only one of sip uri or phone number must be provided");
    if (e4.sipUri) {
      if ("string" != typeof e4.sipUri)
        throw new Error("Error starting dial out: sipUri must be a string");
      if (!e4.sipUri.startsWith("sip:"))
        throw new Error("Error starting dial out: Invalid SIP URI, must start with 'sip:'");
      if (e4.video && "boolean" != typeof e4.video)
        throw new Error("Error starting dial out: video must be a boolean value");
      !function(e5) {
        if (e5 && (n3(e5.audio), e5.video)) {
          if (!Array.isArray(e5.video))
            throw new Error("Error starting dial out: video codec must be an array");
          if (e5.video.length <= 0)
            throw new Error("Error starting dial out: video codec array specified but empty");
          e5.video.forEach(function(e6) {
            if ("string" != typeof e6)
              throw new Error("Error starting dial out: video codec must be a string");
            if ("H264" !== e6 && "VP8" !== e6)
              throw new Error("Error starting dial out: video codec must be H264 or VP8");
          });
        }
      }(e4.codecs);
    }
    if (e4.phoneNumber) {
      if ("string" != typeof e4.phoneNumber)
        throw new Error("Error starting dial out: phoneNumber must be a string");
      if (!/^\+\d{1,}$/.test(e4.phoneNumber))
        throw new Error("Error starting dial out: Invalid phone number, must be valid phone number as per E.164");
      e4.codecs && n3(e4.codecs.audio);
    }
    if (e4.callerId) {
      if ("string" != typeof e4.callerId)
        throw new Error("Error starting dial out: callerId must be a string");
      if (e4.sipUri)
        throw new Error("Error starting dial out: callerId not allowed with sipUri");
    }
    if (e4.displayName) {
      if ("string" != typeof e4.displayName)
        throw new Error("Error starting dial out: displayName must be a string");
      if (e4.displayName.length >= 200)
        throw new Error("Error starting dial out: displayName length must be less than 200");
    }
    if (e4.userId) {
      if ("string" != typeof e4.userId)
        throw new Error("Error starting dial out: userId must be a string");
      if (e4.userId.length > 36)
        throw new Error("Error starting dial out: userId length must be less than or equal to 36");
    }
    return new Promise(function(n4, r5) {
      t3.sendMessageToCallMachine(qa2({ action: "dialout-start" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n4(e5);
      });
    });
  }), function(e4) {
    return E3.apply(this, arguments);
  }) }, { key: "stopDialOut", value: function(e4) {
    var t3 = this;
    return lc2(this._callState, "stopDialOut()"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(qa2({ action: "dialout-stop" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  } }, { key: "sipCallTransfer", value: (C3 = h2(function* (e4) {
    var t3 = this;
    if (lc2(this._callState, "sipCallTransfer()"), !e4)
      throw new Error("sipCallTransfer() requires a sessionId and toEndPoint");
    return e4.useSipRefer = false, jc2(e4, "sipCallTransfer"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(qa2({ action: gs2 }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return C3.apply(this, arguments);
  }) }, { key: "sipRefer", value: (M3 = h2(function* (e4) {
    var t3 = this;
    if (lc2(this._callState, "sipRefer()"), !e4)
      throw new Error("sessionId and toEndPoint are mandatory parameter");
    return e4.useSipRefer = true, jc2(e4, "sipRefer"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(qa2({ action: gs2 }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return M3.apply(this, arguments);
  }) }, { key: "sendDTMF", value: (k3 = h2(function* (e4) {
    var t3 = this;
    return lc2(this._callState, "sendDTMF()"), function(e5) {
      var t4 = e5.sessionId, n3 = e5.tones;
      if (!t4 || !n3)
        throw new Error("sessionId and tones are mandatory parameter");
      if ("string" != typeof t4 || "string" != typeof n3)
        throw new Error("sessionId and tones should be of string type");
      if (n3.length > 20)
        throw new Error("tones string must be upto 20 characters");
      var r5 = /[^0-9A-D*#]/g, i4 = n3.match(r5);
      if (i4 && i4[0])
        throw new Error("".concat(i4[0], " is not valid DTMF tone"));
    }(e4), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine(qa2({ action: "send-dtmf" }, e4), function(e5) {
        e5.error ? r5(e5.error) : n3(e5);
      });
    });
  }), function(e4) {
    return k3.apply(this, arguments);
  }) }, { key: "getNetworkStats", value: function() {
    var e4 = this;
    if (this._callState !== bi2) {
      return Promise.resolve(qa2({ stats: { latest: {} } }, this._network));
    }
    return new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-calc-stats" }, function(n3) {
        t3(qa2(qa2({}, e4._network), {}, { stats: n3.stats }));
      });
    });
  } }, { key: "testWebsocketConnectivity", value: (S3 = h2(function* () {
    var e4 = this;
    if (pc2(this._testCallInProgress, "testWebsocketConnectivity()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    return new Promise(function(t3, n3) {
      e4.sendMessageToCallMachine({ action: "test-websocket-connectivity" }, function(e5) {
        e5.error ? n3(e5.error) : t3(e5.results);
      });
    });
  }), function() {
    return S3.apply(this, arguments);
  }) }, { key: "abortTestWebsocketConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-websocket-connectivity" });
  } }, { key: "_validateVideoTrackForNetworkTests", value: function(e4) {
    return e4 ? e4 instanceof MediaStreamTrack ? !!Pa2(e4, { isLocalScreenVideo: false }) || (console.error("Video track is not playable. This test needs a live video track."), false) : (console.error("Video track needs to be of type `MediaStreamTrack`."), false) : (console.error("Missing video track. You must provide a video track in order to run this test."), false);
  } }, { key: "testCallQuality", value: (w3 = h2(function* () {
    var t3 = this;
    gc2(), fc2(this._callObjectMode, "testCallQuality()"), hc2(this._callMachineInitialized, "testCallQuality()", null, true), dc2(this._callState, this._isPreparingToJoin, "testCallQuality()");
    var n3 = this._testCallAlreadyInProgress, r5 = function(e4) {
      n3 || (t3._testCallInProgress = e4);
    };
    if (r5(true), this.needsLoad())
      try {
        var i4 = this._callState;
        yield this.load(), this._callState = i4;
      } catch (e4) {
        return r5(false), Promise.reject(e4);
      }
    return new Promise(function(n4) {
      t3.sendMessageToCallMachine({ action: "test-call-quality", dailyJsVersion: t3.properties.dailyJsVersion }, function(i5) {
        var o4 = i5.results, s3 = o4.result, a3 = e2(o4, Va2);
        if ("failed" === s3) {
          var c4, l3 = qa2({}, a3);
          null !== (c4 = a3.error) && void 0 !== c4 && c4.details ? (a3.error.details = JSON.parse(a3.error.details), l3.error = qa2(qa2({}, l3.error), {}, { details: qa2({}, l3.error.details) }), l3.error.details.duringTest = "testCallQuality") : (l3.error = l3.error ? qa2({}, l3.error) : {}, l3.error.details = { duringTest: "testCallQuality" }), t3._maybeSendToSentry(l3);
        }
        r5(false), n4(qa2({ result: s3 }, a3));
      });
    });
  }), function() {
    return w3.apply(this, arguments);
  }) }, { key: "stopTestCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-call-quality" });
  } }, { key: "testConnectionQuality", value: (_4 = h2(function* (e4) {
    var t3;
    ys2() ? (console.warn("testConnectionQuality() is deprecated: use testPeerToPeerCallQuality() instead"), t3 = yield this.testPeerToPeerCallQuality(e4)) : (console.warn("testConnectionQuality() is deprecated: use testCallQuality() instead"), t3 = yield this.testCallQuality());
    var n3 = { result: t3.result, secondsElapsed: t3.secondsElapsed };
    return t3.data && (n3.data = { maxRTT: t3.data.maxRoundTripTime, packetLoss: t3.data.avgRecvPacketLoss }), n3;
  }), function(e4) {
    return _4.apply(this, arguments);
  }) }, { key: "testPeerToPeerCallQuality", value: (b3 = h2(function* (e4) {
    var t3 = this;
    if (pc2(this._testCallInProgress, "testPeerToPeerCallQuality()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    var n3 = e4.videoTrack, r5 = e4.duration;
    if (!this._validateVideoTrackForNetworkTests(n3))
      throw new Error("Video track error");
    return this._sharedTracks.videoTrackForConnectionQualityTest = n3, new Promise(function(e5, n4) {
      t3.sendMessageToCallMachine({ action: "test-p2p-call-quality", duration: r5 }, function(t4) {
        t4.error ? n4(t4.error) : e5(t4.results);
      });
    });
  }), function(e4) {
    return b3.apply(this, arguments);
  }) }, { key: "stopTestConnectionQuality", value: function() {
    ys2() ? (console.warn("stopTestConnectionQuality() is deprecated: use testPeerToPeerCallQuality() and stopTestPeerToPeerCallQuality() instead"), this.stopTestPeerToPeerCallQuality()) : (console.warn("stopTestConnectionQuality() is deprecated: use testCallQuality() and stopTestCallQuality() instead"), this.stopTestCallQuality());
  } }, { key: "stopTestPeerToPeerCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-p2p-call-quality" });
  } }, { key: "testNetworkConnectivity", value: (y3 = h2(function* (e4) {
    var t3 = this;
    if (pc2(this._testCallInProgress, "testNetworkConnectivity()"), this.needsLoad())
      try {
        yield this.load();
      } catch (e5) {
        return Promise.reject(e5);
      }
    if (!this._validateVideoTrackForNetworkTests(e4))
      throw new Error("Video track error");
    return this._sharedTracks.videoTrackForNetworkConnectivityTest = e4, new Promise(function(e5, n3) {
      t3.sendMessageToCallMachine({ action: "test-network-connectivity" }, function(t4) {
        t4.error ? n3(t4.error) : e5(t4.results);
      });
    });
  }), function(e4) {
    return y3.apply(this, arguments);
  }) }, { key: "abortTestNetworkConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-network-connectivity" });
  } }, { key: "getCpuLoadStats", value: function() {
    var e4 = this;
    return new Promise(function(t3) {
      if (e4._callState === bi2) {
        e4.sendMessageToCallMachine({ action: "get-cpu-load-stats" }, function(e5) {
          t3(e5.cpuStats);
        });
      } else
        t3({ cpuLoadState: void 0, cpuLoadStateReason: void 0, stats: {} });
    });
  } }, { key: "_validateEncodingLayerHasValidProperties", value: function(e4) {
    var t3;
    if (!((null === (t3 = Object.keys(e4)) || void 0 === t3 ? void 0 : t3.length) > 0))
      throw new Error("Empty encoding is not allowed. At least one of these valid keys should be specified:" + Object.values(ec2));
  } }, { key: "_validateVideoSendSettings", value: function(e4, t3) {
    var r5 = "screenVideo" === e4 ? ["default-screen-video", "detail-optimized", "motion-optimized", "motion-and-detail-balanced"] : ["default-video", "bandwidth-optimized", "bandwidth-and-quality-balanced", "quality-optimized", "adaptive-2-layers", "adaptive-3-layers"], i4 = "Video send settings should be either an object or one of the supported presets: ".concat(r5.join());
    if ("string" == typeof t3) {
      if (!r5.includes(t3))
        throw new Error(i4);
    } else {
      if ("object" !== n2(t3))
        throw new Error(i4);
      if (!t3.maxQuality && !t3.encodings && void 0 === t3.allowAdaptiveLayers)
        throw new Error("Video send settings must contain at least maxQuality, allowAdaptiveLayers or encodings attribute");
      if (t3.maxQuality && -1 === ["low", "medium", "high"].indexOf(t3.maxQuality))
        throw new Error("maxQuality must be either low, medium or high");
      if (t3.encodings) {
        var o4 = false;
        switch (Object.keys(t3.encodings).length) {
          case 1:
            o4 = !t3.encodings.low;
            break;
          case 2:
            o4 = !t3.encodings.low || !t3.encodings.medium;
            break;
          case 3:
            o4 = !t3.encodings.low || !t3.encodings.medium || !t3.encodings.high;
            break;
          default:
            o4 = true;
        }
        if (o4)
          throw new Error("Encodings must be defined as: low, low and medium, or low, medium and high.");
        t3.encodings.low && this._validateEncodingLayerHasValidProperties(t3.encodings.low), t3.encodings.medium && this._validateEncodingLayerHasValidProperties(t3.encodings.medium), t3.encodings.high && this._validateEncodingLayerHasValidProperties(t3.encodings.high);
      }
    }
  } }, { key: "validateUpdateSendSettings", value: function(e4) {
    var t3 = this;
    if (!e4 || 0 === Object.keys(e4).length)
      throw new Error("Send settings must contain at least information for one track!");
    Object.entries(e4).forEach(function(e5) {
      var n3 = f2(e5, 2), r5 = n3[0], i4 = n3[1];
      t3._validateVideoSendSettings(r5, i4);
    });
  } }, { key: "updateSendSettings", value: function(e4) {
    var t3 = this;
    return this.validateUpdateSendSettings(e4), this.needsLoad() ? (this._preloadCache.sendSettings = e4, { sendSettings: this._preloadCache.sendSettings }) : new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "update-send-settings", sendSettings: e4 }, function(e5) {
        e5.error ? r5(e5.error) : n3(e5.sendSettings);
      });
    });
  } }, { key: "getSendSettings", value: function() {
    return this._sendSettings || this._preloadCache.sendSettings;
  } }, { key: "getLocalAudioLevel", value: function() {
    return this._localAudioLevel;
  } }, { key: "getRemoteParticipantsAudioLevel", value: function() {
    return this._remoteParticipantsAudioLevel;
  } }, { key: "getActiveSpeaker", value: function() {
    return gc2(), this._activeSpeaker;
  } }, { key: "setActiveSpeakerMode", value: function(e4) {
    return gc2(), this.sendMessageToCallMachine({ action: "set-active-speaker-mode", enabled: e4 }), this;
  } }, { key: "activeSpeakerMode", value: function() {
    return gc2(), this._activeSpeakerMode;
  } }, { key: "subscribeToTracksAutomatically", value: function() {
    return this._preloadCache.subscribeToTracksAutomatically;
  } }, { key: "setSubscribeToTracksAutomatically", value: function(e4) {
    return lc2(this._callState, "setSubscribeToTracksAutomatically()", "Use the subscribeToTracksAutomatically configuration property."), this._preloadCache.subscribeToTracksAutomatically = e4, this.sendMessageToCallMachine({ action: "daily-method-subscribe-to-tracks-automatically", enabled: e4 }), this;
  } }, { key: "enumerateDevices", value: (m3 = h2(function* () {
    var e4 = this;
    if (this._callObjectMode) {
      var t3 = yield navigator.mediaDevices.enumerateDevices();
      return "Firefox" === js2() && Is2().major > 115 && Is2().major < 123 && (t3 = t3.filter(function(e5) {
        return "audiooutput" !== e5.kind;
      })), { devices: t3.map(function(e5) {
        var t4 = JSON.parse(JSON.stringify(e5));
        if (!ys2() && "videoinput" === e5.kind && e5.getCapabilities) {
          var n3, r5 = e5.getCapabilities();
          t4.facing = (null == r5 || null === (n3 = r5.facingMode) || void 0 === n3 ? void 0 : n3.length) >= 1 ? r5.facingMode[0] : void 0;
        }
        return t4;
      }) };
    }
    return new Promise(function(t4) {
      e4.sendMessageToCallMachine({ action: "enumerate-devices" }, function(e5) {
        t4({ devices: e5.devices });
      });
    });
  }), function() {
    return m3.apply(this, arguments);
  }) }, { key: "sendAppMessage", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "*";
    if (lc2(this._callState, "sendAppMessage()"), JSON.stringify(e4).length > this._maxAppMessageSize)
      throw new Error("Message data too large. Max size is " + this._maxAppMessageSize);
    return this.sendMessageToCallMachine({ action: "app-msg", data: e4, to: t3 }), this;
  } }, { key: "addFakeParticipant", value: function(e4) {
    return gc2(), lc2(this._callState, "addFakeParticipant()"), this.sendMessageToCallMachine(qa2({ action: "add-fake-participant" }, e4)), this;
  } }, { key: "setShowNamesMode", value: function(e4) {
    return vc2(this._callObjectMode, "setShowNamesMode()"), gc2(), e4 && "always" !== e4 && "never" !== e4 ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({ action: "set-show-names", mode: e4 }), this);
  } }, { key: "setShowLocalVideo", value: function() {
    var e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return vc2(this._callObjectMode, "setShowLocalVideo()"), gc2(), lc2(this._callState, "setShowLocalVideo()"), "boolean" != typeof e4 ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-local-video", show: e4 }), this._showLocalVideo = e4, this);
  } }, { key: "showLocalVideo", value: function() {
    return vc2(this._callObjectMode, "showLocalVideo()"), gc2(), this._showLocalVideo;
  } }, { key: "setShowParticipantsBar", value: function() {
    var e4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return vc2(this._callObjectMode, "setShowParticipantsBar()"), gc2(), lc2(this._callState, "setShowParticipantsBar()"), "boolean" != typeof e4 ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-participants-bar", show: e4 }), this._showParticipantsBar = e4, this);
  } }, { key: "showParticipantsBar", value: function() {
    return vc2(this._callObjectMode, "showParticipantsBar()"), gc2(), this._showParticipantsBar;
  } }, { key: "customIntegrations", value: function() {
    return gc2(), vc2(this._callObjectMode, "customIntegrations()"), this._customIntegrations;
  } }, { key: "setCustomIntegrations", value: function(e4) {
    return gc2(), vc2(this._callObjectMode, "setCustomIntegrations()"), lc2(this._callState, "setCustomIntegrations()"), Pc2(e4) ? (this.sendMessageToCallMachine({ action: "set-custom-integrations", integrations: e4 }), this._customIntegrations = e4, this) : this;
  } }, { key: "startCustomIntegrations", value: function(e4) {
    var t3 = this;
    if (gc2(), vc2(this._callObjectMode, "startCustomIntegrations()"), lc2(this._callState, "startCustomIntegrations()"), Array.isArray(e4) && e4.some(function(e5) {
      return "string" != typeof e5;
    }) || !Array.isArray(e4) && "string" != typeof e4)
      return console.error("startCustomIntegrations() only accepts string | string[]"), this;
    var n3 = "string" == typeof e4 ? [e4] : e4, r5 = n3.filter(function(e5) {
      return !(e5 in t3._customIntegrations);
    });
    return r5.length ? (console.error(`Can't find custom integration(s): "`.concat(r5.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "start-custom-integrations", ids: n3 }), this);
  } }, { key: "stopCustomIntegrations", value: function(e4) {
    var t3 = this;
    if (gc2(), vc2(this._callObjectMode, "stopCustomIntegrations()"), lc2(this._callState, "stopCustomIntegrations()"), Array.isArray(e4) && e4.some(function(e5) {
      return "string" != typeof e5;
    }) || !Array.isArray(e4) && "string" != typeof e4)
      return console.error("stopCustomIntegrations() only accepts string | string[]"), this;
    var n3 = "string" == typeof e4 ? [e4] : e4, r5 = n3.filter(function(e5) {
      return !(e5 in t3._customIntegrations);
    });
    return r5.length ? (console.error(`Can't find custom integration(s): "`.concat(r5.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "stop-custom-integrations", ids: n3 }), this);
  } }, { key: "customTrayButtons", value: function() {
    return vc2(this._callObjectMode, "customTrayButtons()"), gc2(), this._customTrayButtons;
  } }, { key: "updateCustomTrayButtons", value: function(e4) {
    return vc2(this._callObjectMode, "updateCustomTrayButtons()"), gc2(), lc2(this._callState, "updateCustomTrayButtons()"), Oc2(e4) ? (this.sendMessageToCallMachine({ action: "update-custom-tray-buttons", btns: e4 }), this._customTrayButtons = e4, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify(rc2))), this);
  } }, { key: "theme", value: function() {
    return vc2(this._callObjectMode, "theme()"), this.properties.theme;
  } }, { key: "setTheme", value: function(e4) {
    var t3 = this;
    return vc2(this._callObjectMode, "setTheme()"), new Promise(function(n3, r5) {
      try {
        t3.validateProperties({ theme: e4 }), t3.properties.theme = qa2({}, e4), t3.sendMessageToCallMachine({ action: "set-theme", theme: t3.properties.theme });
        try {
          t3.emitDailyJSEvent({ action: eo2, theme: t3.properties.theme });
        } catch (e5) {
          console.log("could not emit 'theme-updated'", e5);
        }
        n3(t3.properties.theme);
      } catch (e5) {
        r5(e5);
      }
    });
  } }, { key: "requestFullscreen", value: (g3 = h2(function* () {
    if (gc2(), this._iframe && !document.fullscreenElement && ws2())
      try {
        (yield this._iframe.requestFullscreen) ? this._iframe.requestFullscreen() : this._iframe.webkitRequestFullscreen();
      } catch (e4) {
        console.log("could not make video call fullscreen", e4);
      }
  }), function() {
    return g3.apply(this, arguments);
  }) }, { key: "exitFullscreen", value: function() {
    gc2(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
  } }, { key: "getSidebarView", value: (v3 = h2(function* () {
    var e4 = this;
    return this._callObjectMode ? (console.error("getSidebarView is not available in callObject mode"), Promise.resolve(null)) : new Promise(function(t3) {
      e4.sendMessageToCallMachine({ action: "get-sidebar-view" }, function(e5) {
        t3(e5.view);
      });
    });
  }), function() {
    return v3.apply(this, arguments);
  }) }, { key: "setSidebarView", value: function(e4) {
    return this._callObjectMode ? (console.error("setSidebarView is not available in callObject mode"), this) : (this.sendMessageToCallMachine({ action: "set-sidebar-view", view: e4 }), this);
  } }, { key: "room", value: (p3 = h2(function* () {
    var e4 = this, t3 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeRoomConfigDefaults, n3 = void 0 === t3 || t3;
    return this._accessState.access === Oi2 || this.needsLoad() ? this.properties.url ? { roomUrlPendingJoin: this.properties.url } : null : new Promise(function(t4) {
      e4.sendMessageToCallMachine({ action: "lib-room-info", includeRoomConfigDefaults: n3 }, function(e5) {
        delete e5.action, delete e5.callbackStamp, t4(e5);
      });
    });
  }), function() {
    return p3.apply(this, arguments);
  }) }, { key: "geo", value: (d3 = h2(function* () {
    try {
      var e4 = yield fetch("https://gs.daily.co/_ks_/x-swsl/:");
      return { current: (yield e4.json()).geo };
    } catch (e5) {
      return console.error("geo lookup failed", e5), { current: "" };
    }
  }), function() {
    return d3.apply(this, arguments);
  }) }, { key: "setNetworkTopology", value: (c3 = h2(function* (e4) {
    var t3 = this;
    return gc2(), lc2(this._callState, "setNetworkTopology()"), new Promise(function(n3, r5) {
      t3.sendMessageToCallMachine({ action: "set-network-topology", opts: e4 }, function(e5) {
        e5.error ? r5({ error: e5.error }) : n3({ workerId: e5.workerId });
      });
    });
  }), function(e4) {
    return c3.apply(this, arguments);
  }) }, { key: "getNetworkTopology", value: (i3 = h2(function* () {
    var e4 = this;
    return new Promise(function(t3, n3) {
      e4.needsLoad() && t3({ topology: "none" }), e4.sendMessageToCallMachine({ action: "get-network-topology" }, function(e5) {
        e5.error ? n3({ error: e5.error }) : t3({ topology: e5.topology });
      });
    });
  }), function() {
    return i3.apply(this, arguments);
  }) }, { key: "setPlayNewParticipantSound", value: function(e4) {
    if (gc2(), "number" != typeof e4 && true !== e4 && false !== e4)
      throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e4));
    this.sendMessageToCallMachine({ action: "daily-method-set-play-ding", arg: e4 });
  } }, { key: "on", value: function(e4, t3) {
    return x2.prototype.on.call(this, e4, t3);
  } }, { key: "once", value: function(e4, t3) {
    return x2.prototype.once.call(this, e4, t3);
  } }, { key: "off", value: function(e4, t3) {
    return x2.prototype.off.call(this, e4, t3);
  } }, { key: "validateProperties", value: function(e4) {
    var t3, n3;
    if (null != e4 && null !== (t3 = e4.dailyConfig) && void 0 !== t3 && t3.userMediaAudioConstraints) {
      var r5, i4;
      ys2() || console.warn("userMediaAudioConstraints is deprecated. You can override constraints with inputSettings.audio.settings, found in DailyCallOptions.");
      var o4 = e4.inputSettings || {};
      o4.audio = (null === (r5 = e4.inputSettings) || void 0 === r5 ? void 0 : r5.audio) || {}, o4.audio.settings = (null === (i4 = e4.inputSettings) || void 0 === i4 || null === (i4 = i4.audio) || void 0 === i4 ? void 0 : i4.settings) || {}, o4.audio.settings = qa2(qa2({}, o4.audio.settings), e4.dailyConfig.userMediaAudioConstraints), e4.inputSettings = o4, delete e4.dailyConfig.userMediaAudioConstraints;
    }
    if (null != e4 && null !== (n3 = e4.dailyConfig) && void 0 !== n3 && n3.userMediaVideoConstraints) {
      var s3, a3;
      ys2() || console.warn("userMediaVideoConstraints is deprecated. You can override constraints with inputSettings.video.settings, found in DailyCallOptions.");
      var c4 = e4.inputSettings || {};
      c4.video = (null === (s3 = e4.inputSettings) || void 0 === s3 ? void 0 : s3.video) || {}, c4.video.settings = (null === (a3 = e4.inputSettings) || void 0 === a3 || null === (a3 = a3.video) || void 0 === a3 ? void 0 : a3.settings) || {}, c4.video.settings = qa2(qa2({}, c4.video.settings), e4.dailyConfig.userMediaVideoConstraints), e4.inputSettings = c4, delete e4.dailyConfig.userMediaVideoConstraints;
    }
    for (var l3 in e4) {
      if (!oc2[l3])
        throw new Error("unrecognized property '".concat(l3, "'"));
      if (oc2[l3].validate && !oc2[l3].validate(e4[l3], this))
        throw new Error("property '".concat(l3, "': ").concat(oc2[l3].help));
    }
  } }, { key: "assembleMeetingUrl", value: function() {
    var e4, t3, n3 = qa2(qa2({}, this.properties), {}, { emb: this.callClientId, embHref: encodeURIComponent(window.location.href), proxy: null !== (e4 = this.properties.dailyConfig) && void 0 !== e4 && e4.proxyUrl ? encodeURIComponent(null === (t3 = this.properties.dailyConfig) || void 0 === t3 ? void 0 : t3.proxyUrl) : void 0 }), r5 = n3.url.match(/\?/) ? "&" : "?";
    return n3.url + r5 + Object.keys(oc2).filter(function(e5) {
      return oc2[e5].queryString && void 0 !== n3[e5];
    }).map(function(e5) {
      return "".concat(oc2[e5].queryString, "=").concat(n3[e5]);
    }).join("&");
  } }, { key: "needsLoad", value: function() {
    return [vi2, gi2, _i2, wi2].includes(this._callState);
  } }, { key: "sendMessageToCallMachine", value: function(e4, t3) {
    if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode))
      throw new Error("Use after destroy");
    this._messageChannel.sendMessageToCallMachine(e4, t3, this.callClientId, this._iframe);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e4) {
    this._messageChannel.forwardPackagedMessageToCallMachine(e4, this._iframe, this.callClientId);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e4) {
    return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e4, this.callClientId);
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e4) {
    this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e4);
  } }, { key: "handleMessageFromCallMachine", value: function(t3) {
    switch (t3.action) {
      case Xi2:
        this.sendMessageToCallMachine(qa2({ action: Zi2 }, this.properties));
        break;
      case "call-machine-initialized":
        this._callMachineInitialized = true;
        var n3 = { action: cs2, level: "log", code: 1011, stats: { event: "bundle load", time: "no-op" === this._bundleLoadTime ? 0 : this._bundleLoadTime, preLoaded: "no-op" === this._bundleLoadTime, url: Z2(this.properties.dailyConfig) } };
        this.sendMessageToCallMachine(n3), this._delayDuplicateInstanceLog && this._logDuplicateInstanceAttempt();
        break;
      case ro2:
        this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null), this.emitDailyJSEvent(t3);
        break;
      case ao2:
        var r5, i4 = qa2({}, t3);
        delete i4.internal, this._maxAppMessageSize = (null === (r5 = t3.internal) || void 0 === r5 ? void 0 : r5._maxAppMessageSize) || rs2, this._joinedCallback && (this._joinedCallback(t3.participants), this._joinedCallback = null), this.emitDailyJSEvent(i4);
        break;
      case lo2:
      case uo2:
        if (this._callState === _i2)
          return;
        if (t3.participant && t3.participant.session_id) {
          var o4 = t3.participant.local ? "local" : t3.participant.session_id;
          if (this._callObjectMode) {
            var s3 = this._callMachine().store;
            pa2(t3.participant, s3), fa2(t3.participant, s3), ga2(t3.participant, this._participants[o4], s3);
          }
          try {
            this.maybeParticipantTracksStopped(this._participants[o4], t3.participant), this.maybeParticipantTracksStarted(this._participants[o4], t3.participant), this.maybeEventRecordingStopped(this._participants[o4], t3.participant), this.maybeEventRecordingStarted(this._participants[o4], t3.participant);
          } catch (e4) {
            console.error("track events error", e4);
          }
          this.compareEqualForParticipantUpdateEvent(t3.participant, this._participants[o4]) || (this._participants[o4] = qa2({}, t3.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus(), this.emitDailyJSEvent(t3));
        }
        break;
      case ho2:
        if (t3.participant && t3.participant.session_id) {
          var a3 = this._participants[t3.participant.session_id];
          a3 && this.maybeParticipantTracksStopped(a3, null), delete this._participants[t3.participant.session_id], this.emitDailyJSEvent(t3);
        }
        break;
      case po2:
        N2(this._participantCounts, t3.participantCounts) || (this._participantCounts = t3.participantCounts, this.emitDailyJSEvent(t3));
        break;
      case fo2:
        var c4 = { access: t3.access };
        t3.awaitingAccess && (c4.awaitingAccess = t3.awaitingAccess), N2(this._accessState, c4) || (this._accessState = c4, this.emitDailyJSEvent(t3));
        break;
      case vo2:
        if (t3.meetingSession) {
          this._meetingSessionSummary = t3.meetingSession, this.emitDailyJSEvent(t3);
          var l3 = qa2(qa2({}, t3), {}, { action: "meeting-session-updated" });
          this.emitDailyJSEvent(l3);
        }
        break;
      case ns2:
        var u3;
        this._iframe && !t3.preserveIframe && (this._iframe.src = ""), this._updateCallState(wi2), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(t3.errorMsg), this._loadedCallback = null), t3.preserveIframe;
        var d4 = e2(t3, Ja2);
        null != d4 && null !== (u3 = d4.error) && void 0 !== u3 && u3.details && (d4.error.details = JSON.parse(d4.error.details)), this._maybeSendToSentry(t3), this._joinedCallback && (this._joinedCallback(null, d4), this._joinedCallback = null), this.emitDailyJSEvent(d4);
        break;
      case co2:
        this._callState !== wi2 && this._updateCallState(_i2), this.resetMeetingDependentVars(), this._resolveLeave && (this._resolveLeave(), this._resolveLeave = null), this.emitDailyJSEvent(t3);
        break;
      case "selected-devices-updated":
        t3.devices && this.emitDailyJSEvent(t3);
        break;
      case Jo2:
        var h4 = t3.state, p4 = t3.threshold, f3 = t3.quality, v5 = h4.state, g4 = h4.reasons;
        v5 === this._network.networkState && N2(g4, this._network.networkStateReasons) && p4 === this._network.threshold && f3 === this._network.quality || (this._network.networkState = v5, this._network.networkStateReasons = g4, this._network.quality = f3, this._network.threshold = p4, t3.networkState = v5, g4.length && (t3.networkStateReasons = g4), delete t3.state, this.emitDailyJSEvent(t3));
        break;
      case qo2:
        t3 && t3.cpuLoadState && this.emitDailyJSEvent(t3);
        break;
      case zo2:
        t3 && void 0 !== t3.faceCounts && this.emitDailyJSEvent(t3);
        break;
      case Uo2:
        var m4 = t3.activeSpeaker;
        this._activeSpeaker.peerId !== m4.peerId && (this._activeSpeaker.peerId = m4.peerId, this.emitDailyJSEvent({ action: t3.action, activeSpeaker: this._activeSpeaker }));
        break;
      case "show-local-video-changed":
        if (this._callObjectMode)
          return;
        var y4 = t3.show;
        this._showLocalVideo = y4, this.emitDailyJSEvent({ action: t3.action, show: y4 });
        break;
      case Vo2:
        var b4 = t3.enabled;
        this._activeSpeakerMode !== b4 && (this._activeSpeakerMode = b4, this.emitDailyJSEvent({ action: t3.action, enabled: this._activeSpeakerMode }));
        break;
      case yo2:
      case bo2:
      case _o2:
        this._waitingParticipants = t3.allWaitingParticipants, this.emitDailyJSEvent({ action: t3.action, participant: t3.participant });
        break;
      case Zo2:
        N2(this._receiveSettings, t3.receiveSettings) || (this._receiveSettings = t3.receiveSettings, this.emitDailyJSEvent({ action: t3.action, receiveSettings: t3.receiveSettings }));
        break;
      case es2:
        this._maybeUpdateInputSettings(t3.inputSettings);
        break;
      case "send-settings-updated":
        N2(this._sendSettings, t3.sendSettings) || (this._sendSettings = t3.sendSettings, this._preloadCache.sendSettings = null, this.emitDailyJSEvent({ action: t3.action, sendSettings: t3.sendSettings }));
        break;
      case "local-audio-level":
        this._localAudioLevel = t3.audioLevel, this._preloadCache.localAudioLevelObserver = null, this.emitDailyJSEvent(t3);
        break;
      case "remote-participants-audio-level":
        this._remoteParticipantsAudioLevel = t3.participantsAudioLevel, this._preloadCache.remoteParticipantsAudioLevelObserver = null, this.emitDailyJSEvent(t3);
        break;
      case Lo2:
        var _5 = t3.session_id;
        this._rmpPlayerState[_5] = t3.playerState, this.emitDailyJSEvent(t3);
        break;
      case No2:
        delete this._rmpPlayerState[t3.session_id], this.emitDailyJSEvent(t3);
        break;
      case Do2:
        var w4 = t3.session_id, S4 = this._rmpPlayerState[w4];
        S4 && this.compareEqualForRMPUpdateEvent(S4, t3.remoteMediaPlayerState) || (this._rmpPlayerState[w4] = t3.remoteMediaPlayerState, this.emitDailyJSEvent(t3));
        break;
      case "custom-button-click":
      case "sidebar-view-changed":
        this.emitDailyJSEvent(t3);
        break;
      case go2:
        var k4 = this._meetingSessionState.topology !== (t3.meetingSessionState && t3.meetingSessionState.topology);
        this._meetingSessionState = Lc(t3.meetingSessionState, this._callObjectMode), (this._callObjectMode || k4) && this.emitDailyJSEvent(t3);
        break;
      case Ro2:
        this._isScreenSharing = true, this.emitDailyJSEvent(t3);
        break;
      case Fo2:
      case Bo2:
        this._isScreenSharing = false, this.emitDailyJSEvent(t3);
        break;
      case Eo2:
      case To2:
      case Oo2:
      case Po2:
      case Ao2:
      case ko2:
      case Mo2:
      case Co2:
      case io2:
      case oo2:
      case Io2:
      case xo2:
      case "test-completed":
      case $o2:
      case jo2:
      case Go2:
      case Qo2:
      case Ko2:
      case Yo2:
      case ts2:
      case Xo2:
      case "dialin-ready":
      case "dialin-connected":
      case "dialin-error":
      case "dialin-stopped":
      case "dialin-warning":
      case "dialout-connected":
      case "dialout-answered":
      case "dialout-error":
      case "dialout-stopped":
      case "dialout-warning":
        this.emitDailyJSEvent(t3);
        break;
      case "request-fullscreen":
        this.requestFullscreen();
        break;
      case "request-exit-fullscreen":
        this.exitFullscreen();
    }
  } }, { key: "maybeEventRecordingStopped", value: function(e4, t3) {
    var n3 = "record";
    e4 && (t3.local || false !== t3[n3] || e4[n3] === t3[n3] || this.emitDailyJSEvent({ action: To2 }));
  } }, { key: "maybeEventRecordingStarted", value: function(e4, t3) {
    var n3 = "record";
    e4 && (t3.local || true !== t3[n3] || e4[n3] === t3[n3] || this.emitDailyJSEvent({ action: Eo2 }));
  } }, { key: "_trackStatePlayable", value: function(e4) {
    return !(!e4 || e4.state !== Ti2);
  } }, { key: "_trackChanged", value: function(e4, t3) {
    return !((null == e4 ? void 0 : e4.id) === (null == t3 ? void 0 : t3.id));
  } }, { key: "maybeEventTrackStopped", value: function(e4, t3, n3) {
    var r5, i4, o4 = null !== (r5 = null == t3 ? void 0 : t3.tracks[e4]) && void 0 !== r5 ? r5 : null, s3 = null !== (i4 = null == n3 ? void 0 : n3.tracks[e4]) && void 0 !== i4 ? i4 : null, a3 = null == o4 ? void 0 : o4.track;
    if (a3) {
      var c4 = this._trackStatePlayable(o4), l3 = this._trackStatePlayable(s3), u3 = this._trackChanged(a3, null == s3 ? void 0 : s3.track);
      c4 && (l3 && !u3 || this.emitDailyJSEvent({ action: So2, track: a3, participant: null != n3 ? n3 : t3, type: e4 }));
    }
  } }, { key: "maybeEventTrackStarted", value: function(e4, t3, n3) {
    var r5, i4, o4 = null !== (r5 = null == t3 ? void 0 : t3.tracks[e4]) && void 0 !== r5 ? r5 : null, s3 = null !== (i4 = null == n3 ? void 0 : n3.tracks[e4]) && void 0 !== i4 ? i4 : null, a3 = null == s3 ? void 0 : s3.track;
    if (a3) {
      var c4 = this._trackStatePlayable(o4), l3 = this._trackStatePlayable(s3), u3 = this._trackChanged(null == o4 ? void 0 : o4.track, a3);
      l3 && (c4 && !u3 || this.emitDailyJSEvent({ action: wo2, track: a3, participant: n3, type: e4 }));
    }
  } }, { key: "maybeParticipantTracksStopped", value: function(e4, t3) {
    if (e4)
      for (var n3 in e4.tracks)
        this.maybeEventTrackStopped(n3, e4, t3);
  } }, { key: "maybeParticipantTracksStarted", value: function(e4, t3) {
    if (t3)
      for (var n3 in t3.tracks)
        this.maybeEventTrackStarted(n3, e4, t3);
  } }, { key: "compareEqualForRMPUpdateEvent", value: function(e4, t3) {
    var n3, r5;
    return e4.state === t3.state && (null === (n3 = e4.settings) || void 0 === n3 ? void 0 : n3.volume) === (null === (r5 = t3.settings) || void 0 === r5 ? void 0 : r5.volume);
  } }, { key: "emitDailyJSEvent", value: function(e4) {
    try {
      e4.callClientId = this.callClientId, this.emit(e4.action, e4);
    } catch (t3) {
      console.log("could not emit", e4, t3);
    }
  } }, { key: "compareEqualForParticipantUpdateEvent", value: function(e4, t3) {
    return !!N2(e4, t3) && ((!e4.videoTrack || !t3.videoTrack || e4.videoTrack.id === t3.videoTrack.id && e4.videoTrack.muted === t3.videoTrack.muted && e4.videoTrack.enabled === t3.videoTrack.enabled) && (!e4.audioTrack || !t3.audioTrack || e4.audioTrack.id === t3.audioTrack.id && e4.audioTrack.muted === t3.audioTrack.muted && e4.audioTrack.enabled === t3.audioTrack.enabled));
  } }, { key: "nativeUtils", value: function() {
    return ys2() ? "undefined" == typeof DailyNativeUtils ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
  } }, { key: "updateIsPreparingToJoin", value: function(e4) {
    this._updateCallState(this._callState, e4);
  } }, { key: "_updateCallState", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._isPreparingToJoin;
    if (e4 !== this._callState || t3 !== this._isPreparingToJoin) {
      var n3 = this._callState, r5 = this._isPreparingToJoin;
      this._callState = e4, this._isPreparingToJoin = t3;
      var i4 = this._callState === bi2;
      this.updateShowAndroidOngoingMeetingNotification(i4);
      var o4 = uc2(n3, r5), s3 = uc2(this._callState, this._isPreparingToJoin);
      o4 !== s3 && (this.updateKeepDeviceAwake(s3), this.updateDeviceAudioMode(s3), this.updateNoOpRecordingEnsuringBackgroundContinuity(s3));
    }
  } }, { key: "resetMeetingDependentVars", value: function() {
    this._participants = {}, this._participantCounts = Xa2, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = false, this._didPreAuth = false, this._accessState = { access: Oi2 }, this._finalSummaryOfPrevSession = this._meetingSessionSummary, this._meetingSessionSummary = {}, this._meetingSessionState = Lc(Ya2, this._callObjectMode), this._isScreenSharing = false, this._receiveSettings = {}, this._inputSettings = void 0, this._sendSettings = {}, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this._maxAppMessageSize = rs2, this._callMachineInitialized = false, this._bundleLoadTime = void 0, this._preloadCache;
  } }, { key: "updateKeepDeviceAwake", value: function(e4) {
    ys2() && this.nativeUtils().setKeepDeviceAwake(e4, this.callClientId);
  } }, { key: "updateDeviceAudioMode", value: function(e4) {
    if (ys2() && !this.disableReactNativeAutoDeviceManagement("audio")) {
      var t3 = e4 ? this._nativeInCallAudioMode : "idle";
      this.nativeUtils().setAudioMode(t3);
    }
  } }, { key: "updateShowAndroidOngoingMeetingNotification", value: function(e4) {
    if (ys2() && this.nativeUtils().setShowOngoingMeetingNotification) {
      var t3, n3, r5, i4;
      if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
        var o4 = this.properties.reactNativeConfig.androidInCallNotification;
        t3 = o4.title, n3 = o4.subtitle, r5 = o4.iconName, i4 = o4.disableForCustomOverride;
      }
      i4 && (e4 = false), this.nativeUtils().setShowOngoingMeetingNotification(e4, t3, n3, r5, this.callClientId);
    }
  } }, { key: "updateNoOpRecordingEnsuringBackgroundContinuity", value: function(e4) {
    ys2() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e4);
  } }, { key: "toggleParticipantAudioBasedOnNativeAudioFocus", value: function() {
    var e4;
    if (ys2()) {
      var t3 = null === (e4 = this._callMachine()) || void 0 === e4 || null === (e4 = e4.store) || void 0 === e4 ? void 0 : e4.getState();
      for (var n3 in null == t3 ? void 0 : t3.streams) {
        var r5 = t3.streams[n3];
        r5 && r5.pendingTrack && "audio" === r5.pendingTrack.kind && (r5.pendingTrack.enabled = this._hasNativeAudioFocus);
      }
    }
  } }, { key: "disableReactNativeAutoDeviceManagement", value: function(e4) {
    return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e4];
  } }, { key: "absoluteUrl", value: function(e4) {
    if (void 0 !== e4) {
      var t3 = document.createElement("a");
      return t3.href = e4, t3.href;
    }
  } }, { key: "sayHello", value: function() {
    var e4 = "hello, world.";
    return console.log(e4), e4;
  } }, { key: "_logUseAfterDestroy", value: function() {
    var e4 = Object.values(Ga2)[0];
    if (this.needsLoad()) {
      if (e4 && !e4.needsLoad()) {
        var t3 = { action: cs2, level: "error", code: this.strictMode ? 9995 : 9997 };
        e4.sendMessageToCallMachine(t3);
      } else if (!this.strictMode) {
        console.error("You are are attempting to use a call instance that was previously destroyed, which is unsupported. Please remove `strictMode: false` from your constructor properties to enable strict mode to track down and fix this unsupported usage.");
      }
    } else {
      var n3 = { action: cs2, level: "error", code: this.strictMode ? 9995 : 9997 };
      this._messageChannel.sendMessageToCallMachine(n3, null, this.callClientId, this._iframe);
    }
  } }, { key: "_logDuplicateInstanceAttempt", value: function() {
    for (var e4 = 0, t3 = Object.values(Ga2); e4 < t3.length; e4++) {
      var n3 = t3[e4];
      n3._callMachineInitialized ? (n3.sendMessageToCallMachine({ action: cs2, level: "warn", code: this.allowMultipleCallInstances ? 9993 : 9992 }), n3._delayDuplicateInstanceLog = false) : n3._delayDuplicateInstanceLog = true;
    }
  } }, { key: "_maybeSendToSentry", value: function(e4) {
    var t3, n3, i4, o4;
    if (null !== (t3 = e4.error) && void 0 !== t3 && t3.type) {
      if (![$i2, Vi2, Bi2].includes(e4.error.type))
        return;
      if (e4.error.type === Bi2 && e4.error.msg.includes("deleted"))
        return;
    }
    var s3 = null !== (n3 = this.properties) && void 0 !== n3 && n3.url ? new URL(this.properties.url) : void 0, a3 = "production";
    s3 && s3.host.includes(".staging.daily") && (a3 = "staging");
    var c4, l3, u3, d4, h4, p4 = function(e5) {
      const t4 = [Gn2(), Wn2(), ii2(), ni2(), ui2(), fi2(), rr2(), pi2()];
      return false !== e5.autoSessionTracking && t4.push(li2()), t4;
    }({}).filter(function(e5) {
      return !["BrowserApiErrors", "Breadcrumbs", "GlobalHandlers"].includes(e5.name);
    }), f3 = new jr2({ dsn: "https://f10f1c81e5d44a4098416c0867a8b740@o77906.ingest.sentry.io/168844", transport: Wr2, stackParser: Zr2, integrations: p4, environment: a3 }), v5 = new Mt2();
    if (v5.setClient(f3), f3.init(), this.session_id && v5.setExtra("sessionId", this.session_id), this.properties) {
      var g4 = qa2({}, this.properties);
      g4.userName = g4.userName ? "[Filtered]" : void 0, g4.userData = g4.userData ? "[Filtered]" : void 0, g4.token = g4.token ? "[Filtered]" : void 0, v5.setExtra("properties", g4);
    }
    if (s3) {
      var m4 = s3.searchParams.get("domain");
      if (!m4) {
        var y4 = s3.host.match(/(.*?)\./);
        m4 = y4 && y4[1] || "";
      }
      m4 && v5.setTag("domain", m4);
    }
    e4.error && (v5.setTag("fatalErrorType", e4.error.type), v5.setExtra("errorDetails", e4.error.details), (null === (c4 = e4.error.details) || void 0 === c4 ? void 0 : c4.uri) && v5.setTag("serverAddress", e4.error.details.uri), (null === (l3 = e4.error.details) || void 0 === l3 ? void 0 : l3.workerGroup) && v5.setTag("workerGroup", e4.error.details.workerGroup), (null === (u3 = e4.error.details) || void 0 === u3 ? void 0 : u3.geoGroup) && v5.setTag("geoGroup", e4.error.details.geoGroup), (null === (d4 = e4.error.details) || void 0 === d4 ? void 0 : d4.on) && v5.setTag("connectionAttempt", e4.error.details.on), null !== (h4 = e4.error.details) && void 0 !== h4 && h4.bundleUrl && (v5.setTag("bundleUrl", e4.error.details.bundleUrl), v5.setTag("bundleError", e4.error.details.sourceError.type)));
    v5.setTags({ callMode: this._callObjectMode ? ys2() ? "reactNative" : null !== (i4 = this.properties) && void 0 !== i4 && null !== (i4 = i4.dailyConfig) && void 0 !== i4 && null !== (i4 = i4.callMode) && void 0 !== i4 && i4.includes("prebuilt") ? this.properties.dailyConfig.callMode : "custom" : "prebuilt-frame", version: r4.version() });
    var b4 = (null === (o4 = e4.error) || void 0 === o4 ? void 0 : o4.msg) || e4.errorMsg;
    v5.captureException(new Error(b4));
  } }, { key: "_callMachine", value: function() {
    var e4;
    return null === (e4 = window._daily) || void 0 === e4 || null === (e4 = e4.instances) || void 0 === e4 || null === (e4 = e4[this.callClientId]) || void 0 === e4 ? void 0 : e4.callMachine;
  } }, { key: "_maybeUpdateInputSettings", value: function(e4) {
    if (!N2(this._inputSettings, e4)) {
      var t3 = this._getInputSettings();
      this._inputSettings = e4;
      var n3 = this._getInputSettings();
      N2(t3, n3) || this.emitDailyJSEvent({ action: es2, inputSettings: n3 });
    }
  } }], [{ key: "supportedBrowser", value: function() {
    if (ys2())
      return { supported: true, mobile: true, name: "React Native", version: null, supportsScreenShare: true, supportsSfu: true, supportsVideoProcessing: false, supportsAudioProcessing: false };
    var e4 = Q2.getParser(ms2());
    return { supported: !!Os2(), mobile: "mobile" === e4.getPlatformType(), name: e4.getBrowserName(), version: e4.getBrowserVersion(), supportsFullscreen: !!ws2(), supportsScreenShare: !!_s2(), supportsSfu: !!Os2(), supportsVideoProcessing: Es2(), supportsAudioProcessing: Ts2() };
  } }, { key: "version", value: function() {
    return "0.79.0";
  } }, { key: "createCallObject", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return e4.layout = "none", new r4(null, e4);
  } }, { key: "wrap", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (gc2(), !e4 || !e4.contentWindow || "string" != typeof e4.src)
      throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
    return t3.layout || (t3.customLayout ? t3.layout = "custom-v1" : t3.layout = "browser"), new r4(e4, t3);
  } }, { key: "createFrame", value: function(e4, t3) {
    var n3, i4;
    gc2(), e4 && t3 ? (n3 = e4, i4 = t3) : e4 && e4.append ? (n3 = e4, i4 = {}) : (n3 = document.body, i4 = e4 || {});
    var o4 = i4.iframeStyle;
    o4 || (o4 = n3 === document.body ? { position: "fixed", border: "1px solid black", backgroundColor: "white", width: "375px", height: "450px", right: "1em", bottom: "1em" } : { border: 0, width: "100%", height: "100%" });
    var s3 = document.createElement("iframe");
    window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? s3.allow = "microphone, camera" : s3.allow = "microphone; camera; autoplay; display-capture; screen-wake-lock", s3.style.visibility = "hidden", n3.appendChild(s3), s3.style.visibility = null, Object.keys(o4).forEach(function(e5) {
      return s3.style[e5] = o4[e5];
    }), i4.layout || (i4.customLayout ? i4.layout = "custom-v1" : i4.layout = "browser");
    try {
      return new r4(s3, i4);
    } catch (e5) {
      throw n3.removeChild(s3), e5;
    }
  } }, { key: "createTransparentFrame", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    gc2();
    var t3 = document.createElement("iframe");
    return t3.allow = "microphone; camera; autoplay", t3.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t3), e4.layout || (e4.layout = "custom-v1"), r4.wrap(t3, e4);
  } }, { key: "getCallInstance", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    return e4 ? Ga2[e4] : Object.values(Ga2)[0];
  } }]);
  var i3, c3, d3, p3, v3, g3, m3, y3, b3, _4, w3, S3, k3, M3, C3, E3, T3, O3, P3, A3, j3, I3, L3, D3, R3, F3, B3, U3, V3, J3, $3, q3, z3, W3, H3, G3, Y3, ee3;
}();
function cc2(e4, t3) {
  var n3 = {};
  for (var r4 in e4)
    if (e4[r4] instanceof MediaStreamTrack)
      console.warn("MediaStreamTrack found in props or cache.", r4), n3[r4] = ls2;
    else if ("dailyConfig" === r4) {
      if (e4[r4].modifyLocalSdpHook) {
        var i3 = window._daily.instances[t3].customCallbacks || {};
        i3.modifyLocalSdpHook = e4[r4].modifyLocalSdpHook, window._daily.instances[t3].customCallbacks = i3, delete e4[r4].modifyLocalSdpHook;
      }
      if (e4[r4].modifyRemoteSdpHook) {
        var o4 = window._daily.instances[t3].customCallbacks || {};
        o4.modifyRemoteSdpHook = e4[r4].modifyRemoteSdpHook, window._daily.instances[t3].customCallbacks = o4, delete e4[r4].modifyRemoteSdpHook;
      }
      n3[r4] = e4[r4];
    } else
      n3[r4] = e4[r4];
  return n3;
}
function lc2(e4) {
  var t3 = arguments.length > 2 ? arguments[2] : void 0;
  if (e4 !== bi2) {
    var n3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " only supported after join.");
    throw t3 && (n3 += " ".concat(t3)), console.error(n3), new Error(n3);
  }
}
function uc2(e4, t3) {
  return [yi2, bi2].includes(e4) || t3;
}
function dc2(e4, t3) {
  var n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "This daily-js method", r4 = arguments.length > 3 ? arguments[3] : void 0;
  if (uc2(e4, t3)) {
    var i3 = "".concat(n3, " not supported after joining a meeting.");
    throw r4 && (i3 += " ".concat(r4)), console.error(i3), new Error(i3);
  }
}
function hc2(e4) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", n3 = arguments.length > 2 ? arguments[2] : void 0;
  if (!e4) {
    var r4 = "".concat(t3, arguments.length > 3 && void 0 !== arguments[3] && arguments[3] ? " requires preAuth() or startCamera() to initialize call state." : " requires preAuth(), startCamera(), or join() to initialize call state.");
    throw n3 && (r4 += " ".concat(n3)), console.error(r4), new Error(r4);
  }
}
function pc2(e4) {
  if (e4) {
    var t3 = "A pre-call quality test is in progress. Please try ".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " again once testing has completed. Use stopTestCallQuality() to end it early.");
    throw console.error(t3), new Error(t3);
  }
}
function fc2(e4) {
  if (!e4) {
    var t3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported on custom callObject instances");
    throw console.error(t3), new Error(t3);
  }
}
function vc2(e4) {
  if (e4) {
    var t3 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported as part of Daily's Prebuilt");
    throw console.error(t3), new Error(t3);
  }
}
function gc2() {
  if (ys2())
    throw new Error("This daily-js method is not currently supported in React Native");
}
function mc2() {
  if (!ys2())
    throw new Error("This daily-js method is only supported in React Native");
}
function yc2(e4) {
  if (void 0 === e4)
    return true;
  var t3;
  if ("string" == typeof e4)
    t3 = e4;
  else
    try {
      t3 = JSON.stringify(e4), N2(JSON.parse(t3), e4) || console.warn("The userData provided will be modified when serialized.");
    } catch (e5) {
      throw Error("userData must be serializable to JSON: ".concat(e5));
    }
  if (t3.length > 4096)
    throw Error("userData is too large (".concat(t3.length, " characters). Maximum size suppported is ").concat(4096, "."));
  return true;
}
function bc2(e4, t3) {
  for (var n3 = t3.allowAllParticipantsKey, r4 = function(e5) {
    var t4 = ["local"];
    return n3 || t4.push("*"), e5 && !t4.includes(e5);
  }, i3 = function(e5) {
    return !!(void 0 === e5.layer || Number.isInteger(e5.layer) && e5.layer >= 0 || "inherit" === e5.layer);
  }, o4 = function(e5) {
    return !!e5 && (!(e5.video && !i3(e5.video)) && !(e5.screenVideo && !i3(e5.screenVideo)));
  }, s3 = 0, a3 = Object.entries(e4); s3 < a3.length; s3++) {
    var c3 = f2(a3[s3], 2), l3 = c3[0], u3 = c3[1];
    if (!r4(l3) || !o4(u3))
      return false;
  }
  return true;
}
function _c2(e4) {
  if ("object" !== n2(e4))
    return false;
  for (var t3 = 0, r4 = Object.entries(e4); t3 < r4.length; t3++) {
    var i3 = f2(r4[t3], 2), o4 = i3[0], s3 = i3[1];
    switch (o4) {
      case "video":
        if ("object" !== n2(s3))
          return false;
        for (var a3 = 0, c3 = Object.entries(s3); a3 < c3.length; a3++) {
          var l3 = f2(c3[a3], 2), u3 = l3[0], d3 = l3[1];
          switch (u3) {
            case "processor":
              if (!kc2(d3))
                return false;
              break;
            case "settings":
              if (!Mc2(d3))
                return false;
              break;
            default:
              return false;
          }
        }
        break;
      case "audio":
        if ("object" !== n2(s3))
          return false;
        for (var h4 = 0, p3 = Object.entries(s3); h4 < p3.length; h4++) {
          var v3 = f2(p3[h4], 2), g3 = v3[0], m3 = v3[1];
          switch (g3) {
            case "processor":
              if (!Sc2(m3))
                return false;
              break;
            case "settings":
              if (!Mc2(m3))
                return false;
              break;
            default:
              return false;
          }
        }
        break;
      default:
        return false;
    }
  }
  return true;
}
function wc2(e4, t3, n3) {
  var r4, i3 = [];
  e4.video && e4.video.processor && (Es2(null !== (r4 = null == t3 ? void 0 : t3.useLegacyVideoProcessor) && void 0 !== r4 && r4) || (e4.video.settings ? delete e4.video.processor : delete e4.video, i3.push("video")));
  e4.audio && e4.audio.processor && (Ts2() || (e4.audio.settings ? delete e4.audio.processor : delete e4.audio, i3.push("audio"))), i3.length > 0 && console.error("Ignoring settings for browser- or platform-unsupported input processor(s): ".concat(i3.join(", "))), e4.audio && e4.audio.settings && (e4.audio.settings.customTrack ? (n3.audioTrack = e4.audio.settings.customTrack, e4.audio.settings = { customTrack: ls2 }) : delete n3.audioTrack), e4.video && e4.video.settings && (e4.video.settings.customTrack ? (n3.videoTrack = e4.video.settings.customTrack, e4.video.settings = { customTrack: ls2 }) : delete n3.videoTrack);
}
function Sc2(e4) {
  if (ys2())
    return console.warn("Video processing is not yet supported in React Native"), false;
  var t3 = ["type"];
  return !!e4 && ("object" === n2(e4) && (Object.keys(e4).filter(function(e5) {
    return !t3.includes(e5);
  }).forEach(function(t4) {
    console.warn("invalid key inputSettings -> audio -> processor : ".concat(t4)), delete e4[t4];
  }), !!function(e5) {
    if ("string" != typeof e5)
      return false;
    if (!Object.values(ds2).includes(e5))
      return console.error("inputSettings audio processor type invalid"), false;
    return true;
  }(e4.type)));
}
function kc2(e4) {
  if (ys2())
    return console.warn("Video processing is not yet supported in React Native"), false;
  var t3 = ["type", "config"];
  if (!e4)
    return false;
  if ("object" !== n2(e4))
    return false;
  if (!function(e5) {
    if ("string" != typeof e5)
      return false;
    if (!Object.values(us2).includes(e5))
      return console.error("inputSettings video processor type invalid"), false;
    return true;
  }(e4.type))
    return false;
  if (e4.config) {
    if ("object" !== n2(e4.config))
      return false;
    if (!function(e5, t4) {
      var n3 = Object.keys(t4);
      if (0 === n3.length)
        return true;
      var r4 = "invalid object in inputSettings -> video -> processor -> config";
      switch (e5) {
        case us2.BGBLUR:
          return n3.length > 1 || "strength" !== n3[0] ? (console.error(r4), false) : !("number" != typeof t4.strength || t4.strength <= 0 || t4.strength > 1 || isNaN(t4.strength)) || (console.error("".concat(r4, "; expected: {0 < strength <= 1}, got: ").concat(t4.strength)), false);
        case us2.BGIMAGE:
          return !(void 0 !== t4.source && !function(e6) {
            if ("default" === e6.source)
              return e6.type = "default", true;
            if (e6.source instanceof ArrayBuffer)
              return true;
            if (ee2(e6.source))
              return e6.type = "url", !!function(e7) {
                var t6 = new URL(e7), n5 = t6.pathname;
                if ("data:" === t6.protocol)
                  try {
                    var r5 = n5.substring(n5.indexOf(":") + 1, n5.indexOf(";")).split("/")[1];
                    return ps2.includes(r5);
                  } catch (e8) {
                    return console.error("failed to deduce blob content type", e8), false;
                  }
                var i3 = n5.split(".").at(-1).toLowerCase().trim();
                return ps2.includes(i3);
              }(e6.source) || (console.error("invalid image type; supported types: [".concat(ps2.join(", "), "]")), false);
            return t5 = e6.source, n4 = Number(t5), isNaN(n4) || !Number.isInteger(n4) || n4 <= 0 || n4 > 10 ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(10)), false) : (e6.type = "daily-preselect", true);
            var t5, n4;
          }(t4));
        default:
          return true;
      }
    }(e4.type, e4.config))
      return false;
  }
  return Object.keys(e4).filter(function(e5) {
    return !t3.includes(e5);
  }).forEach(function(t4) {
    console.warn("invalid key inputSettings -> video -> processor : ".concat(t4)), delete e4[t4];
  }), true;
}
function Mc2(e4) {
  return "object" === n2(e4) && (!e4.customTrack || e4.customTrack instanceof MediaStreamTrack);
}
function Cc2() {
  var e4 = Object.values(us2).join(" | "), t3 = Object.values(ds2).join(" | ");
  return "inputSettings must be of the form: { video?: { processor?: { type: [ ".concat(e4, " ], config?: {} } }, audio?: { processor: {type: [ ").concat(t3, " ] } } }");
}
function Ec2(e4) {
  var t3 = e4.allowAllParticipantsKey;
  return "receiveSettings must be of the form { [<remote participant id> | ".concat(Ii2).concat(t3 ? ' | "'.concat("*", '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
}
function Tc2() {
  return "customIntegrations should be an object of type ".concat(JSON.stringify(ic2), ".");
}
function Oc2(e4) {
  if (e4 && "object" !== n2(e4) || Array.isArray(e4))
    return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify(rc2), ".")), false;
  if (e4)
    for (var t3 = 0, r4 = Object.entries(e4); t3 < r4.length; t3++)
      for (var i3 = f2(r4[t3], 1)[0], o4 = 0, s3 = Object.entries(e4[i3]); o4 < s3.length; o4++) {
        var a3 = f2(s3[o4], 2), c3 = a3[0], l3 = a3[1], u3 = rc2.id[c3];
        if (!u3)
          return console.error("customTrayButton does not support key ".concat(c3)), false;
        switch (c3) {
          case "iconPath":
          case "iconPathDarkMode":
            if (!ee2(l3))
              return console.error("customTrayButton ".concat(c3, " should be a url.")), false;
            break;
          case "visualState":
            if (!["default", "sidebar-open", "active"].includes(l3))
              return console.error("customTrayButton ".concat(c3, " should be ").concat(u3, ". Got: ").concat(l3)), false;
            break;
          default:
            if (n2(l3) !== u3)
              return console.error("customTrayButton ".concat(c3, " should be a ").concat(u3, ".")), false;
        }
      }
  return true;
}
function Pc2(e4) {
  if (!e4 || e4 && "object" !== n2(e4) || Array.isArray(e4))
    return console.error(Tc2()), false;
  for (var t3 = function(e5) {
    return "".concat(e5, " should be ").concat(ic2.id[e5]);
  }, r4 = function(e5, t4) {
    return console.error("customIntegration ".concat(e5, ": ").concat(t4));
  }, i3 = 0, o4 = Object.entries(e4); i3 < o4.length; i3++) {
    var s3 = f2(o4[i3], 1)[0];
    if (!("label" in e4[s3]))
      return r4(s3, "label is required"), false;
    if (!("location" in e4[s3]))
      return r4(s3, "location is required"), false;
    if (!("src" in e4[s3]) && !("srcdoc" in e4[s3]))
      return r4(s3, "src or srcdoc is required"), false;
    for (var a3 = 0, c3 = Object.entries(e4[s3]); a3 < c3.length; a3++) {
      var l3 = f2(c3[a3], 2), u3 = l3[0], d3 = l3[1];
      switch (u3) {
        case "allow":
        case "csp":
        case "name":
        case "referrerPolicy":
        case "sandbox":
          if ("string" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        case "iconURL":
          if (!ee2(d3))
            return r4(s3, "".concat(u3, " should be a url")), false;
          break;
        case "src":
          if ("srcdoc" in e4[s3])
            return r4(s3, "cannot have both src and srcdoc"), false;
          if (!ee2(d3))
            return r4(s3, 'src "'.concat(d3, '" is not a valid URL')), false;
          break;
        case "srcdoc":
          if ("src" in e4[s3])
            return r4(s3, "cannot have both src and srcdoc"), false;
          if ("string" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        case "location":
          if (!["main", "sidebar"].includes(d3))
            return r4(s3, t3(u3)), false;
          break;
        case "controlledBy":
          if ("*" !== d3 && "owners" !== d3 && (!Array.isArray(d3) || d3.some(function(e5) {
            return "string" != typeof e5;
          })))
            return r4(s3, t3(u3)), false;
          break;
        case "shared":
          if ((!Array.isArray(d3) || d3.some(function(e5) {
            return "string" != typeof e5;
          })) && "owners" !== d3 && "boolean" != typeof d3)
            return r4(s3, t3(u3)), false;
          break;
        default:
          if (!ic2.id[u3])
            return console.error("customIntegration does not support key ".concat(u3)), false;
      }
    }
  }
  return true;
}
function Ac2(e4, t3) {
  if (void 0 === t3)
    return false;
  switch (n2(t3)) {
    case "string":
      return n2(e4) === t3;
    case "object":
      if ("object" !== n2(e4))
        return false;
      for (var r4 in e4)
        if (!Ac2(e4[r4], t3[r4]))
          return false;
      return true;
    default:
      return false;
  }
}
function jc2(e4, t3) {
  var n3 = e4.sessionId, r4 = e4.toEndPoint, i3 = e4.callerId, o4 = e4.useSipRefer;
  if (!n3 || !r4)
    throw new Error("".concat(t3, "() requires a sessionId and toEndPoint"));
  if ("string" != typeof n3 || "string" != typeof r4)
    throw new Error("Invalid paramater: sessionId and toEndPoint must be of type string");
  if (o4 && !r4.startsWith("sip:"))
    throw new Error('"toEndPoint" must be a "sip" address');
  if (!r4.startsWith("sip:") && !r4.startsWith("+"))
    throw new Error("toEndPoint: ".concat(r4, ' must starts with either "sip:" or "+"'));
  if (i3 && "string" != typeof i3)
    throw new Error("callerId must be of type string");
  if (i3 && !r4.startsWith("+"))
    throw new Error("callerId is only valid when transferring to a PSTN number");
}
function Ic(e4) {
  if ("object" !== n2(e4))
    throw new Error('RemoteMediaPlayerSettings: must be "object" type');
  if (e4.state && !Object.values(hs2).includes(e4.state))
    throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(hs2));
  if (e4.volume) {
    if ("number" != typeof e4.volume)
      throw new Error('RemoteMediaPlayerSettings.volume: must be "number" type');
    if (e4.volume < 0 || e4.volume > 2)
      throw new Error("RemoteMediaPlayerSettings.volume: must be between 0.0 - 2.0");
  }
}
function xc(e4, t3, n3) {
  return !("number" != typeof e4 || e4 < t3 || e4 > n3);
}
function Lc(e4, t3) {
  return e4 && !t3 && delete e4.data, e4;
}

// ../node_modules/@pipecat-ai/gemini-live-websocket-transport/dist/index.module.js
var import_events2 = __toESM(require_events());
function $parcel$export4(e4, n3, v3, s3) {
  Object.defineProperty(e4, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $d4cf498bb51af8a5$exports = {};
$parcel$export4($d4cf498bb51af8a5$exports, "GeminiLiveWebsocketTransport", () => $d4cf498bb51af8a5$export$bef67da0c82ecefe);
var $6d4b7449a1e1544a$export$13afda237b1c98463 = class {
  /**
  * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format
  * @param {Float32Array} float32Array
  * @returns {ArrayBuffer}
  */
  static floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i3 = 0; i3 < float32Array.length; i3++, offset += 2) {
      let s3 = Math.max(-1, Math.min(1, float32Array[i3]));
      view.setInt16(offset, s3 < 0 ? s3 * 32768 : s3 * 32767, true);
    }
    return buffer;
  }
  /**
  * Concatenates two ArrayBuffers
  * @param {ArrayBuffer} leftBuffer
  * @param {ArrayBuffer} rightBuffer
  * @returns {ArrayBuffer}
  */
  static mergeBuffers(leftBuffer, rightBuffer) {
    const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
    tmpArray.set(new Uint8Array(leftBuffer), 0);
    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
    return tmpArray.buffer;
  }
  /**
  * Packs data into an Int16 format
  * @private
  * @param {number} size 0 = 1x Int16, 1 = 2x Int16
  * @param {number} arg value to pack
  * @returns
  */
  _packData(size, arg) {
    return [
      new Uint8Array([
        arg,
        arg >> 8
      ]),
      new Uint8Array([
        arg,
        arg >> 8,
        arg >> 16,
        arg >> 24
      ])
    ][size];
  }
  /**
  * Packs audio into "audio/wav" Blob
  * @param {number} sampleRate
  * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio
  * @returns {WavPackerAudioType}
  */
  pack(sampleRate, audio) {
    if (!audio?.bitsPerSample)
      throw new Error(`Missing "bitsPerSample"`);
    else if (!audio?.channels)
      throw new Error(`Missing "channels"`);
    else if (!audio?.data)
      throw new Error(`Missing "data"`);
    const { bitsPerSample, channels, data } = audio;
    const output = [
      // Header
      "RIFF",
      this._packData(1, 52),
      "WAVE",
      // chunk 1
      "fmt ",
      this._packData(1, 16),
      this._packData(0, 1),
      this._packData(0, channels.length),
      this._packData(1, sampleRate),
      this._packData(1, sampleRate * channels.length * bitsPerSample / 8),
      this._packData(0, channels.length * bitsPerSample / 8),
      this._packData(0, bitsPerSample),
      // chunk 2
      "data",
      this._packData(1, channels[0].length * channels.length * bitsPerSample / 8),
      data
    ];
    const blob = new Blob(output, {
      type: "audio/mpeg"
    });
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      channelCount: channels.length,
      sampleRate,
      duration: data.byteLength / (channels.length * sampleRate * 2)
    };
  }
};
globalThis.WavPacker = $6d4b7449a1e1544a$export$13afda237b1c98463;
var $03f71ce85e00ada6$var$octave8Frequencies3 = [
  4186.01,
  4434.92,
  4698.63,
  4978.03,
  5274.04,
  5587.65,
  5919.91,
  6271.93,
  6644.88,
  7040,
  7458.62,
  7902.13
];
var $03f71ce85e00ada6$var$octave8FrequencyLabels3 = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];
var $03f71ce85e00ada6$export$776c63898ae5b6363 = [];
var $03f71ce85e00ada6$export$facd167cc27ea9b03 = [];
for (let i3 = 1; i3 <= 8; i3++)
  for (let f3 = 0; f3 < $03f71ce85e00ada6$var$octave8Frequencies3.length; f3++) {
    const freq = $03f71ce85e00ada6$var$octave8Frequencies3[f3];
    $03f71ce85e00ada6$export$776c63898ae5b6363.push(freq / Math.pow(2, 8 - i3));
    $03f71ce85e00ada6$export$facd167cc27ea9b03.push($03f71ce85e00ada6$var$octave8FrequencyLabels3[f3] + i3);
  }
var $03f71ce85e00ada6$var$voiceFrequencyRange3 = [
  32,
  2e3
];
var $03f71ce85e00ada6$export$dbc1581ed2cfa1833 = $03f71ce85e00ada6$export$776c63898ae5b6363.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6363[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange3[0] && $03f71ce85e00ada6$export$776c63898ae5b6363[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange3[1];
});
var $03f71ce85e00ada6$export$30a6f2881311088f3 = $03f71ce85e00ada6$export$facd167cc27ea9b03.filter((_4, i3) => {
  return $03f71ce85e00ada6$export$776c63898ae5b6363[i3] > $03f71ce85e00ada6$var$voiceFrequencyRange3[0] && $03f71ce85e00ada6$export$776c63898ae5b6363[i3] < $03f71ce85e00ada6$var$voiceFrequencyRange3[1];
});
var $f32f064564ee62f6$export$2c3136da0bf130f93 = class _$f32f064564ee62f6$export$2c3136da0bf130f9 {
  /**
  * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range
  * returns human-readable formatting and labels
  * @param {AnalyserNode} analyser
  * @param {number} sampleRate
  * @param {Float32Array} [fftResult]
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  static getFrequencies(analyser, sampleRate, fftResult, analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!fftResult) {
      fftResult = new Float32Array(analyser.frequencyBinCount);
      analyser.getFloatFrequencyData(fftResult);
    }
    const nyquistFrequency = sampleRate / 2;
    const frequencyStep = 1 / fftResult.length * nyquistFrequency;
    let outputValues;
    let frequencies;
    let labels;
    if (analysisType === "music" || analysisType === "voice") {
      const useFrequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1833) : (0, $03f71ce85e00ada6$export$776c63898ae5b6363);
      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);
      for (let i3 = 0; i3 < fftResult.length; i3++) {
        const frequency = i3 * frequencyStep;
        const amplitude = fftResult[i3];
        for (let n3 = useFrequencies.length - 1; n3 >= 0; n3--)
          if (frequency > useFrequencies[n3]) {
            aggregateOutput[n3] = Math.max(aggregateOutput[n3], amplitude);
            break;
          }
      }
      outputValues = aggregateOutput;
      frequencies = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$dbc1581ed2cfa1833) : (0, $03f71ce85e00ada6$export$776c63898ae5b6363);
      labels = analysisType === "voice" ? (0, $03f71ce85e00ada6$export$30a6f2881311088f3) : (0, $03f71ce85e00ada6$export$facd167cc27ea9b03);
    } else {
      outputValues = Array.from(fftResult);
      frequencies = outputValues.map((_4, i3) => frequencyStep * i3);
      labels = frequencies.map((f3) => `${f3.toFixed(2)} Hz`);
    }
    const normalizedOutput = outputValues.map((v3) => {
      return Math.max(0, Math.min((v3 - minDecibels) / (maxDecibels - minDecibels), 1));
    });
    const values = new Float32Array(normalizedOutput);
    return {
      values,
      frequencies,
      labels
    };
  }
  /**
  * Creates a new AudioAnalysis instance for an HTMLAudioElement
  * @param {HTMLAudioElement} audioElement
  * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer
  * @returns {AudioAnalysis}
  */
  constructor(audioElement, audioBuffer = null) {
    this.fftResults = [];
    if (audioBuffer) {
      const { length, sampleRate } = audioBuffer;
      const offlineAudioContext = new OfflineAudioContext({
        length,
        sampleRate
      });
      const source = offlineAudioContext.createBufferSource();
      source.buffer = audioBuffer;
      const analyser = offlineAudioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      source.connect(analyser);
      const renderQuantumInSeconds = 1 / 60;
      const durationInSeconds = length / sampleRate;
      const analyze = (index) => {
        const suspendTime = renderQuantumInSeconds * index;
        if (suspendTime < durationInSeconds)
          offlineAudioContext.suspend(suspendTime).then(() => {
            const fftResult = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(fftResult);
            this.fftResults.push(fftResult);
            analyze(index + 1);
          });
        if (index === 1)
          offlineAudioContext.startRendering();
        else
          offlineAudioContext.resume();
      };
      source.start(0);
      analyze(1);
      this.audio = audioElement;
      this.context = offlineAudioContext;
      this.analyser = analyser;
      this.sampleRate = sampleRate;
      this.audioBuffer = audioBuffer;
    } else {
      const audioContext = new AudioContext();
      const track2 = audioContext.createMediaElementSource(audioElement);
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 8192;
      analyser.smoothingTimeConstant = 0.1;
      track2.connect(analyser);
      analyser.connect(audioContext.destination);
      this.audio = audioElement;
      this.context = audioContext;
      this.analyser = analyser;
      this.sampleRate = this.context.sampleRate;
      this.audioBuffer = null;
    }
  }
  /**
  * Gets the current frequency domain data from the playing audio track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    let fftResult = null;
    if (this.audioBuffer && this.fftResults.length) {
      const pct = this.audio.currentTime / this.audio.duration;
      const index = Math.min(pct * this.fftResults.length | 0, this.fftResults.length - 1);
      fftResult = this.fftResults[index];
    }
    return _$f32f064564ee62f6$export$2c3136da0bf130f9.getFrequencies(this.analyser, this.sampleRate, fftResult, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Resume the internal AudioContext if it was suspended due to the lack of
  * user interaction when the AudioAnalysis was instantiated.
  * @returns {Promise<true>}
  */
  async resumeIfSuspended() {
    if (this.context.state === "suspended")
      await this.context.resume();
    return true;
  }
};
globalThis.AudioAnalysis = $f32f064564ee62f6$export$2c3136da0bf130f93;
var $29a8a70a9466b14f$export$50b76700e2b15e93 = `
class StreamProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.hasStarted = false;
    this.hasInterrupted = false;
    this.outputBuffers = [];
    this.bufferLength = 128;
    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };
    this.writeOffset = 0;
    this.trackSampleOffsets = {};
    this.port.onmessage = (event) => {
      if (event.data) {
        const payload = event.data;
        if (payload.event === 'write') {
          const int16Array = payload.buffer;
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32
          }
          this.writeData(float32Array, payload.trackId);
        } else if (
          payload.event === 'offset' ||
          payload.event === 'interrupt'
        ) {
          const requestId = payload.requestId;
          const trackId = this.write.trackId;
          const offset = this.trackSampleOffsets[trackId] || 0;
          this.port.postMessage({
            event: 'offset',
            requestId,
            trackId,
            offset,
          });
          if (payload.event === 'interrupt') {
            this.hasInterrupted = true;
          }
        } else {
          throw new Error(\`Unhandled event "\${payload.event}"\`);
        }
      }
    };
  }

  writeData(float32Array, trackId = null) {
    let { buffer } = this.write;
    let offset = this.writeOffset;
    for (let i = 0; i < float32Array.length; i++) {
      buffer[offset++] = float32Array[i];
      if (offset >= buffer.length) {
        this.outputBuffers.push(this.write);
        this.write = { buffer: new Float32Array(this.bufferLength), trackId };
        buffer = this.write.buffer;
        offset = 0;
      }
    }
    this.writeOffset = offset;
    return true;
  }

  process(inputs, outputs, parameters) {
    const output = outputs[0];
    const outputChannelData = output[0];
    const outputBuffers = this.outputBuffers;
    if (this.hasInterrupted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else if (outputBuffers.length) {
      this.hasStarted = true;
      const { buffer, trackId } = outputBuffers.shift();
      for (let i = 0; i < outputChannelData.length; i++) {
        outputChannelData[i] = buffer[i] || 0;
      }
      if (trackId) {
        this.trackSampleOffsets[trackId] =
          this.trackSampleOffsets[trackId] || 0;
        this.trackSampleOffsets[trackId] += buffer.length;
      }
      return true;
    } else if (this.hasStarted) {
      this.port.postMessage({ event: 'stop' });
      return false;
    } else {
      return true;
    }
  }
}

registerProcessor('stream_processor', StreamProcessor);
`;
var $29a8a70a9466b14f$var$script3 = new Blob([
  $29a8a70a9466b14f$export$50b76700e2b15e93
], {
  type: "application/javascript"
});
var $29a8a70a9466b14f$var$src3 = URL.createObjectURL($29a8a70a9466b14f$var$script3);
var $29a8a70a9466b14f$export$bfa8c596114d74df3 = $29a8a70a9466b14f$var$src3;
var $d0a969833958d9e7$export$9698d62c78b8f3663 = class {
  /**
  * Creates a new WavStreamPlayer instance
  * @param {{sampleRate?: number}} options
  * @returns {WavStreamPlayer}
  */
  constructor({ sampleRate = 44100 } = {}) {
    this.scriptSrc = (0, $29a8a70a9466b14f$export$bfa8c596114d74df3);
    this.sampleRate = sampleRate;
    this.context = null;
    this.stream = null;
    this.analyser = null;
    this.trackSampleOffsets = {};
    this.interruptedTrackIds = {};
  }
  /**
  * Connects the audio context and enables output to speakers
  * @returns {Promise<true>}
  */
  async connect() {
    this.context = new AudioContext({
      sampleRate: this.sampleRate
    });
    if (this._speakerID)
      this.context.setSinkId(this._speakerID);
    if (this.context.state === "suspended")
      await this.context.resume();
    try {
      await this.context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const analyser = this.context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    this.analyser = analyser;
    return true;
  }
  /**
  * Gets the current frequency domain data from the playing track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.analyser)
      throw new Error("Not connected, please call .connect() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f93).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * @param {string} speaker deviceId
  */
  async updateSpeaker(speaker) {
    const _prevSpeaker = this._speakerID;
    this._speakerID = speaker;
    if (this.context)
      try {
        if (speaker === "default")
          await this.context.setSinkId();
        else
          await this.context.setSinkId(speaker);
      } catch (e4) {
        console.error(`Could not set sinkId to ${speaker}: ${e4}`);
        this._speakerID = _prevSpeaker;
      }
  }
  /**
  * Starts audio streaming
  * @private
  * @returns {Promise<true>}
  */
  _start() {
    const streamNode = new AudioWorkletNode(this.context, "stream_processor");
    streamNode.connect(this.context.destination);
    streamNode.port.onmessage = (e4) => {
      const { event } = e4.data;
      if (event === "stop") {
        streamNode.disconnect();
        this.stream = null;
      } else if (event === "offset") {
        const { requestId, trackId, offset } = e4.data;
        const currentTime = offset / this.sampleRate;
        this.trackSampleOffsets[requestId] = {
          trackId,
          offset,
          currentTime
        };
      }
    };
    this.analyser.disconnect();
    streamNode.connect(this.analyser);
    this.stream = streamNode;
    return true;
  }
  /**
  * Adds 16BitPCM data to the currently playing audio stream
  * You can add chunks beyond the current play point and they will be queued for play
  * @param {ArrayBuffer|Int16Array} arrayBuffer
  * @param {string} [trackId]
  * @returns {Int16Array}
  */
  add16BitPCM(arrayBuffer, trackId = "default") {
    if (typeof trackId !== "string")
      throw new Error(`trackId must be a string`);
    else if (this.interruptedTrackIds[trackId])
      return;
    if (!this.stream)
      this._start();
    let buffer;
    if (arrayBuffer instanceof Int16Array)
      buffer = arrayBuffer;
    else if (arrayBuffer instanceof ArrayBuffer)
      buffer = new Int16Array(arrayBuffer);
    else
      throw new Error(`argument must be Int16Array or ArrayBuffer`);
    this.stream.port.postMessage({
      event: "write",
      buffer,
      trackId
    });
    return buffer;
  }
  /**
  * Gets the offset (sample count) of the currently playing stream
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async getTrackSampleOffset(interrupt = false) {
    if (!this.stream)
      return null;
    const requestId = crypto.randomUUID();
    this.stream.port.postMessage({
      event: interrupt ? "interrupt" : "offset",
      requestId
    });
    let trackSampleOffset;
    while (!trackSampleOffset) {
      trackSampleOffset = this.trackSampleOffsets[requestId];
      await new Promise((r4) => setTimeout(() => r4(), 1));
    }
    const { trackId } = trackSampleOffset;
    if (interrupt && trackId)
      this.interruptedTrackIds[trackId] = true;
    return trackSampleOffset;
  }
  /**
  * Strips the current stream and returns the sample offset of the audio
  * @param {boolean} [interrupt]
  * @returns {{trackId: string|null, offset: number, currentTime: number}}
  */
  async interrupt() {
    return this.getTrackSampleOffset(true);
  }
};
globalThis.WavStreamPlayer = $d0a969833958d9e7$export$9698d62c78b8f3663;
var $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet3 = `
class AudioProcessor extends AudioWorkletProcessor {

  constructor() {
    super();
    this.port.onmessage = this.receive.bind(this);
    this.initialize();
  }

  initialize() {
    this.foundAudio = false;
    this.recording = false;
    this.chunks = [];
  }

  /**
   * Concatenates sampled chunks into channels
   * Format is chunk[Left[], Right[]]
   */
  readChannelData(chunks, channel = -1, maxChannels = 9) {
    let channelLimit;
    if (channel !== -1) {
      if (chunks[0] && chunks[0].length - 1 < channel) {
        throw new Error(
          \`Channel \${channel} out of range: max \${chunks[0].length}\`
        );
      }
      channelLimit = channel + 1;
    } else {
      channel = 0;
      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);
    }
    const channels = [];
    for (let n = channel; n < channelLimit; n++) {
      const length = chunks.reduce((sum, chunk) => {
        return sum + chunk[n].length;
      }, 0);
      const buffers = chunks.map((chunk) => chunk[n]);
      const result = new Float32Array(length);
      let offset = 0;
      for (let i = 0; i < buffers.length; i++) {
        result.set(buffers[i], offset);
        offset += buffers[i].length;
      }
      channels[n] = result;
    }
    return channels;
  }

  /**
   * Combines parallel audio data into correct format,
   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]
   */
  formatAudioData(channels) {
    if (channels.length === 1) {
      // Simple case is only one channel
      const float32Array = channels[0].slice();
      const meanValues = channels[0].slice();
      return { float32Array, meanValues };
    } else {
      const float32Array = new Float32Array(
        channels[0].length * channels.length
      );
      const meanValues = new Float32Array(channels[0].length);
      for (let i = 0; i < channels[0].length; i++) {
        const offset = i * channels.length;
        let meanValue = 0;
        for (let n = 0; n < channels.length; n++) {
          float32Array[offset + n] = channels[n][i];
          meanValue += channels[n][i];
        }
        meanValues[i] = meanValue / channels.length;
      }
      return { float32Array, meanValues };
    }
  }

  /**
   * Converts 32-bit float data to 16-bit integers
   */
  floatTo16BitPCM(float32Array) {
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
    return buffer;
  }

  /**
   * Retrieves the most recent amplitude values from the audio stream
   * @param {number} channel
   */
  getValues(channel = -1) {
    const channels = this.readChannelData(this.chunks, channel);
    const { meanValues } = this.formatAudioData(channels);
    return { meanValues, channels };
  }

  /**
   * Exports chunks as an audio/wav file
   */
  export() {
    const channels = this.readChannelData(this.chunks);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const audioData = this.floatTo16BitPCM(float32Array);
    return {
      meanValues: meanValues,
      audio: {
        bitsPerSample: 16,
        channels: channels,
        data: audioData,
      },
    };
  }

  receive(e) {
    const { event, id } = e.data;
    let receiptData = {};
    switch (event) {
      case 'start':
        this.recording = true;
        break;
      case 'stop':
        this.recording = false;
        break;
      case 'clear':
        this.initialize();
        break;
      case 'export':
        receiptData = this.export();
        break;
      case 'read':
        receiptData = this.getValues();
        break;
      default:
        break;
    }
    // Always send back receipt
    this.port.postMessage({ event: 'receipt', id, data: receiptData });
  }

  sendChunk(chunk) {
    const channels = this.readChannelData([chunk]);
    const { float32Array, meanValues } = this.formatAudioData(channels);
    const rawAudioData = this.floatTo16BitPCM(float32Array);
    const monoAudioData = this.floatTo16BitPCM(meanValues);
    this.port.postMessage({
      event: 'chunk',
      data: {
        mono: monoAudioData,
        raw: rawAudioData,
      },
    });
  }

  process(inputList, outputList, parameters) {
    // Copy input to output (e.g. speakers)
    // Note that this creates choppy sounds with Mac products
    const sourceLimit = Math.min(inputList.length, outputList.length);
    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {
      const input = inputList[inputNum];
      const output = outputList[inputNum];
      const channelCount = Math.min(input.length, output.length);
      for (let channelNum = 0; channelNum < channelCount; channelNum++) {
        input[channelNum].forEach((sample, i) => {
          output[channelNum][i] = sample;
        });
      }
    }
    const inputs = inputList[0];
    // There's latency at the beginning of a stream before recording starts
    // Make sure we actually receive audio data before we start storing chunks
    let sliceIndex = 0;
    if (!this.foundAudio) {
      for (const channel of inputs) {
        sliceIndex = 0; // reset for each channel
        if (this.foundAudio) {
          break;
        }
        if (channel) {
          for (const value of channel) {
            if (value !== 0) {
              // find only one non-zero entry in any channel
              this.foundAudio = true;
              break;
            } else {
              sliceIndex++;
            }
          }
        }
      }
    }
    if (inputs && inputs[0] && this.foundAudio && this.recording) {
      // We need to copy the TypedArray, because the \`process\`
      // internals will reuse the same buffer to hold each input
      const chunk = inputs.map((input) => input.slice(sliceIndex));
      this.chunks.push(chunk);
      this.sendChunk(chunk);
    }
    return true;
  }
}

registerProcessor('audio_processor', AudioProcessor);
`;
var $8e1d1e6ff08f6fb5$var$script3 = new Blob([
  $8e1d1e6ff08f6fb5$var$AudioProcessorWorklet3
], {
  type: "application/javascript"
});
var $8e1d1e6ff08f6fb5$var$src3 = URL.createObjectURL($8e1d1e6ff08f6fb5$var$script3);
var $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c3 = $8e1d1e6ff08f6fb5$var$src3;
var $62bc376044a05513$export$439b217ca659a8773 = class {
  /**
  * Create a new WavRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {WavRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c3);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this._deviceChangeCallback = null;
    this._devices = [];
    this.deviceSelection = null;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer
  * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData
  * @param {number} sampleRate
  * @param {number} fromSampleRate
  * @returns {Promise<DecodedAudioType>}
  */
  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {
    const context = new AudioContext({
      sampleRate
    });
    let arrayBuffer;
    let blob;
    if (audioData instanceof Blob) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from Blob`);
      blob = audioData;
      arrayBuffer = await blob.arrayBuffer();
    } else if (audioData instanceof ArrayBuffer) {
      if (fromSampleRate !== -1)
        throw new Error(`Can not specify "fromSampleRate" when reading from ArrayBuffer`);
      arrayBuffer = audioData;
      blob = new Blob([
        arrayBuffer
      ], {
        type: "audio/wav"
      });
    } else {
      let float32Array;
      let data;
      if (audioData instanceof Int16Array) {
        data = audioData;
        float32Array = new Float32Array(audioData.length);
        for (let i3 = 0; i3 < audioData.length; i3++)
          float32Array[i3] = audioData[i3] / 32768;
      } else if (audioData instanceof Float32Array)
        float32Array = audioData;
      else if (audioData instanceof Array)
        float32Array = new Float32Array(audioData);
      else
        throw new Error(`"audioData" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`);
      if (fromSampleRate === -1)
        throw new Error(`Must specify "fromSampleRate" when reading from Float32Array, In16Array or Array`);
      else if (fromSampleRate < 3e3)
        throw new Error(`Minimum "fromSampleRate" is 3000 (3kHz)`);
      if (!data)
        data = (0, $6d4b7449a1e1544a$export$13afda237b1c98463).floatTo16BitPCM(float32Array);
      const audio = {
        bitsPerSample: 16,
        channels: [
          float32Array
        ],
        data
      };
      const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98463)();
      const result = packer.pack(fromSampleRate, audio);
      blob = result.blob;
      arrayBuffer = await blob.arrayBuffer();
    }
    const audioBuffer = await context.decodeAudioData(arrayBuffer);
    const values = audioBuffer.getChannelData(0);
    const url = URL.createObjectURL(blob);
    return {
      blob,
      url,
      values,
      audioBuffer
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Sets device change callback, remove if callback provided is `null`
  * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback
  * @returns {true}
  */
  listenForDeviceChange(callback) {
    if (callback === null && this._deviceChangeCallback) {
      navigator.mediaDevices.removeEventListener("devicechange", this._deviceChangeCallback);
      this._deviceChangeCallback = null;
    } else if (callback !== null) {
      let lastId = 0;
      let lastDevices = [];
      const serializeDevices = (devices) => devices.map((d3) => d3.deviceId).sort().join(",");
      const cb = async () => {
        let id = ++lastId;
        const devices = await this.listDevices();
        if (id === lastId) {
          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {
            lastDevices = devices;
            callback(devices.slice());
          }
        }
      };
      navigator.mediaDevices.addEventListener("devicechange", cb);
      cb();
      this._deviceChangeCallback = cb;
    }
    return true;
  }
  /**
  * Manually request permission to use the microphone
  * @returns {Promise<true>}
  */
  async requestPermission() {
    const permissionStatus = await navigator.permissions.query({
      name: "microphone"
    });
    if (permissionStatus.state === "denied")
      window.alert("You must grant microphone access to use this feature.");
    else if (permissionStatus.state === "prompt")
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        const tracks = stream.getTracks();
        tracks.forEach((track2) => track2.stop());
      } catch (e4) {
        window.alert("You must grant microphone access to use this feature.");
      }
    return true;
  }
  /**
  * List all eligible devices for recording, will request permission to use microphone
  * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}
  */
  async listDevices() {
    if (!navigator.mediaDevices || !("enumerateDevices" in navigator.mediaDevices))
      throw new Error("Could not request user devices");
    await this.requestPermission();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioDevices = devices.filter((device) => device.kind === "audioinput");
    return audioDevices;
  }
  /**
  * Begins a recording session and requests microphone permissions if not already granted
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {string} [deviceId] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(deviceId) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!navigator.mediaDevices || !("getUserMedia" in navigator.mediaDevices))
      throw new Error("Could not request user media");
    deviceId = deviceId ?? this.deviceSelection?.deviceId;
    try {
      const config = {
        audio: true
      };
      if (deviceId)
        config.audio = {
          deviceId: {
            exact: deviceId
          }
        };
      this.stream = await navigator.mediaDevices.getUserMedia(config);
    } catch (err) {
      throw new Error("Could not start media stream");
    }
    this.listDevices().then((devices) => {
      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;
      console.log("find current device", devices, deviceId, this.stream.getAudioTracks()[0].getSettings());
      this.deviceSelection = devices.find((d3) => d3.deviceId === deviceId);
      console.log("current device", this.deviceSelection);
    });
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98463).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98463).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    console.log("begin completed");
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f93).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98463)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    const tracks = this.stream.getTracks();
    tracks.forEach((track2) => track2.stop());
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98463)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    this.deviceSelection = null;
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = $62bc376044a05513$export$439b217ca659a8773;
var $5fc11d7bc0d20724$export$2934cf2d25c67a483 = class {
  /**
  * Create a new MediaStreamRecorder instance
  * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]
  * @returns {MediaStreamRecorder}
  */
  constructor({ sampleRate = 44100, outputToSpeakers = false, debug = false } = {}) {
    this.scriptSrc = (0, $8e1d1e6ff08f6fb5$export$1f65f50a8cbff43c3);
    this.sampleRate = sampleRate;
    this.outputToSpeakers = outputToSpeakers;
    this.debug = !!debug;
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    this.recording = false;
    this._lastEventId = 0;
    this.eventReceipts = {};
    this.eventTimeout = 5e3;
    this._chunkProcessor = () => {
    };
    this._chunkProcessorSize = void 0;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
  }
  /**
  * Logs data in debug mode
  * @param {...any} arguments
  * @returns {true}
  */
  log() {
    if (this.debug)
      this.log(...arguments);
    return true;
  }
  /**
  * Retrieves the current sampleRate for the recorder
  * @returns {number}
  */
  getSampleRate() {
    return this.sampleRate;
  }
  /**
  * Retrieves the current status of the recording
  * @returns {"ended"|"paused"|"recording"}
  */
  getStatus() {
    if (!this.processor)
      return "ended";
    else if (!this.recording)
      return "paused";
    else
      return "recording";
  }
  /**
  * Sends an event to the AudioWorklet
  * @private
  * @param {string} name
  * @param {{[key: string]: any}} data
  * @param {AudioWorkletNode} [_processor]
  * @returns {Promise<{[key: string]: any}>}
  */
  async _event(name, data = {}, _processor = null) {
    _processor = _processor || this.processor;
    if (!_processor)
      throw new Error("Can not send events without recording first");
    const message = {
      event: name,
      id: this._lastEventId++,
      data
    };
    _processor.port.postMessage(message);
    const t0 = (/* @__PURE__ */ new Date()).valueOf();
    while (!this.eventReceipts[message.id]) {
      if ((/* @__PURE__ */ new Date()).valueOf() - t0 > this.eventTimeout)
        throw new Error(`Timeout waiting for "${name}" event`);
      await new Promise((res) => setTimeout(() => res(true), 1));
    }
    const payload = this.eventReceipts[message.id];
    delete this.eventReceipts[message.id];
    return payload;
  }
  /**
  * Begins a recording session for the given audioTrack
  * Microphone recording indicator will appear on browser tab but status will be "paused"
  * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used
  * @returns {Promise<true>}
  */
  async begin(audioTrack) {
    if (this.processor)
      throw new Error(`Already connected: please call .end() to start a new session`);
    if (!audioTrack || audioTrack.kind !== "audio")
      throw new Error("No audio track provided");
    this.stream = new MediaStream([
      audioTrack
    ]);
    const context = new AudioContext({
      sampleRate: this.sampleRate
    });
    const source = context.createMediaStreamSource(this.stream);
    try {
      await context.audioWorklet.addModule(this.scriptSrc);
    } catch (e4) {
      console.error(e4);
      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);
    }
    const processor = new AudioWorkletNode(context, "audio_processor");
    processor.port.onmessage = (e4) => {
      const { event, id, data } = e4.data;
      if (event === "receipt")
        this.eventReceipts[id] = data;
      else if (event === "chunk") {
        if (this._chunkProcessorSize) {
          const buffer = this._chunkProcessorBuffer;
          this._chunkProcessorBuffer = {
            raw: (0, $6d4b7449a1e1544a$export$13afda237b1c98463).mergeBuffers(buffer.raw, data.raw),
            mono: (0, $6d4b7449a1e1544a$export$13afda237b1c98463).mergeBuffers(buffer.mono, data.mono)
          };
          if (this._chunkProcessorBuffer.mono.byteLength >= this._chunkProcessorSize) {
            this._chunkProcessor(this._chunkProcessorBuffer);
            this._chunkProcessorBuffer = {
              raw: new ArrayBuffer(0),
              mono: new ArrayBuffer(0)
            };
          }
        } else
          this._chunkProcessor(data);
      }
    };
    const node = source.connect(processor);
    const analyser = context.createAnalyser();
    analyser.fftSize = 8192;
    analyser.smoothingTimeConstant = 0.1;
    node.connect(analyser);
    if (this.outputToSpeakers) {
      console.warn("Warning: Output to speakers may affect sound quality,\nespecially due to system audio feedback preventative measures.\nuse only for debugging");
      analyser.connect(context.destination);
    }
    this.source = source;
    this.node = node;
    this.analyser = analyser;
    this.processor = processor;
    return true;
  }
  /**
  * Gets the current frequency domain data from the recording track
  * @param {"frequency"|"music"|"voice"} [analysisType]
  * @param {number} [minDecibels] default -100
  * @param {number} [maxDecibels] default -30
  * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}
  */
  getFrequencies(analysisType = "frequency", minDecibels = -100, maxDecibels = -30) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    return (0, $f32f064564ee62f6$export$2c3136da0bf130f93).getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);
  }
  /**
  * Pauses the recording
  * Keeps microphone stream open but halts storage of audio
  * @returns {Promise<true>}
  */
  async pause() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (!this.recording)
      throw new Error("Already paused: please call .record() first");
    if (this._chunkProcessorBuffer.raw.byteLength)
      this._chunkProcessor(this._chunkProcessorBuffer);
    this.log("Pausing ...");
    await this._event("stop");
    this.recording = false;
    return true;
  }
  /**
  * Start recording stream and storing to memory from the connected audio source
  * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]
  * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio
  * @returns {Promise<true>}
  */
  async record(chunkProcessor = () => {
  }, chunkSize = 8192) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    else if (this.recording)
      throw new Error("Already recording: HELLO please call .pause() first");
    else if (typeof chunkProcessor !== "function")
      throw new Error(`chunkProcessor must be a function`);
    this._chunkProcessor = chunkProcessor;
    this._chunkProcessorSize = chunkSize;
    this._chunkProcessorBuffer = {
      raw: new ArrayBuffer(0),
      mono: new ArrayBuffer(0)
    };
    this.log("Recording ...");
    await this._event("start");
    this.recording = true;
    return true;
  }
  /**
  * Clears the audio buffer, empties stored recording
  * @returns {Promise<true>}
  */
  async clear() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    await this._event("clear");
    return true;
  }
  /**
  * Reads the current audio stream data
  * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}
  */
  async read() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    this.log("Reading ...");
    const result = await this._event("read");
    return result;
  }
  /**
  * Saves the current audio stream to a file
  * @param {boolean} [force] Force saving while still recording
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async save(force = false) {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    if (!force && this.recording)
      throw new Error("Currently recording: please call .pause() first, or call .save(true) to force");
    this.log("Exporting ...");
    const exportData = await this._event("export");
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98463)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Ends the current recording session and saves the result
  * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}
  */
  async end() {
    if (!this.processor)
      throw new Error("Session ended: please call .begin() first");
    const _processor = this.processor;
    this.log("Stopping ...");
    await this._event("stop");
    this.recording = false;
    this.log("Exporting ...");
    const exportData = await this._event("export", {}, _processor);
    this.processor.disconnect();
    this.source.disconnect();
    this.node.disconnect();
    this.analyser.disconnect();
    this.stream = null;
    this.processor = null;
    this.source = null;
    this.node = null;
    const packer = new (0, $6d4b7449a1e1544a$export$13afda237b1c98463)();
    const result = packer.pack(this.sampleRate, exportData.audio);
    return result;
  }
  /**
  * Performs a full cleanup of WavRecorder instance
  * Stops actively listening via microphone and removes existing listeners
  * @returns {Promise<true>}
  */
  async quit() {
    this.listenForDeviceChange(null);
    if (this.processor)
      await this.end();
    return true;
  }
};
globalThis.WavRecorder = WavRecorder;
var $fc49a56cd8739127$var$__extends2 = function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var $fc49a56cd8739127$var$__awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $fc49a56cd8739127$var$__generator2 = function(thisArg, body) {
  var _4 = {
    label: 0,
    sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    },
    trys: [],
    ops: []
  }, f3, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([
        n3,
        v3
      ]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_4 = 0)), _4)
      try {
        if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [
            op[0] & 2,
            t3.value
          ];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _4.label++;
            y3 = op[1];
            op = [
              0
            ];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e4) {
        op = [
          6,
          e4
        ];
        y3 = 0;
      } finally {
        f3 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $fc49a56cd8739127$export$4a0c46dbbe2ddb672 = (
  /** @class */
  function() {
    function MediaManager() {
      this._callbacks = {};
      this._micEnabled = true;
      this._camEnabled = false;
    }
    MediaManager.prototype.setUserAudioCallback = function(userAudioCallback) {
      this._userAudioCallback = userAudioCallback;
    };
    MediaManager.prototype.setRTVIOptions = function(options, override) {
      var _a3, _b, _c3;
      if (override === void 0)
        override = false;
      if (this._options && !override)
        return;
      this._options = options;
      this._callbacks = (_a3 = options.callbacks) !== null && _a3 !== void 0 ? _a3 : {};
      this._micEnabled = (_b = options.enableMic) !== null && _b !== void 0 ? _b : true;
      this._camEnabled = (_c3 = options.enableCam) !== null && _c3 !== void 0 ? _c3 : false;
    };
    return MediaManager;
  }()
);
var $fc49a56cd8739127$export$45c5b9bfba2f63042 = (
  /** @class */
  function(_super) {
    $fc49a56cd8739127$var$__extends2(WavMediaManager, _super);
    function WavMediaManager(recorderChunkSize, recorderSampleRate) {
      if (recorderChunkSize === void 0)
        recorderChunkSize = void 0;
      if (recorderSampleRate === void 0)
        recorderSampleRate = 24e3;
      var _this = _super.call(this) || this;
      _this._initialized = false;
      _this._recorderChunkSize = void 0;
      _this._recorderChunkSize = recorderChunkSize;
      _this._wavRecorder = new (0, $62bc376044a05513$export$439b217ca659a8773)({
        sampleRate: recorderSampleRate
      });
      _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3663)({
        sampleRate: 24e3
      });
      return _this;
    }
    WavMediaManager.prototype.initialize = function() {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._wavRecorder.begin()
              ];
            case 1:
              _a3.sent();
              this._wavRecorder.listenForDeviceChange(null);
              this._wavRecorder.listenForDeviceChange(this._handleAvailableDevicesUpdated.bind(this));
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 2:
              _a3.sent();
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.connect = function() {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        var isAlreadyRecording;
        return $fc49a56cd8739127$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!!this._initialized)
                return [
                  3,
                  2
                ];
              return [
                4,
                this.initialize()
              ];
            case 1:
              _a3.sent();
              _a3.label = 2;
            case 2:
              isAlreadyRecording = this._wavRecorder.getStatus() == "recording";
              if (!(this._micEnabled && !isAlreadyRecording))
                return [
                  3,
                  4
                ];
              return [
                4,
                this._startRecording()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.disconnect = function() {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!this._initialized)
                return [
                  2
                  /*return*/
                ];
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _a3.sent();
              return [
                4,
                this._wavStreamPlayer.interrupt()
              ];
            case 2:
              _a3.sent();
              this._initialized = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.userStartedSpeaking = function() {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        return $fc49a56cd8739127$var$__generator2(this, function(_a3) {
          return [
            2,
            this._wavStreamPlayer.interrupt()
          ];
        });
      });
    };
    WavMediaManager.prototype.bufferBotAudio = function(data, id) {
      return this._wavStreamPlayer.add16BitPCM(data, id);
    };
    WavMediaManager.prototype.getAllMics = function() {
      return this._wavRecorder.listDevices();
    };
    WavMediaManager.prototype.getAllCams = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.getAllSpeakers = function() {
      return Promise.resolve([]);
    };
    WavMediaManager.prototype.updateMic = function(micId) {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        var prevMic, curMic;
        var _a3, _b;
        return $fc49a56cd8739127$var$__generator2(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              prevMic = this._wavRecorder.deviceSelection;
              return [
                4,
                this._wavRecorder.end()
              ];
            case 1:
              _c3.sent();
              return [
                4,
                this._wavRecorder.begin(micId)
              ];
            case 2:
              _c3.sent();
              if (!this._micEnabled)
                return [
                  3,
                  4
                ];
              return [
                4,
                this._startRecording()
              ];
            case 3:
              _c3.sent();
              _c3.label = 4;
            case 4:
              curMic = this._wavRecorder.deviceSelection;
              if (curMic && prevMic && prevMic.label !== curMic.label)
                (_b = (_a3 = this._callbacks).onMicUpdated) === null || _b === void 0 || _b.call(_a3, curMic);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.updateCam = function(camId) {
    };
    WavMediaManager.prototype.updateSpeaker = function(speakerId) {
    };
    Object.defineProperty(WavMediaManager.prototype, "selectedMic", {
      get: function() {
        var _a3;
        return (_a3 = this._wavRecorder.deviceSelection) !== null && _a3 !== void 0 ? _a3 : {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedCam", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.enableMic = function(enable) {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, Promise, function() {
        var _this = this;
        return $fc49a56cd8739127$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._micEnabled = enable;
              if (!this._wavRecorder.stream)
                return [
                  2
                  /*return*/
                ];
              this._wavRecorder.stream.getAudioTracks().forEach(function(track2) {
                var _a4, _b;
                track2.enabled = enable;
                if (!enable)
                  (_b = (_a4 = _this._callbacks).onTrackStopped) === null || _b === void 0 || _b.call(_a4, track2, $fc49a56cd8739127$var$localParticipant2());
              });
              if (!enable)
                return [
                  3,
                  2
                ];
              return [
                4,
                this._startRecording()
              ];
            case 1:
              _a3.sent();
              return [
                3,
                4
              ];
            case 2:
              return [
                4,
                this._wavRecorder.pause()
              ];
            case 3:
              _a3.sent();
              _a3.label = 4;
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype.enableCam = function(enable) {
    };
    Object.defineProperty(WavMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return false;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WavMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._micEnabled;
      },
      enumerable: false,
      configurable: true
    });
    WavMediaManager.prototype.tracks = function() {
      var _a3;
      var tracks = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getTracks()[0];
      return {
        local: tracks ? {
          audio: tracks
        } : {}
      };
    };
    WavMediaManager.prototype._startRecording = function() {
      return $fc49a56cd8739127$var$__awaiter2(this, void 0, void 0, function() {
        var track2;
        var _this = this;
        var _a3, _b, _c3;
        return $fc49a56cd8739127$var$__generator2(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [
                4,
                this._wavRecorder.record(function(data) {
                  _this._userAudioCallback(data.mono);
                }, this._recorderChunkSize)
              ];
            case 1:
              _d.sent();
              track2 = (_a3 = this._wavRecorder.stream) === null || _a3 === void 0 ? void 0 : _a3.getAudioTracks()[0];
              if (track2)
                (_c3 = (_b = this._callbacks).onTrackStarted) === null || _c3 === void 0 || _c3.call(_b, track2, $fc49a56cd8739127$var$localParticipant2());
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WavMediaManager.prototype._handleAvailableDevicesUpdated = function(devices) {
      var _a3, _b, _c3, _d;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, devices.filter(function(d3) {
        return d3.kind === "videoinput";
      }));
      (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, devices.filter(function(d3) {
        return d3.kind === "audioinput";
      }));
      var defaultDevice = devices.find(function(d3) {
        return d3.deviceId === "default";
      });
      var currentDevice = this._wavRecorder.deviceSelection;
      if (currentDevice && (!devices.some(function(d3) {
        return d3.deviceId === currentDevice.deviceId;
      }) || currentDevice.deviceId === "default" && currentDevice.label !== (defaultDevice === null || defaultDevice === void 0 ? void 0 : defaultDevice.label)))
        this.updateMic("");
    };
    return WavMediaManager;
  }($fc49a56cd8739127$export$4a0c46dbbe2ddb672)
);
var $fc49a56cd8739127$var$localParticipant2 = function() {
  return {
    id: "local",
    name: "",
    local: true
  };
};
var $22ece045290c996a$var$__extends2 = function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var $22ece045290c996a$var$__awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $22ece045290c996a$var$__generator2 = function(thisArg, body) {
  var _4 = {
    label: 0,
    sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    },
    trys: [],
    ops: []
  }, f3, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([
        n3,
        v3
      ]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_4 = 0)), _4)
      try {
        if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [
            op[0] & 2,
            t3.value
          ];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _4.label++;
            y3 = op[1];
            op = [
              0
            ];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e4) {
        op = [
          6,
          e4
        ];
        y3 = 0;
      } finally {
        f3 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $22ece045290c996a$export$c95c65abc5f471252 = (
  /** @class */
  function(_super) {
    $22ece045290c996a$var$__extends2(DailyMediaManager, _super);
    function DailyMediaManager(enablePlayer, enableRecording, onTrackStartedCallback, onTrackStoppedCallback, recorderChunkSize, recorderSampleRate) {
      if (enablePlayer === void 0)
        enablePlayer = true;
      if (enableRecording === void 0)
        enableRecording = true;
      if (recorderChunkSize === void 0)
        recorderChunkSize = void 0;
      if (recorderSampleRate === void 0)
        recorderSampleRate = 24e3;
      var _a3;
      var _this = _super.call(this) || this;
      _this._selectedCam = {};
      _this._selectedMic = {};
      _this._selectedSpeaker = {};
      _this._remoteAudioLevelInterval = null;
      _this._recorderChunkSize = void 0;
      _this._initialized = false;
      _this._connected = false;
      _this._currentAudioTrack = null;
      _this._connectResolve = null;
      _this.onTrackStartedCallback = onTrackStartedCallback;
      _this.onTrackStoppedCallback = onTrackStoppedCallback;
      _this._recorderChunkSize = recorderChunkSize;
      _this._daily = (_a3 = (0, ac2).getCallInstance()) !== null && _a3 !== void 0 ? _a3 : (0, ac2).createCallObject();
      if (enableRecording)
        _this._mediaStreamRecorder = new (0, $5fc11d7bc0d20724$export$2934cf2d25c67a483)({
          sampleRate: recorderSampleRate
        });
      if (enablePlayer)
        _this._wavStreamPlayer = new (0, $d0a969833958d9e7$export$9698d62c78b8f3663)({
          sampleRate: 24e3
        });
      _this._daily.on("track-started", _this.handleTrackStarted.bind(_this));
      _this._daily.on("track-stopped", _this.handleTrackStopped.bind(_this));
      _this._daily.on("available-devices-updated", _this._handleAvailableDevicesUpdated.bind(_this));
      _this._daily.on("selected-devices-updated", _this._handleSelectedDevicesUpdated.bind(_this));
      _this._daily.on("local-audio-level", _this._handleLocalAudioLevel.bind(_this));
      return _this;
    }
    DailyMediaManager.prototype.initialize = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var infos, devices, cams, mics, speakers;
        var _this = this;
        var _a3, _b, _c3, _d, _e3, _f, _g, _h, _j, _k, _l, _m;
        return $22ece045290c996a$var$__generator2(this, function(_o3) {
          switch (_o3.label) {
            case 0:
              if (this._initialized) {
                console.warn("DailyMediaManager already initialized");
                return [
                  2
                  /*return*/
                ];
              }
              return [
                4,
                this._daily.startCamera({
                  startVideoOff: !this._camEnabled,
                  startAudioOff: !this._micEnabled
                })
              ];
            case 1:
              infos = _o3.sent();
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 2:
              devices = _o3.sent().devices;
              cams = devices.filter(function(d3) {
                return d3.kind === "videoinput";
              });
              mics = devices.filter(function(d3) {
                return d3.kind === "audioinput";
              });
              speakers = devices.filter(function(d3) {
                return d3.kind === "audiooutput";
              });
              (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, cams);
              (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, mics);
              (_f = (_e3 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e3, speakers);
              this._selectedCam = infos.camera;
              (_h = (_g = this._callbacks).onCamUpdated) === null || _h === void 0 || _h.call(_g, infos.camera);
              this._selectedMic = infos.mic;
              (_k = (_j = this._callbacks).onMicUpdated) === null || _k === void 0 || _k.call(_j, infos.mic);
              this._selectedSpeaker = infos.speaker;
              (_m = (_l = this._callbacks).onSpeakerUpdated) === null || _m === void 0 || _m.call(_l, infos.speaker);
              if (!!this._daily.isLocalAudioLevelObserverRunning())
                return [
                  3,
                  4
                ];
              return [
                4,
                this._daily.startLocalAudioLevelObserver(100)
              ];
            case 3:
              _o3.sent();
              _o3.label = 4;
            case 4:
              if (!this._wavStreamPlayer)
                return [
                  3,
                  6
                ];
              return [
                4,
                this._wavStreamPlayer.connect()
              ];
            case 5:
              _o3.sent();
              if (!this._remoteAudioLevelInterval)
                this._remoteAudioLevelInterval = setInterval(function() {
                  var _a4;
                  var frequencies = _this._wavStreamPlayer.getFrequencies();
                  var aveVal = 0;
                  if ((_a4 = frequencies.values) === null || _a4 === void 0 ? void 0 : _a4.length)
                    aveVal = frequencies.values.reduce(function(a3, c3) {
                      return a3 + c3;
                    }, 0) / frequencies.values.length;
                  _this._handleRemoteAudioLevel(aveVal);
                }, 100);
              _o3.label = 6;
            case 6:
              this._initialized = true;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.connect = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var _this = this;
        return $22ece045290c996a$var$__generator2(this, function(_a3) {
          if (this._connected) {
            console.warn("DailyMediaManager already connected");
            return [
              2
              /*return*/
            ];
          }
          this._connected = true;
          if (!this._initialized)
            return [
              2,
              new Promise(function(resolve) {
                (function() {
                  return $22ece045290c996a$var$__awaiter2(_this, void 0, void 0, function() {
                    return $22ece045290c996a$var$__generator2(this, function(_a4) {
                      switch (_a4.label) {
                        case 0:
                          this._connectResolve = resolve;
                          return [
                            4,
                            this.initialize()
                          ];
                        case 1:
                          _a4.sent();
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                })();
              })
            ];
          if (this._micEnabled)
            this._startRecording();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.disconnect = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var _a3, _b;
        return $22ece045290c996a$var$__generator2(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              if (this._remoteAudioLevelInterval)
                clearInterval(this._remoteAudioLevelInterval);
              this._remoteAudioLevelInterval = null;
              this._daily.leave();
              this._currentAudioTrack = null;
              return [
                4,
                (_a3 = this._mediaStreamRecorder) === null || _a3 === void 0 ? void 0 : _a3.end()
              ];
            case 1:
              _c3.sent();
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.interrupt();
              this._initialized = false;
              this._connected = false;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.userStartedSpeaking = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator2(this, function(_b) {
          return [
            2,
            (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.interrupt()
          ];
        });
      });
    };
    DailyMediaManager.prototype.bufferBotAudio = function(data, id) {
      var _a3;
      return (_a3 = this._wavStreamPlayer) === null || _a3 === void 0 ? void 0 : _a3.add16BitPCM(data, id);
    };
    DailyMediaManager.prototype.getAllMics = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audioinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllCams = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "videoinput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.getAllSpeakers = function() {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var devices;
        return $22ece045290c996a$var$__generator2(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              return [
                4,
                this._daily.enumerateDevices()
              ];
            case 1:
              devices = _a3.sent().devices;
              return [
                2,
                devices.filter(function(device) {
                  return device.kind === "audiooutput";
                })
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.updateMic = function(micId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        audioDeviceId: micId
      }).then(function(deviceInfo) {
        _this._selectedMic = deviceInfo.mic;
      });
    };
    DailyMediaManager.prototype.updateCam = function(camId) {
      var _this = this;
      this._daily.setInputDevicesAsync({
        videoDeviceId: camId
      }).then(function(deviceInfo) {
        _this._selectedCam = deviceInfo.camera;
      });
    };
    DailyMediaManager.prototype.updateSpeaker = function(speakerId) {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var sID, speakers, defaultSpeaker_1, defaultSpeakerCp;
        var _this = this;
        var _a3, _b;
        return $22ece045290c996a$var$__generator2(this, function(_c3) {
          switch (_c3.label) {
            case 0:
              if (speakerId !== "default" && this._selectedSpeaker.deviceId === speakerId)
                return [
                  2
                  /*return*/
                ];
              sID = speakerId;
              if (!(sID === "default"))
                return [
                  3,
                  2
                ];
              return [
                4,
                this.getAllSpeakers()
              ];
            case 1:
              speakers = _c3.sent();
              defaultSpeaker_1 = speakers.find(function(s3) {
                return s3.deviceId === "default";
              });
              if (!defaultSpeaker_1) {
                console.warn("No default speaker found");
                return [
                  2
                  /*return*/
                ];
              }
              speakers.splice(speakers.indexOf(defaultSpeaker_1), 1);
              defaultSpeakerCp = speakers.find(function(s3) {
                return defaultSpeaker_1.label.includes(s3.label);
              });
              sID = (_a3 = defaultSpeakerCp === null || defaultSpeakerCp === void 0 ? void 0 : defaultSpeakerCp.deviceId) !== null && _a3 !== void 0 ? _a3 : speakerId;
              _c3.label = 2;
            case 2:
              (_b = this._wavStreamPlayer) === null || _b === void 0 || _b.updateSpeaker(sID).then(function() {
                var _a4, _b2;
                _this._selectedSpeaker = {
                  deviceId: speakerId
                };
                (_b2 = (_a4 = _this._callbacks).onSpeakerUpdated) === null || _b2 === void 0 || _b2.call(_a4, _this._selectedSpeaker);
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Object.defineProperty(DailyMediaManager.prototype, "selectedMic", {
      get: function() {
        return this._selectedMic;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedCam", {
      get: function() {
        return this._selectedCam;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "selectedSpeaker", {
      get: function() {
        return this._selectedSpeaker;
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.enableMic = function(enable) {
      return $22ece045290c996a$var$__awaiter2(this, void 0, Promise, function() {
        var _a3;
        return $22ece045290c996a$var$__generator2(this, function(_b) {
          this._micEnabled = enable;
          if (!((_a3 = this._daily.participants()) === null || _a3 === void 0 ? void 0 : _a3.local))
            return [
              2
              /*return*/
            ];
          this._daily.setLocalAudio(enable);
          if (this._mediaStreamRecorder) {
            if (enable) {
              if (this._mediaStreamRecorder.getStatus() === "paused")
                this._startRecording();
            } else if (this._mediaStreamRecorder.getStatus() === "recording")
              this._mediaStreamRecorder.pause();
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    DailyMediaManager.prototype.enableCam = function(enable) {
      this._camEnabled = enable;
      this._daily.setLocalVideo(enable);
    };
    Object.defineProperty(DailyMediaManager.prototype, "isCamEnabled", {
      get: function() {
        return this._daily.localVideo();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DailyMediaManager.prototype, "isMicEnabled", {
      get: function() {
        return this._daily.localAudio();
      },
      enumerable: false,
      configurable: true
    });
    DailyMediaManager.prototype.tracks = function() {
      var _a3, _b, _c3, _d, _e3, _f;
      var participants = this._daily.participants();
      return {
        local: {
          audio: (_c3 = (_b = (_a3 = participants === null || participants === void 0 ? void 0 : participants.local) === null || _a3 === void 0 ? void 0 : _a3.tracks) === null || _b === void 0 ? void 0 : _b.audio) === null || _c3 === void 0 ? void 0 : _c3.persistentTrack,
          video: (_f = (_e3 = (_d = participants === null || participants === void 0 ? void 0 : participants.local) === null || _d === void 0 ? void 0 : _d.tracks) === null || _e3 === void 0 ? void 0 : _e3.video) === null || _f === void 0 ? void 0 : _f.persistentTrack
        }
      };
    };
    DailyMediaManager.prototype._startRecording = function() {
      var _this = this;
      if (!this._connected || !this._mediaStreamRecorder)
        return;
      try {
        this._mediaStreamRecorder.record(function(data) {
          _this._userAudioCallback(data.mono);
        }, this._recorderChunkSize);
      } catch (e4) {
        var err = e4;
        if (!err.message.includes("Already recording"))
          console.error("Error starting recording", e4);
      }
    };
    DailyMediaManager.prototype._handleAvailableDevicesUpdated = function(event) {
      var _a3, _b, _c3, _d, _e3, _f;
      (_b = (_a3 = this._callbacks).onAvailableCamsUpdated) === null || _b === void 0 || _b.call(_a3, event.availableDevices.filter(function(d3) {
        return d3.kind === "videoinput";
      }));
      (_d = (_c3 = this._callbacks).onAvailableMicsUpdated) === null || _d === void 0 || _d.call(_c3, event.availableDevices.filter(function(d3) {
        return d3.kind === "audioinput";
      }));
      (_f = (_e3 = this._callbacks).onAvailableSpeakersUpdated) === null || _f === void 0 || _f.call(_e3, event.availableDevices.filter(function(d3) {
        return d3.kind === "audiooutput";
      }));
      if (this._selectedSpeaker.deviceId === "default")
        this.updateSpeaker("default");
    };
    DailyMediaManager.prototype._handleSelectedDevicesUpdated = function(event) {
      var _a3, _b, _c3, _d, _e3, _f;
      if (((_a3 = this._selectedCam) === null || _a3 === void 0 ? void 0 : _a3.deviceId) !== event.devices.camera) {
        this._selectedCam = event.devices.camera;
        (_c3 = (_b = this._callbacks).onCamUpdated) === null || _c3 === void 0 || _c3.call(_b, event.devices.camera);
      }
      if (((_d = this._selectedMic) === null || _d === void 0 ? void 0 : _d.deviceId) !== event.devices.mic) {
        this._selectedMic = event.devices.mic;
        (_f = (_e3 = this._callbacks).onMicUpdated) === null || _f === void 0 || _f.call(_e3, event.devices.mic);
      }
    };
    DailyMediaManager.prototype._handleLocalAudioLevel = function(ev) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onLocalAudioLevel) === null || _b === void 0 || _b.call(_a3, ev.audioLevel);
    };
    DailyMediaManager.prototype._handleRemoteAudioLevel = function(audioLevel) {
      var _a3, _b;
      (_b = (_a3 = this._callbacks).onRemoteAudioLevel) === null || _b === void 0 || _b.call(_a3, audioLevel, $22ece045290c996a$var$botParticipant2());
    };
    DailyMediaManager.prototype.handleTrackStarted = function(event) {
      return $22ece045290c996a$var$__awaiter2(this, void 0, void 0, function() {
        var status, _a3;
        var _b, _c3, _d, _e3;
        return $22ece045290c996a$var$__generator2(this, function(_f) {
          switch (_f.label) {
            case 0:
              if (!((_b = event.participant) === null || _b === void 0 ? void 0 : _b.local))
                return [
                  2
                  /*return*/
                ];
              if (!(event.track.kind === "audio"))
                return [
                  3,
                  10
                ];
              if (!this._mediaStreamRecorder)
                return [
                  3,
                  9
                ];
              status = this._mediaStreamRecorder.getStatus();
              _a3 = status;
              switch (_a3) {
                case "ended":
                  return [
                    3,
                    1
                  ];
                case "paused":
                  return [
                    3,
                    3
                  ];
                case "recording":
                  return [
                    3,
                    4
                  ];
              }
              return [
                3,
                4
              ];
            case 1:
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 2:
              _f.sent();
              if (this._connected) {
                this._startRecording();
                if (this._connectResolve) {
                  this._connectResolve();
                  this._connectResolve = null;
                }
              }
              return [
                3,
                9
              ];
            case 3:
              this._startRecording();
              return [
                3,
                9
              ];
            case 4:
              if (!(this._currentAudioTrack !== event.track))
                return [
                  3,
                  7
                ];
              return [
                4,
                this._mediaStreamRecorder.end()
              ];
            case 5:
              _f.sent();
              return [
                4,
                this._mediaStreamRecorder.begin(event.track)
              ];
            case 6:
              _f.sent();
              this._startRecording();
              return [
                3,
                8
              ];
            case 7:
              console.warn("track-started event received for current track and already recording");
              _f.label = 8;
            case 8:
              return [
                3,
                9
              ];
            case 9:
              this._currentAudioTrack = event.track;
              _f.label = 10;
            case 10:
              (_d = (_c3 = this._callbacks).onTrackStarted) === null || _d === void 0 || _d.call(_c3, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant2(event.participant) : void 0);
              (_e3 = this.onTrackStartedCallback) === null || _e3 === void 0 || _e3.call(this, event);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    DailyMediaManager.prototype.handleTrackStopped = function(event) {
      var _a3, _b, _c3, _d;
      if (!((_a3 = event.participant) === null || _a3 === void 0 ? void 0 : _a3.local))
        return;
      if (event.track.kind === "audio") {
        if (this._mediaStreamRecorder && this._mediaStreamRecorder.getStatus() === "recording")
          this._mediaStreamRecorder.pause();
      }
      (_c3 = (_b = this._callbacks).onTrackStopped) === null || _c3 === void 0 || _c3.call(_b, event.track, event.participant ? $22ece045290c996a$var$dailyParticipantToParticipant2(event.participant) : void 0);
      (_d = this.onTrackStoppedCallback) === null || _d === void 0 || _d.call(this, event);
    };
    return DailyMediaManager;
  }((0, $fc49a56cd8739127$export$4a0c46dbbe2ddb672))
);
var $22ece045290c996a$var$dailyParticipantToParticipant2 = function(p3) {
  return {
    id: p3.user_id,
    local: p3.local,
    name: p3.user_name
  };
};
var $22ece045290c996a$var$botParticipant2 = function() {
  return {
    id: "bot",
    local: false,
    name: "Bot"
  };
};
var $032380dbcf3f4e13$var$__extends = function() {
  var extendStatics = function(d3, b3) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d4, b4) {
      d4.__proto__ = b4;
    } || function(d4, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d4[p3] = b4[p3];
    };
    return extendStatics(d3, b3);
  };
  return function(d3, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d3, b3);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var $032380dbcf3f4e13$var$__awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var $032380dbcf3f4e13$var$__generator = function(thisArg, body) {
  var _4 = {
    label: 0,
    sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    },
    trys: [],
    ops: []
  }, f3, y3, t3, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n3) {
    return function(v3) {
      return step([
        n3,
        v3
      ]);
    };
  }
  function step(op) {
    if (f3)
      throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_4 = 0)), _4)
      try {
        if (f3 = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [
            op[0] & 2,
            t3.value
          ];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _4.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _4.label++;
            y3 = op[1];
            op = [
              0
            ];
            continue;
          case 7:
            op = _4.ops.pop();
            _4.trys.pop();
            continue;
          default:
            if (!(t3 = _4.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _4 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _4.label = op[1];
              break;
            }
            if (op[0] === 6 && _4.label < t3[1]) {
              _4.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _4.label < t3[2]) {
              _4.label = t3[2];
              _4.ops.push(op);
              break;
            }
            if (t3[2])
              _4.ops.pop();
            _4.trys.pop();
            continue;
        }
        op = body.call(thisArg, _4);
      } catch (e4) {
        op = [
          6,
          e4
        ];
        y3 = 0;
      } finally {
        f3 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var $032380dbcf3f4e13$var$__spreadArray = function(to3, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i3 = 0, l3 = from.length, ar3; i3 < l3; i3++)
      if (ar3 || !(i3 in from)) {
        if (!ar3)
          ar3 = Array.prototype.slice.call(from, 0, i3);
        ar3[i3] = from[i3];
      }
  }
  return to3.concat(ar3 || Array.prototype.slice.call(from));
};
var $032380dbcf3f4e13$var$readyStates = [
  "CONNECTING",
  "OPEN",
  "CLOSING",
  "CLOSED"
];
var $032380dbcf3f4e13$var$KEEP_ALIVE_INTERVAL = 5e3;
var $032380dbcf3f4e13$var$KEEP_ALIVE_TIMEOUT = 15e3;
var $032380dbcf3f4e13$var$WEBSOCKET_CONNECTION_TIMEOUT = 15e4;
var $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS = 2;
var $032380dbcf3f4e13$var$MAX_RECONNECT_ATTEMPTS = 10;
var $032380dbcf3f4e13$var$DEFAULT_RECONNECT_INTERVAL = 1e3;
var $032380dbcf3f4e13$var$MAX_RECONNECT_INTERVAL = 3e4;
var $032380dbcf3f4e13$var$DEFAULT_RECONNECT_DECAY = 1.5;
var $032380dbcf3f4e13$var$WEBSOCKET_TIMEOUT_CODE = 4100;
var $032380dbcf3f4e13$var$SIG_CONNECTION_CANCELED = "SIG_CONNECTION_CANCELED";
var $032380dbcf3f4e13$var$WEBSOCKET_ERROR = "WEBSOCKET_ERROR";
var $032380dbcf3f4e13$var$LOG_LEVEL;
(function(LOG_LEVEL) {
  LOG_LEVEL[LOG_LEVEL["DEBUG"] = 0] = "DEBUG";
  LOG_LEVEL[LOG_LEVEL["ERROR"] = 1] = "ERROR";
  LOG_LEVEL[LOG_LEVEL["INFO"] = 2] = "INFO";
  LOG_LEVEL[LOG_LEVEL["WARN"] = 3] = "WARN";
})($032380dbcf3f4e13$var$LOG_LEVEL || ($032380dbcf3f4e13$var$LOG_LEVEL = {}));
var $032380dbcf3f4e13$var$rWebSocket = (
  /** @class */
  function() {
    function rWebSocket(url, protocols) {
      this._closedManually = false;
      this._errored = false;
      this._rejected = false;
      this._timed_out = false;
      this._initialConnectionOk = false;
      this._ws = new WebSocket(url, protocols);
    }
    rWebSocket.prototype.addEventListener = function(type, listener) {
      this._ws.addEventListener(type, listener);
    };
    rWebSocket.prototype.close = function(code, reason) {
      this._ws.close(code, reason);
    };
    rWebSocket.prototype.send = function(data) {
      this._ws.send(data);
    };
    Object.defineProperty(rWebSocket.prototype, "url", {
      // Add getters for WebSocket properties
      get: function() {
        return this._ws.url;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(rWebSocket.prototype, "readyState", {
      get: function() {
        return this._ws.readyState;
      },
      enumerable: false,
      configurable: true
    });
    return rWebSocket;
  }()
);
var $032380dbcf3f4e13$export$4f3d0ffd941ebefb = (
  /** @class */
  function(_super) {
    $032380dbcf3f4e13$var$__extends(ReconnectingWebSocket, _super);
    function ReconnectingWebSocket(address, protocols, options) {
      if (options === void 0)
        options = {};
      var _a3;
      var _this = _super.call(this) || this;
      if (!address)
        throw new Error("Need a valid WebSocket URL");
      _this._ws = null;
      _this._url = address;
      _this._protocols = protocols;
      _this._parseBlobToJson = (_a3 = options === null || options === void 0 ? void 0 : options.parseBlobToJson) !== null && _a3 !== void 0 ? _a3 : true;
      _this.init();
      return _this;
    }
    ReconnectingWebSocket.prototype.init = function() {
      this._keepAliveTimeout = $032380dbcf3f4e13$var$KEEP_ALIVE_TIMEOUT;
      this._keepAliveInterval = $032380dbcf3f4e13$var$KEEP_ALIVE_INTERVAL;
      this._disconnected = false;
      this._keepIntervalID = null;
      this._shouldRetryFn = null;
      this._connectionTimeout = $032380dbcf3f4e13$var$WEBSOCKET_CONNECTION_TIMEOUT;
      this._reconnectAttempts = 0;
      this._allowedReconnectAttempts = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS;
      this._reconnectInterval = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_INTERVAL;
      this._maxReconnectInterval = $032380dbcf3f4e13$var$MAX_RECONNECT_INTERVAL;
      this._reconnectDecay = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_DECAY;
    };
    ReconnectingWebSocket.prototype.connect = function() {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          return [
            2,
            new Promise(function(resolve, reject) {
              _this._disconnected = false;
              _this.clearReconnectTimeout();
              var ws3 = new $032380dbcf3f4e13$var$rWebSocket(_this._url, _this._protocols);
              _this.setConnectionTimeout();
              ws3.addEventListener("close", function(evt) {
                var closeEvent = evt;
                var code = ws3._timed_out ? $032380dbcf3f4e13$var$WEBSOCKET_TIMEOUT_CODE : closeEvent.code;
                var reason = ws3._timed_out ? "websocket connection timed out" : closeEvent.reason;
                ws3._timed_out = false;
                if (!ws3._closedManually && ws3._initialConnectionOk) {
                  console.warn("signaling socket closed unexpectedly: ".concat(code).concat(reason ? " " + reason : ""));
                  _this._closeSocket();
                  _this.emit("close", code, reason);
                } else
                  _this.log("signaling socket closed");
                if (!ws3._closedManually && (ws3._errored || ws3._timed_out)) {
                  console.warn("signaling socket closed on error: ".concat(code).concat(reason ? " " + reason : ""));
                  if (!ws3._rejected) {
                    ws3._rejected = true;
                    var err = new Error("WebSocket connection error (".concat(code, "): ").concat(reason));
                    err.name = $032380dbcf3f4e13$var$WEBSOCKET_ERROR;
                    reject(err);
                  }
                }
              });
              ws3.addEventListener("open", function(evt) {
                _this.log("wss connection opened to", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG, _this._url);
                _this.clearConnectionTimeout();
                if (ws3._rejected || ws3._timed_out)
                  return;
                if (ws3._closedManually || _this._ws && _this._ws !== ws3) {
                  ws3._rejected = true;
                  ws3.close();
                  var err = Error("wss connection interrupted by disconnect or newer connection");
                  err.name = $032380dbcf3f4e13$var$SIG_CONNECTION_CANCELED;
                  reject(err);
                  return;
                }
                ws3._initialConnectionOk = _this._url;
                _this._lastMsgRecvTime = Date.now();
                if (_this._keepAliveInterval)
                  _this._keepIntervalID = setInterval(function() {
                    return _this.checkSocketHealthAndSendKeepAlive();
                  }, _this._keepAliveInterval);
                _this._ws = ws3;
                _this.emit("open");
                resolve(ws3);
              });
              ws3.addEventListener("error", function(evt) {
                if (!ws3._closedManually) {
                  var wsTarget = evt.currentTarget;
                  _this.log("websocket error event: ".concat(wsTarget === null || wsTarget === void 0 ? void 0 : wsTarget.url));
                }
                ws3._errored = true;
              });
              ws3.addEventListener("message", function(msg) {
                _this._handleMessage(msg);
              });
            })
          ];
        });
      });
    };
    ReconnectingWebSocket.prototype.setConnectionTimeout = function() {
      var _this = this;
      this._connectionTimeoutID = setTimeout(function() {
        return $032380dbcf3f4e13$var$__awaiter(_this, void 0, void 0, function() {
          return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                this.log("Connection reconnect attempt timed out.");
                this.emit("connection-timeout");
                this.clearConnectionTimeout();
                return [
                  4,
                  this._closeSocket()
                ];
              case 1:
                _a3.sent();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, this._connectionTimeout);
    };
    ReconnectingWebSocket.prototype.clearConnectionTimeout = function() {
      clearTimeout(this._connectionTimeoutID);
      this._connectionTimeoutID = void 0;
    };
    ReconnectingWebSocket.prototype.clearReconnectTimeout = function() {
      clearTimeout(this._reconnectTimeoutID);
      this._reconnectTimeoutID = void 0;
    };
    ReconnectingWebSocket.prototype.clearKeepAliveInterval = function() {
      if (this._keepIntervalID) {
        clearInterval(this._keepIntervalID);
        this._keepIntervalID = null;
      }
    };
    ReconnectingWebSocket.prototype.checkSocketHealthAndSendKeepAlive = function() {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!(this._ws && this._ws.readyState === WebSocket.OPEN))
                return [
                  2
                  /*return*/
                ];
              if (!this._keepAliveTimeout || !this._keepAliveInterval)
                return [
                  2
                  /*return*/
                ];
              if (!(Date.now() - this._lastMsgRecvTime > this._keepAliveTimeout))
                return [
                  3,
                  2
                ];
              this.log("Connection is stale, need to reconnect", $032380dbcf3f4e13$var$LOG_LEVEL.WARN);
              return [
                4,
                this._closeSocket()
              ];
            case 1:
              _a3.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              if (Date.now() - this._lastMsgSendTime < this._keepAliveInterval)
                return [
                  2
                  /*return*/
                ];
              this.log("Emitting keep-alive", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG);
              this.emit("keep-alive");
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    ReconnectingWebSocket.prototype._closeSocket = function() {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        var shouldRetry, error_1;
        var _a3;
        return $032380dbcf3f4e13$var$__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              this.log("Closing");
              _b.label = 1;
            case 1:
              _b.trys.push([
                1,
                4,
                ,
                5
              ]);
              this.clearKeepAliveInterval();
              this._lastMsgRecvTime = 0;
              if (this._ws) {
                this._ws._closedManually = true;
                this._ws.close();
              }
              shouldRetry = ((_a3 = this._ws) === null || _a3 === void 0 ? void 0 : _a3._initialConnectionOk) && this._shouldRetryFn && this._shouldRetryFn();
              this._ws = null;
              if (!shouldRetry)
                return [
                  3,
                  3
                ];
              this.log("Emitting reconnect", $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG);
              this.emit("reconnecting");
              return [
                4,
                this.retryFailedConnection()
              ];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              return [
                3,
                5
              ];
            case 4:
              error_1 = _b.sent();
              this.log("Error while closing and retrying: ".concat(error_1), $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);
              return [
                3,
                5
              ];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    ReconnectingWebSocket.prototype.retryFailedConnection = function() {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        var timeout;
        var _this = this;
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          if (this._reconnectAttempts < this._allowedReconnectAttempts) {
            if (this._reconnectTimeoutID) {
              this.log("Retry already scheduled");
              return [
                2
                /*return*/
              ];
            }
            this.log("Retrying failed connection");
            timeout = // The timeout logic is taken from
            // https://github.com/joewalnes/reconnecting-websocket
            this._reconnectInterval * Math.pow(this._reconnectDecay, this._reconnectAttempts);
            timeout = timeout > this._maxReconnectInterval ? this._maxReconnectInterval : timeout;
            this.log("Reconnecting in ".concat(timeout / 1e3, " seconds"));
            this._reconnectAttempts += 1;
            this._reconnectTimeoutID = setTimeout(function() {
              return _this.connect();
            }, timeout);
          } else {
            this.log("Maximum connection retry attempts exceeded", $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);
            this.emit("reconnect-failed");
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    ReconnectingWebSocket.prototype.log = function(msg, log_level) {
      if (log_level === void 0)
        log_level = $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG;
      var args = [];
      for (var _i3 = 2; _i3 < arguments.length; _i3++)
        args[_i3 - 2] = arguments[_i3];
      switch (log_level) {
        case $032380dbcf3f4e13$var$LOG_LEVEL.DEBUG:
          console.debug.apply(console, $032380dbcf3f4e13$var$__spreadArray([
            "websocket: ".concat(msg)
          ], args, false));
          break;
        case $032380dbcf3f4e13$var$LOG_LEVEL.ERROR:
          console.error.apply(console, $032380dbcf3f4e13$var$__spreadArray([
            "websocket: ".concat(msg)
          ], args, false));
          break;
        case $032380dbcf3f4e13$var$LOG_LEVEL.WARN:
          console.warn.apply(console, $032380dbcf3f4e13$var$__spreadArray([
            "websocket: ".concat(msg)
          ], args, false));
          break;
        case $032380dbcf3f4e13$var$LOG_LEVEL.INFO:
        default:
          console.log.apply(console, $032380dbcf3f4e13$var$__spreadArray([
            "websocket: ".concat(msg)
          ], args, false));
          break;
      }
    };
    ReconnectingWebSocket.prototype.send = function(data) {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          try {
            if (this._ws && this._ws.readyState === WebSocket.OPEN) {
              this._lastMsgSendTime = Date.now();
              this._ws.send(data);
            } else
              this.log("Failed to send data, web socket not open.", $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);
          } catch (error) {
            this.log("Failed to send data. ".concat(error), $032380dbcf3f4e13$var$LOG_LEVEL.ERROR);
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    ReconnectingWebSocket.prototype.close = function() {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          try {
            this.log("Closing websocket");
            this._disconnected = true;
            this.clearReconnectTimeout();
            this._closeSocket();
          } catch (error) {
            this.log("Failed to close websocket. ".concat(error));
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    Object.defineProperty(ReconnectingWebSocket.prototype, "readyState", {
      get: function() {
        var _a3, _b;
        return (_b = (_a3 = this._ws) === null || _a3 === void 0 ? void 0 : _a3.readyState) !== null && _b !== void 0 ? _b : WebSocket.CLOSED;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "url", {
      get: function() {
        return this._url;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "keepAliveTimeout", {
      get: function() {
        return this._keepAliveTimeout;
      },
      set: function(keepAliveTimeout) {
        if (typeof keepAliveTimeout === "number") {
          this.log("Setting ACK freshness timeout to ".concat(keepAliveTimeout));
          this._keepAliveTimeout = keepAliveTimeout;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "keepAliveInterval", {
      get: function() {
        return this._keepAliveInterval;
      },
      set: function(keepAliveInterval) {
        if (typeof keepAliveInterval === "number") {
          this.log("Setting keep-alive interval to ".concat(keepAliveInterval));
          this._keepAliveInterval = keepAliveInterval;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "shouldRetryFn", {
      set: function(cb) {
        if (typeof cb === "function")
          this._shouldRetryFn = cb;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "connectionTimeout", {
      get: function() {
        return this._connectionTimeout;
      },
      set: function(timeout) {
        if (typeof timeout === "number")
          this._connectionTimeout = timeout;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "maxReconnectAttempts", {
      get: function() {
        return this._allowedReconnectAttempts;
      },
      set: function(attempts) {
        if (attempts > 0 && attempts < $032380dbcf3f4e13$var$MAX_RECONNECT_ATTEMPTS) {
          this.log("Setting maximum connection retry attempts to ".concat(attempts));
          this._allowedReconnectAttempts = attempts;
        } else
          this._allowedReconnectAttempts = $032380dbcf3f4e13$var$DEFAULT_RECONNECT_ATTEMPTS;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReconnectingWebSocket.prototype, "reconnectInterval", {
      get: function() {
        return this._reconnectInterval;
      },
      set: function(interval) {
        if (typeof interval === "number")
          this._reconnectInterval = interval < this._maxReconnectInterval ? interval : this._maxReconnectInterval;
      },
      enumerable: false,
      configurable: true
    });
    ReconnectingWebSocket.prototype._handleMessage = function(event) {
      return $032380dbcf3f4e13$var$__awaiter(this, void 0, void 0, function() {
        var data, _parsePromise, msg;
        var _this = this;
        return $032380dbcf3f4e13$var$__generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._lastMsgRecvTime = Date.now();
              data = event.data;
              _parsePromise = new Promise(function(resolve, reject) {
                if (typeof data === "string")
                  resolve(data);
                else if (data instanceof ArrayBuffer) {
                  var arrayBuffer = data;
                  resolve(new Uint8Array(arrayBuffer));
                } else if (data instanceof Blob) {
                  if (!_this._parseBlobToJson) {
                    resolve(data);
                    return;
                  }
                  var blob = data;
                  var reader_1 = new FileReader();
                  reader_1.onload = function() {
                    var text = reader_1.result;
                    try {
                      var json = JSON.parse(text);
                      resolve(json);
                    } catch (e4) {
                      console.error("Failed to parse JSON from Blob:", e4);
                    }
                  };
                  reader_1.readAsText(blob);
                }
              });
              return [
                4,
                _parsePromise
              ];
            case 1:
              msg = _a3.sent();
              this.emit("message", msg);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return ReconnectingWebSocket;
  }((0, import_events2.EventEmitter))
);
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "protocol",
  "readyState",
  "url",
  "keepAliveTimeout",
  "keepAliveInterval",
  "shouldRetryFn",
  "connectionTimeout",
  "maxReconnectAttempts",
  "reconnectInterval"
].forEach(function(property) {
  Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb.prototype, property, {
    enumerable: true
  });
});
[
  "CONNECTING",
  "OPEN",
  "CLOSING",
  "CLOSED"
].forEach(function(property) {
  Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb.prototype, property, {
    enumerable: true,
    value: $032380dbcf3f4e13$var$readyStates.indexOf(property)
  });
});
[
  "CONNECTING",
  "OPEN",
  "CLOSING",
  "CLOSED"
].forEach(function(property) {
  Object.defineProperty($032380dbcf3f4e13$export$4f3d0ffd941ebefb, property, {
    enumerable: true,
    value: $032380dbcf3f4e13$var$readyStates.indexOf(property)
  });
});
var $763b38ac211abed6$export$7fb989e764be5cac = class extends (0, $4086f06442fcb7d7$export$86495b081fef8e52) {
  constructor(service_options, manager) {
    super();
    this._botIsSpeaking = false;
    this._service_options = service_options;
    this._mediaManager = manager;
    this._mediaManager.setUserAudioCallback(this.handleUserAudioStream.bind(this));
  }
  // subclasses should implement this method to initialize the LLM
  // client and call super() on this method
  initialize(options, messageHandler) {
    this._options = options;
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    this._mediaManager.setRTVIOptions(options);
    this.initializeLLM();
    this.attachDeviceListeners();
    this.attachLLMListeners();
    this.state = "disconnected";
  }
  async initDevices() {
    this.state = "initializing";
    await this._mediaManager.initialize();
    this.state = "initialized";
  }
  async connect(authBundle, abortController) {
    this.state = "connecting";
    await this.connectLLM();
    this._mediaManager.connect();
    this.state = "connected";
    this._callbacks.onConnected?.();
  }
  async disconnect() {
    this.state = "disconnecting";
    await this._mediaManager.disconnect();
    await this.disconnectLLM();
    this.state = "disconnected";
    this._callbacks.onDisconnected?.();
  }
  getAllMics() {
    return this._mediaManager.getAllMics();
  }
  getAllCams() {
    return this._mediaManager.getAllCams();
  }
  getAllSpeakers() {
    return this._mediaManager.getAllSpeakers();
  }
  async updateMic(micId) {
    return this._mediaManager.updateMic(micId);
  }
  updateCam(camId) {
    return this._mediaManager.updateCam(camId);
  }
  updateSpeaker(speakerId) {
    return this._mediaManager.updateSpeaker(speakerId);
  }
  get selectedMic() {
    return this._mediaManager.selectedMic;
  }
  get selectedCam() {
    return this._mediaManager.selectedCam;
  }
  get selectedSpeaker() {
    return this._mediaManager.selectedSpeaker;
  }
  enableMic(enable) {
    this._mediaManager.enableMic(enable);
  }
  enableCam(enable) {
    this._mediaManager.enableCam(enable);
  }
  get isCamEnabled() {
    return this._mediaManager.isCamEnabled;
  }
  get isMicEnabled() {
    return this._mediaManager.isMicEnabled;
  }
  get state() {
    return this._state;
  }
  set state(state) {
    if (this._state === state)
      return;
    this._state = state;
    this._callbacks.onTransportStateChanged?.(state);
  }
  get expiry() {
    return this._expiry;
  }
  tracks() {
    return this._mediaManager.tracks();
  }
  // Realtime event handlers
  async userStartedSpeaking() {
    const trackSampleOffset = await this._mediaManager.userStartedSpeaking();
    this._callbacks.onUserStartedSpeaking?.();
    return trackSampleOffset;
  }
  userStoppedSpeaking() {
    this._callbacks.onUserStoppedSpeaking?.();
  }
  userTranscript(transcript) {
    this._callbacks.onUserTranscript?.(transcript);
  }
  botStartedSpeaking() {
    if (!this._botIsSpeaking) {
      this._botIsSpeaking = true;
      this._callbacks.onBotStartedSpeaking?.();
    }
  }
  botStoppedSpeaking() {
    if (this._botIsSpeaking) {
      this._botIsSpeaking = false;
      this._callbacks.onBotStoppedSpeaking?.();
    }
  }
  botTtsText(data) {
    this._callbacks.onBotTtsText?.(data);
  }
  bufferBotAudio(audio, id) {
    this._mediaManager.bufferBotAudio(audio, id);
  }
  connectionError(errorMsg) {
    console.error(errorMsg);
    this.state = "error";
    this.disconnect();
  }
  attachDeviceListeners() {
  }
};
var $d4cf498bb51af8a5$var$HOST = `generativelanguage.googleapis.com`;
var $d4cf498bb51af8a5$var$BIDI_PATH = `google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent`;
var $d4cf498bb51af8a5$var$MODEL = "models/gemini-2.0-flash-exp";
var $d4cf498bb51af8a5$export$bef67da0c82ecefe = class extends (0, $763b38ac211abed6$export$7fb989e764be5cac) {
  constructor(service_options, manager) {
    if (!manager)
      manager = new (0, $22ece045290c996a$export$c95c65abc5f471252)();
    super(service_options, manager);
    this._ws = null;
    this._botResponseID = 0;
  }
  initializeLLM() {
    const service_options = this._service_options;
    const apiKey = service_options.api_key;
    if (!apiKey) {
      console.error("!!! No API key provided in llm_service_options");
      return;
    }
    const base_url = `wss://${$d4cf498bb51af8a5$var$HOST}/ws/${$d4cf498bb51af8a5$var$BIDI_PATH}`;
    this._ws = new (0, $032380dbcf3f4e13$export$4f3d0ffd941ebefb)(`${base_url}?key=${apiKey}`);
    this._ws.keepAliveInterval = 0;
  }
  // This is called from super.initialize()
  attachLLMListeners() {
    if (!this._ws) {
      console.error("attachLLMListeners called before the websocket is initialized. Be sure to call initializeLLM() first.");
      return;
    }
    this._ws.on("open", () => {
    });
    this._ws.on("message", async (msg) => {
      const content = msg.serverContent;
      if (!content) {
        if ("setupComplete" in msg) {
          this.state = "ready";
          if (this._botIsReadyResolve) {
            this._botIsReadyResolve();
            this._botIsReadyResolve = null;
          }
        } else
          console.log("received unknown message", msg);
        return;
      }
      if (content.modelTurn) {
        let result = null;
        content.modelTurn.parts?.forEach((part) => {
          if (part.inlineData?.data) {
            if (result)
              $d4cf498bb51af8a5$var$mergeBuffers(result, $d4cf498bb51af8a5$var$base64ToArrayBuffer(part.inlineData.data));
            else
              result = $d4cf498bb51af8a5$var$base64ToArrayBuffer(part.inlineData.data);
          }
        });
        if (result) {
          if (!this._botIsSpeaking) {
            this._botResponseID++;
            this.botStartedSpeaking();
          }
          this.bufferBotAudio(result, this._botResponseID.toString());
        }
      } else if (content.interrupted)
        await this.userStartedSpeaking();
      else if (content.turnComplete)
        this.botStoppedSpeaking();
    });
    this._ws.on("error", (error) => {
      this.connectionError(`websocket error: ${error}`);
    });
    this._ws.on("connection-timeout", () => {
      this.connectionError("websocket connection timed out");
    });
    this._ws.on("close", (code) => {
      this.connectionError(`websocket connection closed. Code: ${code}`);
    });
    this._ws.on("reconnect-failed", () => {
      this.connectionError(`websocket reconnect failed`);
    });
  }
  async connectLLM() {
    if (!this._ws) {
      console.error("connectLLM called before the websocket is initialized. Be sure to call initializeLLM() first.");
      return;
    }
    try {
      await this._ws.connect();
    } catch (error) {
      const msg = `Failed to connect to LLM: ${error}`;
      console.error(msg);
      this.state = "error";
      throw new (0, $8ead7b33b8402751$export$e0624a511a2c4e9)(msg);
    }
    const service_options = this._service_options;
    const model = service_options?.model ?? $d4cf498bb51af8a5$var$MODEL;
    const generation_config = service_options?.settings ?? {};
    let config = {
      setup: {
        model,
        generation_config
      }
    };
    await this._sendMsg(config);
    if (service_options?.initial_messages)
      service_options.initial_messages.forEach((msg) => {
        this._sendTextInput(msg.content, msg.role);
      });
  }
  async disconnectLLM() {
    await this._ws?.close();
  }
  async sendReadyMessage() {
    const p3 = new Promise((resolve) => {
      if (this.state === "ready")
        resolve();
      else
        this._botIsReadyResolve = resolve;
    });
    await p3;
    this._onMessage({
      type: (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_READY,
      data: {}
    });
  }
  handleUserAudioStream(data) {
    if (this.state === "ready")
      try {
        this._sendAudioInput(data);
      } catch (error) {
        console.error("Error adding audio to stream player", error);
        this.state = "error";
      }
  }
  sendMessage(message) {
    switch (message.type) {
      case "action":
        {
          const data = message.data;
          switch (data.action) {
            case "append_to_messages":
              if (data.arguments) {
                for (const a3 of data.arguments)
                  if (a3.name === "messages") {
                    const value = a3.value;
                    for (const m3 of value)
                      this._sendTextInput(m3.content, m3.role);
                  }
              }
              break;
            case "get_context":
            case "set_context":
              console.warn("get_context and set_context are not implemented");
              break;
          }
        }
        break;
    }
  }
  async _sendAudioInput(data) {
    const sampleRate = 24e3;
    const msg = {
      realtimeInput: {
        mediaChunks: [
          {
            mimeType: `audio/pcm;rate=${sampleRate}`,
            data: $d4cf498bb51af8a5$var$arrayBufferToBase64(data)
          }
        ]
      }
    };
    await this._sendMsg(msg);
  }
  async _sendTextInput(text, role) {
    const msg = {
      clientContent: {
        turns: [
          {
            role,
            parts: [
              {
                text
              }
            ]
          }
        ],
        turnComplete: role === "user" ? true : false
      }
    };
    await this._sendMsg(msg);
  }
  async _sendMsg(msg) {
    if (!this._ws) {
      console.error("sendMsg called but WS is null");
      return;
    }
    if (this._ws.readyState !== WebSocket.OPEN) {
      console.error("attempt to send to closed socket");
      return;
    }
    if (!msg) {
      console.error("need a msg to send a msg");
      return;
    }
    try {
      await this._ws.send(JSON.stringify(msg));
    } catch (e4) {
      console.error("sendMsg error", e4);
    }
  }
  // Not implemented
  enableScreenShare(enable) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("startScreenShare not implemented for GeminiLiveWebsocketTransport");
    throw new Error("Not implemented");
  }
  get isSharingScreen() {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("isSharingScreen not implemented for GeminiLiveWebsocketTransport");
    return false;
  }
};
function $d4cf498bb51af8a5$var$base64ToArrayBuffer(base64) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i3 = 0; i3 < len; i3++)
    bytes[i3] = binaryString.charCodeAt(i3);
  return bytes.buffer;
}
function $d4cf498bb51af8a5$var$arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i3 = 0; i3 < bytes.byteLength; i3++)
    binary += String.fromCharCode(bytes[i3]);
  return btoa(binary);
}
function $d4cf498bb51af8a5$var$mergeBuffers(leftBuffer, rightBuffer) {
  const tmpArray = new Uint8Array(leftBuffer.byteLength + rightBuffer.byteLength);
  tmpArray.set(new Uint8Array(leftBuffer), 0);
  tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);
  return tmpArray.buffer;
}

// ../node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// ../node_modules/@pipecat-ai/openai-realtime-webrtc-transport/dist/index.module.js
function $parcel$export5(e4, n3, v3, s3) {
  Object.defineProperty(e4, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $4e887b6dcd7ec3e7$exports = {};
$parcel$export5($4e887b6dcd7ec3e7$exports, "OpenAIRealTimeWebRTCTransport", () => $4e887b6dcd7ec3e7$export$60a765086a8f0478);
var $4e887b6dcd7ec3e7$var$BASE_URL = "https://api.openai.com/v1/realtime";
var $4e887b6dcd7ec3e7$var$MODEL = "gpt-4o-realtime-preview-2024-12-17";
var $4e887b6dcd7ec3e7$export$60a765086a8f0478 = class extends (0, $4086f06442fcb7d7$export$86495b081fef8e52) {
  constructor(service_options) {
    super();
    this._openai_channel = null;
    this._openai_cxn = null;
    this._senders = {};
    this._botTracks = {};
    this._selectedCam = {};
    this._selectedMic = {};
    this._selectedSpeaker = {};
    this._service_options = service_options;
  }
  // subclasses should implement this method to initialize the LLM
  // client and call super() on this method
  initialize(options, messageHandler) {
    this._options = options;
    this._callbacks = options.callbacks ?? {};
    this._onMessage = messageHandler;
    this._openai_cxn = new RTCPeerConnection();
    const existingInstance = (0, ic).getCallInstance();
    if (existingInstance)
      this._daily = existingInstance;
    else {
      this._daily = (0, ic).createCallObject({
        // Default is cam off
        startVideoOff: options.enableCam != true,
        // Default is mic on
        startAudioOff: options.enableMic == false
      });
      this._attachDeviceListeners();
    }
    this._attachLLMListeners();
    this.state = "disconnected";
  }
  async initDevices() {
    if (!this._daily)
      throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)("Transport instance not initialized");
    this.state = "initializing";
    const infos = await this._daily.startCamera({
      startVideoOff: true,
      startAudioOff: !(this._options.enableMic ?? true)
    });
    const { devices } = await this._daily.enumerateDevices();
    const cams = devices.filter((d3) => d3.kind === "videoinput");
    const mics = devices.filter((d3) => d3.kind === "audioinput");
    const speakers = devices.filter((d3) => d3.kind === "audiooutput");
    this._callbacks.onAvailableCamsUpdated?.(cams);
    this._callbacks.onAvailableMicsUpdated?.(mics);
    this._callbacks.onAvailableSpeakersUpdated?.(speakers);
    this._selectedCam = infos.camera;
    this._callbacks.onCamUpdated?.(infos.camera);
    this._selectedMic = infos.mic;
    this._callbacks.onMicUpdated?.(infos.mic);
    this._selectedSpeaker = infos.speaker;
    this._callbacks.onSpeakerUpdated?.(infos.speaker);
    if (!this._daily.isLocalAudioLevelObserverRunning())
      await this._daily.startLocalAudioLevelObserver(100);
    this.state = "initialized";
  }
  /**********************************/
  /** Call Lifecycle functionality */
  async connect(authBundle, abortController) {
    if (!this._openai_cxn) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("connectLLM called before the webrtc connection is initialized. Be sure to call initializeLLM() first.");
      return;
    }
    if (abortController.signal.aborted)
      return;
    this.state = "connecting";
    await this._connectLLM();
    if (abortController.signal.aborted)
      return;
    this.state = "connected";
    this._callbacks.onConnected?.();
  }
  async disconnect() {
    this.state = "disconnecting";
    await this._disconnectLLM();
    this.state = "disconnected";
    this._callbacks.onDisconnected?.();
    this.initialize(this._options, this._onMessage);
  }
  get state() {
    return this._state;
  }
  set state(state) {
    if (this._state === state)
      return;
    this._state = state;
    this._callbacks.onTransportStateChanged?.(state);
  }
  /**********************************/
  /** OpenAI-specific functionality */
  updateSettings(settings) {
    if (settings.voice && this._channelReady()) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn("changing voice settings after session start is not supported");
      delete settings.voice;
    }
    const newSettings = {
      ...this._service_options.settings,
      ...settings
    };
    if ((0, dequal)(newSettings, this._service_options.settings))
      return;
    this._service_options.settings = {
      ...this._service_options.settings,
      ...settings
    };
    this._updateSession();
  }
  /**********************************/
  /** Device functionality */
  async getAllMics() {
    let devices = (await this._daily.enumerateDevices()).devices;
    return devices.filter((device) => device.kind === "audioinput");
  }
  async getAllCams() {
    let devices = (await this._daily.enumerateDevices()).devices;
    return devices.filter((device) => device.kind === "videoinput");
  }
  async getAllSpeakers() {
    let devices = (await this._daily.enumerateDevices()).devices;
    return devices.filter((device) => device.kind === "audiooutput");
  }
  updateMic(micId) {
    this._daily.setInputDevicesAsync({
      audioDeviceId: micId
    }).then((deviceInfo) => {
      this._selectedMic = deviceInfo.mic;
    });
  }
  updateCam(camId) {
    this._daily.setInputDevicesAsync({
      videoDeviceId: camId
    }).then((deviceInfo) => {
      this._selectedCam = deviceInfo.camera;
    });
  }
  updateSpeaker(speakerId) {
    this._daily.setOutputDeviceAsync({
      outputDeviceId: speakerId
    }).then((deviceInfo) => {
      this._selectedSpeaker = deviceInfo.speaker;
    });
  }
  get selectedMic() {
    return this._selectedMic;
  }
  get selectedCam() {
    return this._selectedCam;
  }
  get selectedSpeaker() {
    return this._selectedSpeaker;
  }
  enableMic(enable) {
    if (!this._daily.participants()?.local)
      return;
    this._daily.setLocalAudio(enable);
  }
  enableCam(enable) {
    if (!this._daily.participants()?.local)
      return;
    this._daily.setLocalVideo(enable);
  }
  get isCamEnabled() {
    return this._daily.localVideo();
  }
  get isMicEnabled() {
    return this._daily.localAudio();
  }
  // Not implemented
  enableScreenShare(enable) {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("startScreenShare not implemented for OpenAIRealTimeWebRTCTransport");
    throw new Error("Not implemented");
  }
  get isSharingScreen() {
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("isSharingScreen not implemented for OpenAIRealTimeWebRTCTransport");
    return false;
  }
  tracks() {
    const participants = this._daily?.participants() ?? {};
    const tracks = {
      local: {
        audio: participants?.local?.tracks?.audio?.persistentTrack,
        video: participants?.local?.tracks?.video?.persistentTrack
      }
    };
    if (Object.keys(this._botTracks).length > 0)
      tracks.bot = this._botTracks;
    return tracks;
  }
  /**********************************/
  /** Bot communication */
  async sendReadyMessage() {
    const p3 = new Promise((resolve, reject) => {
      if (this.state === "ready")
        resolve();
      else
        this._botIsReadyResolve = {
          resolve,
          reject
        };
    });
    try {
      await p3;
      this._onMessage({
        type: (0, $b48f893ed1354c1e$export$38b3db05cbf0e240).BOT_READY,
        data: {}
      });
    } catch (e4) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Failed to start bot");
      throw new (0, $8ead7b33b8402751$export$e0624a511a2c4e9)();
    }
  }
  sendMessage(message) {
    switch (message.type) {
      case "action": {
        const data = message.data;
        switch (data.action) {
          case "append_to_messages":
            if (data.arguments) {
              let messages = [];
              let runImmediately = false;
              for (const a3 of data.arguments) {
                if (a3.name === "messages")
                  messages = a3.value;
                else if (a3.name === "run_immediately")
                  runImmediately = a3.value;
              }
              this._sendTextInput(messages, runImmediately);
            }
            break;
          case "run":
            this._run();
            break;
          case "get_contex":
          case "set_context":
            (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn("get_context and set_context are not implemented");
            break;
        }
        break;
      }
      case (0, $0908f693e3e0724c$export$441bcd2e10762760).LLM_FUNCTION_CALL_RESULT:
        this._sendFunctionCallResult(message.data);
        break;
    }
  }
  /**********************************/
  /** Private methods */
  async _connectLLM() {
    const audioSender = this._senders["audio"];
    if (!audioSender) {
      let micTrack = this._daily.participants()?.local?.tracks?.audio?.persistentTrack;
      if (!micTrack)
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true
          });
          micTrack = stream.getAudioTracks()[0];
        } catch (e4) {
          (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("Failed to get mic track. OpenAI requires audio on initial connection.", e4);
          throw new (0, $8ead7b33b8402751$export$59b4786f333aac02)("Failed to get mic track. OpenAI requires audio on initial connection.");
        }
      this._senders["audio"] = this._openai_cxn.addTrack(micTrack);
    }
    await this._negotiateConnection();
  }
  async _disconnectLLM() {
    this._cleanup();
  }
  _attachDeviceListeners() {
    this._daily.on("track-started", this._handleTrackStarted.bind(this));
    this._daily.on("track-stopped", this._handleTrackStopped.bind(this));
    this._daily.on("available-devices-updated", this._handleAvailableDevicesUpdated.bind(this));
    this._daily.on("selected-devices-updated", this._handleSelectedDevicesUpdated.bind(this));
    this._daily.on("local-audio-level", this._handleLocalAudioLevel.bind(this));
  }
  _attachLLMListeners() {
    if (!this._openai_cxn) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("_attachLLMListeners called before the websocket is initialized. Be sure to call initializeLLM() first.");
      return;
    }
    this._openai_cxn.ontrack = (e4) => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("[openai] got track from openai", e4);
      this._botTracks[e4.track.kind] = e4.track;
      this._callbacks.onTrackStarted?.(e4.track, $4e887b6dcd7ec3e7$var$botParticipant());
    };
    if (this._openai_channel) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn('closing existing data channel "oai-events"');
      this._openai_channel.close();
      this._openai_channel = null;
    }
    const dc3 = this._openai_cxn.createDataChannel("oai-events");
    dc3.addEventListener("message", (e4) => {
      const realtimeEvent = JSON.parse(e4.data);
      this._handleOpenAIMessage(realtimeEvent);
    });
    this._openai_channel = dc3;
    this._openai_cxn.onconnectionstatechange = (e4) => {
      const state = e4.target?.connectionState;
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug(`connection state changed to ${state.toUpperCase()}`);
      switch (state) {
        case "closed":
        case "failed":
          this.state = "error";
          if (this._botIsReadyResolve) {
            this._botIsReadyResolve.reject("Connection to OpenAI failed. Check your API key.");
            this._botIsReadyResolve = null;
          } else
            this._callbacks.onError?.((0, $b48f893ed1354c1e$export$69aa9ab0334b212).error(`Connection to OpenAI ${state}`, true));
          break;
      }
    };
    this._openai_cxn.onicecandidateerror = (e4) => {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("ice candidate error", e4);
    };
  }
  async _negotiateConnection() {
    const cxn = this._openai_cxn;
    const service_options = this._service_options;
    const apiKey = service_options.api_key;
    if (!apiKey) {
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error("!!! No API key provided in service_options");
      return;
    }
    try {
      const offer = await cxn.createOffer();
      await cxn.setLocalDescription(offer);
      const model = service_options?.model ?? $4e887b6dcd7ec3e7$var$MODEL;
      const sdpResponse = await fetch(`${$4e887b6dcd7ec3e7$var$BASE_URL}?model=${model}`, {
        method: "POST",
        body: offer.sdp,
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "Content-Type": "application/sdp"
        }
      });
      const answer = {
        type: "answer",
        sdp: await sdpResponse.text()
      };
      await cxn.setRemoteDescription(answer);
    } catch (error) {
      const msg = `Failed to connect to LLM: ${error}`;
      (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).error(msg);
      this.state = "error";
      throw new (0, $8ead7b33b8402751$export$e0624a511a2c4e9)(msg);
    }
  }
  _cleanup() {
    this._openai_channel?.close();
    this._openai_channel = null;
    this._openai_cxn?.close();
    this._openai_cxn = null;
    this._senders = {};
    this._botTracks = {};
  }
  _updateSession() {
    if (!this._channelReady())
      return;
    const service_options = this._service_options;
    const session_config = service_options?.settings ?? {};
    if (session_config.input_audio_transcription === void 0)
      session_config.input_audio_transcription = {
        model: "gpt-4o-transcribe"
      };
    (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("updating session", session_config);
    this._openai_channel.send(JSON.stringify({
      type: "session.update",
      session: session_config
    }));
    if (service_options?.initial_messages)
      this._sendTextInput(service_options.initial_messages, true);
  }
  async _handleOpenAIMessage(msg) {
    const type = msg.type;
    switch (type) {
      case "error":
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).warn("openai error", msg);
        break;
      case "session.created":
        this.state = "ready";
        if (this._botIsReadyResolve) {
          this._botIsReadyResolve.resolve();
          this._botIsReadyResolve = null;
        }
        this._updateSession();
        break;
      case "input_audio_buffer.speech_started":
        this._callbacks.onUserStartedSpeaking?.();
        break;
      case "input_audio_buffer.speech_stopped":
        this._callbacks.onUserStoppedSpeaking?.();
        break;
      case "conversation.item.input_audio_transcription.completed":
        this._callbacks.onUserTranscript?.({
          text: msg.transcript,
          final: true,
          timestamp: Date.now().toString(),
          user_id: "user"
        });
        break;
      case "response.content_part.added":
        if (msg?.part?.type === "audio")
          this._callbacks.onBotStartedSpeaking?.();
        break;
      case "output_audio_buffer.cleared":
      case "output_audio_buffer.stopped":
        this._callbacks.onBotStoppedSpeaking?.();
        break;
      case "response.audio_transcript.delta":
        this._callbacks.onBotTtsText?.({
          text: msg.delta
        });
        break;
      case "response.audio_transcript.done":
        this._callbacks.onBotTranscript?.({
          text: msg.transcript
        });
        break;
      case "response.function_call_arguments.done":
        {
          let data = {
            function_name: msg.name,
            tool_call_id: msg.call_id,
            args: JSON.parse(msg.arguments)
          };
          this._onMessage({
            type: (0, $0908f693e3e0724c$export$441bcd2e10762760).LLM_FUNCTION_CALL,
            data
          });
        }
        break;
      case "response.function_call_arguments.delta":
      default:
        (0, $7afbbd59ebaa42bf$export$af88d00dbe7f521).debug("ignoring openai message", msg);
    }
  }
  async _handleTrackStarted(ev) {
    const sender = this._senders[ev.track.kind];
    if (sender) {
      if (sender.track?.id !== ev.track.id)
        sender.replaceTrack(ev.track);
    } else
      this._senders[ev.track.kind] = this._openai_cxn.addTrack(ev.track);
    this._callbacks.onTrackStarted?.(ev.track, ev.participant ? $4e887b6dcd7ec3e7$var$dailyParticipantToParticipant(ev.participant) : void 0);
  }
  async _handleTrackStopped(ev) {
    this._callbacks.onTrackStopped?.(ev.track, ev.participant ? $4e887b6dcd7ec3e7$var$dailyParticipantToParticipant(ev.participant) : void 0);
  }
  _handleAvailableDevicesUpdated(ev) {
    this._callbacks.onAvailableCamsUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "videoinput"));
    this._callbacks.onAvailableMicsUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "audioinput"));
    this._callbacks.onAvailableSpeakersUpdated?.(ev.availableDevices.filter((d3) => d3.kind === "audiooutput"));
  }
  _handleSelectedDevicesUpdated(ev) {
    if (this._selectedCam?.deviceId !== ev.devices.camera) {
      this._selectedCam = ev.devices.camera;
      this._callbacks.onCamUpdated?.(ev.devices.camera);
    }
    if (this._selectedMic?.deviceId !== ev.devices.mic) {
      this._selectedMic = ev.devices.mic;
      this._callbacks.onMicUpdated?.(ev.devices.mic);
    }
    if (this._selectedSpeaker?.deviceId !== ev.devices.speaker) {
      this._selectedSpeaker = ev.devices.speaker;
      this._callbacks.onSpeakerUpdated?.(ev.devices.speaker);
    }
  }
  _handleLocalAudioLevel(ev) {
    this._callbacks.onLocalAudioLevel?.(ev.audioLevel);
  }
  _sendTextInput(messages, runImmediately = false) {
    if (!this._channelReady())
      return;
    messages.forEach((m3) => {
      const event = {
        type: "conversation.item.create",
        item: {
          type: "message",
          role: m3.role,
          content: [
            {
              type: m3.role === "assistant" ? "text" : "input_text",
              text: m3.content
            }
          ]
        }
      };
      this._openai_channel.send(JSON.stringify(event));
    });
    if (runImmediately)
      this._run();
  }
  _sendFunctionCallResult(data) {
    if (!this._channelReady() || !data.result)
      return;
    const event = {
      type: "conversation.item.create",
      item: {
        type: "function_call_output",
        call_id: data.tool_call_id,
        output: JSON.stringify(data.result)
      }
    };
    this._openai_channel.send(JSON.stringify(event));
    this._run();
  }
  _run() {
    if (!this._channelReady)
      return;
    this._openai_channel.send(JSON.stringify({
      type: "response.create"
    }));
  }
  _channelReady() {
    if (!this._openai_channel)
      return false;
    return this._openai_channel?.readyState === "open";
  }
};
var $4e887b6dcd7ec3e7$var$dailyParticipantToParticipant = (p3) => ({
  id: p3.user_id,
  local: p3.local,
  name: p3.user_name
});
var $4e887b6dcd7ec3e7$var$botParticipant = () => ({
  id: "bot",
  local: false,
  name: "Bot"
});

// ../node_modules/livekit-client/dist/livekit-client.esm.mjs
function _mergeNamespaces(n3, m3) {
  m3.forEach(function(e4) {
    e4 && typeof e4 !== "string" && !Array.isArray(e4) && Object.keys(e4).forEach(function(k3) {
      if (k3 !== "default" && !(k3 in n3)) {
        var d3 = Object.getOwnPropertyDescriptor(e4, k3);
        Object.defineProperty(n3, k3, d3.get ? d3 : {
          enumerable: true,
          get: function() {
            return e4[k3];
          }
        });
      }
    });
  });
  return Object.freeze(n3);
}
var e3 = Object.defineProperty;
var h3 = (i3, s3, t3) => s3 in i3 ? e3(i3, s3, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: t3
}) : i3[s3] = t3;
var o3 = (i3, s3, t3) => h3(i3, typeof s3 != "symbol" ? s3 + "" : s3, t3);
var _3 = class {
  constructor() {
    o3(this, "_locking");
    o3(this, "_locks");
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let s3;
    const t3 = new Promise((l3) => s3 = () => {
      this._locks -= 1, l3();
    }), c3 = this._locking.then(() => s3);
    return this._locking = this._locking.then(() => t3), c3;
  }
};
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t3 = enumObject[enumTypeSymbol];
  assert(t3, "missing enum type on enum object");
  return t3;
}
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v3) => ({
    no: v3.no,
    name: v3.name,
    localName: enumObject[v3.no]
  })));
}
function makeEnumType(typeName, values, _opt) {
  const names = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value of values) {
    const n3 = normalizeEnumValue(value);
    normalValues.push(n3);
    names[value.name] = n3;
    numbers[value.no] = n3;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name) {
      return names[name];
    },
    findNumber(no3) {
      return numbers[no3];
    }
  };
}
function makeEnum(typeName, values, opt) {
  const enumObject = {};
  for (const value of values) {
    const n3 = normalizeEnumValue(value);
    enumObject[n3.localName] = n3.no;
    enumObject[n3.no] = n3.localName;
  }
  setEnumType(enumObject, typeName, values);
  return enumObject;
}
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), {
    localName: value.name
  });
}
var Message = class {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes, options) {
    const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
    format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue, options) {
    const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
    format.readMessage(type, jsonValue, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json;
    try {
      json = JSON.parse(jsonString);
    } catch (e4) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e4 instanceof Error ? e4.message : String(e4)));
    }
    return this.fromJson(json, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer2 = opt.writerFactory();
    bin.writeMessage(this, writer2, opt);
    return writer2.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
    return json.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a3;
    const value = this.toJson(options);
    return JSON.stringify(value, null, (_a3 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a3 !== void 0 ? _a3 : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
};
function makeMessageType(runtime, typeName, fields, opt) {
  var _a3;
  const localName = (_a3 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a3 !== void 0 ? _a3 : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type = {
    [localName]: function(data) {
      runtime.util.initFields(this);
      runtime.util.initPartial(data, this);
    }
  }[localName];
  Object.setPrototypeOf(type.prototype, new Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary(bytes, options) {
      return new type().fromBinary(bytes, options);
    },
    fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals(a3, b3) {
      return runtime.util.equals(type, a3, b3);
    }
  });
  return type;
}
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b3 = this.buf[this.pos++];
    lowBits |= (b3 & 127) << shift;
    if ((b3 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b3 = this.buf[this.pos++];
    highBits |= (b3 & 127) << shift;
    if ((b3 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo3, hi3, bytes) {
  for (let i3 = 0; i3 < 28; i3 = i3 + 7) {
    const shift = lo3 >>> i3;
    const hasNext = !(shift >>> 7 == 0 && hi3 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo3 >>> 28 & 15 | (hi3 & 7) << 4;
  const hasMoreBits = !(hi3 >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i3 = 3; i3 < 31; i3 = i3 + 7) {
    const shift = hi3 >>> i3;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi3 >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo3, hi3) {
  let bits = newBits(lo3, hi3);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo3, hi3) {
  ({
    lo: lo3,
    hi: hi3
  } = toUnsigned(lo3, hi3));
  if (hi3 <= 2097151) {
    return String(TWO_PWR_32_DBL * hi3 + lo3);
  }
  const low = lo3 & 16777215;
  const mid = (lo3 >>> 24 | hi3 << 8) & 16777215;
  const high = hi3 >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo3, hi3) {
  return {
    lo: lo3 >>> 0,
    hi: hi3 >>> 0
  };
}
function newBits(lo3, hi3) {
  return {
    lo: lo3 | 0,
    hi: hi3 | 0
  };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i3 = 0; i3 < 9; i3++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b3 = this.buf[this.pos++];
  let result = b3 & 127;
  if ((b3 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b3 = this.buf[this.pos++];
  result |= (b3 & 127) << 7;
  if ((b3 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b3 = this.buf[this.pos++];
  result |= (b3 & 127) << 14;
  if ((b3 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b3 = this.buf[this.pos++];
  result |= (b3 & 127) << 21;
  if ((b3 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b3 = this.buf[this.pos++];
  result |= (b3 & 15) << 28;
  for (let readBytes = 5; (b3 & 128) !== 0 && readBytes < 10; readBytes++)
    b3 = this.buf[this.pos++];
  if ((b3 & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi3 = typeof value == "bigint" ? value : BigInt(value);
        if (bi3 > MAX || bi3 < MIN) {
          throw new Error("int64 invalid: ".concat(value));
        }
        return bi3;
      },
      uParse(value) {
        const bi3 = typeof value == "bigint" ? value : BigInt(value);
        if (bi3 > UMAX || bi3 < UMIN) {
          throw new Error("uint64 invalid: ".concat(value));
        }
        return bi3;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo3, hi3) {
        dv.setInt32(0, lo3, true);
        dv.setInt32(4, hi3, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo3, hi3) {
        dv.setInt32(0, lo3, true);
        dv.setInt32(4, hi3, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));
  const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo3, hi3) {
      return int64ToString(lo3, hi3);
    },
    uDec(lo3, hi3) {
      return uInt64ToString(lo3, hi3);
    }
  };
}
var protoInt64 = makeInt64Support();
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));
function scalarEquals(type, a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (type == ScalarType.BYTES) {
    if (!(a3 instanceof Uint8Array) || !(b3 instanceof Uint8Array)) {
      return false;
    }
    if (a3.length !== b3.length) {
      return false;
    }
    for (let i3 = 0; i3 < a3.length; i3++) {
      if (a3[i3] !== b3[i3]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a3 == b3;
  }
  return false;
}
function scalarZeroValue(type, longType) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i3 = 0; i3 < this.chunks.length; i3++)
      len += this.chunks[i3].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i3 = 0; i3 < this.chunks.length; i3++) {
      bytes.set(this.chunks[i3], offset);
      offset += this.chunks[i3].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.textEncoder.encode(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc3 = protoInt64.enc(value);
    view.setInt32(0, tc3.lo, true);
    view.setInt32(4, tc3.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc3 = protoInt64.uEnc(value);
    view.setInt32(0, tc3.lo, true);
    view.setInt32(4, tc3.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc3 = protoInt64.enc(value);
    varint64write(tc3.lo, tc3.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc3 = protoInt64.enc(value), sign = tc3.hi >> 31, lo3 = tc3.lo << 1 ^ sign, hi3 = (tc3.hi << 1 | tc3.lo >>> 31) ^ sign;
    varint64write(lo3, hi3, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc3 = protoInt64.uEnc(value);
    varint64write(tc3.lo, tc3.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn3, wt3] = this.tag();
          if (wt3 === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn3 !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt3, fn3);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo3, hi3] = this.varint64();
    let s3 = -(lo3 & 1);
    lo3 = (lo3 >>> 1 | (hi3 & 1) << 31) ^ s3;
    hi3 = hi3 >>> 1 ^ s3;
    return protoInt64.dec(lo3, hi3);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo3, hi3] = this.varint64();
    return lo3 !== 0 || hi3 !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};
function makeExtension(runtime, typeName, extendee, field) {
  let fi3;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi3) {
        const i3 = typeof field == "function" ? field() : field;
        i3.name = typeName.split(".").pop();
        i3.jsonName = "[".concat(typeName, "]");
        fi3 = runtime.util.newFieldList([i3]).list()[0];
      }
      return fi3;
    },
    runtime
  };
}
function createExtensionContainer(extension) {
  const localName = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName] = initExtensionField(extension);
  return [container, () => container[localName]];
}
function initExtensionField(ext) {
  const field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field.default !== void 0) {
    return field.default;
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      const T3 = field.T, value = new T3();
      return T3.fieldWrapper ? T3.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (let i3 = unknownFields.length - 1; i3 >= 0; --i3) {
      if (unknownFields[i3].no == field.no) {
        return [unknownFields[i3]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field.no);
}
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i3 = 0; i3 < encTable.length; i3++)
  decTable[encTable[i3].charCodeAt(0)] = i3;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es3 = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es3 -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es3 -= 1;
    let bytes = new Uint8Array(es3), bytePos = 0, groupPos = 0, b3, p3 = 0;
    for (let i3 = 0; i3 < base64Str.length; i3++) {
      b3 = decTable[base64Str.charCodeAt(i3)];
      if (b3 === void 0) {
        switch (base64Str[i3]) {
          case "=":
            groupPos = 0;
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p3 = b3;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p3 << 2 | (b3 & 48) >> 4;
          p3 = b3;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p3 & 15) << 4 | (b3 & 60) >> 2;
          p3 = b3;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p3 & 3) << 6 | b3;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes) {
    let base64 = "", groupPos = 0, b3, p3 = 0;
    for (let i3 = 0; i3 < bytes.length; i3++) {
      b3 = bytes[i3];
      switch (groupPos) {
        case 0:
          base64 += encTable[b3 >> 2];
          p3 = (b3 & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p3 | b3 >> 4];
          p3 = (b3 & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p3 | b3 >> 6];
          base64 += encTable[b3 & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p3];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
};
function getExtension(message, extension, options) {
  assertExtendee(extension, message);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
  const [container, get] = createExtensionContainer(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get();
}
function setExtension(message, extension, value, options) {
  assertExtendee(extension, message);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message, extension)) {
    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
    message.getType().runtime.bin.discardUnknownFields(message);
    for (const uf of ufs) {
      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
    }
  }
  const writer2 = writeOpt.writerFactory();
  let f3 = extension.field;
  if (!f3.opt && !f3.repeated && (f3.kind == "enum" || f3.kind == "scalar")) {
    f3 = Object.assign(Object.assign({}, extension.field), {
      opt: true
    });
  }
  extension.runtime.bin.writeField(f3, value, writer2, writeOpt);
  const reader = readOpt.readerFactory(writer2.finish());
  while (reader.pos < reader.len) {
    const [no3, wireType] = reader.tag();
    const data = reader.skip(wireType, no3);
    message.getType().runtime.bin.onUnknownField(message, no3, wireType, data);
  }
}
function hasExtension(message, extension) {
  const messageType = message.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
}
function assertExtendee(extension, message) {
  assert(extension.extendee.typeName == message.getType().typeName, "extension ".concat(extension.typeName, " can only be applied to message ").concat(extension.extendee.typeName));
}
function isFieldSet(field, target) {
  const localName = field.localName;
  if (field.repeated) {
    return target[localName].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName].case === localName;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName]);
    case "message":
      return target[localName] !== void 0;
    case "map":
      return Object.keys(target[localName]).length > 0;
  }
}
function clearField(field, target) {
  const localName = field.localName;
  const implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = {
      case: void 0
    };
  } else {
    switch (field.kind) {
      case "map":
        target[localName] = {};
        break;
      case "enum":
        target[localName] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName] = void 0;
        break;
    }
  }
}
function isMessage(arg, type) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every((m3) => m3 in arg && typeof arg[m3] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}
function wrapField(type, value) {
  if (isMessage(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
({
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
});
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    readMessage(type, json, options, message) {
      if (json == null || Array.isArray(json) || typeof json != "object") {
        throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
      }
      message = message !== null && message !== void 0 ? message : new type();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue] of Object.entries(json)) {
        const field = type.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: multiple keys for oneof "').concat(field.oneof.name, '" present: "').concat(seen, '", "').concat(jsonKey, '"'));
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField$1(message, jsonValue, field, options, type);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              const [container, get] = createExtensionContainer(ext);
              readField$1(container, jsonValue, ext.field, options, ext);
              setExtension(message, ext, get(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: key "').concat(jsonKey, '" is unknown'));
          }
        }
      }
      return message;
    },
    writeMessage(message, options) {
      const type = message.getType();
      const json = {};
      let field;
      try {
        for (field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw "required field not set";
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field)) {
              continue;
            }
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          const jsonValue = writeField$1(field, value, options);
          if (jsonValue !== void 0) {
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type.runtime.bin.listUnknownFields(message)) {
            const ext = registry.findExtensionFor(type.typeName, uf.no);
            if (ext && hasExtension(message, ext)) {
              const value = getExtension(message, ext, options);
              const jsonValue = writeField$1(ext.field, value, options);
              if (jsonValue !== void 0) {
                json[ext.field.jsonName] = jsonValue;
              }
            }
          }
        }
      } catch (e4) {
        const m3 = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");
        const r4 = e4 instanceof Error ? e4.message : String(e4);
        throw new Error(m3 + (r4.length > 0 ? ": ".concat(r4) : ""));
      }
      return json;
    },
    readScalar(type, json, longType) {
      return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type, value)) {
        return writeScalar$1(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (typeof json) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : '"'.concat(json.split('"').join('\\"'), '"');
    default:
      return String(json);
  }
}
function readField$1(target, jsonValue, field, options, parentType) {
  let localName = field.localName;
  if (field.repeated) {
    assert(field.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
    }
    const targetArray = target[localName];
    for (const jsonItem of jsonValue) {
      if (jsonItem === null) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem)));
      }
      switch (field.kind) {
        case "message":
          targetArray.push(field.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
          } catch (e4) {
            let m3 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem));
            if (e4 instanceof Error && e4.message.length > 0) {
              m3 += ": ".concat(e4.message);
            }
            throw new Error(m3);
          }
          break;
      }
    }
  } else if (field.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
      throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
    }
    const targetMap = target[localName];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
      if (jsonMapValue === null) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: map value null"));
      }
      let key;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e4) {
        let m3 = "cannot decode map key for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
        if (e4 instanceof Error && e4.message.length > 0) {
          m3 += ": ".concat(e4.message);
        }
        throw new Error(m3);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e4) {
            let m3 = "cannot decode map value for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
            if (e4 instanceof Error && e4.message.length > 0) {
              m3 += ": ".concat(e4.message);
            }
            throw new Error(m3);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = {
        case: localName
      };
      localName = "value";
    }
    switch (field.kind) {
      case "message":
        const messageType = field.T;
        if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName] = currentValue = messageType.fromJson(jsonValue, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName] = scalarValue;
              break;
          }
        } catch (e4) {
          let m3 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
          if (e4 instanceof Error && e4.message.length > 0) {
            m3 += ": ".concat(e4.message);
          }
          throw new Error(m3);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return readScalar$1(type, json, LongType.BIGINT, true).toString();
}
function readScalar$1(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json === "NaN")
        return Number.NaN;
      if (json === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      const float = Number(json);
      if (Number.isNaN(float)) {
        break;
      }
      if (!Number.isFinite(float)) {
        break;
      }
      if (type == ScalarType.FLOAT)
        assertFloat32(float);
      return float;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let int32;
      if (typeof json == "number")
        int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length)
          int32 = Number(json);
      }
      if (int32 === void 0)
        break;
      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
        assertUInt32(int32);
      else
        assertInt32(int32);
      return int32;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const long = protoInt64.parse(json);
      return longType ? long.toString() : long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string")
        break;
      const uLong = protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    case ScalarType.BOOL:
      if (typeof json !== "boolean")
        break;
      return json;
    case ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e4) {
        throw new Error("invalid UTF8");
      }
      return json;
    case ScalarType.BYTES:
      if (json === "")
        return new Uint8Array(0);
      if (typeof json !== "string")
        break;
      return protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (typeof json) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      const value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField$1(field, value, options) {
  if (field.kind == "map") {
    assert(typeof value == "object" && value != null);
    const jsonObj = {};
    const entries = Object.entries(value);
    switch (field.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field.V.T;
        for (const [entryKey, entryValue] of entries) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert(Array.isArray(value));
    const jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (let i3 = 0; i3 < value.length; i3++) {
          jsonArr.push(writeScalar$1(field.T, value[i3]));
        }
        break;
      case "enum":
        for (let i3 = 0; i3 < value.length; i3++) {
          jsonArr.push(writeEnum(field.T, value[i3], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i3 = 0; i3 < value.length; i3++) {
          jsonArr.push(value[i3].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return writeScalar$1(field.T, value);
    case "enum":
      return writeEnum(field.T, value, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a3;
  assert(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  const val = type.findNumber(value);
  return (_a3 = val === null || val === void 0 ? void 0 : val.name) !== null && _a3 !== void 0 ? _a3 : value;
}
function writeScalar$1(type, value) {
  switch (type) {
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert(typeof value == "number");
      return value;
    case ScalarType.FLOAT:
    case ScalarType.DOUBLE:
      assert(typeof value == "number");
      if (Number.isNaN(value))
        return "NaN";
      if (value === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value;
    case ScalarType.STRING:
      assert(typeof value == "string");
      return value;
    case ScalarType.BOOL:
      assert(typeof value == "boolean");
      return value;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    case ScalarType.BYTES:
      assert(value instanceof Uint8Array);
      return protoBase64.enc(value);
  }
}
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    listUnknownFields(message) {
      var _a3;
      return (_a3 = message[unknownFieldsSymbol]) !== null && _a3 !== void 0 ? _a3 : [];
    },
    discardUnknownFields(message) {
      delete message[unknownFieldsSymbol];
    },
    writeUnknownFields(message, writer2) {
      const m3 = message;
      const c3 = m3[unknownFieldsSymbol];
      if (c3) {
        for (const f3 of c3) {
          writer2.tag(f3.no, f3.wireType).raw(f3.data);
        }
      }
    },
    onUnknownField(message, no3, wireType, data) {
      const m3 = message;
      if (!Array.isArray(m3[unknownFieldsSymbol])) {
        m3[unknownFieldsSymbol] = [];
      }
      m3[unknownFieldsSymbol].push({
        no: no3,
        wireType,
        data
      });
    },
    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type = message.getType();
      const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
          break;
        }
        const field = type.fields.find(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message, fieldNo, wireType, data);
          }
          continue;
        }
        readField(message, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error("invalid end group tag");
      }
    },
    readField,
    writeMessage(message, writer2, options) {
      const type = message.getType();
      for (const field of type.fields.byNumber()) {
        if (!isFieldSet(field, message)) {
          if (field.req) {
            throw new Error("cannot encode field ".concat(type.typeName, ".").concat(field.name, " to binary: required field not set"));
          }
          continue;
        }
        const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
        writeField(field, value, writer2, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer2);
      }
      return writer2;
    },
    writeField(field, value, writer2, options) {
      if (value === void 0) {
        return void 0;
      }
      writeField(field, value, writer2, options);
    }
  };
}
function readField(target, reader, field, wireType, options) {
  let {
    repeated,
    localName
  } = field;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target.case != localName) {
      delete target.value;
    }
    target.case = localName;
    localName = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      let read = readScalar;
      if (field.kind == "scalar" && field.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        let arr = target[localName];
        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          let e4 = reader.uint32() + reader.pos;
          while (reader.pos < e4) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName] = read(reader, scalarType);
      }
      break;
    case "message":
      const messageType = field.T;
      if (repeated) {
        target[localName].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName])) {
          readMessageField(reader, target[localName], options, field);
        } else {
          target[localName] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field, reader, options);
      target[localName][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message, options, field) {
  const format = message.getType().runtime.bin;
  const delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format.readMessage(
    message,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message;
}
function readMapEntry(field, reader, options) {
  const length = reader.uint32(), end = reader.pos + length;
  let key, val;
  while (reader.pos < end) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type) {
  const v3 = readScalar(reader, type);
  return typeof v3 == "bigint" ? v3.toString() : v3;
}
function readScalar(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField(field, value, writer2, options) {
  assert(value !== void 0);
  const repeated = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated) {
        assert(Array.isArray(value));
        if (field.packed) {
          writePacked(writer2, scalarType, field.no, value);
        } else {
          for (const item of value) {
            writeScalar(writer2, scalarType, field.no, item);
          }
        }
      } else {
        writeScalar(writer2, scalarType, field.no, value);
      }
      break;
    case "message":
      if (repeated) {
        assert(Array.isArray(value));
        for (const item of value) {
          writeMessageField(writer2, options, field, item);
        }
      } else {
        writeMessageField(writer2, options, field, value);
      }
      break;
    case "map":
      assert(typeof value == "object" && value != null);
      for (const [key, val] of Object.entries(value)) {
        writeMapEntry(writer2, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer2, options, field, key, value) {
  writer2.tag(field.no, WireType.LengthDelimited);
  writer2.fork();
  let keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar(writer2, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar(writer2, field.V.T, 2, value);
      break;
    case "enum":
      writeScalar(writer2, ScalarType.INT32, 2, value);
      break;
    case "message":
      assert(value !== void 0);
      writer2.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer2.join();
}
function writeMessageField(writer2, options, field, value) {
  const message = wrapField(field.T, value);
  if (field.delimited)
    writer2.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
  else
    writer2.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
}
function writeScalar(writer2, type, fieldNo, value) {
  assert(value !== void 0);
  let [wireType, method] = scalarTypeInfo(type);
  writer2.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer2, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer2.tag(fieldNo, WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type);
  for (let i3 = 0; i3 < value.length; i3++) {
    writer2[method](value[i3]);
  }
  writer2.join();
}
function scalarTypeInfo(type) {
  let wireType = WireType.Varint;
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  const method = ScalarType[type].toLowerCase();
  return [wireType, method];
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type = target.getType();
      for (const member of type.fields.byMember()) {
        const localName = member.localName, t3 = target, s3 = source;
        if (s3[localName] == null) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s3[localName].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s3[localName].value;
            if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t3[localName] = {
              case: sk,
              value: val
            };
            break;
          case "scalar":
          case "enum":
            let copy = s3[localName];
            if (member.T === ScalarType.BYTES) {
              copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
            }
            t3[localName] = copy;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === ScalarType.BYTES) {
                  for (const [k3, v3] of Object.entries(s3[localName])) {
                    t3[localName][k3] = toU8Arr(v3);
                  }
                } else {
                  Object.assign(t3[localName], s3[localName]);
                }
                break;
              case "message":
                const messageType = member.V.T;
                for (const k3 of Object.keys(s3[localName])) {
                  let val2 = s3[localName][k3];
                  if (!messageType.fieldWrapper) {
                    val2 = new messageType(val2);
                  }
                  t3[localName][k3] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt3 = member.T;
            if (member.repeated) {
              t3[localName] = s3[localName].map((val2) => isMessage(val2, mt3) ? val2 : new mt3(val2));
            } else {
              const val2 = s3[localName];
              if (mt3.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt3.typeName === "google.protobuf.BytesValue"
                ) {
                  t3[localName] = toU8Arr(val2);
                } else {
                  t3[localName] = val2;
                }
              } else {
                t3[localName] = isMessage(val2, mt3) ? val2 : new mt3(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type, a3, b3) {
      if (a3 === b3) {
        return true;
      }
      if (!a3 || !b3) {
        return false;
      }
      return type.fields.byMember().every((m3) => {
        const va3 = a3[m3.localName];
        const vb = b3[m3.localName];
        if (m3.repeated) {
          if (va3.length !== vb.length) {
            return false;
          }
          switch (m3.kind) {
            case "message":
              return va3.every((a4, i3) => m3.T.equals(a4, vb[i3]));
            case "scalar":
              return va3.every((a4, i3) => scalarEquals(m3.T, a4, vb[i3]));
            case "enum":
              return va3.every((a4, i3) => scalarEquals(ScalarType.INT32, a4, vb[i3]));
          }
          throw new Error("repeated cannot contain ".concat(m3.kind));
        }
        switch (m3.kind) {
          case "message":
            let a4 = va3;
            let b4 = vb;
            if (m3.T.fieldWrapper) {
              if (a4 !== void 0 && !isMessage(a4)) {
                a4 = m3.T.fieldWrapper.wrapField(a4);
              }
              if (b4 !== void 0 && !isMessage(b4)) {
                b4 = m3.T.fieldWrapper.wrapField(b4);
              }
            }
            return m3.T.equals(a4, b4);
          case "enum":
            return scalarEquals(ScalarType.INT32, va3, vb);
          case "scalar":
            return scalarEquals(m3.T, va3, vb);
          case "oneof":
            if (va3.case !== vb.case) {
              return false;
            }
            const s3 = m3.findField(va3.case);
            if (s3 === void 0) {
              return true;
            }
            switch (s3.kind) {
              case "message":
                return s3.T.equals(va3.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va3.value, vb.value);
              case "scalar":
                return scalarEquals(s3.T, va3.value, vb.value);
            }
            throw new Error("oneof cannot contain ".concat(s3.kind));
          case "map":
            const keys = Object.keys(va3).concat(Object.keys(vb));
            switch (m3.V.kind) {
              case "message":
                const messageType = m3.V.T;
                return keys.every((k3) => messageType.equals(va3[k3], vb[k3]));
              case "enum":
                return keys.every((k3) => scalarEquals(ScalarType.INT32, va3[k3], vb[k3]));
              case "scalar":
                const scalarType = m3.V.T;
                return keys.every((k3) => scalarEquals(scalarType, va3[k3], vb[k3]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message) {
      const type = message.getType(), target = new type(), any = target;
      for (const member of type.fields.byMember()) {
        const source = message[member.localName];
        let copy;
        if (member.repeated) {
          copy = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy = any[member.localName];
          for (const [key, v3] of Object.entries(source)) {
            copy[key] = cloneSingularField(v3);
          }
        } else if (member.kind == "oneof") {
          const f3 = member.findField(source.case);
          copy = f3 ? {
            case: source.case,
            value: cloneSingularField(source.value)
          } : {
            case: void 0
          };
        } else {
          copy = cloneSingularField(source);
        }
        any[member.localName] = copy;
      }
      for (const uf of type.runtime.bin.listUnknownFields(message)) {
        type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
      }
      return target;
    }
  };
}
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if (isMessage(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    const c3 = new Uint8Array(value.byteLength);
    c3.set(value);
    return c3;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}
var InternalFieldList = class {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t3 = {};
      for (const f3 of this.list()) {
        t3[f3.jsonName] = t3[f3.name] = f3;
      }
      this.jsonNames = t3;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t3 = {};
      for (const f3 of this.list()) {
        t3[f3.no] = f3;
      }
      this.numbers = t3;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a3, b3) => a3.no - b3.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a3 = this.members;
      let o4;
      for (const f3 of this.list()) {
        if (f3.oneof) {
          if (f3.oneof !== o4) {
            o4 = f3.oneof;
            a3.push(o4);
          }
        } else {
          a3.push(f3);
        }
      }
    }
    return this.members;
  }
};
function localFieldName(protoName, inOneof) {
  const name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase) {
  let capNext = false;
  const b3 = [];
  for (let i3 = 0; i3 < snakeCase.length; i3++) {
    let c3 = snakeCase.charAt(i3);
    switch (c3) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b3.push(c3);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c3 = c3.toUpperCase();
        }
        b3.push(c3);
        break;
    }
  }
  return b3.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback = (name) => "".concat(name, "$");
var safeMessageProperty = (name) => {
  if (reservedMessageProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var safeObjectProperty = (name) => {
  if (reservedObjectProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var InternalOneofInfo = class {
  constructor(name) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  addField(field) {
    assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));
    this.fields.push(field);
  }
  findField(localName) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i3 = 0; i3 < this.fields.length; i3++) {
        this._lookup[this.fields[i3].localName] = this.fields[i3];
      }
    }
    return this._lookup[localName];
  }
};
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a3, _b, _c3, _d, _e3, _f;
  const r4 = [];
  let o4;
  for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f3 = field;
    f3.localName = localFieldName(field.name, field.oneof !== void 0);
    f3.jsonName = (_a3 = field.jsonName) !== null && _a3 !== void 0 ? _a3 : fieldJsonName(field.name);
    f3.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
    if (field.kind == "scalar") {
      f3.L = (_c3 = field.L) !== null && _c3 !== void 0 ? _c3 : LongType.BIGINT;
    }
    f3.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
    f3.req = (_e3 = field.req) !== null && _e3 !== void 0 ? _e3 : false;
    f3.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
    if (field.packed === void 0) {
      {
        f3.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      }
    }
    if (field.oneof !== void 0) {
      const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
      if (!o4 || o4.name != ooname) {
        o4 = new InternalOneofInfo(ooname);
      }
      f3.oneof = o4;
      o4.addField(f3);
    }
    r4.push(f3);
  }
  return r4;
}
var proto3 = makeProtoRuntime(
  "proto3",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name = member.localName, t3 = target;
      if (member.repeated) {
        t3[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t3[name] = {
            case: void 0
          };
          break;
        case "enum":
          t3[name] = 0;
          break;
        case "map":
          t3[name] = {};
          break;
        case "scalar":
          t3[name] = scalarZeroValue(member.T, member.L);
          break;
      }
    }
  }
);
var Timestamp = class _Timestamp extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto3.util.initPartial(data, this);
  }
  fromJson(json, options) {
    if (typeof json !== "string") {
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));
    }
    const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    }
    const ms3 = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms3)) {
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    }
    if (ms3 < Date.parse("0001-01-01T00:00:00Z") || ms3 > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    }
    this.seconds = protoInt64.parse(ms3 / 1e3);
    this.nanos = 0;
    if (matches[7]) {
      this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    }
    return this;
  }
  toJson(options) {
    const ms3 = Number(this.seconds) * 1e3;
    if (ms3 < Date.parse("0001-01-01T00:00:00Z") || ms3 > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    }
    if (this.nanos < 0) {
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    }
    let z3 = "Z";
    if (this.nanos > 0) {
      const nanosStr = (this.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000") {
        z3 = "." + nanosStr.substring(0, 3) + "Z";
      } else if (nanosStr.substring(6) === "000") {
        z3 = "." + nanosStr.substring(0, 6) + "Z";
      } else {
        z3 = "." + nanosStr + "Z";
      }
    }
    return new Date(ms3).toISOString().replace(".000Z", z3);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(date) {
    const ms3 = date.getTime();
    return new _Timestamp({
      seconds: protoInt64.parse(Math.floor(ms3 / 1e3)),
      nanos: ms3 % 1e3 * 1e6
    });
  }
  static fromBinary(bytes, options) {
    return new _Timestamp().fromBinary(bytes, options);
  }
  static fromJson(jsonValue, options) {
    return new _Timestamp().fromJson(jsonValue, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Timestamp().fromJsonString(jsonString, options);
  }
  static equals(a3, b3) {
    return proto3.util.equals(_Timestamp, a3, b3);
  }
};
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
var MetricsBatch = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricsBatch", () => [{
  no: 1,
  name: "timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "normalized_timestamp",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "str_data",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 4,
  name: "time_series",
  kind: "message",
  T: TimeSeriesMetric,
  repeated: true
}, {
  no: 5,
  name: "events",
  kind: "message",
  T: EventMetric,
  repeated: true
}]);
var TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.TimeSeriesMetric", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "samples",
  kind: "message",
  T: MetricSample,
  repeated: true
}, {
  no: 5,
  name: "rid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var MetricSample = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricSample", () => [{
  no: 1,
  name: "timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "normalized_timestamp",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "value",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]);
var EventMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.EventMetric", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "participant_identity",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "track_sid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "start_timestamp_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 5,
  name: "end_timestamp_ms",
  kind: "scalar",
  T: 3,
  opt: true
}, {
  no: 6,
  name: "normalized_start_timestamp",
  kind: "message",
  T: Timestamp
}, {
  no: 7,
  name: "normalized_end_timestamp",
  kind: "message",
  T: Timestamp,
  opt: true
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "rid",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum("livekit.BackupCodecPolicy", [{
  no: 0,
  name: "PREFER_REGRESSION"
}, {
  no: 1,
  name: "SIMULCAST"
}, {
  no: 2,
  name: "REGRESSION"
}]);
var TrackType = /* @__PURE__ */ proto3.makeEnum("livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]);
var TrackSource = /* @__PURE__ */ proto3.makeEnum("livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]);
var VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]);
var ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]);
var ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum("livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]);
var DisconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}, {
  no: 10,
  name: "ROOM_CLOSED"
}, {
  no: 11,
  name: "USER_UNAVAILABLE"
}, {
  no: 12,
  name: "USER_REJECTED"
}, {
  no: 13,
  name: "SIP_TRUNK_FAILURE"
}, {
  no: 14,
  name: "CONNECTION_TIMEOUT"
}, {
  no: 15,
  name: "MEDIA_FAILURE"
}]);
var ReconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]);
var SubscriptionError = /* @__PURE__ */ proto3.makeEnum("livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]);
var AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum("livekit.AudioTrackFeature", [{
  no: 0,
  name: "TF_STEREO"
}, {
  no: 1,
  name: "TF_NO_DTX"
}, {
  no: 2,
  name: "TF_AUTO_GAIN_CONTROL"
}, {
  no: 3,
  name: "TF_ECHO_CANCELLATION"
}, {
  no: 4,
  name: "TF_NOISE_SUPPRESSION"
}, {
  no: 5,
  name: "TF_ENHANCED_NOISE_CANCELLATION"
}, {
  no: 6,
  name: "TF_PRECONNECT_BUFFER"
}]);
var Room$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.Room", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 14,
  name: "departure_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 15,
  name: "creation_time_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: true
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]);
var Codec = /* @__PURE__ */ proto3.makeMessageType("livekit.Codec", () => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantPermission", () => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: true
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 12,
  name: "can_subscribe_metrics",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: true
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 17,
  name: "joined_at_ms",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}, {
  no: 15,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 16,
  name: "disconnect_reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 18,
  name: "kind_details",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_KindDetail),
  repeated: true
}]);
var ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]);
var ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
var ParticipantInfo_KindDetail = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.KindDetail", [{
  no: 0,
  name: "CLOUD_AGENT"
}, {
  no: 1,
  name: "FORWARDED"
}]);
var Encryption_Type = /* @__PURE__ */ proto3.makeEnum("livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]);
var SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: true
}]);
var TrackInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: true
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: true
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}, {
  no: 19,
  name: "audio_features",
  kind: "enum",
  T: proto3.getEnumType(AudioTrackFeature),
  repeated: true
}, {
  no: 20,
  name: "backup_codec_policy",
  kind: "enum",
  T: proto3.getEnumType(BackupCodecPolicy$1)
}]);
var VideoLayer = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoLayer", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "spatial_layer",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 7,
  name: "rid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var DataPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.DataPacket", () => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}, {
  no: 6,
  name: "sip_dtmf",
  kind: "message",
  T: SipDTMF,
  oneof: "value"
}, {
  no: 7,
  name: "transcription",
  kind: "message",
  T: Transcription,
  oneof: "value"
}, {
  no: 8,
  name: "metrics",
  kind: "message",
  T: MetricsBatch,
  oneof: "value"
}, {
  no: 9,
  name: "chat_message",
  kind: "message",
  T: ChatMessage,
  oneof: "value"
}, {
  no: 10,
  name: "rpc_request",
  kind: "message",
  T: RpcRequest,
  oneof: "value"
}, {
  no: 11,
  name: "rpc_ack",
  kind: "message",
  T: RpcAck,
  oneof: "value"
}, {
  no: 12,
  name: "rpc_response",
  kind: "message",
  T: RpcResponse,
  oneof: "value"
}, {
  no: 13,
  name: "stream_header",
  kind: "message",
  T: DataStream_Header,
  oneof: "value"
}, {
  no: 14,
  name: "stream_chunk",
  kind: "message",
  T: DataStream_Chunk,
  oneof: "value"
}, {
  no: 15,
  name: "stream_trailer",
  kind: "message",
  T: DataStream_Trailer,
  oneof: "value"
}, {
  no: 16,
  name: "sequence",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 17,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]);
var ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: true
}]);
var SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakerInfo", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var UserPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.UserPacket", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: true
}, {
  no: 8,
  name: "id",
  kind: "scalar",
  T: 9,
  opt: true
}, {
  no: 9,
  name: "start_time",
  kind: "scalar",
  T: 4,
  opt: true
}, {
  no: 10,
  name: "end_time",
  kind: "scalar",
  T: 4,
  opt: true
}, {
  no: 11,
  name: "nonce",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]);
var SipDTMF = /* @__PURE__ */ proto3.makeMessageType("livekit.SipDTMF", () => [{
  no: 3,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "digit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var Transcription = /* @__PURE__ */ proto3.makeMessageType("livekit.Transcription", () => [{
  no: 2,
  name: "transcribed_participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "track_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "segments",
  kind: "message",
  T: TranscriptionSegment,
  repeated: true
}]);
var TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType("livekit.TranscriptionSegment", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "text",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "start_time",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 4,
  name: "end_time",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "final",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "language",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ChatMessage = /* @__PURE__ */ proto3.makeMessageType("livekit.ChatMessage", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "edit_timestamp",
  kind: "scalar",
  T: 3,
  opt: true
}, {
  no: 4,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "deleted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 6,
  name: "generated",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var RpcRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcRequest", () => [{
  no: 1,
  name: "id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "method",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "payload",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "response_timeout_ms",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var RpcAck = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcAck", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var RpcResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcResponse", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 9,
  oneof: "value"
}, {
  no: 3,
  name: "error",
  kind: "message",
  T: RpcError$1,
  oneof: "value"
}]);
var RpcError$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcError", () => [{
  no: 1,
  name: "code",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "data",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantTracks", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: true
}]);
var ServerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ServerInfo", () => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "agent_protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
var ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum("livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]);
var ClientInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientInfo", () => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 11,
  name: "other_sdks",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum("livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}, {
  no: 11,
  name: "UNITY_WEB"
}, {
  no: 12,
  name: "NODE"
}, {
  no: 13,
  name: "UNREAL"
}, {
  no: 14,
  name: "ESP32"
}]);
var ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientConfiguration", () => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
var VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoConfiguration", () => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
var DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType("livekit.DisabledCodecs", () => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: true
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: true
}]);
var TimedVersion = /* @__PURE__ */ proto3.makeMessageType("livekit.TimedVersion", () => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
var DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum("livekit.DataStream.OperationType", [{
  no: 0,
  name: "CREATE"
}, {
  no: 1,
  name: "UPDATE"
}, {
  no: 2,
  name: "DELETE"
}, {
  no: 3,
  name: "REACTION"
}]);
var DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.TextHeader", () => [{
  no: 1,
  name: "operation_type",
  kind: "enum",
  T: proto3.getEnumType(DataStream_OperationType)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 3,
  name: "reply_to_stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "attached_stream_ids",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 5,
  name: "generated",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}], {
  localName: "DataStream_TextHeader"
});
var DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.ByteHeader", () => [{
  no: 1,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}], {
  localName: "DataStream_ByteHeader"
});
var DataStream_Header = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Header", () => [{
  no: 1,
  name: "stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 3,
  name: "topic",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "total_length",
  kind: "scalar",
  T: 4,
  opt: true
}, {
  no: 7,
  name: "encryption_type",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 8,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 9,
  name: "text_header",
  kind: "message",
  T: DataStream_TextHeader,
  oneof: "content_header"
}, {
  no: 10,
  name: "byte_header",
  kind: "message",
  T: DataStream_ByteHeader,
  oneof: "content_header"
}], {
  localName: "DataStream_Header"
});
var DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Chunk", () => [{
  no: 1,
  name: "stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "chunk_index",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 3,
  name: "content",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 4,
  name: "version",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 5,
  name: "iv",
  kind: "scalar",
  T: 12,
  opt: true
}], {
  localName: "DataStream_Chunk"
});
var DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Trailer", () => [{
  no: 1,
  name: "stream_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "reason",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}], {
  localName: "DataStream_Trailer"
});
var SignalTarget = /* @__PURE__ */ proto3.makeEnum("livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]);
var StreamState = /* @__PURE__ */ proto3.makeEnum("livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]);
var CandidateProtocol = /* @__PURE__ */ proto3.makeEnum("livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]);
var SignalRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalRequest", () => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}, {
  no: 17,
  name: "update_audio_track",
  kind: "message",
  T: UpdateLocalAudioTrack,
  oneof: "message"
}, {
  no: 18,
  name: "update_video_track",
  kind: "message",
  T: UpdateLocalVideoTrack,
  oneof: "message"
}]);
var SignalResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalResponse", () => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}, {
  no: 22,
  name: "request_response",
  kind: "message",
  T: RequestResponse,
  oneof: "message"
}, {
  no: 23,
  name: "track_subscribed",
  kind: "message",
  T: TrackSubscribed,
  oneof: "message"
}, {
  no: 24,
  name: "room_moved",
  kind: "message",
  T: RoomMovedResponse,
  oneof: "message"
}]);
var SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.AddTrackRequest", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: true
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: true
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 16,
  name: "backup_codec_policy",
  kind: "enum",
  T: proto3.getEnumType(BackupCodecPolicy$1)
}, {
  no: 17,
  name: "audio_features",
  kind: "enum",
  T: proto3.getEnumType(AudioTrackFeature),
  repeated: true
}]);
var TrickleRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.TrickleRequest", () => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}, {
  no: 3,
  name: "final",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var JoinResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.JoinResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: true
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: true
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 14,
  name: "enabled_publish_codecs",
  kind: "message",
  T: Codec,
  repeated: true
}, {
  no: 15,
  name: "fast_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.ReconnectResponse", () => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: true
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 3,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 4,
  name: "last_message_seq",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
var TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var SessionDescription = /* @__PURE__ */ proto3.makeMessageType("livekit.SessionDescription", () => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: true
}]);
var UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateSubscription", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: true
}]);
var UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalAudioTrack", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "features",
  kind: "enum",
  T: proto3.getEnumType(AudioTrackFeature),
  repeated: true
}]);
var UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalVideoTrack", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var LeaveRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.LeaveRequest", () => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]);
var LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum("livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]);
var UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: true
}]);
var UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "attributes",
  kind: "map",
  K: 9,
  V: {
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
}, {
  no: 4,
  name: "request_id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var ICEServer = /* @__PURE__ */ proto3.makeMessageType("livekit.ICEServer", () => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakersChanged", () => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: true
}]);
var RoomUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.RoomUpdate", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]);
var ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]);
var ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: true
}]);
var StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateInfo", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]);
var StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: true
}]);
var SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQuality", () => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedCodec", () => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: true
}]);
var SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: true
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: true
}]);
var TrackPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPermission", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: true
}]);
var SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
var RoomMovedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RoomMovedResponse", () => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "token",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 4,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: true
}]);
var SyncState = /* @__PURE__ */ proto3.makeMessageType("livekit.SyncState", () => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: true
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: true
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: true
}, {
  no: 7,
  name: "datachannel_receive_states",
  kind: "message",
  T: DataChannelReceiveState,
  repeated: true
}]);
var DataChannelReceiveState = /* @__PURE__ */ proto3.makeMessageType("livekit.DataChannelReceiveState", () => [{
  no: 1,
  name: "publisher_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "last_seq",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
var DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.DataChannelInfo", () => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]);
var SimulateScenario = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulateScenario", () => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 9,
  name: "leave_request_full_reconnect",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]);
var Ping = /* @__PURE__ */ proto3.makeMessageType("livekit.Ping", () => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
var Pong = /* @__PURE__ */ proto3.makeMessageType("livekit.Pong", () => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
var RegionSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionSettings", () => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: true
}]);
var RegionInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionInfo", () => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
var SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]);
var RequestResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RequestResponse", () => [{
  no: 1,
  name: "request_id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(RequestResponse_Reason)
}, {
  no: 3,
  name: "message",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum("livekit.RequestResponse.Reason", [{
  no: 0,
  name: "OK"
}, {
  no: 1,
  name: "NOT_FOUND"
}, {
  no: 2,
  name: "NOT_ALLOWED"
}, {
  no: 3,
  name: "LIMIT_EXCEEDED"
}]);
var TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackSubscribed", () => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
var loglevel$1 = { exports: {} };
var loglevel = loglevel$1.exports;
var hasRequiredLoglevel;
function requireLoglevel() {
  if (hasRequiredLoglevel)
    return loglevel$1.exports;
  hasRequiredLoglevel = 1;
  (function(module) {
    (function(root, definition) {
      if (module.exports) {
        module.exports = definition();
      } else {
        root.log = definition();
      }
    })(loglevel, function() {
      var noop = function() {
      };
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = ["trace", "debug", "info", "warn", "error"];
      var _loggersByName = {};
      var defaultLogger = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e4) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace)
          console.trace();
      }
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i3 = 0; i3 < logMethods.length; i3++) {
          var methodName = logMethods[i3];
          this[methodName] = i3 < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      function Logger(name, factory) {
        var self = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];
              }
            } catch (ignore) {
            }
          }
          if (self.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey)
            return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== void 0) {
            level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        self.name = name;
        self.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self.methodFactory = factory || defaultMethodFactory;
        self.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self);
        };
        self.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self.setLevel(level, false);
          }
        };
        self.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self);
        };
        self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
        };
        self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
        };
        self.rebuild = function() {
          if (defaultLogger !== self) {
            inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self);
          if (defaultLogger === self) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self);
      }
      defaultLogger = new Logger();
      defaultLogger.getLogger = function getLogger2(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
        }
        return logger;
      };
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger) {
          window.log = _log;
        }
        return defaultLogger;
      };
      defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
      };
      defaultLogger["default"] = defaultLogger;
      return defaultLogger;
    });
  })(loglevel$1);
  return loglevel$1.exports;
}
var loglevelExports = requireLoglevel();
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["trace"] = 0] = "trace";
  LogLevel2[LogLevel2["debug"] = 1] = "debug";
  LogLevel2[LogLevel2["info"] = 2] = "info";
  LogLevel2[LogLevel2["warn"] = 3] = "warn";
  LogLevel2[LogLevel2["error"] = 4] = "error";
  LogLevel2[LogLevel2["silent"] = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(LoggerNames2) {
  LoggerNames2["Default"] = "livekit";
  LoggerNames2["Room"] = "livekit-room";
  LoggerNames2["Participant"] = "livekit-participant";
  LoggerNames2["Track"] = "livekit-track";
  LoggerNames2["Publication"] = "livekit-track-publication";
  LoggerNames2["Engine"] = "livekit-engine";
  LoggerNames2["Signal"] = "livekit-signal";
  LoggerNames2["PCManager"] = "livekit-pc-manager";
  LoggerNames2["PCTransport"] = "livekit-pc-transport";
  LoggerNames2["E2EE"] = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
var livekitLogger = loglevelExports.getLogger("livekit");
var livekitLoggers = Object.values(LoggerNames).map((name) => loglevelExports.getLogger(name));
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(name) {
  const logger = loglevelExports.getLogger(name);
  logger.setDefaultLevel(livekitLogger.getLevel());
  return logger;
}
var workerLogger = loglevelExports.getLogger("lk-e2ee");
var maxRetryDelay = 7e3;
var DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
var DefaultReconnectPolicy = class {
  constructor(retryDelays) {
    this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(context) {
    if (context.retryCount >= this._retryDelays.length)
      return null;
    const retryDelay = this._retryDelays[context.retryCount];
    if (context.retryCount <= 1)
      return retryDelay;
    return retryDelay + Math.random() * 1e3;
  }
};
function __rest(s3, e4) {
  var t3 = {};
  for (var p3 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p3) && e4.indexOf(p3) < 0)
      t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e4.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t3[p3[i3]] = s3[p3[i3]];
    }
  return t3;
}
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o4) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o4[s3], i3 = 0;
  if (m3)
    return m3.call(o4);
  if (o4 && typeof o4.length === "number")
    return {
      next: function() {
        if (o4 && i3 >= o4.length)
          o4 = void 0;
        return { value: o4 && o4[i3++], done: !o4 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(o4) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o4[Symbol.asyncIterator], i3;
  return m3 ? m3.call(o4) : (o4 = typeof __values === "function" ? __values(o4) : o4[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n3) {
    i3[n3] = o4[n3] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o4[n3](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d3, v3) {
    Promise.resolve(v3).then(function(v5) {
      resolve({ value: v5, done: d3 });
    }, reject);
  }
}
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents)
    return events.exports;
  hasRequiredEvents = 1;
  var R3 = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R3 && typeof R3.ownKeys === "function") {
    ReflectOwnKeys = R3.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn)
      console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n3) {
    if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
    }
    this._maxListeners = n3;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i3 = 1; i3 < arguments.length; i3++)
      args.push(arguments[i3]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er3;
      if (args.length > 0)
        er3 = args[0];
      if (er3 instanceof Error) {
        throw er3;
      }
      var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
      err.context = er3;
      throw err;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i3 = 0; i3 < len; ++i3)
        ReflectApply(listeners[i3], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m3;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit("newListener", type, listener.listener ? listener.listener : listener);
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m3 = _getMaxListeners(target);
      if (m3 > 0 && existing.length > m3 && !existing.warned) {
        existing.warned = true;
        var w3 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w3.name = "MaxListenersExceededWarning";
        w3.emitter = target;
        w3.type = type;
        w3.count = existing.length;
        ProcessEmitWarning(w3);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state = {
      fired: false,
      wrapFn: void 0,
      target,
      type,
      listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events2, position, i3, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i3 = list.length - 1; i3 >= 0; i3--) {
        if (list[i3] === listener || list[i3].listener === listener) {
          originalListener = list[i3].listener;
          position = i3;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events2, i3;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i3 = 0; i3 < keys.length; ++i3) {
        key = keys[i3];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== void 0) {
      for (i3 = listeners.length - 1; i3 >= 0; i3--) {
        this.removeListener(type, listeners[i3]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n3) {
    var copy = new Array(n3);
    for (var i3 = 0; i3 < n3; ++i3)
      copy[i3] = arr[i3];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i3 = 0; i3 < ret.length; ++i3) {
      ret[i3] = arr[i3].listener || arr[i3];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, {
        once: true
      });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, {
          once: true
        });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var eventsExports = requireEvents();
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseFloat(match[pos], 10);
}
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e4) => {
      const modifiedEvent = wrapper(e4);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window2) {
  const result = {
    browser: null,
    version: null
  };
  if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
    result.browser = "Not a browser.";
    return result;
  }
  const {
    navigator: navigator2
  } = window2;
  if (navigator2.userAgentData && navigator2.userAgentData.brands) {
    const chromium = navigator2.userAgentData.brands.find((brand) => {
      return brand.brand === "Chromium";
    });
    if (chromium) {
      return {
        browser: "chrome",
        version: parseInt(chromium.version, 10)
      };
    }
  }
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = parseInt(extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1));
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = parseInt(extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = parseInt(extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1));
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    result._safariVersion = extractVersion(navigator2.userAgent, /Version\/(\d+(\.?\d+))/, 1);
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }
  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, {
      [key]: value
    });
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name) => {
    if (name.endsWith("Id")) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith("Ids")) {
      base[name].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track2, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track2 === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track2.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}
var logging = log;
function shimGetUserMedia$2(window2, browserDetails2) {
  const navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c3) {
    if (typeof c3 !== "object" || c3.mandatory || c3.optional) {
      return c3;
    }
    const cc3 = {};
    Object.keys(c3).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r4 = typeof c3[key] === "object" ? c3[key] : {
        ideal: c3[key]
      };
      if (r4.exact !== void 0 && typeof r4.exact === "number") {
        r4.min = r4.max = r4.exact;
      }
      const oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === "deviceId" ? "sourceId" : name;
      };
      if (r4.ideal !== void 0) {
        cc3.optional = cc3.optional || [];
        let oc3 = {};
        if (typeof r4.ideal === "number") {
          oc3[oldname_("min", key)] = r4.ideal;
          cc3.optional.push(oc3);
          oc3 = {};
          oc3[oldname_("max", key)] = r4.ideal;
          cc3.optional.push(oc3);
        } else {
          oc3[oldname_("", key)] = r4.ideal;
          cc3.optional.push(oc3);
        }
      }
      if (r4.exact !== void 0 && typeof r4.exact !== "number") {
        cc3.mandatory = cc3.mandatory || {};
        cc3.mandatory[oldname_("", key)] = r4.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r4[mix] !== void 0) {
            cc3.mandatory = cc3.mandatory || {};
            cc3.mandatory[oldname_(mix, key)] = r4[mix];
          }
        });
      }
    });
    if (c3.advanced) {
      cc3.optional = (cc3.optional || []).concat(c3.advanced);
    }
    return cc3;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails2.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a3, b3) {
        if (a3 in obj && !(b3 in obj)) {
          obj[b3] = obj[a3];
          delete obj[a3];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : {
        ideal: face
      });
      const getSupportedFacingModeLies = browserDetails2.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d3) => d3.kind === "videoinput");
            let dev = devices.find((d3) => matches.some((match) => d3.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {
                exact: dev.deviceId
              } : {
                ideal: dev.deviceId
              };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e4) {
    if (browserDetails2.version >= 64) {
      return e4;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e4.name] || e4.name,
      message: e4.message,
      constraint: e4.constraint || e4.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c3) => {
      navigator2.webkitGetUserMedia(c3, onSuccess, (e4) => {
        if (onError) {
          onError(shimError_(e4));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs3) {
      return shimConstraints_(cs3, (c3) => origGetUserMedia(c3).then((stream) => {
        if (c3.audio && !stream.getAudioTracks().length || c3.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track2) => {
            track2.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e4) => Promise.reject(shimError_(e4))));
    };
  }
}
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
function shimOnTrack$1(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f3) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f3);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e4) => {
          e4.stream.addEventListener("addtrack", (te3) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r4) => r4.track && r4.track.id === te3.track.id);
            } else {
              receiver = {
                track: te3.track
              };
            }
            const event = new Event("track");
            event.track = te3.track;
            event.receiver = receiver;
            event.transceiver = {
              receiver
            };
            event.streams = [e4.stream];
            this.dispatchEvent(event);
          });
          e4.stream.getTracks().forEach((track2) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r4) => r4.track && r4.track.id === track2.id);
            } else {
              receiver = {
                track: track2
              };
            }
            const event = new Event("track");
            event.track = track2;
            event.receiver = receiver;
            event.transceiver = {
              receiver
            };
            event.streams = [e4.stream];
            this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window2, "track", (e4) => {
      if (!e4.transceiver) {
        Object.defineProperty(e4, "transceiver", {
          value: {
            receiver: e4.receiver
          }
        });
      }
      return e4;
    });
  }
}
function shimGetSendersWithDtmf(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc3, track2) {
      return {
        track: track2,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track2.kind === "audio") {
              this._dtmf = pc3.createDTMFSender(track2);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc3
      };
    };
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track2);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track2) => {
        this._senders.push(shimSenderWithDtmf(this, track2));
      });
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track2) => {
        const sender = this._senders.find((s3) => s3.track === track2);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimSenderReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(result, sender.track, true)
      ));
    };
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e4) => {
      e4.receiver._pc = e4.srcElement;
      return e4;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      const track2 = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s3) => {
        if (s3.track === track2) {
          if (sender) {
            err = true;
          } else {
            sender = s3;
          }
        }
      });
      this.getReceivers().forEach((r4) => {
        if (r4.track === track2) {
          if (receiver) {
            err = true;
          } else {
            receiver = r4;
          }
        }
        return r4.track === track2;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track2) => {
      const alreadyExists = this.getSenders().find((s3) => s3.track === track2);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails2.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track2) => {
      const alreadyExists = this.getSenders().find((s3) => s3.track === track2);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t3) => t3 === track2)) {
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    }
    const alreadyExists = this.getSenders().find((s3) => s3.track === track2);
    if (alreadyExists) {
      throw new DOMException("Track already exists.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track2);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window2.MediaStream([track2]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s3) => s3.track === track2);
  };
  function replaceInternalStreamId(pc3, description) {
    let sdp2 = description.sdp;
    Object.keys(pc3._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc3._reverseStreams[internalId];
      const internalStream = pc3._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc3, description) {
    let sdp2 = description.sdp;
    Object.keys(pc3._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc3._reverseStreams[internalId];
      const internalStream = pc3._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window2.RTCPeerConnection.prototype[method];
    const methodObj = {
      [method]() {
        const args = arguments;
        const isLegacyCall = arguments.length && typeof arguments[0] === "function";
        if (isLegacyCall) {
          return nativeMethod.apply(this, [(description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          }, (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          }, arguments[2]]);
        }
        return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
      }
    };
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const description = origLocalDescription.get.apply(this);
      if (description.type === "") {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track2) => sender.track === track2);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection$1(window2, browserDetails2) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails2.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window2, browserDetails2) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", (e4) => {
    const pc3 = e4.target;
    if (browserDetails2.version < 72 || pc3.getConfiguration && pc3.getConfiguration().sdpSemantics === "plan-b") {
      if (pc3.signalingState !== "stable") {
        return;
      }
    }
    return e4;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetSendersWithDtmf,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(window2, browserDetails2) {
  const navigator2 = window2 && window2.navigator;
  const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails2.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a3, b3) {
      if (a3 in obj && !(b3 in obj)) {
        obj[b3] = obj[a3];
        delete obj[a3];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c3) {
      if (typeof c3 === "object" && typeof c3.audio === "object") {
        c3 = JSON.parse(JSON.stringify(c3));
        remap(c3.audio, "autoGainControl", "mozAutoGainControl");
        remap(c3.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c3);
    };
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
      MediaStreamTrack2.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
      MediaStreamTrack2.prototype.applyConstraints = function(c3) {
        if (this.kind === "audio" && typeof c3 === "object") {
          c3 = JSON.parse(JSON.stringify(c3));
          remap(c3, "autoGainControl", "mozAutoGainControl");
          remap(c3, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c3]);
      };
    }
  }
}
function shimGetDisplayMedia(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = {
        mediaSource: preferredMediaSource
      };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  };
}
function shimOnTrack(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimPeerConnection(window2, browserDetails2) {
  if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails2.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
          return nativeMethod.apply(this, arguments);
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails2.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e4) {
          if (e4.name !== "TypeError") {
            throw e4;
          }
          stats.forEach((stat, i3) => {
            stats.set(i3, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window2.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window2, "track", (e4) => {
    e4.receiver._pc = e4.srcElement;
    return e4;
  });
  window2.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
function shimAddTransceiver(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      let sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = [...sendEncodings];
      const shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const {
          sender
        } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).then(() => {
            delete sender.sendEncodings;
          }).catch(() => {
            delete sender.sendEncodings;
          }));
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window2) {
  if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track2) => _addTrack.call(this, track2, stream));
      stream.getVideoTracks().forEach((track2) => _addTrack.call(this, track2, stream));
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2) {
      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        streams[_key - 1] = arguments[_key];
      }
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f3) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f3);
        this.addEventListener("track", this._onaddstreampoly = (e4) => {
          e4.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc3 = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e4) {
          e4.streams.forEach((stream) => {
            if (!pc3._remoteStreams) {
              pc3._remoteStreams = [];
            }
            if (pc3._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc3._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            pc3.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc3, arguments);
    };
  }
}
function shimCallbacksAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  const prototype = window2.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window2) {
  const navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }.bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign({}, constraints, {
      video: compactObject(constraints.video)
    });
  }
  return constraints;
}
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i3 = 0; i3 < pcConfig.iceServers.length; i3++) {
        let server = pcConfig.iceServers[i3];
        if (server.urls === void 0 && server.url) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i3]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimCreateOfferLegacy(window2) {
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", {
          direction: "recvonly"
        });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", {
          direction: "recvonly"
        });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window2) {
  if (typeof window2 !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
});
var sdp$1 = { exports: {} };
var hasRequiredSdp;
function requireSdp() {
  if (hasRequiredSdp)
    return sdp$1.exports;
  hasRequiredSdp = 1;
  (function(module) {
    const SDPUtils2 = {};
    SDPUtils2.generateIdentifier = function() {
      return Math.random().toString(36).substring(2, 12);
    };
    SDPUtils2.localCName = SDPUtils2.generateIdentifier();
    SDPUtils2.splitLines = function(blob) {
      return blob.trim().split("\n").map((line) => line.trim());
    };
    SDPUtils2.splitSections = function(blob) {
      const parts = blob.split("\nm=");
      return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
    };
    SDPUtils2.getDescription = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      return sections && sections[0];
    };
    SDPUtils2.getMediaSections = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      sections.shift();
      return sections;
    };
    SDPUtils2.matchPrefix = function(blob, prefix) {
      return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
    };
    SDPUtils2.parseCandidate = function(line) {
      let parts;
      if (line.indexOf("a=candidate:") === 0) {
        parts = line.substring(12).split(" ");
      } else {
        parts = line.substring(10).split(" ");
      }
      const candidate = {
        foundation: parts[0],
        component: {
          1: "rtp",
          2: "rtcp"
        }[parts[1]] || parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parseInt(parts[3], 10),
        ip: parts[4],
        address: parts[4],
        // address is an alias for ip.
        port: parseInt(parts[5], 10),
        // skip parts[6] == 'typ'
        type: parts[7]
      };
      for (let i3 = 8; i3 < parts.length; i3 += 2) {
        switch (parts[i3]) {
          case "raddr":
            candidate.relatedAddress = parts[i3 + 1];
            break;
          case "rport":
            candidate.relatedPort = parseInt(parts[i3 + 1], 10);
            break;
          case "tcptype":
            candidate.tcpType = parts[i3 + 1];
            break;
          case "ufrag":
            candidate.ufrag = parts[i3 + 1];
            candidate.usernameFragment = parts[i3 + 1];
            break;
          default:
            if (candidate[parts[i3]] === void 0) {
              candidate[parts[i3]] = parts[i3 + 1];
            }
            break;
        }
      }
      return candidate;
    };
    SDPUtils2.writeCandidate = function(candidate) {
      const sdp2 = [];
      sdp2.push(candidate.foundation);
      const component = candidate.component;
      if (component === "rtp") {
        sdp2.push(1);
      } else if (component === "rtcp") {
        sdp2.push(2);
      } else {
        sdp2.push(component);
      }
      sdp2.push(candidate.protocol.toUpperCase());
      sdp2.push(candidate.priority);
      sdp2.push(candidate.address || candidate.ip);
      sdp2.push(candidate.port);
      const type = candidate.type;
      sdp2.push("typ");
      sdp2.push(type);
      if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
        sdp2.push("raddr");
        sdp2.push(candidate.relatedAddress);
        sdp2.push("rport");
        sdp2.push(candidate.relatedPort);
      }
      if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
        sdp2.push("tcptype");
        sdp2.push(candidate.tcpType);
      }
      if (candidate.usernameFragment || candidate.ufrag) {
        sdp2.push("ufrag");
        sdp2.push(candidate.usernameFragment || candidate.ufrag);
      }
      return "candidate:" + sdp2.join(" ");
    };
    SDPUtils2.parseIceOptions = function(line) {
      return line.substring(14).split(" ");
    };
    SDPUtils2.parseRtpMap = function(line) {
      let parts = line.substring(9).split(" ");
      const parsed = {
        payloadType: parseInt(parts.shift(), 10)
        // was: id
      };
      parts = parts[0].split("/");
      parsed.name = parts[0];
      parsed.clockRate = parseInt(parts[1], 10);
      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
      parsed.numChannels = parsed.channels;
      return parsed;
    };
    SDPUtils2.writeRtpMap = function(codec) {
      let pt3 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt3 = codec.preferredPayloadType;
      }
      const channels = codec.channels || codec.numChannels || 1;
      return "a=rtpmap:" + pt3 + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
    };
    SDPUtils2.parseExtmap = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        id: parseInt(parts[0], 10),
        direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
        uri: parts[1],
        attributes: parts.slice(2).join(" ")
      };
    };
    SDPUtils2.writeExtmap = function(headerExtension) {
      return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
    };
    SDPUtils2.parseFmtp = function(line) {
      const parsed = {};
      let kv;
      const parts = line.substring(line.indexOf(" ") + 1).split(";");
      for (let j3 = 0; j3 < parts.length; j3++) {
        kv = parts[j3].trim().split("=");
        parsed[kv[0].trim()] = kv[1];
      }
      return parsed;
    };
    SDPUtils2.writeFmtp = function(codec) {
      let line = "";
      let pt3 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt3 = codec.preferredPayloadType;
      }
      if (codec.parameters && Object.keys(codec.parameters).length) {
        const params = [];
        Object.keys(codec.parameters).forEach((param) => {
          if (codec.parameters[param] !== void 0) {
            params.push(param + "=" + codec.parameters[param]);
          } else {
            params.push(param);
          }
        });
        line += "a=fmtp:" + pt3 + " " + params.join(";") + "\r\n";
      }
      return line;
    };
    SDPUtils2.parseRtcpFb = function(line) {
      const parts = line.substring(line.indexOf(" ") + 1).split(" ");
      return {
        type: parts.shift(),
        parameter: parts.join(" ")
      };
    };
    SDPUtils2.writeRtcpFb = function(codec) {
      let lines = "";
      let pt3 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt3 = codec.preferredPayloadType;
      }
      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
        codec.rtcpFeedback.forEach((fb) => {
          lines += "a=rtcp-fb:" + pt3 + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
        });
      }
      return lines;
    };
    SDPUtils2.parseSsrcMedia = function(line) {
      const sp = line.indexOf(" ");
      const parts = {
        ssrc: parseInt(line.substring(7, sp), 10)
      };
      const colon = line.indexOf(":", sp);
      if (colon > -1) {
        parts.attribute = line.substring(sp + 1, colon);
        parts.value = line.substring(colon + 1);
      } else {
        parts.attribute = line.substring(sp + 1);
      }
      return parts;
    };
    SDPUtils2.parseSsrcGroup = function(line) {
      const parts = line.substring(13).split(" ");
      return {
        semantics: parts.shift(),
        ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
      };
    };
    SDPUtils2.getMid = function(mediaSection) {
      const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
      if (mid) {
        return mid.substring(6);
      }
    };
    SDPUtils2.parseFingerprint = function(line) {
      const parts = line.substring(14).split(" ");
      return {
        algorithm: parts[0].toLowerCase(),
        // algorithm is case-sensitive in Edge.
        value: parts[1].toUpperCase()
        // the definition is upper-case in RFC 4572.
      };
    };
    SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
      return {
        role: "auto",
        fingerprints: lines.map(SDPUtils2.parseFingerprint)
      };
    };
    SDPUtils2.writeDtlsParameters = function(params, setupType) {
      let sdp2 = "a=setup:" + setupType + "\r\n";
      params.fingerprints.forEach((fp) => {
        sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
      });
      return sdp2;
    };
    SDPUtils2.parseCryptoLine = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        tag: parseInt(parts[0], 10),
        cryptoSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3)
      };
    };
    SDPUtils2.writeCryptoLine = function(parameters) {
      return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
    };
    SDPUtils2.parseCryptoKeyParams = function(keyParams) {
      if (keyParams.indexOf("inline:") !== 0) {
        return null;
      }
      const parts = keyParams.substring(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: parts[0],
        lifeTime: parts[1],
        mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
        mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
      };
    };
    SDPUtils2.writeCryptoKeyParams = function(keyParams) {
      return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
    };
    SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
      return lines.map(SDPUtils2.parseCryptoLine);
    };
    SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
      const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
      const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
      if (!(ufrag && pwd)) {
        return null;
      }
      return {
        usernameFragment: ufrag.substring(12),
        password: pwd.substring(10)
      };
    };
    SDPUtils2.writeIceParameters = function(params) {
      let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
      if (params.iceLite) {
        sdp2 += "a=ice-lite\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseRtpParameters = function(mediaSection) {
      const description = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      };
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      description.profile = mline[2];
      for (let i3 = 3; i3 < mline.length; i3++) {
        const pt3 = mline[i3];
        const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt3 + " ")[0];
        if (rtpmapline) {
          const codec = SDPUtils2.parseRtpMap(rtpmapline);
          const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt3 + " ");
          codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
          codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt3 + " ").map(SDPUtils2.parseRtcpFb);
          description.codecs.push(codec);
          switch (codec.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              description.fecMechanisms.push(codec.name.toUpperCase());
              break;
          }
        }
      }
      SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
        description.headerExtensions.push(SDPUtils2.parseExtmap(line));
      });
      const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
      description.codecs.forEach((codec) => {
        wildcardRtcpFb.forEach((fb) => {
          const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
          });
          if (!duplicate) {
            codec.rtcpFeedback.push(fb);
          }
        });
      });
      return description;
    };
    SDPUtils2.writeRtpDescription = function(kind, caps) {
      let sdp2 = "";
      sdp2 += "m=" + kind + " ";
      sdp2 += caps.codecs.length > 0 ? "9" : "0";
      sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
      sdp2 += caps.codecs.map((codec) => {
        if (codec.preferredPayloadType !== void 0) {
          return codec.preferredPayloadType;
        }
        return codec.payloadType;
      }).join(" ") + "\r\n";
      sdp2 += "c=IN IP4 0.0.0.0\r\n";
      sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
      caps.codecs.forEach((codec) => {
        sdp2 += SDPUtils2.writeRtpMap(codec);
        sdp2 += SDPUtils2.writeFmtp(codec);
        sdp2 += SDPUtils2.writeRtcpFb(codec);
      });
      let maxptime = 0;
      caps.codecs.forEach((codec) => {
        if (codec.maxptime > maxptime) {
          maxptime = codec.maxptime;
        }
      });
      if (maxptime > 0) {
        sdp2 += "a=maxptime:" + maxptime + "\r\n";
      }
      if (caps.headerExtensions) {
        caps.headerExtensions.forEach((extension) => {
          sdp2 += SDPUtils2.writeExtmap(extension);
        });
      }
      return sdp2;
    };
    SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
      const encodingParameters = [];
      const description = SDPUtils2.parseRtpParameters(mediaSection);
      const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
      const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
      const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
      let secondarySsrc;
      const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
        const parts = line.substring(17).split(" ");
        return parts.map((part) => parseInt(part, 10));
      });
      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
        secondarySsrc = flows[0][1];
      }
      description.codecs.forEach((codec) => {
        if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
          let encParam = {
            ssrc: primarySsrc,
            codecPayloadType: parseInt(codec.parameters.apt, 10)
          };
          if (primarySsrc && secondarySsrc) {
            encParam.rtx = {
              ssrc: secondarySsrc
            };
          }
          encodingParameters.push(encParam);
          if (hasRed) {
            encParam = JSON.parse(JSON.stringify(encParam));
            encParam.fec = {
              ssrc: primarySsrc,
              mechanism: hasUlpfec ? "red+ulpfec" : "red"
            };
            encodingParameters.push(encParam);
          }
        }
      });
      if (encodingParameters.length === 0 && primarySsrc) {
        encodingParameters.push({
          ssrc: primarySsrc
        });
      }
      let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
      if (bandwidth.length) {
        if (bandwidth[0].indexOf("b=TIAS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(7), 10);
        } else if (bandwidth[0].indexOf("b=AS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
        } else {
          bandwidth = void 0;
        }
        encodingParameters.forEach((params) => {
          params.maxBitrate = bandwidth;
        });
      }
      return encodingParameters;
    };
    SDPUtils2.parseRtcpParameters = function(mediaSection) {
      const rtcpParameters = {};
      const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
      if (remoteSsrc) {
        rtcpParameters.cname = remoteSsrc.value;
        rtcpParameters.ssrc = remoteSsrc.ssrc;
      }
      const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
      rtcpParameters.reducedSize = rsize.length > 0;
      rtcpParameters.compound = rsize.length === 0;
      const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
      rtcpParameters.mux = mux.length > 0;
      return rtcpParameters;
    };
    SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
      let sdp2 = "";
      if (rtcpParameters.reducedSize) {
        sdp2 += "a=rtcp-rsize\r\n";
      }
      if (rtcpParameters.mux) {
        sdp2 += "a=rtcp-mux\r\n";
      }
      if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
        sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseMsid = function(mediaSection) {
      let parts;
      const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
      if (spec.length === 1) {
        parts = spec[0].substring(7).split(" ");
        return {
          stream: parts[0],
          track: parts[1]
        };
      }
      const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
      if (planB.length > 0) {
        parts = planB[0].value.split(" ");
        return {
          stream: parts[0],
          track: parts[1]
        };
      }
    };
    SDPUtils2.parseSctpDescription = function(mediaSection) {
      const mline = SDPUtils2.parseMLine(mediaSection);
      const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
      let maxMessageSize;
      if (maxSizeLine.length > 0) {
        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
      }
      if (isNaN(maxMessageSize)) {
        maxMessageSize = 65536;
      }
      const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
      if (sctpPort.length > 0) {
        return {
          port: parseInt(sctpPort[0].substring(12), 10),
          protocol: mline.fmt,
          maxMessageSize
        };
      }
      const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
      if (sctpMapLines.length > 0) {
        const parts = sctpMapLines[0].substring(10).split(" ");
        return {
          port: parseInt(parts[0], 10),
          protocol: parts[1],
          maxMessageSize
        };
      }
    };
    SDPUtils2.writeSctpDescription = function(media, sctp) {
      let output = [];
      if (media.protocol !== "DTLS/SCTP") {
        output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
      } else {
        output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
      }
      if (sctp.maxMessageSize !== void 0) {
        output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
      }
      return output.join("");
    };
    SDPUtils2.generateSessionId = function() {
      return Math.random().toString().substr(2, 22);
    };
    SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
      let sessionId;
      const version2 = sessVer !== void 0 ? sessVer : 2;
      if (sessId) {
        sessionId = sessId;
      } else {
        sessionId = SDPUtils2.generateSessionId();
      }
      const user = sessUser || "thisisadapterortc";
      return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    };
    SDPUtils2.getDirection = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.splitLines(mediaSection);
      for (let i3 = 0; i3 < lines.length; i3++) {
        switch (lines[i3]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return lines[i3].substring(2);
        }
      }
      if (sessionpart) {
        return SDPUtils2.getDirection(sessionpart);
      }
      return "sendrecv";
    };
    SDPUtils2.getKind = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      return mline[0].substring(2);
    };
    SDPUtils2.isRejected = function(mediaSection) {
      return mediaSection.split(" ", 2)[1] === "0";
    };
    SDPUtils2.parseMLine = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const parts = lines[0].substring(2).split(" ");
      return {
        kind: parts[0],
        port: parseInt(parts[1], 10),
        protocol: parts[2],
        fmt: parts.slice(3).join(" ")
      };
    };
    SDPUtils2.parseOLine = function(mediaSection) {
      const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
      const parts = line.substring(2).split(" ");
      return {
        username: parts[0],
        sessionId: parts[1],
        sessionVersion: parseInt(parts[2], 10),
        netType: parts[3],
        addressType: parts[4],
        address: parts[5]
      };
    };
    SDPUtils2.isValidSDP = function(blob) {
      if (typeof blob !== "string" || blob.length === 0) {
        return false;
      }
      const lines = SDPUtils2.splitLines(blob);
      for (let i3 = 0; i3 < lines.length; i3++) {
        if (lines[i3].length < 2 || lines[i3].charAt(1) !== "=") {
          return false;
        }
      }
      return true;
    };
    {
      module.exports = SDPUtils2;
    }
  })(sdp$1);
  return sdp$1.exports;
}
var sdpExports = requireSdp();
var SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports);
var sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = function RTCIceCandidate2(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substring(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      for (const key in parsedCandidate) {
        if (!(key in nativeCandidate)) {
          Object.defineProperty(nativeCandidate, key, {
            value: parsedCandidate[key]
          });
        }
      }
      nativeCandidate.toJSON = function toJSON() {
        return {
          candidate: nativeCandidate.candidate,
          sdpMid: nativeCandidate.sdpMid,
          sdpMLineIndex: nativeCandidate.sdpMLineIndex,
          usernameFragment: nativeCandidate.usernameFragment
        };
      };
      return nativeCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", (e4) => {
    if (e4.candidate) {
      Object.defineProperty(e4, "candidate", {
        value: new window2.RTCIceCandidate(e4.candidate),
        writable: "false"
      });
    }
    return e4;
  });
}
function shimRTCIceCandidateRelayProtocol(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window2, "icecandidate", (e4) => {
    if (e4.candidate) {
      const parsedCandidate = SDPUtils.parseCandidate(e4.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e4.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e4;
  });
}
function shimMaxMessageSize(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = SDPUtils.splitSections(description.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = SDPUtils.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description) {
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version2 = parseInt(match[1], 10);
    return version2 !== version2 ? -1 : version2;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails2.browser === "firefox") {
      if (browserDetails2.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails2.version < 60) {
        canSendMaxMessageSize = browserDetails2.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails2.browser === "firefox" && browserDetails2.version === 57) {
      maxMessageSize = 65535;
    }
    const match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substring(19), 10);
    } else if (browserDetails2.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails2.browser === "chrome" && browserDetails2.version >= 76) {
      const {
        sdpSemantics
      } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc3, pc3) {
    const origDataChannelSend = dc3.send;
    dc3.send = function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc3.readyState === "open" && pc3.sctp && length > pc3.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc3.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc3, arguments);
    };
  }
  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window2, "datachannel", (e4) => {
    wrapDcSend(e4.channel, e4.target);
    return e4;
  });
}
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e4) => {
          const pc3 = e4.target;
          if (pc3._lastConnectionState !== pc3.connectionState) {
            pc3._lastConnectionState = pc3.connectionState;
            const newEvent = new Event("connectionstatechange", e4);
            pc3.dispatchEvent(newEvent);
          }
          return e4;
        };
        this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails2.browser === "chrome" && browserDetails2.version >= 71) {
    return;
  }
  if (browserDetails2.browser === "safari" && browserDetails2._safariVersion >= 13.1) {
    return;
  }
  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window2, browserDetails2) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails2.browser === "chrome" && browserDetails2.version < 78 || browserDetails2.browser === "firefox" && browserDetails2.version < 68 || browserDetails2.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window2, browserDetails2) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = {
      type: desc.type,
      sdp: desc.sdp
    };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d3) => nativeSetLocalDescription.apply(this, [d3]));
  };
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: window2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimSafari: true
  };
  const logging2 = log;
  const browserDetails2 = detectBrowser(window2);
  const adapter = {
    browserDetails: browserDetails2,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (browserDetails2.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter;
      }
      if (browserDetails2.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter;
      }
      logging2("adapter.js shimming chrome.");
      adapter.browserShim = chromeShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$2(window2, browserDetails2);
      shimMediaStream(window2);
      shimPeerConnection$1(window2, browserDetails2);
      shimOnTrack$1(window2);
      shimAddTrackRemoveTrack(window2, browserDetails2);
      shimGetSendersWithDtmf(window2);
      shimSenderReceiverGetStats(window2);
      fixNegotiationNeeded(window2, browserDetails2);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails2);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming firefox.");
      adapter.browserShim = firefoxShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$1(window2, browserDetails2);
      shimPeerConnection(window2, browserDetails2);
      shimOnTrack(window2);
      shimRemoveStream(window2);
      shimSenderGetStats(window2);
      shimReceiverGetStats(window2);
      shimRTCDataChannel(window2);
      shimAddTransceiver(window2);
      shimGetParameters(window2);
      shimCreateOffer(window2);
      shimCreateAnswer(window2);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      break;
    case "safari":
      if (!safariShim || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming safari.");
      adapter.browserShim = safariShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimRTCIceServerUrls(window2);
      shimCreateOfferLegacy(window2);
      shimCallbacksAPI(window2);
      shimLocalStreamsAPI(window2);
      shimRemoteStreamsAPI(window2);
      shimTrackEventTransceiver(window2);
      shimGetUserMedia(window2);
      shimAudioContext(window2);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails2);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter;
}
adapterFactory({
  window: typeof window === "undefined" ? void 0 : window
});
var DECRYPTION_FAILURE_TOLERANCE = 10;
var E2EE_FLAG = "lk_e2ee";
var SALT = "LKFrameEncryptionKey";
var KEY_PROVIDER_DEFAULTS = {
  sharedKey: false,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16
};
var KeyProviderEvent;
(function(KeyProviderEvent2) {
  KeyProviderEvent2["SetKey"] = "setKey";
  KeyProviderEvent2["RatchetRequest"] = "ratchetRequest";
  KeyProviderEvent2["KeyRatcheted"] = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(KeyHandlerEvent2) {
  KeyHandlerEvent2["KeyRatcheted"] = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(EncryptionEvent2) {
  EncryptionEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
  EncryptionEvent2["EncryptionError"] = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(CryptorEvent2) {
  CryptorEvent2["Error"] = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform !== "undefined";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
}
var BaseKeyProvider = class extends eventsExports.EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    this.onKeyRatcheted = (ratchetResult, participantId, keyIndex) => {
      livekitLogger.debug("key ratcheted event received", {
        ratchetResult,
        participantId,
        keyIndex
      });
    };
    this.keyInfoMap = /* @__PURE__ */ new Map();
    this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
    this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(key, participantIdentity, keyIndex) {
    const keyInfo = {
      key,
      participantIdentity,
      keyIndex
    };
    if (!this.options.sharedKey && !participantIdentity) {
      throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
    }
    this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
    this.emit(KeyProviderEvent.SetKey, keyInfo);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(participantIdentity, keyIndex) {
    this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
  }
};
var LivekitError = class extends Error {
  constructor(code, message) {
    super(message || "an error has occured");
    this.name = "LiveKitError";
    this.code = code;
  }
};
var ConnectionErrorReason;
(function(ConnectionErrorReason2) {
  ConnectionErrorReason2[ConnectionErrorReason2["NotAllowed"] = 0] = "NotAllowed";
  ConnectionErrorReason2[ConnectionErrorReason2["ServerUnreachable"] = 1] = "ServerUnreachable";
  ConnectionErrorReason2[ConnectionErrorReason2["InternalError"] = 2] = "InternalError";
  ConnectionErrorReason2[ConnectionErrorReason2["Cancelled"] = 3] = "Cancelled";
  ConnectionErrorReason2[ConnectionErrorReason2["LeaveRequest"] = 4] = "LeaveRequest";
  ConnectionErrorReason2[ConnectionErrorReason2["Timeout"] = 5] = "Timeout";
})(ConnectionErrorReason || (ConnectionErrorReason = {}));
var ConnectionError = class extends LivekitError {
  constructor(message, reason, status, context) {
    super(1, message);
    this.name = "ConnectionError";
    this.status = status;
    this.reason = reason;
    this.context = context;
    this.reasonName = ConnectionErrorReason[reason];
  }
};
var DeviceUnsupportedError = class extends LivekitError {
  constructor(message) {
    super(21, message !== null && message !== void 0 ? message : "device is unsupported");
    this.name = "DeviceUnsupportedError";
  }
};
var TrackInvalidError = class extends LivekitError {
  constructor(message) {
    super(20, message !== null && message !== void 0 ? message : "track is invalid");
    this.name = "TrackInvalidError";
  }
};
var UnsupportedServer = class extends LivekitError {
  constructor(message) {
    super(10, message !== null && message !== void 0 ? message : "unsupported server");
    this.name = "UnsupportedServer";
  }
};
var UnexpectedConnectionState = class extends LivekitError {
  constructor(message) {
    super(12, message !== null && message !== void 0 ? message : "unexpected connection state");
    this.name = "UnexpectedConnectionState";
  }
};
var NegotiationError = class extends LivekitError {
  constructor(message) {
    super(13, message !== null && message !== void 0 ? message : "unable to negotiate");
    this.name = "NegotiationError";
  }
};
var PublishTrackError = class extends LivekitError {
  constructor(message, status) {
    super(15, message);
    this.name = "PublishTrackError";
    this.status = status;
  }
};
var SignalRequestError = class extends LivekitError {
  constructor(message, reason) {
    super(15, message);
    this.reason = reason;
    this.reasonName = typeof reason === "string" ? reason : RequestResponse_Reason[reason];
  }
};
var MediaDeviceFailure;
(function(MediaDeviceFailure2) {
  MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
  MediaDeviceFailure2["NotFound"] = "NotFound";
  MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
  MediaDeviceFailure2["Other"] = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(MediaDeviceFailure2) {
  function getFailure(error) {
    if (error && "name" in error) {
      if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
        return MediaDeviceFailure2.NotFound;
      }
      if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
        return MediaDeviceFailure2.PermissionDenied;
      }
      if (error.name === "NotReadableError" || error.name === "TrackStartError") {
        return MediaDeviceFailure2.DeviceInUse;
      }
      return MediaDeviceFailure2.Other;
    }
  }
  MediaDeviceFailure2.getFailure = getFailure;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var CryptorErrorReason;
(function(CryptorErrorReason2) {
  CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
  CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
  CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
})(CryptorErrorReason || (CryptorErrorReason = {}));
var RoomEvent;
(function(RoomEvent2) {
  RoomEvent2["Connected"] = "connected";
  RoomEvent2["Reconnecting"] = "reconnecting";
  RoomEvent2["SignalReconnecting"] = "signalReconnecting";
  RoomEvent2["Reconnected"] = "reconnected";
  RoomEvent2["Disconnected"] = "disconnected";
  RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
  RoomEvent2["Moved"] = "moved";
  RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
  RoomEvent2["ParticipantConnected"] = "participantConnected";
  RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
  RoomEvent2["TrackPublished"] = "trackPublished";
  RoomEvent2["TrackSubscribed"] = "trackSubscribed";
  RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  RoomEvent2["TrackUnpublished"] = "trackUnpublished";
  RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  RoomEvent2["TrackMuted"] = "trackMuted";
  RoomEvent2["TrackUnmuted"] = "trackUnmuted";
  RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
  RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  RoomEvent2["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";
  RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
  RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
  RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
  RoomEvent2["ParticipantActive"] = "participantActive";
  RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
  RoomEvent2["DataReceived"] = "dataReceived";
  RoomEvent2["SipDTMFReceived"] = "sipDTMFReceived";
  RoomEvent2["TranscriptionReceived"] = "transcriptionReceived";
  RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
  RoomEvent2["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";
  RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
  RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
  RoomEvent2["SignalConnected"] = "signalConnected";
  RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
  RoomEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
  RoomEvent2["EncryptionError"] = "encryptionError";
  RoomEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
  RoomEvent2["ActiveDeviceChanged"] = "activeDeviceChanged";
  RoomEvent2["ChatMessage"] = "chatMessage";
  RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  RoomEvent2["MetricsReceived"] = "metricsReceived";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(ParticipantEvent2) {
  ParticipantEvent2["TrackPublished"] = "trackPublished";
  ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
  ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
  ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  ParticipantEvent2["TrackMuted"] = "trackMuted";
  ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
  ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
  ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  ParticipantEvent2["LocalTrackCpuConstrained"] = "localTrackCpuConstrained";
  ParticipantEvent2["LocalSenderCreated"] = "localSenderCreated";
  ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  ParticipantEvent2["ParticipantNameChanged"] = "participantNameChanged";
  ParticipantEvent2["DataReceived"] = "dataReceived";
  ParticipantEvent2["SipDTMFReceived"] = "sipDTMFReceived";
  ParticipantEvent2["TranscriptionReceived"] = "transcriptionReceived";
  ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
  ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  ParticipantEvent2["TrackCpuConstrained"] = "trackCpuConstrained";
  ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
  ParticipantEvent2["AudioStreamAcquired"] = "audioStreamAcquired";
  ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
  ParticipantEvent2["PCTrackAdded"] = "pcTrackAdded";
  ParticipantEvent2["AttributesChanged"] = "attributesChanged";
  ParticipantEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  ParticipantEvent2["ChatMessage"] = "chatMessage";
  ParticipantEvent2["Active"] = "active";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(EngineEvent2) {
  EngineEvent2["TransportsCreated"] = "transportsCreated";
  EngineEvent2["Connected"] = "connected";
  EngineEvent2["Disconnected"] = "disconnected";
  EngineEvent2["Resuming"] = "resuming";
  EngineEvent2["Resumed"] = "resumed";
  EngineEvent2["Restarting"] = "restarting";
  EngineEvent2["Restarted"] = "restarted";
  EngineEvent2["SignalResumed"] = "signalResumed";
  EngineEvent2["SignalRestarted"] = "signalRestarted";
  EngineEvent2["Closing"] = "closing";
  EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
  EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
  EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
  EngineEvent2["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";
  EngineEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
  EngineEvent2["ParticipantUpdate"] = "participantUpdate";
  EngineEvent2["RoomUpdate"] = "roomUpdate";
  EngineEvent2["SpeakersChanged"] = "speakersChanged";
  EngineEvent2["StreamStateChanged"] = "streamStateChanged";
  EngineEvent2["ConnectionQualityUpdate"] = "connectionQualityUpdate";
  EngineEvent2["SubscriptionError"] = "subscriptionError";
  EngineEvent2["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";
  EngineEvent2["RemoteMute"] = "remoteMute";
  EngineEvent2["SubscribedQualityUpdate"] = "subscribedQualityUpdate";
  EngineEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  EngineEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  EngineEvent2["Offline"] = "offline";
  EngineEvent2["SignalRequestResponse"] = "signalRequestResponse";
  EngineEvent2["SignalConnected"] = "signalConnected";
  EngineEvent2["RoomMoved"] = "roomMoved";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(TrackEvent2) {
  TrackEvent2["Message"] = "message";
  TrackEvent2["Muted"] = "muted";
  TrackEvent2["Unmuted"] = "unmuted";
  TrackEvent2["Restarted"] = "restarted";
  TrackEvent2["Ended"] = "ended";
  TrackEvent2["Subscribed"] = "subscribed";
  TrackEvent2["Unsubscribed"] = "unsubscribed";
  TrackEvent2["CpuConstrained"] = "cpuConstrained";
  TrackEvent2["UpdateSettings"] = "updateSettings";
  TrackEvent2["UpdateSubscription"] = "updateSubscription";
  TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
  TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
  TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
  TrackEvent2["VisibilityChanged"] = "visibilityChanged";
  TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
  TrackEvent2["VideoPlaybackStarted"] = "videoPlaybackStarted";
  TrackEvent2["VideoPlaybackFailed"] = "videoPlaybackFailed";
  TrackEvent2["ElementAttached"] = "elementAttached";
  TrackEvent2["ElementDetached"] = "elementDetached";
  TrackEvent2["UpstreamPaused"] = "upstreamPaused";
  TrackEvent2["UpstreamResumed"] = "upstreamResumed";
  TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
  TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
  TrackEvent2["SubscriptionFailed"] = "subscriptionFailed";
  TrackEvent2["TrackProcessorUpdate"] = "trackProcessorUpdate";
  TrackEvent2["AudioTrackFeatureUpdate"] = "audioTrackFeatureUpdate";
  TrackEvent2["TranscriptionReceived"] = "transcriptionReceived";
  TrackEvent2["TimeSyncUpdate"] = "timeSyncUpdate";
  TrackEvent2["PreConnectBufferFlushed"] = "preConnectBufferFlushed";
})(TrackEvent || (TrackEvent = {}));
function cloneDeep(value) {
  if (typeof value === "undefined") {
    return value;
  }
  if (typeof structuredClone === "function") {
    if (typeof value === "object" && value !== null) {
      return structuredClone(Object.assign({}, value));
    }
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browserDetails;
function getBrowser(userAgent) {
  let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (typeof userAgent === "undefined" && typeof navigator === "undefined") {
    return;
  }
  const ua3 = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || force) {
    const browser = browsersList.find((_ref) => {
      let {
        test
      } = _ref;
      return test.test(ua3);
    });
    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua3);
  }
  return browserDetails;
}
var browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(ua3) {
      const browser = {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua3),
        os: ua3.toLowerCase().includes("fxios") ? "iOS" : void 0,
        osVersion: getOSVersion(ua3)
      };
      return browser;
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(ua3) {
      const browser = {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua3),
        os: ua3.toLowerCase().includes("crios") ? "iOS" : void 0,
        osVersion: getOSVersion(ua3)
      };
      return browser;
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(ua3) {
      const browser = {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, ua3),
        os: ua3.includes("mobile/") ? "iOS" : "macOS",
        osVersion: getOSVersion(ua3)
      };
      return browser;
    }
  }
];
function getMatch(exp, ua3) {
  let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const match = ua3.match(exp);
  return match && match.length >= id && match[id] || "";
}
function getOSVersion(ua3) {
  return ua3.includes("mac os") ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua3, 1).replace(/_/g, ".") : void 0;
}
var version$1 = "2.15.2";
var version = version$1;
var protocolVersion = 16;
var CriticalTimers = class {
};
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
var BACKGROUND_REACTION_DELAY = 5e3;
var recycledElements = [];
var VideoQuality;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
  VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
var Track = class _Track extends eventsExports.EventEmitter {
  constructor(mediaTrack, kind) {
    let loggerOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _a3;
    super();
    this.attachedElements = [];
    this.isMuted = false;
    this.streamState = _Track.StreamState.Active;
    this.isInBackground = false;
    this._currentBitrate = 0;
    this.log = livekitLogger;
    this.appVisibilityChangedListener = () => {
      if (this.backgroundTimeout) {
        clearTimeout(this.backgroundTimeout);
      }
      if (document.visibilityState === "hidden") {
        this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);
      } else {
        this.handleAppVisibilityChanged();
      }
    };
    this.log = getLogger((_a3 = loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Track);
    this.loggerContextCb = loggerOptions.loggerContextCb;
    this.setMaxListeners(100);
    this.kind = kind;
    this._mediaStreamTrack = mediaTrack;
    this._mediaStreamID = mediaTrack.id;
    this.source = _Track.Source.Unknown;
  }
  get logContext() {
    var _a3;
    return Object.assign(Object.assign({}, (_a3 = this.loggerContextCb) === null || _a3 === void 0 ? void 0 : _a3.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(element) {
    let elementType = "audio";
    if (this.kind === _Track.Kind.Video) {
      elementType = "video";
    }
    if (this.attachedElements.length === 0 && this.kind === _Track.Kind.Video) {
      this.addAppVisibilityListener();
    }
    if (!element) {
      if (elementType === "audio") {
        recycledElements.forEach((e4) => {
          if (e4.parentElement === null && !element) {
            element = e4;
          }
        });
        if (element) {
          recycledElements.splice(recycledElements.indexOf(element), 1);
        }
      }
      if (!element) {
        element = document.createElement(elementType);
      }
    }
    if (!this.attachedElements.includes(element)) {
      this.attachedElements.push(element);
    }
    attachToElement(this.mediaStreamTrack, element);
    const allMediaStreamTracks = element.srcObject.getTracks();
    const hasAudio = allMediaStreamTracks.some((tr3) => tr3.kind === "audio");
    element.play().then(() => {
      this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((e4) => {
      if (e4.name === "NotAllowedError") {
        this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e4);
      } else if (e4.name === "AbortError") {
        livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));
      } else {
        livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e4);
      }
      if (hasAudio && element && allMediaStreamTracks.some((tr3) => tr3.kind === "video") && e4.name === "NotAllowedError") {
        element.muted = true;
        element.play().catch(() => {
        });
      }
    });
    this.emit(TrackEvent.ElementAttached, element);
    return element;
  }
  detach(element) {
    try {
      if (element) {
        detachTrack(this.mediaStreamTrack, element);
        const idx = this.attachedElements.indexOf(element);
        if (idx >= 0) {
          this.attachedElements.splice(idx, 1);
          this.recycleElement(element);
          this.emit(TrackEvent.ElementDetached, element);
        }
        return element;
      }
      const detached = [];
      this.attachedElements.forEach((elm) => {
        detachTrack(this.mediaStreamTrack, elm);
        detached.push(elm);
        this.recycleElement(elm);
        this.emit(TrackEvent.ElementDetached, elm);
      });
      this.attachedElements = [];
      return detached;
    } finally {
      if (this.attachedElements.length === 0) {
        this.removeAppVisibilityListener();
      }
    }
  }
  stop() {
    this.stopMonitor();
    this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = true;
  }
  disable() {
    this._mediaStreamTrack.enabled = false;
  }
  /* @internal */
  stopMonitor() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
    }
    if (this.timeSyncHandle) {
      cancelAnimationFrame(this.timeSyncHandle);
    }
  }
  /** @internal */
  updateLoggerOptions(loggerOptions) {
    if (loggerOptions.loggerName) {
      this.log = getLogger(loggerOptions.loggerName);
    }
    if (loggerOptions.loggerContextCb) {
      this.loggerContextCb = loggerOptions.loggerContextCb;
    }
  }
  recycleElement(element) {
    if (element instanceof HTMLAudioElement) {
      let shouldCache = true;
      element.pause();
      recycledElements.forEach((e4) => {
        if (!e4.parentElement) {
          shouldCache = false;
        }
      });
      if (shouldCache) {
        recycledElements.push(element);
      }
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
      if (!this.isInBackground && this.kind === _Track.Kind.Video) {
        setTimeout(() => this.attachedElements.forEach((el) => el.play().catch(() => {
        })), 0);
      }
    });
  }
  addAppVisibilityListener() {
    if (isWeb()) {
      this.isInBackground = document.visibilityState === "hidden";
      document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
    } else {
      this.isInBackground = false;
    }
  }
  removeAppVisibilityListener() {
    if (isWeb()) {
      document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
    }
  }
};
function attachToElement(track2, element) {
  let mediaStream;
  if (element.srcObject instanceof MediaStream) {
    mediaStream = element.srcObject;
  } else {
    mediaStream = new MediaStream();
  }
  let existingTracks;
  if (track2.kind === "audio") {
    existingTracks = mediaStream.getAudioTracks();
  } else {
    existingTracks = mediaStream.getVideoTracks();
  }
  if (!existingTracks.includes(track2)) {
    existingTracks.forEach((et3) => {
      mediaStream.removeTrack(et3);
    });
    mediaStream.addTrack(track2);
  }
  if (!isSafari() || !(element instanceof HTMLVideoElement)) {
    element.autoplay = true;
  }
  element.muted = mediaStream.getAudioTracks().length === 0;
  if (element instanceof HTMLVideoElement) {
    element.playsInline = true;
  }
  if (element.srcObject !== mediaStream) {
    element.srcObject = mediaStream;
    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
      setTimeout(() => {
        element.srcObject = mediaStream;
        element.play().catch(() => {
        });
      }, 0);
    }
  }
}
function detachTrack(track2, element) {
  if (element.srcObject instanceof MediaStream) {
    const mediaStream = element.srcObject;
    mediaStream.removeTrack(track2);
    if (mediaStream.getTracks().length > 0) {
      element.srcObject = mediaStream;
    } else {
      element.srcObject = null;
    }
  }
}
(function(Track2) {
  let Kind;
  (function(Kind2) {
    Kind2["Audio"] = "audio";
    Kind2["Video"] = "video";
    Kind2["Unknown"] = "unknown";
  })(Kind = Track2.Kind || (Track2.Kind = {}));
  let Source;
  (function(Source2) {
    Source2["Camera"] = "camera";
    Source2["Microphone"] = "microphone";
    Source2["ScreenShare"] = "screen_share";
    Source2["ScreenShareAudio"] = "screen_share_audio";
    Source2["Unknown"] = "unknown";
  })(Source = Track2.Source || (Track2.Source = {}));
  let StreamState$1;
  (function(StreamState2) {
    StreamState2["Active"] = "active";
    StreamState2["Paused"] = "paused";
    StreamState2["Unknown"] = "unknown";
  })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
  function kindToProto(k3) {
    switch (k3) {
      case Kind.Audio:
        return TrackType.AUDIO;
      case Kind.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  Track2.kindToProto = kindToProto;
  function kindFromProto(t3) {
    switch (t3) {
      case TrackType.AUDIO:
        return Kind.Audio;
      case TrackType.VIDEO:
        return Kind.Video;
      default:
        return Kind.Unknown;
    }
  }
  Track2.kindFromProto = kindFromProto;
  function sourceToProto(s3) {
    switch (s3) {
      case Source.Camera:
        return TrackSource.CAMERA;
      case Source.Microphone:
        return TrackSource.MICROPHONE;
      case Source.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case Source.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  Track2.sourceToProto = sourceToProto;
  function sourceFromProto(s3) {
    switch (s3) {
      case TrackSource.CAMERA:
        return Source.Camera;
      case TrackSource.MICROPHONE:
        return Source.Microphone;
      case TrackSource.SCREEN_SHARE:
        return Source.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return Source.ScreenShareAudio;
      default:
        return Source.Unknown;
    }
  }
  Track2.sourceFromProto = sourceFromProto;
  function streamStateFromProto(s3) {
    switch (s3) {
      case StreamState.ACTIVE:
        return StreamState$1.Active;
      case StreamState.PAUSED:
        return StreamState$1.Paused;
      default:
        return StreamState$1.Unknown;
    }
  }
  Track2.streamStateFromProto = streamStateFromProto;
})(Track || (Track = {}));
var VideoPreset = class {
  constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
    if (typeof widthOrOptions === "object") {
      this.width = widthOrOptions.width;
      this.height = widthOrOptions.height;
      this.aspectRatio = widthOrOptions.aspectRatio;
      this.encoding = {
        maxBitrate: widthOrOptions.maxBitrate,
        maxFramerate: widthOrOptions.maxFramerate,
        priority: widthOrOptions.priority
      };
    } else if (height !== void 0 && maxBitrate !== void 0) {
      this.width = widthOrOptions;
      this.height = height;
      this.aspectRatio = widthOrOptions / height;
      this.encoding = {
        maxBitrate,
        maxFramerate,
        priority
      };
    } else {
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
    }
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio
    };
  }
};
var backupCodecs = ["vp8", "h264"];
var videoCodecs = ["vp8", "h264", "vp9", "av1", "h265"];
function isBackupCodec(codec) {
  return !!backupCodecs.find((backup) => backup === codec);
}
var BackupCodecPolicy;
(function(BackupCodecPolicy2) {
  BackupCodecPolicy2[BackupCodecPolicy2["PREFER_REGRESSION"] = 0] = "PREFER_REGRESSION";
  BackupCodecPolicy2[BackupCodecPolicy2["SIMULCAST"] = 1] = "SIMULCAST";
  BackupCodecPolicy2[BackupCodecPolicy2["REGRESSION"] = 2] = "REGRESSION";
})(BackupCodecPolicy || (BackupCodecPolicy = {}));
var AudioPresets;
(function(AudioPresets2) {
  AudioPresets2.telephone = {
    maxBitrate: 12e3
  };
  AudioPresets2.speech = {
    maxBitrate: 24e3
  };
  AudioPresets2.music = {
    maxBitrate: 48e3
  };
  AudioPresets2.musicStereo = {
    maxBitrate: 64e3
  };
  AudioPresets2.musicHighQuality = {
    maxBitrate: 96e3
  };
  AudioPresets2.musicHighQualityStereo = {
    maxBitrate: 128e3
  };
})(AudioPresets || (AudioPresets = {}));
var VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
};
var VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
};
var ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
var separator = "|";
var ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(packed) {
  const parts = packed.split(separator);
  if (parts.length > 1) {
    return [parts[0], packed.substr(parts[0].length + 1)];
  }
  return [packed, ""];
}
function sleep(duration) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve) => CriticalTimers.setTimeout(resolve, duration));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender)) {
    return false;
  }
  if (isSafari()) {
    return false;
  }
  const capabilities = RTCRtpSender.getCapabilities("video");
  let hasAV1 = false;
  if (capabilities) {
    for (const codec of capabilities.codecs) {
      if (codec.mimeType === "video/AV1") {
        hasAV1 = true;
        break;
      }
    }
  }
  return hasAV1;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender)) {
    return false;
  }
  if (isFireFox()) {
    return false;
  }
  if (isSafari()) {
    const browser = getBrowser();
    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {
      return false;
    }
    if ((browser === null || browser === void 0 ? void 0 : browser.os) === "iOS" && (browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, "16") < 0) {
      return false;
    }
  }
  const capabilities = RTCRtpSender.getCapabilities("video");
  let hasVP9 = false;
  if (capabilities) {
    for (const codec of capabilities.codecs) {
      if (codec.mimeType === "video/VP9") {
        hasVP9 = true;
        break;
      }
    }
  }
  return hasVP9;
}
function isSVCCodec(codec) {
  return codec === "av1" || codec === "vp9";
}
function supportsSetSinkId(elm) {
  if (!document) {
    return false;
  }
  if (!elm) {
    elm = document.createElement("audio");
  }
  return "setSinkId" in elm;
}
function isBrowserSupported() {
  if (typeof RTCPeerConnection === "undefined") {
    return false;
  }
  return supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var _a3;
  return ((_a3 = getBrowser()) === null || _a3 === void 0 ? void 0 : _a3.name) === "Firefox";
}
function isSafari() {
  var _a3;
  return ((_a3 = getBrowser()) === null || _a3 === void 0 ? void 0 : _a3.name) === "Safari";
}
function isSafariBased() {
  const b3 = getBrowser();
  return (b3 === null || b3 === void 0 ? void 0 : b3.name) === "Safari" || (b3 === null || b3 === void 0 ? void 0 : b3.os) === "iOS";
}
function isSafari17Based() {
  const b3 = getBrowser();
  return (b3 === null || b3 === void 0 ? void 0 : b3.name) === "Safari" && b3.version.startsWith("17.") || (b3 === null || b3 === void 0 ? void 0 : b3.os) === "iOS" && !!(b3 === null || b3 === void 0 ? void 0 : b3.osVersion) && compareVersions(b3.osVersion, "17") >= 0;
}
function isSafariSvcApi(browser) {
  if (!browser) {
    browser = getBrowser();
  }
  return (browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "18.3") > 0 || (browser === null || browser === void 0 ? void 0 : browser.os) === "iOS" && !!(browser === null || browser === void 0 ? void 0 : browser.osVersion) && compareVersions(browser.osVersion, "18.3") > 0;
}
function isMobile() {
  var _a3, _b;
  if (!isWeb())
    return false;
  return (
    // @ts-expect-error `userAgentData` is not yet part of typescript
    (_b = (_a3 = navigator.userAgentData) === null || _a3 === void 0 ? void 0 : _a3.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
  );
}
function isE2EESimulcastSupported() {
  const browser = getBrowser();
  const supportedSafariVersion = "17.2";
  if (browser) {
    if (browser.name !== "Safari" && browser.os !== "iOS") {
      return true;
    } else if (browser.os === "iOS" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {
      return true;
    } else if (browser.name === "Safari" && compareVersions(supportedSafariVersion, browser.version) >= 0) {
      return true;
    } else {
      return false;
    }
  }
}
function isWeb() {
  return typeof document !== "undefined";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(serverUrl) {
  return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global && global.LiveKitReactNativeGlobal) {
    return global.LiveKitReactNativeGlobal;
  }
  return void 0;
}
function getReactNativeOs() {
  if (!isReactNative()) {
    return void 0;
  }
  let info = getLKReactNativeInfo();
  if (info) {
    return info.platform;
  }
  return void 0;
}
function getDevicePixelRatio() {
  if (isWeb()) {
    return window.devicePixelRatio;
  }
  if (isReactNative()) {
    let info = getLKReactNativeInfo();
    if (info) {
      return info.devicePixelRatio;
    }
  }
  return 1;
}
function compareVersions(v1, v22) {
  const parts1 = v1.split(".");
  const parts2 = v22.split(".");
  const k3 = Math.min(parts1.length, parts2.length);
  for (let i3 = 0; i3 < k3; ++i3) {
    const p1 = parseInt(parts1[i3], 10);
    const p22 = parseInt(parts2[i3], 10);
    if (p1 > p22)
      return 1;
    if (p1 < p22)
      return -1;
    if (i3 === k3 - 1 && p1 === p22)
      return 0;
  }
  if (v1 === "" && v22 !== "") {
    return -1;
  } else if (v22 === "") {
    return 1;
  }
  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
}
function roDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleResize(entry);
  }
}
function ioDispatchCallback(entries) {
  for (const entry of entries) {
    entry.target.handleVisibilityChanged(entry);
  }
}
var resizeObserver = null;
var getResizeObserver = () => {
  if (!resizeObserver)
    resizeObserver = new ResizeObserver(roDispatchCallback);
  return resizeObserver;
};
var intersectionObserver = null;
var getIntersectionObserver = () => {
  if (!intersectionObserver) {
    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
      root: null,
      rootMargin: "0px"
    });
  }
  return intersectionObserver;
};
function getClientInfo() {
  var _a3;
  const info = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version
  });
  if (isReactNative()) {
    info.os = (_a3 = getReactNativeOs()) !== null && _a3 !== void 0 ? _a3 : "";
  }
  return info;
}
function createDummyVideoStreamTrack() {
  let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
  let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (paintContent && ctx) {
    ctx.beginPath();
    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fillStyle = "grey";
    ctx.fill();
  }
  const dummyStream = canvas.captureStream();
  const [dummyTrack] = dummyStream.getTracks();
  if (!dummyTrack) {
    throw Error("Could not get empty media stream video track");
  }
  dummyTrack.enabled = enabled;
  return dummyTrack;
}
var emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const ctx = new AudioContext();
    const oscillator = ctx.createOscillator();
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0, 0);
    const dst = ctx.createMediaStreamDestination();
    oscillator.connect(gain);
    gain.connect(dst);
    oscillator.start();
    [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
    if (!emptyAudioStreamTrack) {
      throw Error("Could not get empty media stream audio track");
    }
    emptyAudioStreamTrack.enabled = false;
  }
  return emptyAudioStreamTrack.clone();
}
var Future = class {
  constructor(futureBase, onFinally) {
    this.onFinally = onFinally;
    this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      this.resolve = resolve;
      this.reject = reject;
      if (futureBase) {
        yield futureBase(resolve, reject);
      }
    })).finally(() => {
      var _a3;
      return (_a3 = this.onFinally) === null || _a3 === void 0 ? void 0 : _a3.call(this);
    });
  }
};
function isVideoCodec(maybeCodec) {
  return videoCodecs.includes(maybeCodec);
}
function unwrapConstraint(constraint) {
  if (typeof constraint === "string" || typeof constraint === "number") {
    return constraint;
  }
  if (Array.isArray(constraint)) {
    return constraint[0];
  }
  if (constraint.exact) {
    if (Array.isArray(constraint.exact)) {
      return constraint.exact[0];
    }
    return constraint.exact;
  }
  if (constraint.ideal) {
    if (Array.isArray(constraint.ideal)) {
      return constraint.ideal[0];
    }
    return constraint.ideal;
  }
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(url) {
  if (url.startsWith("http")) {
    return url.replace(/^(http)/, "ws");
  }
  return url;
}
function toHttpUrl(url) {
  if (url.startsWith("ws")) {
    return url.replace(/^(ws)/, "http");
  }
  return url;
}
function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
  return transcription.segments.map((_ref) => {
    let {
      id,
      text,
      language,
      startTime,
      endTime,
      final
    } = _ref;
    var _a3;
    const firstReceivedTime = (_a3 = firstReceivedTimesMap.get(id)) !== null && _a3 !== void 0 ? _a3 : Date.now();
    const lastReceivedTime = Date.now();
    if (final) {
      firstReceivedTimesMap.delete(id);
    } else {
      firstReceivedTimesMap.set(id, firstReceivedTime);
    }
    return {
      id,
      text,
      startTime: Number.parseInt(startTime.toString()),
      endTime: Number.parseInt(endTime.toString()),
      final,
      language,
      firstReceivedTime,
      lastReceivedTime
    };
  });
}
function extractChatMessage(msg) {
  const {
    id,
    timestamp,
    message,
    editTimestamp
  } = msg;
  return {
    id,
    timestamp: Number.parseInt(timestamp.toString()),
    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : void 0,
    message
  };
}
function getDisconnectReasonFromConnectionError(e4) {
  switch (e4.reason) {
    case ConnectionErrorReason.LeaveRequest:
      return e4.context;
    case ConnectionErrorReason.Cancelled:
      return DisconnectReason.CLIENT_INITIATED;
    case ConnectionErrorReason.NotAllowed:
      return DisconnectReason.USER_REJECTED;
    case ConnectionErrorReason.ServerUnreachable:
      return DisconnectReason.JOIN_FAILURE;
    default:
      return DisconnectReason.UNKNOWN_REASON;
  }
}
function bigIntToNumber(value) {
  return value !== void 0 ? Number(value) : void 0;
}
function numberToBigInt(value) {
  return value !== void 0 ? BigInt(value) : void 0;
}
function isLocalTrack(track2) {
  return !!track2 && !(track2 instanceof MediaStreamTrack) && track2.isLocal;
}
function isAudioTrack(track2) {
  return !!track2 && track2.kind == Track.Kind.Audio;
}
function isVideoTrack(track2) {
  return !!track2 && track2.kind == Track.Kind.Video;
}
function isLocalVideoTrack(track2) {
  return isLocalTrack(track2) && isVideoTrack(track2);
}
function isLocalAudioTrack(track2) {
  return isLocalTrack(track2) && isAudioTrack(track2);
}
function isRemoteTrack(track2) {
  return !!track2 && !track2.isLocal;
}
function isRemotePub(pub) {
  return !!pub && !pub.isLocal;
}
function isRemoteVideoTrack(track2) {
  return isRemoteTrack(track2) && isVideoTrack(track2);
}
function isLocalParticipant(p3) {
  return p3.isLocal;
}
function splitUtf8(s3, n3) {
  const result = [];
  let encoded = new TextEncoder().encode(s3);
  while (encoded.length > n3) {
    let k3 = n3;
    while (k3 > 0) {
      const byte = encoded[k3];
      if (byte !== void 0 && (byte & 192) !== 128) {
        break;
      }
      k3--;
    }
    result.push(encoded.slice(0, k3));
    encoded = encoded.slice(k3);
  }
  if (encoded.length > 0) {
    result.push(encoded);
  }
  return result;
}
function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
  var _a3, _b;
  var _c3, _d;
  const {
    optionsWithoutProcessor,
    audioProcessor,
    videoProcessor
  } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});
  const defaultAudioProcessor = audioDefaults2 === null || audioDefaults2 === void 0 ? void 0 : audioDefaults2.processor;
  const defaultVideoProcessor = videoDefaults2 === null || videoDefaults2 === void 0 ? void 0 : videoDefaults2.processor;
  const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};
  if (clonedOptions.audio === true)
    clonedOptions.audio = {};
  if (clonedOptions.video === true)
    clonedOptions.video = {};
  if (clonedOptions.audio) {
    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults2);
    (_a3 = (_c3 = clonedOptions.audio).deviceId) !== null && _a3 !== void 0 ? _a3 : _c3.deviceId = {
      ideal: "default"
    };
    if (audioProcessor || defaultAudioProcessor) {
      clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;
    }
  }
  if (clonedOptions.video) {
    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults2);
    (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {
      ideal: "default"
    };
    if (videoProcessor || defaultVideoProcessor) {
      clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;
    }
  }
  return clonedOptions;
}
function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
  Object.keys(objectToMerge).forEach((key) => {
    if (mainObject[key] === void 0)
      mainObject[key] = objectToMerge[key];
  });
  return mainObject;
}
function constraintsForOptions(options) {
  var _a3, _b;
  var _c3, _d;
  const constraints = {};
  if (options.video) {
    if (typeof options.video === "object") {
      const videoOptions = {};
      const target = videoOptions;
      const source = options.video;
      Object.keys(source).forEach((key) => {
        switch (key) {
          case "resolution":
            mergeObjectWithoutOverwriting(target, source.resolution);
            break;
          default:
            target[key] = source[key];
        }
      });
      constraints.video = videoOptions;
      (_a3 = (_c3 = constraints.video).deviceId) !== null && _a3 !== void 0 ? _a3 : _c3.deviceId = {
        ideal: "default"
      };
    } else {
      constraints.video = options.video ? {
        deviceId: {
          ideal: "default"
        }
      } : false;
    }
  } else {
    constraints.video = false;
  }
  if (options.audio) {
    if (typeof options.audio === "object") {
      constraints.audio = options.audio;
      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {
        ideal: "default"
      };
    } else {
      constraints.audio = {
        deviceId: {
          ideal: "default"
        }
      };
    }
  } else {
    constraints.audio = false;
  }
  return constraints;
}
function detectSilence(track_1) {
  return __awaiter(this, arguments, void 0, function(track2) {
    let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
    return function* () {
      const ctx = getNewAudioContext();
      if (ctx) {
        const analyser = ctx.createAnalyser();
        analyser.fftSize = 2048;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        const source = ctx.createMediaStreamSource(new MediaStream([track2.mediaStreamTrack]));
        source.connect(analyser);
        yield sleep(timeOffset);
        analyser.getByteTimeDomainData(dataArray);
        const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);
        ctx.close();
        return !someNoise;
      }
      return false;
    }();
  });
}
function getNewAudioContext() {
  var _a3;
  const AudioContext2 = (
    // @ts-ignore
    typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)
  );
  if (AudioContext2) {
    const audioContext = new AudioContext2({
      latencyHint: "interactive"
    });
    if (audioContext.state === "suspended" && typeof window !== "undefined" && ((_a3 = window.document) === null || _a3 === void 0 ? void 0 : _a3.body)) {
      const handleResume = () => __awaiter(this, void 0, void 0, function* () {
        var _a4;
        try {
          if (audioContext.state === "suspended") {
            yield audioContext.resume();
          }
        } catch (e4) {
          console.warn("Error trying to auto-resume audio context", e4);
        }
        (_a4 = window.document.body) === null || _a4 === void 0 ? void 0 : _a4.removeEventListener("click", handleResume);
      });
      window.document.body.addEventListener("click", handleResume);
    }
    return audioContext;
  }
}
function kindToSource(kind) {
  if (kind === "audioinput") {
    return Track.Source.Microphone;
  } else if (kind === "videoinput") {
    return Track.Source.Camera;
  } else {
    return Track.Source.Unknown;
  }
}
function sourceToKind(source) {
  if (source === Track.Source.Microphone) {
    return "audioinput";
  } else if (source === Track.Source.Camera) {
    return "videoinput";
  } else {
    return void 0;
  }
}
function screenCaptureToDisplayMediaStreamOptions(options) {
  var _a3, _b;
  let videoConstraints = (_a3 = options.video) !== null && _a3 !== void 0 ? _a3 : true;
  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
    videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;
    if (isSafari()) {
      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
        width: {
          max: options.resolution.width
        },
        height: {
          max: options.resolution.height
        },
        frameRate: options.resolution.frameRate
      });
    } else {
      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
        width: {
          ideal: options.resolution.width
        },
        height: {
          ideal: options.resolution.height
        },
        frameRate: options.resolution.frameRate
      });
    }
  }
  return {
    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
    video: videoConstraints,
    // @ts-expect-error support for experimental display media features
    controller: options.controller,
    selfBrowserSurface: options.selfBrowserSurface,
    surfaceSwitching: options.surfaceSwitching,
    systemAudio: options.systemAudio,
    preferCurrentTab: options.preferCurrentTab
  };
}
function mimeTypeToVideoCodecString(mimeType) {
  return mimeType.split("/")[1].toLowerCase();
}
function getTrackPublicationInfo(tracks) {
  const infos = [];
  tracks.forEach((track2) => {
    if (track2.track !== void 0) {
      infos.push(new TrackPublishedResponse({
        cid: track2.track.mediaStreamID,
        track: track2.trackInfo
      }));
    }
  });
  return infos;
}
function getLogContextFromTrack(track2) {
  if ("mediaStreamTrack" in track2) {
    return {
      trackID: track2.sid,
      source: track2.source,
      muted: track2.isMuted,
      enabled: track2.mediaStreamTrack.enabled,
      kind: track2.kind,
      streamID: track2.mediaStreamID,
      streamTrackID: track2.mediaStreamTrack.id
    };
  } else {
    return {
      trackID: track2.trackSid,
      enabled: track2.isEnabled,
      muted: track2.isMuted,
      trackInfo: Object.assign({
        mimeType: track2.mimeType,
        name: track2.trackName,
        encrypted: track2.isEncrypted,
        kind: track2.kind,
        source: track2.source
      }, track2.track ? getLogContextFromTrack(track2.track) : {})
    };
  }
}
function supportsSynchronizationSources() {
  return typeof RTCRtpReceiver !== "undefined" && "getSynchronizationSources" in RTCRtpReceiver;
}
function diffAttributes(oldValues, newValues) {
  var _a3;
  if (oldValues === void 0) {
    oldValues = {};
  }
  if (newValues === void 0) {
    newValues = {};
  }
  const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];
  const diff = {};
  for (const key of allKeys) {
    if (oldValues[key] !== newValues[key]) {
      diff[key] = (_a3 = newValues[key]) !== null && _a3 !== void 0 ? _a3 : "";
    }
  }
  return diff;
}
function extractProcessorsFromOptions(options) {
  const newOptions = Object.assign({}, options);
  let audioProcessor;
  let videoProcessor;
  if (typeof newOptions.audio === "object" && newOptions.audio.processor) {
    audioProcessor = newOptions.audio.processor;
    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
      processor: void 0
    });
  }
  if (typeof newOptions.video === "object" && newOptions.video.processor) {
    videoProcessor = newOptions.video.processor;
    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
      processor: void 0
    });
  }
  return {
    audioProcessor,
    videoProcessor,
    optionsWithoutProcessor: cloneDeep(newOptions)
  };
}
function getTrackSourceFromProto(source) {
  switch (source) {
    case TrackSource.CAMERA:
      return Track.Source.Camera;
    case TrackSource.MICROPHONE:
      return Track.Source.Microphone;
    case TrackSource.SCREEN_SHARE:
      return Track.Source.ScreenShare;
    case TrackSource.SCREEN_SHARE_AUDIO:
      return Track.Source.ScreenShareAudio;
    default:
      return Track.Source.Unknown;
  }
}
function areDimensionsSmaller(a3, b3) {
  return a3.width * a3.height < b3.width * b3.height;
}
function layerDimensionsFor(trackInfo, quality) {
  var _a3;
  return (_a3 = trackInfo.layers) === null || _a3 === void 0 ? void 0 : _a3.find((l3) => l3.quality === quality);
}
var E2EEManager = class extends eventsExports.EventEmitter {
  constructor(options) {
    super();
    this.onWorkerMessage = (ev) => {
      var _a3, _b;
      const {
        kind,
        data
      } = ev.data;
      switch (kind) {
        case "error":
          livekitLogger.error(data.error.message);
          this.emit(EncryptionEvent.EncryptionError, data.error);
          break;
        case "initAck":
          if (data.enabled) {
            this.keyProvider.getKeys().forEach((keyInfo) => {
              this.postKey(keyInfo);
            });
          }
          break;
        case "enable":
          if (data.enabled) {
            this.keyProvider.getKeys().forEach((keyInfo) => {
              this.postKey(keyInfo);
            });
          }
          if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a3 = this.room) === null || _a3 === void 0 ? void 0 : _a3.localParticipant.identity)) {
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);
            this.encryptionEnabled = data.enabled;
          } else if (data.participantIdentity) {
            const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
            if (!participant) {
              throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
            }
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);
          }
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.ratchetResult, data.participantIdentity, data.keyIndex);
          break;
      }
    };
    this.onWorkerError = (ev) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: ev.error
      });
      this.emit(EncryptionEvent.EncryptionError, ev.error);
    };
    this.keyProvider = options.keyProvider;
    this.worker = options.worker;
    this.encryptionEnabled = false;
  }
  /**
   * @internal
   */
  setup(room) {
    if (!isE2EESupported()) {
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    }
    livekitLogger.info("setting up e2ee");
    if (room !== this.room) {
      this.room = room;
      this.setupEventListeners(room, this.keyProvider);
      const msg = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: workerLogger.getLevel()
        }
      };
      if (this.worker) {
        livekitLogger.info("initializing worker", {
          worker: this.worker
        });
        this.worker.onmessage = this.onWorkerMessage;
        this.worker.onerror = this.onWorkerError;
        this.worker.postMessage(msg);
      }
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(enabled, participantIdentity) {
    livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
    this.postEnable(enabled, participantIdentity);
  }
  /**
   * @internal
   */
  setSifTrailer(trailer) {
    if (!trailer || trailer.length === 0) {
      livekitLogger.warn("ignoring server sent trailer as it's empty");
    } else {
      this.postSifTrailer(trailer);
    }
  }
  setupEngine(engine) {
    engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
      this.postRTPMap(rtpMap);
    });
  }
  setupEventListeners(room, keyProvider) {
    room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));
    room.on(RoomEvent.ConnectionStateChanged, (state) => {
      if (state === ConnectionState.Connected) {
        room.remoteParticipants.forEach((participant) => {
          participant.trackPublications.forEach((pub) => {
            this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
          });
        });
      }
    }).on(RoomEvent.TrackUnsubscribed, (track2, _4, participant) => {
      var _a3;
      const msg = {
        kind: "removeTransform",
        data: {
          participantIdentity: participant.identity,
          trackId: track2.mediaStreamID
        }
      };
      (_a3 = this.worker) === null || _a3 === void 0 ? void 0 : _a3.postMessage(msg);
    }).on(RoomEvent.TrackSubscribed, (track2, pub, participant) => {
      this.setupE2EEReceiver(track2, participant.identity, pub.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room) {
        throw new TypeError("expected room to be present on signal connect");
      }
      keyProvider.getKeys().forEach((keyInfo) => {
        this.postKey(keyInfo);
      });
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
    });
    room.localParticipant.on(ParticipantEvent.LocalSenderCreated, (sender, track2) => __awaiter(this, void 0, void 0, function* () {
      this.setupE2EESender(track2, sender);
    }));
    keyProvider.on(KeyProviderEvent.SetKey, (keyInfo) => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));
  }
  postRatchetRequest(participantIdentity, keyIndex) {
    if (!this.worker) {
      throw Error("could not ratchet key, worker is missing");
    }
    const msg = {
      kind: "ratchetRequest",
      data: {
        participantIdentity,
        keyIndex
      }
    };
    this.worker.postMessage(msg);
  }
  postKey(_ref) {
    let {
      key,
      participantIdentity,
      keyIndex
    } = _ref;
    var _a3;
    if (!this.worker) {
      throw Error("could not set key, worker is missing");
    }
    const msg = {
      kind: "setKey",
      data: {
        participantIdentity,
        isPublisher: participantIdentity === ((_a3 = this.room) === null || _a3 === void 0 ? void 0 : _a3.localParticipant.identity),
        key,
        keyIndex
      }
    };
    this.worker.postMessage(msg);
  }
  postEnable(enabled, participantIdentity) {
    if (this.worker) {
      const enableMsg = {
        kind: "enable",
        data: {
          enabled,
          participantIdentity
        }
      };
      this.worker.postMessage(enableMsg);
    } else {
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
    }
  }
  postRTPMap(map) {
    var _a3;
    if (!this.worker) {
      throw TypeError("could not post rtp map, worker is missing");
    }
    if (!((_a3 = this.room) === null || _a3 === void 0 ? void 0 : _a3.localParticipant.identity)) {
      throw TypeError("could not post rtp map, local participant identity is missing");
    }
    const msg = {
      kind: "setRTPMap",
      data: {
        map,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(msg);
  }
  postSifTrailer(trailer) {
    if (!this.worker) {
      throw Error("could not post SIF trailer, worker is missing");
    }
    const msg = {
      kind: "setSifTrailer",
      data: {
        trailer
      }
    };
    this.worker.postMessage(msg);
  }
  setupE2EEReceiver(track2, remoteId, trackInfo) {
    if (!track2.receiver) {
      return;
    }
    if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {
      throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
    }
    this.handleReceiver(track2.receiver, track2.mediaStreamID, remoteId, track2.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : void 0);
  }
  setupE2EESender(track2, sender) {
    if (!isLocalTrack(track2) || !sender) {
      if (!sender)
        livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(sender, track2.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(receiver, trackId, participantIdentity, codec) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.worker) {
        return;
      }
      if (isScriptTransformSupported()) {
        const options = {
          kind: "decode",
          participantIdentity,
          trackId,
          codec
        };
        receiver.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        if (E2EE_FLAG in receiver && codec) {
          const msg2 = {
            kind: "updateCodec",
            data: {
              trackId,
              codec,
              participantIdentity
            }
          };
          this.worker.postMessage(msg2);
          return;
        }
        let writable = receiver.writableStream;
        let readable = receiver.readableStream;
        if (!writable || !readable) {
          const receiverStreams = receiver.createEncodedStreams();
          receiver.writableStream = receiverStreams.writable;
          writable = receiverStreams.writable;
          receiver.readableStream = receiverStreams.readable;
          readable = receiverStreams.readable;
        }
        const msg = {
          kind: "decode",
          data: {
            readableStream: readable,
            writableStream: writable,
            trackId,
            codec,
            participantIdentity,
            isReuse: E2EE_FLAG in receiver
          }
        };
        this.worker.postMessage(msg, [readable, writable]);
      }
      receiver[E2EE_FLAG] = true;
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(sender, trackId, codec) {
    var _a3;
    if (E2EE_FLAG in sender || !this.worker) {
      return;
    }
    if (!((_a3 = this.room) === null || _a3 === void 0 ? void 0 : _a3.localParticipant.identity) || this.room.localParticipant.identity === "") {
      throw TypeError("local identity needs to be known in order to set up encrypted sender");
    }
    if (isScriptTransformSupported()) {
      livekitLogger.info("initialize script transform");
      const options = {
        kind: "encode",
        participantIdentity: this.room.localParticipant.identity,
        trackId,
        codec
      };
      sender.transform = new RTCRtpScriptTransform(this.worker, options);
    } else {
      livekitLogger.info("initialize encoded streams");
      const senderStreams = sender.createEncodedStreams();
      const msg = {
        kind: "encode",
        data: {
          readableStream: senderStreams.readable,
          writableStream: senderStreams.writable,
          codec,
          trackId,
          participantIdentity: this.room.localParticipant.identity,
          isReuse: false
        }
      };
      this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
    }
    sender[E2EE_FLAG] = true;
  }
};
var defaultId = "default";
var DeviceManager = class _DeviceManager {
  constructor() {
    this._previousDevices = [];
  }
  static getInstance() {
    if (this.instance === void 0) {
      this.instance = new _DeviceManager();
    }
    return this.instance;
  }
  get previousDevices() {
    return this._previousDevices;
  }
  getDevices(kind_1) {
    return __awaiter(this, arguments, void 0, function(kind) {
      var _this = this;
      let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return function* () {
        var _a3;
        if (((_a3 = _DeviceManager.userMediaPromiseMap) === null || _a3 === void 0 ? void 0 : _a3.size) > 0) {
          livekitLogger.debug("awaiting getUserMedia promise");
          try {
            if (kind) {
              yield _DeviceManager.userMediaPromiseMap.get(kind);
            } else {
              yield Promise.all(_DeviceManager.userMediaPromiseMap.values());
            }
          } catch (e4) {
            livekitLogger.warn("error waiting for media permissons");
          }
        }
        let devices = yield navigator.mediaDevices.enumerateDevices();
        if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
        !(isSafari() && _this.hasDeviceInUse(kind))) {
          const isDummyDeviceOrEmpty = devices.filter((d3) => d3.kind === kind).length === 0 || devices.some((device) => {
            const noLabel = device.label === "";
            const isRelevant = kind ? device.kind === kind : true;
            return noLabel && isRelevant;
          });
          if (isDummyDeviceOrEmpty) {
            const permissionsToAcquire = {
              video: kind !== "audioinput" && kind !== "audiooutput",
              audio: kind !== "videoinput" && {
                deviceId: {
                  ideal: "default"
                }
              }
            };
            const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);
            devices = yield navigator.mediaDevices.enumerateDevices();
            stream.getTracks().forEach((track2) => {
              track2.stop();
            });
          }
        }
        _this._previousDevices = devices;
        if (kind) {
          devices = devices.filter((device) => device.kind === kind);
        }
        return devices;
      }();
    });
  }
  normalizeDeviceId(kind, deviceId, groupId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (deviceId !== defaultId) {
        return deviceId;
      }
      const devices = yield this.getDevices(kind);
      const defaultDevice = devices.find((d3) => d3.deviceId === defaultId);
      if (!defaultDevice) {
        livekitLogger.warn("could not reliably determine default device");
        return void 0;
      }
      const device = devices.find((d3) => d3.deviceId !== defaultId && d3.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));
      if (!device) {
        livekitLogger.warn("could not reliably determine default device");
        return void 0;
      }
      return device === null || device === void 0 ? void 0 : device.deviceId;
    });
  }
  hasDeviceInUse(kind) {
    return kind ? _DeviceManager.userMediaPromiseMap.has(kind) : _DeviceManager.userMediaPromiseMap.size > 0;
  }
};
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
var QueueTaskStatus;
(function(QueueTaskStatus2) {
  QueueTaskStatus2[QueueTaskStatus2["WAITING"] = 0] = "WAITING";
  QueueTaskStatus2[QueueTaskStatus2["RUNNING"] = 1] = "RUNNING";
  QueueTaskStatus2[QueueTaskStatus2["COMPLETED"] = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
var AsyncQueue = class {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map();
    this.taskMutex = new _3();
    this.nextTaskIndex = 0;
  }
  run(task) {
    return __awaiter(this, void 0, void 0, function* () {
      const taskInfo = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(taskInfo.id, taskInfo);
      const unlock = yield this.taskMutex.lock();
      try {
        taskInfo.executedAt = Date.now();
        taskInfo.status = QueueTaskStatus.RUNNING;
        return yield task();
      } finally {
        taskInfo.status = QueueTaskStatus.COMPLETED;
        this.pendingTasks.delete(taskInfo.id);
        unlock();
      }
    });
  }
  flush() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.run(() => __awaiter(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
};
function createRtcUrl(url, searchParams) {
  const urlObj = new URL(toWebsocketUrl(url));
  searchParams.forEach((value, key) => {
    urlObj.searchParams.set(key, value);
  });
  return appendUrlPath(urlObj, "rtc");
}
function createValidateUrl(rtcWsUrl) {
  const urlObj = new URL(toHttpUrl(rtcWsUrl));
  return appendUrlPath(urlObj, "validate");
}
function ensureTrailingSlash(path) {
  return path.endsWith("/") ? path : "".concat(path, "/");
}
function appendUrlPath(urlObj, path) {
  urlObj.pathname = "".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);
  return urlObj.toString();
}
var passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(req) {
  const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;
  livekitLogger.trace("request allowed to bypass queue:", {
    canPass,
    req
  });
  return canPass;
}
var SignalConnectionState;
(function(SignalConnectionState2) {
  SignalConnectionState2[SignalConnectionState2["CONNECTING"] = 0] = "CONNECTING";
  SignalConnectionState2[SignalConnectionState2["CONNECTED"] = 1] = "CONNECTED";
  SignalConnectionState2[SignalConnectionState2["RECONNECTING"] = 2] = "RECONNECTING";
  SignalConnectionState2[SignalConnectionState2["DISCONNECTING"] = 3] = "DISCONNECTING";
  SignalConnectionState2[SignalConnectionState2["DISCONNECTED"] = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
var SignalClient = class {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  getNextRequestId() {
    this._requestId += 1;
    return this._requestId;
  }
  constructor() {
    let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _a3;
    this.rtt = 0;
    this.state = SignalConnectionState.DISCONNECTED;
    this.log = livekitLogger;
    this._requestId = 0;
    this.resetCallbacks = () => {
      this.onAnswer = void 0;
      this.onLeave = void 0;
      this.onLocalTrackPublished = void 0;
      this.onLocalTrackUnpublished = void 0;
      this.onNegotiateRequested = void 0;
      this.onOffer = void 0;
      this.onRemoteMuteChanged = void 0;
      this.onSubscribedQualityUpdate = void 0;
      this.onTokenRefresh = void 0;
      this.onTrickle = void 0;
      this.onClose = void 0;
    };
    this.log = getLogger((_a3 = loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Signal);
    this.loggerContextCb = loggerOptions.loggerContextCb;
    this.useJSON = useJSON;
    this.requestQueue = new AsyncQueue();
    this.queuedRequests = [];
    this.closingLock = new _3();
    this.connectionLock = new _3();
    this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var _a3, _b;
    return (_b = (_a3 = this.loggerContextCb) === null || _a3 === void 0 ? void 0 : _a3.call(this)) !== null && _b !== void 0 ? _b : {};
  }
  join(url, token, opts, abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
      this.state = SignalConnectionState.CONNECTING;
      this.options = opts;
      const res = yield this.connect(url, token, opts, abortSignal);
      return res;
    });
  }
  reconnect(url, token, sid, reason) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      this.state = SignalConnectionState.RECONNECTING;
      this.clearPingInterval();
      const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {
        reconnect: true,
        sid,
        reconnectReason: reason
      }));
      return res;
    });
  }
  connect(url, token, opts, abortSignal) {
    this.connectOptions = opts;
    const clientInfo = getClientInfo();
    const params = createConnectionParams(token, clientInfo, opts);
    const rtcUrl = createRtcUrl(url, params);
    const validateUrl = createValidateUrl(rtcUrl);
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.connectionLock.lock();
      try {
        const abortHandler = () => __awaiter(this, void 0, void 0, function* () {
          this.close();
          clearTimeout(wsTimeout);
          reject(new ConnectionError("room connection has been cancelled (signal)", ConnectionErrorReason.Cancelled));
        });
        const wsTimeout = setTimeout(() => {
          this.close();
          reject(new ConnectionError("room connection has timed out (signal)", ConnectionErrorReason.ServerUnreachable));
        }, opts.websocketTimeout);
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
          abortHandler();
        }
        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
        const redactedUrl = new URL(rtcUrl);
        if (redactedUrl.searchParams.has("access_token")) {
          redactedUrl.searchParams.set("access_token", "<redacted>");
        }
        this.log.debug("connecting to ".concat(redactedUrl), Object.assign({
          reconnect: opts.reconnect,
          reconnectReason: opts.reconnectReason
        }, this.logContext));
        if (this.ws) {
          yield this.close(false);
        }
        this.ws = new WebSocket(rtcUrl);
        this.ws.binaryType = "arraybuffer";
        this.ws.onopen = () => {
          clearTimeout(wsTimeout);
        };
        this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            this.state = SignalConnectionState.DISCONNECTED;
            clearTimeout(wsTimeout);
            try {
              const resp = yield fetch(validateUrl);
              if (resp.status.toFixed(0).startsWith("4")) {
                const msg = yield resp.text();
                reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));
              } else {
                reject(new ConnectionError("Encountered unknown websocket error during connection: ".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));
              }
            } catch (e4) {
              reject(new ConnectionError(e4 instanceof Error ? e4.message : "server was not reachable", ConnectionErrorReason.ServerUnreachable));
            }
            return;
          }
          this.handleWSError(ev);
        });
        this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
          var _a3, _b, _c3;
          let resp;
          if (typeof ev.data === "string") {
            const json = JSON.parse(ev.data);
            resp = SignalResponse.fromJson(json, {
              ignoreUnknownFields: true
            });
          } else if (ev.data instanceof ArrayBuffer) {
            resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
          } else {
            this.log.error("could not decode websocket message: ".concat(typeof ev.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let shouldProcessMessage = false;
            if (((_a3 = resp.message) === null || _a3 === void 0 ? void 0 : _a3.case) === "join") {
              this.state = SignalConnectionState.CONNECTED;
              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
              this.pingTimeoutDuration = resp.message.value.pingTimeout;
              this.pingIntervalDuration = resp.message.value.pingInterval;
              if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
                  timeout: this.pingTimeoutDuration,
                  interval: this.pingIntervalDuration
                }));
                this.startPingInterval();
              }
              resolve(resp.message.value);
            } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== "leave") {
              this.state = SignalConnectionState.CONNECTED;
              abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
              this.startPingInterval();
              if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === "reconnect") {
                resolve(resp.message.value);
              } else {
                this.log.debug("declaring signal reconnected without reconnect response received", this.logContext);
                resolve(void 0);
                shouldProcessMessage = true;
              }
            } else if (this.isEstablishingConnection && resp.message.case === "leave") {
              reject(new ConnectionError("Received leave request while trying to (re)connect", ConnectionErrorReason.LeaveRequest, void 0, resp.message.value.reason));
            } else if (!opts.reconnect) {
              reject(new ConnectionError("did not receive join response, got ".concat((_c3 = resp.message) === null || _c3 === void 0 ? void 0 : _c3.case, " instead"), ConnectionErrorReason.InternalError));
            }
            if (!shouldProcessMessage) {
              return;
            }
          }
          if (this.signalLatency) {
            yield sleep(this.signalLatency);
          }
          this.handleSignalResponse(resp);
        });
        this.ws.onclose = (ev) => {
          if (this.isEstablishingConnection) {
            reject(new ConnectionError("Websocket got closed during a (re)connection attempt", ConnectionErrorReason.InternalError));
          }
          this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: ev.reason,
            code: ev.code,
            wasClean: ev.wasClean,
            state: this.state
          }));
          this.handleOnClose(ev.reason);
        };
      } finally {
        unlock();
      }
    }));
  }
  close() {
    return __awaiter(this, arguments, void 0, function() {
      var _this = this;
      let updateState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return function* () {
        const unlock = yield _this.closingLock.lock();
        try {
          _this.clearPingInterval();
          if (updateState) {
            _this.state = SignalConnectionState.DISCONNECTING;
          }
          if (_this.ws) {
            _this.ws.onmessage = null;
            _this.ws.onopen = null;
            _this.ws.onclose = null;
            const closePromise = new Promise((resolve) => {
              if (_this.ws) {
                _this.ws.onclose = () => {
                  resolve();
                };
              } else {
                resolve();
              }
            });
            if (_this.ws.readyState < _this.ws.CLOSING) {
              _this.ws.close();
              yield Promise.race([closePromise, sleep(250)]);
            }
            _this.ws = void 0;
          }
        } finally {
          if (updateState) {
            _this.state = SignalConnectionState.DISCONNECTED;
          }
          unlock();
        }
      }();
    });
  }
  // initial offer after joining
  sendOffer(offer, offerId) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: offer.sdp
    }));
    this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(offer, offerId)
    });
  }
  // answer a server-initiated offer
  sendAnswer(answer, offerId) {
    this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: answer.sdp
    }));
    return this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(answer, offerId)
    });
  }
  sendIceCandidate(candidate, target) {
    this.log.debug("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate
    }));
    return this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(candidate),
        target
      })
    });
  }
  sendMuteTrack(trackSid, muted) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: trackSid,
        muted
      })
    });
  }
  sendAddTrack(req) {
    return this.sendRequest({
      case: "addTrack",
      value: req
    });
  }
  sendUpdateLocalMetadata(metadata_1, name_1) {
    return __awaiter(this, arguments, void 0, function(metadata, name) {
      var _this2 = this;
      let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return function* () {
        const requestId = _this2.getNextRequestId();
        yield _this2.sendRequest({
          case: "updateMetadata",
          value: new UpdateParticipantMetadata({
            requestId,
            metadata,
            name,
            attributes
          })
        });
        return requestId;
      }();
    });
  }
  sendUpdateTrackSettings(settings) {
    this.sendRequest({
      case: "trackSetting",
      value: settings
    });
  }
  sendUpdateSubscription(sub) {
    return this.sendRequest({
      case: "subscription",
      value: sub
    });
  }
  sendSyncState(sync) {
    return this.sendRequest({
      case: "syncState",
      value: sync
    });
  }
  sendUpdateVideoLayers(trackSid, layers) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid,
        layers
      })
    });
  }
  sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants,
        trackPermissions
      })
    });
  }
  sendSimulateScenario(scenario) {
    return this.sendRequest({
      case: "simulate",
      value: scenario
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendUpdateLocalAudioTrack(trackSid, features) {
    return this.sendRequest({
      case: "updateAudioTrack",
      value: new UpdateLocalAudioTrack({
        trackSid,
        features
      })
    });
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        reason: DisconnectReason.CLIENT_INITIATED,
        // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
        action: LeaveRequest_Action.DISCONNECT
      })
    });
  }
  sendRequest(message_1) {
    return __awaiter(this, arguments, void 0, function(message) {
      var _this3 = this;
      let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return function* () {
        const canQueue = !fromQueue && !canPassThroughQueue(message);
        if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {
          _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {
            yield this.sendRequest(message, true);
          }));
          return;
        }
        if (!fromQueue) {
          yield _this3.requestQueue.flush();
        }
        if (_this3.signalLatency) {
          yield sleep(_this3.signalLatency);
        }
        if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {
          _this3.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);
          return;
        }
        const req = new SignalRequest({
          message
        });
        try {
          if (_this3.useJSON) {
            _this3.ws.send(req.toJsonString());
          } else {
            _this3.ws.send(req.toBinary());
          }
        } catch (e4) {
          _this3.log.error("error sending signal message", Object.assign(Object.assign({}, _this3.logContext), {
            error: e4
          }));
        }
      }();
    });
  }
  handleSignalResponse(res) {
    var _a3, _b;
    const msg = res.message;
    if (msg == void 0) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let pingHandled = false;
    if (msg.case === "answer") {
      const sd = fromProtoSessionDescription(msg.value);
      if (this.onAnswer) {
        this.onAnswer(sd, msg.value.id);
      }
    } else if (msg.case === "offer") {
      const sd = fromProtoSessionDescription(msg.value);
      if (this.onOffer) {
        this.onOffer(sd, msg.value.id);
      }
    } else if (msg.case === "trickle") {
      const candidate = JSON.parse(msg.value.candidateInit);
      if (this.onTrickle) {
        this.onTrickle(candidate, msg.value.target);
      }
    } else if (msg.case === "update") {
      if (this.onParticipantUpdate) {
        this.onParticipantUpdate((_a3 = msg.value.participants) !== null && _a3 !== void 0 ? _a3 : []);
      }
    } else if (msg.case === "trackPublished") {
      if (this.onLocalTrackPublished) {
        this.onLocalTrackPublished(msg.value);
      }
    } else if (msg.case === "speakersChanged") {
      if (this.onSpeakersChanged) {
        this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
      }
    } else if (msg.case === "leave") {
      if (this.onLeave) {
        this.onLeave(msg.value);
      }
    } else if (msg.case === "mute") {
      if (this.onRemoteMuteChanged) {
        this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
      }
    } else if (msg.case === "roomUpdate") {
      if (this.onRoomUpdate && msg.value.room) {
        this.onRoomUpdate(msg.value.room);
      }
    } else if (msg.case === "connectionQuality") {
      if (this.onConnectionQuality) {
        this.onConnectionQuality(msg.value);
      }
    } else if (msg.case === "streamStateUpdate") {
      if (this.onStreamStateUpdate) {
        this.onStreamStateUpdate(msg.value);
      }
    } else if (msg.case === "subscribedQualityUpdate") {
      if (this.onSubscribedQualityUpdate) {
        this.onSubscribedQualityUpdate(msg.value);
      }
    } else if (msg.case === "subscriptionPermissionUpdate") {
      if (this.onSubscriptionPermissionUpdate) {
        this.onSubscriptionPermissionUpdate(msg.value);
      }
    } else if (msg.case === "refreshToken") {
      if (this.onTokenRefresh) {
        this.onTokenRefresh(msg.value);
      }
    } else if (msg.case === "trackUnpublished") {
      if (this.onLocalTrackUnpublished) {
        this.onLocalTrackUnpublished(msg.value);
      }
    } else if (msg.case === "subscriptionResponse") {
      if (this.onSubscriptionError) {
        this.onSubscriptionError(msg.value);
      }
    } else if (msg.case === "pong")
      ;
    else if (msg.case === "pongResp") {
      this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
      this.resetPingTimeout();
      pingHandled = true;
    } else if (msg.case === "requestResponse") {
      if (this.onRequestResponse) {
        this.onRequestResponse(msg.value);
      }
    } else if (msg.case === "trackSubscribed") {
      if (this.onLocalTrackSubscribed) {
        this.onLocalTrackSubscribed(msg.value.trackSid);
      }
    } else if (msg.case === "roomMoved") {
      if (this.onTokenRefresh) {
        this.onTokenRefresh(msg.value.token);
      }
      if (this.onRoomMoved) {
        this.onRoomMoved(msg.value);
      }
    } else {
      this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: msg.case
      }));
    }
    if (!pingHandled) {
      this.resetPingTimeout();
    }
  }
  setReconnected() {
    while (this.queuedRequests.length > 0) {
      const req = this.queuedRequests.shift();
      if (req) {
        this.requestQueue.run(req);
      }
    }
  }
  handleOnClose(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const onCloseCallback = this.onClose;
      yield this.close();
      this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {
        reason
      }));
      if (onCloseCallback) {
        onCloseCallback(reason);
      }
    });
  }
  handleWSError(ev) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: ev
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    this.clearPingTimeout();
    if (!this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext);
      this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    if (this.pingTimeout) {
      CriticalTimers.clearTimeout(this.pingTimeout);
    }
  }
  startPingInterval() {
    this.clearPingInterval();
    this.resetPingTimeout();
    if (!this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext);
    this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext);
    this.clearPingTimeout();
    if (this.pingInterval) {
      CriticalTimers.clearInterval(this.pingInterval);
    }
  }
};
function fromProtoSessionDescription(sd) {
  const rsd = {
    type: "offer",
    sdp: sd.sdp
  };
  switch (sd.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      rsd.type = sd.type;
      break;
  }
  return rsd;
}
function toProtoSessionDescription(rsd, id) {
  const sd = new SessionDescription({
    sdp: rsd.sdp,
    type: rsd.type,
    id
  });
  return sd;
}
function createConnectionParams(token, info, opts) {
  var _a3;
  const params = new URLSearchParams();
  params.set("access_token", token);
  if (opts.reconnect) {
    params.set("reconnect", "1");
    if (opts.sid) {
      params.set("sid", opts.sid);
    }
  }
  params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
  params.set("sdk", isReactNative() ? "reactnative" : "js");
  params.set("version", info.version);
  params.set("protocol", info.protocol.toString());
  if (info.deviceModel) {
    params.set("device_model", info.deviceModel);
  }
  if (info.os) {
    params.set("os", info.os);
  }
  if (info.osVersion) {
    params.set("os_version", info.osVersion);
  }
  if (info.browser) {
    params.set("browser", info.browser);
  }
  if (info.browserVersion) {
    params.set("browser_version", info.browserVersion);
  }
  if (opts.adaptiveStream) {
    params.set("adaptive_stream", "1");
  }
  if (opts.reconnectReason) {
    params.set("reconnect_reason", opts.reconnectReason.toString());
  }
  if ((_a3 = navigator.connection) === null || _a3 === void 0 ? void 0 : _a3.type) {
    params.set("network", navigator.connection.type);
  }
  return params;
}
var DataPacketBuffer = class {
  constructor() {
    this.buffer = [];
    this._totalSize = 0;
  }
  push(item) {
    this.buffer.push(item);
    this._totalSize += item.data.byteLength;
  }
  pop() {
    const item = this.buffer.shift();
    if (item) {
      this._totalSize -= item.data.byteLength;
    }
    return item;
  }
  getAll() {
    return this.buffer.slice();
  }
  popToSequence(sequence) {
    while (this.buffer.length > 0) {
      const first = this.buffer[0];
      if (first.sequence <= sequence) {
        this.pop();
      } else {
        break;
      }
    }
  }
  alignBufferedAmount(bufferedAmount) {
    while (this.buffer.length > 0) {
      const first = this.buffer[0];
      if (this._totalSize - first.data.byteLength <= bufferedAmount) {
        break;
      }
      this.pop();
    }
  }
  get length() {
    return this.buffer.length;
  }
};
var TTLMap = class {
  /**
   * @param ttl ttl of the key (ms)
   */
  constructor(ttl) {
    this._map = /* @__PURE__ */ new Map();
    this._lastCleanup = 0;
    this.ttl = ttl;
  }
  set(key, value) {
    const now = Date.now();
    if (now - this._lastCleanup > this.ttl / 2) {
      this.cleanup();
    }
    const expiresAt = now + this.ttl;
    this._map.set(key, {
      value,
      expiresAt
    });
    return this;
  }
  get(key) {
    const entry = this._map.get(key);
    if (!entry)
      return void 0;
    if (entry.expiresAt < Date.now()) {
      this._map.delete(key);
      return void 0;
    }
    return entry.value;
  }
  has(key) {
    const entry = this._map.get(key);
    if (!entry)
      return false;
    if (entry.expiresAt < Date.now()) {
      this._map.delete(key);
      return false;
    }
    return true;
  }
  delete(key) {
    return this._map.delete(key);
  }
  clear() {
    this._map.clear();
  }
  cleanup() {
    const now = Date.now();
    for (const [key, entry] of this._map.entries()) {
      if (entry.expiresAt < now) {
        this._map.delete(key);
      }
    }
    this._lastCleanup = now;
  }
  get size() {
    this.cleanup();
    return this._map.size;
  }
  forEach(callback) {
    this.cleanup();
    for (const [key, entry] of this._map.entries()) {
      if (entry.expiresAt >= Date.now()) {
        callback(entry.value, key, this.asValueMap());
      }
    }
  }
  map(callback) {
    this.cleanup();
    const result = [];
    const valueMap = this.asValueMap();
    for (const [key, value] of valueMap.entries()) {
      result.push(callback(value, key, valueMap));
    }
    return result;
  }
  asValueMap() {
    const result = /* @__PURE__ */ new Map();
    for (const [key, entry] of this._map.entries()) {
      if (entry.expiresAt >= Date.now()) {
        result.set(key, entry.value);
      }
    }
    return result;
  }
};
var lib = {};
var parser = {};
var grammar = { exports: {} };
var hasRequiredGrammar;
function requireGrammar() {
  if (hasRequiredGrammar)
    return grammar.exports;
  hasRequiredGrammar = 1;
  var grammar$1 = grammar.exports = {
    v: [{
      name: "version",
      reg: /^(\d*)$/
    }],
    o: [{
      // o=- 20518 0 IN IP4 203.0.113.1
      // NB: sessionId will be a String in most cases because it is huge
      name: "origin",
      reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
      names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
      format: "%s %s %d %s IP%d %s"
    }],
    // default parsing of these only (though some of these feel outdated)
    s: [{
      name: "name"
    }],
    i: [{
      name: "description"
    }],
    u: [{
      name: "uri"
    }],
    e: [{
      name: "email"
    }],
    p: [{
      name: "phone"
    }],
    z: [{
      name: "timezones"
    }],
    // TODO: this one can actually be parsed properly...
    r: [{
      name: "repeats"
    }],
    // TODO: this one can also be parsed properly
    // k: [{}], // outdated thing ignored
    t: [{
      // t=0 0
      name: "timing",
      reg: /^(\d*) (\d*)/,
      names: ["start", "stop"],
      format: "%d %d"
    }],
    c: [{
      // c=IN IP4 10.47.197.26
      name: "connection",
      reg: /^IN IP(\d) (\S*)/,
      names: ["version", "ip"],
      format: "IN IP%d %s"
    }],
    b: [{
      // b=AS:4000
      push: "bandwidth",
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ["type", "limit"],
      format: "%s:%s"
    }],
    m: [{
      // m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
      names: ["type", "port", "protocol", "payloads"],
      format: "%s %d %s %s"
    }],
    a: [
      {
        // a=rtpmap:110 opus/48000/2
        push: "rtp",
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: ["payload", "codec", "rate", "encoding"],
        format: function(o4) {
          return o4.encoding ? "rtpmap:%d %s/%s/%s" : o4.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        }
      },
      {
        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
        // a=fmtp:111 minptime=10; useinbandfec=1
        push: "fmtp",
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: ["payload", "config"],
        format: "fmtp:%d %s"
      },
      {
        // a=control:streamid=0
        name: "control",
        reg: /^control:(.*)/,
        format: "control:%s"
      },
      {
        // a=rtcp:65179 IN IP4 193.84.77.194
        name: "rtcp",
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: ["port", "netType", "ipVer", "address"],
        format: function(o4) {
          return o4.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        }
      },
      {
        // a=rtcp-fb:98 trr-int 100
        push: "rtcpFbTrrInt",
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: ["payload", "value"],
        format: "rtcp-fb:%s trr-int %d"
      },
      {
        // a=rtcp-fb:98 nack rpsi
        push: "rtcpFb",
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: ["payload", "type", "subtype"],
        format: function(o4) {
          return o4.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        }
      },
      {
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:1/recvonly URI-gps-string
        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
        push: "ext",
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: ["value", "direction", "encrypt-uri", "uri", "config"],
        format: function(o4) {
          return "extmap:%d" + (o4.direction ? "/%s" : "%v") + (o4["encrypt-uri"] ? " %s" : "%v") + " %s" + (o4.config ? " %s" : "");
        }
      },
      {
        // a=extmap-allow-mixed
        name: "extmapAllowMixed",
        reg: /^(extmap-allow-mixed)/
      },
      {
        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
        push: "crypto",
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: ["id", "suite", "config", "sessionConfig"],
        format: function(o4) {
          return o4.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        }
      },
      {
        // a=setup:actpass
        name: "setup",
        reg: /^setup:(\w*)/,
        format: "setup:%s"
      },
      {
        // a=connection:new
        name: "connectionType",
        reg: /^connection:(new|existing)/,
        format: "connection:%s"
      },
      {
        // a=mid:1
        name: "mid",
        reg: /^mid:([^\s]*)/,
        format: "mid:%s"
      },
      {
        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
        name: "msid",
        reg: /^msid:(.*)/,
        format: "msid:%s"
      },
      {
        // a=ptime:20
        name: "ptime",
        reg: /^ptime:(\d*(?:\.\d*)*)/,
        format: "ptime:%d"
      },
      {
        // a=maxptime:60
        name: "maxptime",
        reg: /^maxptime:(\d*(?:\.\d*)*)/,
        format: "maxptime:%d"
      },
      {
        // a=sendrecv
        name: "direction",
        reg: /^(sendrecv|recvonly|sendonly|inactive)/
      },
      {
        // a=ice-lite
        name: "icelite",
        reg: /^(ice-lite)/
      },
      {
        // a=ice-ufrag:F7gI
        name: "iceUfrag",
        reg: /^ice-ufrag:(\S*)/,
        format: "ice-ufrag:%s"
      },
      {
        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
        name: "icePwd",
        reg: /^ice-pwd:(\S*)/,
        format: "ice-pwd:%s"
      },
      {
        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
        name: "fingerprint",
        reg: /^fingerprint:(\S*) (\S*)/,
        names: ["type", "hash"],
        format: "fingerprint:%s %s"
      },
      {
        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
        push: "candidates",
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
        format: function(o4) {
          var str = "candidate:%s %d %s %d %s %d typ %s";
          str += o4.raddr != null ? " raddr %s rport %d" : "%v%v";
          str += o4.tcptype != null ? " tcptype %s" : "%v";
          if (o4.generation != null) {
            str += " generation %d";
          }
          str += o4["network-id"] != null ? " network-id %d" : "%v";
          str += o4["network-cost"] != null ? " network-cost %d" : "%v";
          return str;
        }
      },
      {
        // a=end-of-candidates (keep after the candidates line for readability)
        name: "endOfCandidates",
        reg: /^(end-of-candidates)/
      },
      {
        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
        name: "remoteCandidates",
        reg: /^remote-candidates:(.*)/,
        format: "remote-candidates:%s"
      },
      {
        // a=ice-options:google-ice
        name: "iceOptions",
        reg: /^ice-options:(\S*)/,
        format: "ice-options:%s"
      },
      {
        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
        push: "ssrcs",
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: ["id", "attribute", "value"],
        format: function(o4) {
          var str = "ssrc:%d";
          if (o4.attribute != null) {
            str += " %s";
            if (o4.value != null) {
              str += ":%s";
            }
          }
          return str;
        }
      },
      {
        // a=ssrc-group:FEC 1 2
        // a=ssrc-group:FEC-FR 3004364195 1080772241
        push: "ssrcGroups",
        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: ["semantics", "ssrcs"],
        format: "ssrc-group:%s %s"
      },
      {
        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
        name: "msidSemantic",
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: ["semantic", "token"],
        format: "msid-semantic: %s %s"
        // space after ':' is not accidental
      },
      {
        // a=group:BUNDLE audio video
        push: "groups",
        reg: /^group:(\w*) (.*)/,
        names: ["type", "mids"],
        format: "group:%s %s"
      },
      {
        // a=rtcp-mux
        name: "rtcpMux",
        reg: /^(rtcp-mux)/
      },
      {
        // a=rtcp-rsize
        name: "rtcpRsize",
        reg: /^(rtcp-rsize)/
      },
      {
        // a=sctpmap:5000 webrtc-datachannel 1024
        name: "sctpmap",
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: ["sctpmapNumber", "app", "maxMessageSize"],
        format: function(o4) {
          return o4.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        }
      },
      {
        // a=x-google-flag:conference
        name: "xGoogleFlag",
        reg: /^x-google-flag:([^\s]*)/,
        format: "x-google-flag:%s"
      },
      {
        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
        push: "rids",
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: ["id", "direction", "params"],
        format: function(o4) {
          return o4.params ? "rid:%s %s %s" : "rid:%s %s";
        }
      },
      {
        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
        // a=imageattr:* send [x=800,y=640] recv *
        // a=imageattr:100 recv [x=320,y=240]
        push: "imageattrs",
        reg: new RegExp(
          // a=imageattr:97
          "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
        ),
        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
        format: function(o4) {
          return "imageattr:%s %s %s" + (o4.dir2 ? " %s %s" : "");
        }
      },
      {
        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
        // a=simulcast:recv 1;4,5 send 6;7
        name: "simulcast",
        reg: new RegExp(
          // a=simulcast:
          "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
        ),
        names: ["dir1", "list1", "dir2", "list2"],
        format: function(o4) {
          return "simulcast:%s %s" + (o4.dir2 ? " %s %s" : "");
        }
      },
      {
        // old simulcast draft 03 (implemented by Firefox)
        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
        // a=simulcast: recv pt=97;98 send pt=97
        // a=simulcast: send rid=5;6;7 paused=6,7
        name: "simulcast_03",
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: ["value"],
        format: "simulcast: %s"
      },
      {
        // a=framerate:25
        // a=framerate:29.97
        name: "framerate",
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: "framerate:%s"
      },
      {
        // RFC4570
        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
        name: "sourceFilter",
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
        format: "source-filter: %s %s %s %s %s"
      },
      {
        // a=bundle-only
        name: "bundleOnly",
        reg: /^(bundle-only)/
      },
      {
        // a=label:1
        name: "label",
        reg: /^label:(.+)/,
        format: "label:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
        name: "sctpPort",
        reg: /^sctp-port:(\d+)$/,
        format: "sctp-port:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
        name: "maxMessageSize",
        reg: /^max-message-size:(\d+)$/,
        format: "max-message-size:%s"
      },
      {
        // RFC7273
        // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
        push: "tsRefClocks",
        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
        names: ["clksrc", "clksrcExt"],
        format: function(o4) {
          return "ts-refclk:%s" + (o4.clksrcExt != null ? "=%s" : "");
        }
      },
      {
        // RFC7273
        // a=mediaclk:direct=963214424
        name: "mediaClk",
        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
        names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
        format: function(o4) {
          var str = "mediaclk:";
          str += o4.id != null ? "id=%s %s" : "%v%s";
          str += o4.mediaClockValue != null ? "=%s" : "";
          str += o4.rateNumerator != null ? " rate=%s" : "";
          str += o4.rateDenominator != null ? "/%s" : "";
          return str;
        }
      },
      {
        // a=keywds:keywords
        name: "keywords",
        reg: /^keywds:(.+)$/,
        format: "keywds:%s"
      },
      {
        // a=content:main
        name: "content",
        reg: /^content:(.+)/,
        format: "content:%s"
      },
      // BFCP https://tools.ietf.org/html/rfc4583
      {
        // a=floorctrl:c-s
        name: "bfcpFloorCtrl",
        reg: /^floorctrl:(c-only|s-only|c-s)/,
        format: "floorctrl:%s"
      },
      {
        // a=confid:1
        name: "bfcpConfId",
        reg: /^confid:(\d+)/,
        format: "confid:%s"
      },
      {
        // a=userid:1
        name: "bfcpUserId",
        reg: /^userid:(\d+)/,
        format: "userid:%s"
      },
      {
        // a=floorid:1
        name: "bfcpFloorId",
        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
        names: ["id", "mStream"],
        format: "floorid:%s mstrm:%s"
      },
      {
        // any a= that we don't understand is kept verbatim on media.invalid
        push: "invalid",
        names: ["value"]
      }
    ]
  };
  Object.keys(grammar$1).forEach(function(key) {
    var objs = grammar$1[key];
    objs.forEach(function(obj) {
      if (!obj.reg) {
        obj.reg = /(.*)/;
      }
      if (!obj.format) {
        obj.format = "%s";
      }
    });
  });
  return grammar.exports;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser)
    return parser;
  hasRequiredParser = 1;
  (function(exports) {
    var toIntIfInt = function(v3) {
      return String(Number(v3)) === v3 ? Number(v3) : v3;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i3 = 0; i3 < names.length; i3 += 1) {
          if (match[i3 + 1] != null) {
            location[names[i3]] = toIntIfInt(match[i3 + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar2 = requireGrammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp2) {
      var session = {}, media = [], location = session;
      sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l3) {
        var type = l3[0];
        var content = l3.slice(2);
        if (type === "m") {
          media.push({
            rtp: [],
            fmtp: []
          });
          location = media[media.length - 1];
        }
        for (var j3 = 0; j3 < (grammar2[type] || []).length; j3 += 1) {
          var obj = grammar2[type][j3];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s3 = expr.split(/=(.+)/, 2);
      if (s3.length === 2) {
        acc[s3[0]] = toIntIfInt(s3[1]);
      } else if (s3.length === 1 && expr.length > 1) {
        acc[s3[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i3 = 0; i3 < parts.length; i3 += 3) {
        candidates.push({
          component: parts[i3],
          ip: parts[i3 + 1],
          port: parts[i3 + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  })(parser);
  return parser;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter)
    return writer;
  hasRequiredWriter = 1;
  var grammar2 = requireGrammar();
  var formatRegExp = /%[sdv%]/g;
  var format = function(formatStr) {
    var i3 = 1;
    var args = arguments;
    var len = args.length;
    return formatStr.replace(formatRegExp, function(x3) {
      if (i3 >= len) {
        return x3;
      }
      var arg = args[i3];
      i3 += 1;
      switch (x3) {
        case "%%":
          return "%";
        case "%s":
          return String(arg);
        case "%d":
          return Number(arg);
        case "%v":
          return "";
      }
    });
  };
  var makeLine = function(type, obj, location) {
    var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
    var args = [type + "=" + str];
    if (obj.names) {
      for (var i3 = 0; i3 < obj.names.length; i3 += 1) {
        var n3 = obj.names[i3];
        if (obj.name) {
          args.push(location[obj.name][n3]);
        } else {
          args.push(location[obj.names[i3]]);
        }
      }
    } else {
      args.push(location[obj.name]);
    }
    return format.apply(null, args);
  };
  var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
  var defaultInnerOrder = ["i", "c", "b", "a"];
  writer = function(session, opts) {
    opts = opts || {};
    if (session.version == null) {
      session.version = 0;
    }
    if (session.name == null) {
      session.name = " ";
    }
    session.media.forEach(function(mLine) {
      if (mLine.payloads == null) {
        mLine.payloads = "";
      }
    });
    var outerOrder = opts.outerOrder || defaultOuterOrder;
    var innerOrder = opts.innerOrder || defaultInnerOrder;
    var sdp2 = [];
    outerOrder.forEach(function(type) {
      grammar2[type].forEach(function(obj) {
        if (obj.name in session && session[obj.name] != null) {
          sdp2.push(makeLine(type, obj, session));
        } else if (obj.push in session && session[obj.push] != null) {
          session[obj.push].forEach(function(el) {
            sdp2.push(makeLine(type, obj, el));
          });
        }
      });
    });
    session.media.forEach(function(mLine) {
      sdp2.push(makeLine("m", grammar2.m[0], mLine));
      innerOrder.forEach(function(type) {
        grammar2[type].forEach(function(obj) {
          if (obj.name in mLine && mLine[obj.name] != null) {
            sdp2.push(makeLine(type, obj, mLine));
          } else if (obj.push in mLine && mLine[obj.push] != null) {
            mLine[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
    });
    return sdp2.join("\r\n") + "\r\n";
  };
  return writer;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib;
  hasRequiredLib = 1;
  var parser2 = requireParser();
  var writer2 = requireWriter();
  var grammar2 = requireGrammar();
  lib.grammar = grammar2;
  lib.write = writer2;
  lib.parse = parser2.parse;
  lib.parseParams = parser2.parseParams;
  lib.parseFmtpConfig = parser2.parseFmtpConfig;
  lib.parsePayloads = parser2.parsePayloads;
  lib.parseRemoteCandidates = parser2.parseRemoteCandidates;
  lib.parseImageAttributes = parser2.parseImageAttributes;
  lib.parseSimulcastStreamList = parser2.parseSimulcastStreamList;
  return lib;
}
var libExports = requireLib();
function r3(r4, e4, n3) {
  var i3, t3, o4;
  void 0 === e4 && (e4 = 50), void 0 === n3 && (n3 = {});
  var a3 = null != (i3 = n3.isImmediate) && i3, u3 = null != (t3 = n3.callback) && t3, c3 = n3.maxWait, v3 = Date.now(), l3 = [];
  function f3() {
    if (void 0 !== c3) {
      var r5 = Date.now() - v3;
      if (r5 + e4 >= c3)
        return c3 - r5;
    }
    return e4;
  }
  var d3 = function() {
    var e5 = [].slice.call(arguments), n4 = this;
    return new Promise(function(i4, t4) {
      var c4 = a3 && void 0 === o4;
      if (void 0 !== o4 && clearTimeout(o4), o4 = setTimeout(function() {
        if (o4 = void 0, v3 = Date.now(), !a3) {
          var i5 = r4.apply(n4, e5);
          u3 && u3(i5), l3.forEach(function(r5) {
            return (0, r5.resolve)(i5);
          }), l3 = [];
        }
      }, f3()), c4) {
        var d4 = r4.apply(n4, e5);
        return u3 && u3(d4), i4(d4);
      }
      l3.push({
        resolve: i4,
        reject: t4
      });
    });
  };
  return d3.cancel = function(r5) {
    void 0 !== o4 && clearTimeout(o4), l3.forEach(function(e5) {
      return (0, e5.reject)(r5);
    }), l3 = [];
  }, d3;
}
var startBitrateForSVC = 0.7;
var debounceInterval = 20;
var PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
var PCTransport = class extends eventsExports.EventEmitter {
  get pc() {
    if (!this._pc) {
      this._pc = this.createPC();
    }
    return this._pc;
  }
  constructor(config) {
    let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _a3;
    super();
    this.log = livekitLogger;
    this.ddExtID = 0;
    this.latestOfferId = 0;
    this.pendingCandidates = [];
    this.restartingIce = false;
    this.renegotiate = false;
    this.trackBitrates = [];
    this.remoteStereoMids = [];
    this.remoteNackMids = [];
    this.negotiate = r3((onError) => __awaiter(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (e4) {
        if (onError) {
          onError(e4);
        } else {
          throw e4;
        }
      }
    }), debounceInterval);
    this.close = () => {
      if (!this._pc) {
        return;
      }
      this._pc.close();
      this._pc.onconnectionstatechange = null;
      this._pc.oniceconnectionstatechange = null;
      this._pc.onicegatheringstatechange = null;
      this._pc.ondatachannel = null;
      this._pc.onnegotiationneeded = null;
      this._pc.onsignalingstatechange = null;
      this._pc.onicecandidate = null;
      this._pc.ondatachannel = null;
      this._pc.ontrack = null;
      this._pc.onconnectionstatechange = null;
      this._pc.oniceconnectionstatechange = null;
      this._pc = null;
    };
    this.log = getLogger((_a3 = loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.PCTransport);
    this.loggerOptions = loggerOptions;
    this.config = config;
    this._pc = this.createPC();
    this.offerLock = new _3();
  }
  createPC() {
    const pc3 = new RTCPeerConnection(this.config);
    pc3.onicecandidate = (ev) => {
      var _a3;
      if (!ev.candidate)
        return;
      (_a3 = this.onIceCandidate) === null || _a3 === void 0 ? void 0 : _a3.call(this, ev.candidate);
    };
    pc3.onicecandidateerror = (ev) => {
      var _a3;
      (_a3 = this.onIceCandidateError) === null || _a3 === void 0 ? void 0 : _a3.call(this, ev);
    };
    pc3.oniceconnectionstatechange = () => {
      var _a3;
      (_a3 = this.onIceConnectionStateChange) === null || _a3 === void 0 ? void 0 : _a3.call(this, pc3.iceConnectionState);
    };
    pc3.onsignalingstatechange = () => {
      var _a3;
      (_a3 = this.onSignalingStatechange) === null || _a3 === void 0 ? void 0 : _a3.call(this, pc3.signalingState);
    };
    pc3.onconnectionstatechange = () => {
      var _a3;
      (_a3 = this.onConnectionStateChange) === null || _a3 === void 0 ? void 0 : _a3.call(this, pc3.connectionState);
    };
    pc3.ondatachannel = (ev) => {
      var _a3;
      (_a3 = this.onDataChannel) === null || _a3 === void 0 ? void 0 : _a3.call(this, ev);
    };
    pc3.ontrack = (ev) => {
      var _a3;
      (_a3 = this.onTrack) === null || _a3 === void 0 ? void 0 : _a3.call(this, ev);
    };
    return pc3;
  }
  get logContext() {
    var _a3, _b;
    return Object.assign({}, (_b = (_a3 = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a3));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(candidate) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce) {
        return this.pc.addIceCandidate(candidate);
      }
      this.pendingCandidates.push(candidate);
    });
  }
  setRemoteDescription(sd, offerId) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (sd.type === "answer" && this.latestOfferId > 0 && offerId > 0 && offerId !== this.latestOfferId) {
        this.log.warn("ignoring answer for old offer", Object.assign(Object.assign({}, this.logContext), {
          offerId,
          latestOfferId: this.latestOfferId
        }));
        return false;
      }
      let mungedSDP = void 0;
      if (sd.type === "offer") {
        let {
          stereoMids,
          nackMids
        } = extractStereoAndNackAudioFromOffer(sd);
        this.remoteStereoMids = stereoMids;
        this.remoteNackMids = nackMids;
      } else if (sd.type === "answer") {
        const sdpParsed = libExports.parse((_a3 = sd.sdp) !== null && _a3 !== void 0 ? _a3 : "");
        sdpParsed.media.forEach((media) => {
          if (media.type === "audio") {
            this.trackBitrates.some((trackbr) => {
              if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {
                return false;
              }
              let codecPayload = 0;
              media.rtp.some((rtp) => {
                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                  codecPayload = rtp.payload;
                  return true;
                }
                return false;
              });
              if (codecPayload === 0) {
                return true;
              }
              let fmtpFound = false;
              for (const fmtp of media.fmtp) {
                if (fmtp.payload === codecPayload) {
                  fmtp.config = fmtp.config.split(";").filter((attr) => !attr.includes("maxaveragebitrate")).join(";");
                  if (trackbr.maxbr > 0) {
                    fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1e3);
                  }
                  fmtpFound = true;
                  break;
                }
              }
              if (!fmtpFound) {
                if (trackbr.maxbr > 0) {
                  media.fmtp.push({
                    payload: codecPayload,
                    config: "maxaveragebitrate=".concat(trackbr.maxbr * 1e3)
                  });
                }
              }
              return true;
            });
          }
        });
        mungedSDP = libExports.write(sdpParsed);
      }
      yield this.setMungedSDP(sd, mungedSDP, true);
      this.pendingCandidates.forEach((candidate) => {
        this.pc.addIceCandidate(candidate);
      });
      this.pendingCandidates = [];
      this.restartingIce = false;
      if (this.renegotiate) {
        this.renegotiate = false;
        yield this.createAndSendOffer();
      } else if (sd.type === "answer") {
        this.emit(PCEvents.NegotiationComplete);
        if (sd.sdp) {
          const sdpParsed = libExports.parse(sd.sdp);
          sdpParsed.media.forEach((media) => {
            if (media.type === "video") {
              this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
            }
          });
        }
      }
      return true;
    });
  }
  createAndSendOffer(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const unlock = yield this.offerLock.lock();
      try {
        if (this.onOffer === void 0) {
          return;
        }
        if (options === null || options === void 0 ? void 0 : options.iceRestart) {
          this.log.debug("restarting ICE", this.logContext);
          this.restartingIce = true;
        }
        if (this._pc && this._pc.signalingState === "have-local-offer") {
          const currentSD = this._pc.remoteDescription;
          if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
            yield this._pc.setRemoteDescription(currentSD);
          } else {
            this.renegotiate = true;
            return;
          }
        } else if (!this._pc || this._pc.signalingState === "closed") {
          this.log.warn("could not createOffer with closed peer connection", this.logContext);
          return;
        }
        this.log.debug("starting to negotiate", this.logContext);
        const offerId = this.latestOfferId + 1;
        this.latestOfferId = offerId;
        const offer = yield this.pc.createOffer(options);
        this.log.debug("original offer", Object.assign({
          sdp: offer.sdp
        }, this.logContext));
        const sdpParsed = libExports.parse((_a3 = offer.sdp) !== null && _a3 !== void 0 ? _a3 : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, [], []);
          } else if (media.type === "video") {
            this.trackBitrates.some((trackbr) => {
              if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                return false;
              }
              let codecPayload = 0;
              media.rtp.some((rtp) => {
                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                  codecPayload = rtp.payload;
                  return true;
                }
                return false;
              });
              if (codecPayload === 0) {
                return true;
              }
              if (isSVCCodec(trackbr.codec)) {
                this.ensureVideoDDExtensionForSVC(media, sdpParsed);
              }
              if (trackbr.codec !== "av1") {
                return true;
              }
              const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
              for (const fmtp of media.fmtp) {
                if (fmtp.payload === codecPayload) {
                  if (!fmtp.config.includes("x-google-start-bitrate")) {
                    fmtp.config += ";x-google-start-bitrate=".concat(startBitrate);
                  }
                  break;
                }
              }
              return true;
            });
          }
        });
        if (this.latestOfferId > offerId) {
          this.log.warn("latestOfferId mismatch", Object.assign(Object.assign({}, this.logContext), {
            latestOfferId: this.latestOfferId,
            offerId
          }));
          return;
        }
        yield this.setMungedSDP(offer, libExports.write(sdpParsed));
        this.onOffer(offer, this.latestOfferId);
      } finally {
        unlock();
      }
    });
  }
  createAndSetAnswer() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const answer = yield this.pc.createAnswer();
      const sdpParsed = libExports.parse((_a3 = answer.sdp) !== null && _a3 !== void 0 ? _a3 : "");
      sdpParsed.media.forEach((media) => {
        ensureIPAddrMatchVersion(media);
        if (media.type === "audio") {
          ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
        }
      });
      yield this.setMungedSDP(answer, libExports.write(sdpParsed));
      return answer;
    });
  }
  createDataChannel(label, dataChannelDict) {
    return this.pc.createDataChannel(label, dataChannelDict);
  }
  addTransceiver(mediaStreamTrack, transceiverInit) {
    return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
  }
  addTrack(track2) {
    if (!this._pc) {
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    }
    return this._pc.addTrack(track2);
  }
  setTrackCodecBitrate(info) {
    this.trackBitrates.push(info);
  }
  setConfiguration(rtcConfig) {
    var _a3;
    if (!this._pc) {
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    }
    return (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.setConfiguration(rtcConfig);
  }
  canRemoveTrack() {
    var _a3;
    return !!((_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.removeTrack);
  }
  removeTrack(sender) {
    var _a3;
    return (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.removeTrack(sender);
  }
  getConnectionState() {
    var _a3, _b;
    return (_b = (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.connectionState) !== null && _b !== void 0 ? _b : "closed";
  }
  getICEConnectionState() {
    var _a3, _b;
    return (_b = (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";
  }
  getSignallingState() {
    var _a3, _b;
    return (_b = (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.signalingState) !== null && _b !== void 0 ? _b : "closed";
  }
  getTransceivers() {
    var _a3, _b;
    return (_b = (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.getTransceivers()) !== null && _b !== void 0 ? _b : [];
  }
  getSenders() {
    var _a3, _b;
    return (_b = (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.getSenders()) !== null && _b !== void 0 ? _b : [];
  }
  getLocalDescription() {
    var _a3;
    return (_a3 = this._pc) === null || _a3 === void 0 ? void 0 : _a3.localDescription;
  }
  getRemoteDescription() {
    var _a3;
    return (_a3 = this.pc) === null || _a3 === void 0 ? void 0 : _a3.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!this._pc) {
        return;
      }
      let selectedCandidatePairId = "";
      const candidatePairs = /* @__PURE__ */ new Map();
      const candidates = /* @__PURE__ */ new Map();
      const stats = yield this._pc.getStats();
      stats.forEach((v3) => {
        switch (v3.type) {
          case "transport":
            selectedCandidatePairId = v3.selectedCandidatePairId;
            break;
          case "candidate-pair":
            if (selectedCandidatePairId === "" && v3.selected) {
              selectedCandidatePairId = v3.id;
            }
            candidatePairs.set(v3.id, v3);
            break;
          case "remote-candidate":
            candidates.set(v3.id, "".concat(v3.address, ":").concat(v3.port));
            break;
        }
      });
      if (selectedCandidatePairId === "") {
        return void 0;
      }
      const selectedID = (_a3 = candidatePairs.get(selectedCandidatePairId)) === null || _a3 === void 0 ? void 0 : _a3.remoteCandidateId;
      if (selectedID === void 0) {
        return void 0;
      }
      return candidates.get(selectedID);
    });
  }
  setMungedSDP(sd, munged, remote) {
    return __awaiter(this, void 0, void 0, function* () {
      if (munged) {
        const originalSdp = sd.sdp;
        sd.sdp = munged;
        try {
          this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);
          if (remote) {
            yield this.pc.setRemoteDescription(sd);
          } else {
            yield this.pc.setLocalDescription(sd);
          }
          return;
        } catch (e4) {
          this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: e4,
            sdp: munged
          }));
          sd.sdp = originalSdp;
        }
      }
      try {
        if (remote) {
          yield this.pc.setRemoteDescription(sd);
        } else {
          yield this.pc.setLocalDescription(sd);
        }
      } catch (e4) {
        let msg = "unknown error";
        if (e4 instanceof Error) {
          msg = e4.message;
        } else if (typeof e4 === "string") {
          msg = e4;
        }
        const fields = {
          error: msg,
          sdp: sd.sdp
        };
        if (!remote && this.pc.remoteDescription) {
          fields.remoteSdp = this.pc.remoteDescription;
        }
        this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {
          fields
        }));
        throw new NegotiationError(msg);
      }
    });
  }
  ensureVideoDDExtensionForSVC(media, sdp2) {
    var _a3, _b;
    const ddFound = (_a3 = media.ext) === null || _a3 === void 0 ? void 0 : _a3.some((ext) => {
      if (ext.uri === ddExtensionURI) {
        return true;
      }
      return false;
    });
    if (!ddFound) {
      if (this.ddExtID === 0) {
        let maxID = 0;
        sdp2.media.forEach((m3) => {
          var _a4;
          if (m3.type !== "video") {
            return;
          }
          (_a4 = m3.ext) === null || _a4 === void 0 ? void 0 : _a4.forEach((ext) => {
            if (ext.value > maxID) {
              maxID = ext.value;
            }
          });
        });
        this.ddExtID = maxID + 1;
      }
      (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({
        value: this.ddExtID,
        uri: ddExtensionURI
      });
    }
  }
};
function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
  let opusPayload = 0;
  media.rtp.some((rtp) => {
    if (rtp.codec === "opus") {
      opusPayload = rtp.payload;
      return true;
    }
    return false;
  });
  if (opusPayload > 0) {
    if (!media.rtcpFb) {
      media.rtcpFb = [];
    }
    if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
      media.rtcpFb.push({
        payload: opusPayload,
        type: "nack"
      });
    }
    if (stereoMids.includes(media.mid)) {
      media.fmtp.some((fmtp) => {
        if (fmtp.payload === opusPayload) {
          if (!fmtp.config.includes("stereo=1")) {
            fmtp.config += ";stereo=1";
          }
          return true;
        }
        return false;
      });
    }
  }
}
function extractStereoAndNackAudioFromOffer(offer) {
  var _a3;
  const stereoMids = [];
  const nackMids = [];
  const sdpParsed = libExports.parse((_a3 = offer.sdp) !== null && _a3 !== void 0 ? _a3 : "");
  let opusPayload = 0;
  sdpParsed.media.forEach((media) => {
    var _a4;
    if (media.type === "audio") {
      media.rtp.some((rtp) => {
        if (rtp.codec === "opus") {
          opusPayload = rtp.payload;
          return true;
        }
        return false;
      });
      if ((_a4 = media.rtcpFb) === null || _a4 === void 0 ? void 0 : _a4.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
        nackMids.push(media.mid);
      }
      media.fmtp.some((fmtp) => {
        if (fmtp.payload === opusPayload) {
          if (fmtp.config.includes("sprop-stereo=1")) {
            stereoMids.push(media.mid);
          }
          return true;
        }
        return false;
      });
    }
  });
  return {
    stereoMids,
    nackMids
  };
}
function ensureIPAddrMatchVersion(media) {
  if (media.connection) {
    const isV6 = media.connection.ip.indexOf(":") >= 0;
    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {
      media.connection.ip = "0.0.0.0";
      media.connection.version = 4;
    }
  }
}
var defaultVideoCodec = "vp8";
var publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: true,
  red: true,
  forceStereo: false,
  simulcast: true,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: false,
  videoCodec: defaultVideoCodec,
  backupCodec: true,
  preConnectBuffer: false
};
var audioDefaults = {
  deviceId: {
    ideal: "default"
  },
  autoGainControl: true,
  echoCancellation: true,
  noiseSuppression: true,
  voiceIsolation: true
};
var videoDefaults = {
  deviceId: {
    ideal: "default"
  },
  resolution: VideoPresets.h720.resolution
};
var roomOptionDefaults = {
  adaptiveStream: false,
  dynacast: false,
  stopLocalTrackOnUnpublish: true,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: true,
  webAudioMix: false
};
var roomConnectOptionDefaults = {
  autoSubscribe: true,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(PCTransportState2) {
  PCTransportState2[PCTransportState2["NEW"] = 0] = "NEW";
  PCTransportState2[PCTransportState2["CONNECTING"] = 1] = "CONNECTING";
  PCTransportState2[PCTransportState2["CONNECTED"] = 2] = "CONNECTED";
  PCTransportState2[PCTransportState2["FAILED"] = 3] = "FAILED";
  PCTransportState2[PCTransportState2["CLOSING"] = 4] = "CLOSING";
  PCTransportState2[PCTransportState2["CLOSED"] = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
var PCTransportManager = class {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(rtcConfig, subscriberPrimary, loggerOptions) {
    var _a3;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
    this.log = livekitLogger;
    this.updateState = () => {
      var _a4;
      const previousState = this.state;
      const connectionStates = this.requiredTransports.map((tr3) => tr3.getConnectionState());
      if (connectionStates.every((st3) => st3 === "connected")) {
        this.state = PCTransportState.CONNECTED;
      } else if (connectionStates.some((st3) => st3 === "failed")) {
        this.state = PCTransportState.FAILED;
      } else if (connectionStates.some((st3) => st3 === "connecting")) {
        this.state = PCTransportState.CONNECTING;
      } else if (connectionStates.every((st3) => st3 === "closed")) {
        this.state = PCTransportState.CLOSED;
      } else if (connectionStates.some((st3) => st3 === "closed")) {
        this.state = PCTransportState.CLOSING;
      } else if (connectionStates.every((st3) => st3 === "new")) {
        this.state = PCTransportState.NEW;
      }
      if (previousState !== this.state) {
        this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[this.state]), this.logContext);
        (_a4 = this.onStateChange) === null || _a4 === void 0 ? void 0 : _a4.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());
      }
    };
    this.log = getLogger((_a3 = loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.PCManager);
    this.loggerOptions = loggerOptions;
    this.isPublisherConnectionRequired = !subscriberPrimary;
    this.isSubscriberConnectionRequired = subscriberPrimary;
    this.publisher = new PCTransport(rtcConfig, loggerOptions);
    this.subscriber = new PCTransport(rtcConfig, loggerOptions);
    this.publisher.onConnectionStateChange = this.updateState;
    this.subscriber.onConnectionStateChange = this.updateState;
    this.publisher.onIceConnectionStateChange = this.updateState;
    this.subscriber.onIceConnectionStateChange = this.updateState;
    this.publisher.onSignalingStatechange = this.updateState;
    this.subscriber.onSignalingStatechange = this.updateState;
    this.publisher.onIceCandidate = (candidate) => {
      var _a4;
      (_a4 = this.onIceCandidate) === null || _a4 === void 0 ? void 0 : _a4.call(this, candidate, SignalTarget.PUBLISHER);
    };
    this.subscriber.onIceCandidate = (candidate) => {
      var _a4;
      (_a4 = this.onIceCandidate) === null || _a4 === void 0 ? void 0 : _a4.call(this, candidate, SignalTarget.SUBSCRIBER);
    };
    this.subscriber.onDataChannel = (ev) => {
      var _a4;
      (_a4 = this.onDataChannel) === null || _a4 === void 0 ? void 0 : _a4.call(this, ev);
    };
    this.subscriber.onTrack = (ev) => {
      var _a4;
      (_a4 = this.onTrack) === null || _a4 === void 0 ? void 0 : _a4.call(this, ev);
    };
    this.publisher.onOffer = (offer, offerId) => {
      var _a4;
      (_a4 = this.onPublisherOffer) === null || _a4 === void 0 ? void 0 : _a4.call(this, offer, offerId);
    };
    this.state = PCTransportState.NEW;
    this.connectionLock = new _3();
    this.remoteOfferLock = new _3();
  }
  get logContext() {
    var _a3, _b;
    return Object.assign({}, (_b = (_a3 = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a3));
  }
  requirePublisher() {
    let require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this.isPublisherConnectionRequired = require2;
    this.updateState();
  }
  requireSubscriber() {
    let require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    this.isSubscriberConnectionRequired = require2;
    this.updateState();
  }
  createAndSendPublisherOffer(options) {
    return this.publisher.createAndSendOffer(options);
  }
  setPublisherAnswer(sd, offerId) {
    return this.publisher.setRemoteDescription(sd, offerId);
  }
  removeTrack(sender) {
    return this.publisher.removeTrack(sender);
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const publisher = this.publisher;
        for (const sender of publisher.getSenders()) {
          try {
            if (publisher.canRemoveTrack()) {
              publisher.removeTrack(sender);
            }
          } catch (e4) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: e4
            }));
          }
        }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]);
      this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = true;
      if (this.needsPublisher) {
        yield this.createAndSendPublisherOffer({
          iceRestart: true
        });
      }
    });
  }
  addIceCandidate(candidate, target) {
    return __awaiter(this, void 0, void 0, function* () {
      if (target === SignalTarget.PUBLISHER) {
        yield this.publisher.addIceCandidate(candidate);
      } else {
        yield this.subscriber.addIceCandidate(candidate);
      }
    });
  }
  createSubscriberAnswerFromOffer(sd, offerId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: sd.type,
        sdp: sd.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      }));
      const unlock = yield this.remoteOfferLock.lock();
      try {
        const success = yield this.subscriber.setRemoteDescription(sd, offerId);
        if (!success) {
          return void 0;
        }
        const answer = yield this.subscriber.createAndSetAnswer();
        return answer;
      } finally {
        unlock();
      }
    });
  }
  updateConfiguration(config, iceRestart) {
    this.publisher.setConfiguration(config);
    this.subscriber.setConfiguration(config);
    if (iceRestart) {
      this.triggerIceRestart();
    }
  }
  ensurePCTransportConnection(abortController, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const unlock = yield this.connectionLock.lock();
      try {
        if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {
          this.log.debug("negotiation required, start negotiating", this.logContext);
          this.publisher.negotiate();
        }
        yield Promise.all((_a3 = this.requiredTransports) === null || _a3 === void 0 ? void 0 : _a3.map((transport) => this.ensureTransportConnected(transport, abortController, timeout)));
      } finally {
        unlock();
      }
    });
  }
  negotiate(abortController) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const negotiationTimeout = setTimeout(() => {
          reject("negotiation timed out");
        }, this.peerConnectionTimeout);
        const abortHandler = () => {
          clearTimeout(negotiationTimeout);
          reject("negotiation aborted");
        };
        abortController.signal.addEventListener("abort", abortHandler);
        this.publisher.once(PCEvents.NegotiationStarted, () => {
          if (abortController.signal.aborted) {
            return;
          }
          this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(negotiationTimeout);
            resolve();
          });
        });
        yield this.publisher.negotiate((e4) => {
          clearTimeout(negotiationTimeout);
          reject(e4);
        });
      }));
    });
  }
  addPublisherTransceiver(track2, transceiverInit) {
    return this.publisher.addTransceiver(track2, transceiverInit);
  }
  addPublisherTrack(track2) {
    return this.publisher.addTrack(track2);
  }
  createPublisherDataChannel(label, dataChannelDict) {
    return this.publisher.createDataChannel(label, dataChannelDict);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(target) {
    if (target === SignalTarget.PUBLISHER) {
      return this.publisher.getConnectedAddress();
    } else if (target === SignalTarget.SUBSCRIBER) {
      return this.publisher.getConnectedAddress();
    }
    return this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const transports = [];
    if (this.isPublisherConnectionRequired) {
      transports.push(this.publisher);
    }
    if (this.isSubscriberConnectionRequired) {
      transports.push(this.subscriber);
    }
    return transports;
  }
  ensureTransportConnected(pcTransport_1, abortController_1) {
    return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {
      var _this = this;
      let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
      return function* () {
        const connectionState = pcTransport.getConnectionState();
        if (connectionState === "connected") {
          return;
        }
        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
          const abortHandler = () => {
            this.log.warn("abort transport connection", this.logContext);
            CriticalTimers.clearTimeout(connectTimeout);
            reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
          };
          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
            abortHandler();
          }
          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);
          const connectTimeout = CriticalTimers.setTimeout(() => {
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
            reject(new ConnectionError("could not establish pc connection", ConnectionErrorReason.InternalError));
          }, timeout);
          while (this.state !== PCTransportState.CONNECTED) {
            yield sleep(50);
            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
              reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
              return;
            }
          }
          CriticalTimers.clearTimeout(connectTimeout);
          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
          resolve();
        }));
      }();
    });
  }
};
var RpcError = class _RpcError extends Error {
  /**
   * Creates an error object with the given code and message, plus an optional data payload.
   *
   * If thrown in an RPC method handler, the error will be sent back to the caller.
   *
   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
   */
  constructor(code, message, data) {
    super(message);
    this.code = code;
    this.message = truncateBytes(message, _RpcError.MAX_MESSAGE_BYTES);
    this.data = data ? truncateBytes(data, _RpcError.MAX_DATA_BYTES) : void 0;
  }
  /**
   * @internal
   */
  static fromProto(proto) {
    return new _RpcError(proto.code, proto.message, proto.data);
  }
  /**
   * @internal
   */
  toProto() {
    return new RpcError$1({
      code: this.code,
      message: this.message,
      data: this.data
    });
  }
  /**
   * Creates an error object from the code, with an auto-populated message.
   *
   * @internal
   */
  static builtIn(key, data) {
    return new _RpcError(_RpcError.ErrorCode[key], _RpcError.ErrorMessage[key], data);
  }
};
RpcError.MAX_MESSAGE_BYTES = 256;
RpcError.MAX_DATA_BYTES = 15360;
RpcError.ErrorCode = {
  APPLICATION_ERROR: 1500,
  CONNECTION_TIMEOUT: 1501,
  RESPONSE_TIMEOUT: 1502,
  RECIPIENT_DISCONNECTED: 1503,
  RESPONSE_PAYLOAD_TOO_LARGE: 1504,
  SEND_FAILED: 1505,
  UNSUPPORTED_METHOD: 1400,
  RECIPIENT_NOT_FOUND: 1401,
  REQUEST_PAYLOAD_TOO_LARGE: 1402,
  UNSUPPORTED_SERVER: 1403,
  UNSUPPORTED_VERSION: 1404
};
RpcError.ErrorMessage = {
  APPLICATION_ERROR: "Application error in method handler",
  CONNECTION_TIMEOUT: "Connection timeout",
  RESPONSE_TIMEOUT: "Response timeout",
  RECIPIENT_DISCONNECTED: "Recipient disconnected",
  RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
  SEND_FAILED: "Failed to send",
  UNSUPPORTED_METHOD: "Method not supported at destination",
  RECIPIENT_NOT_FOUND: "Recipient not found",
  REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
  UNSUPPORTED_SERVER: "RPC not supported by server",
  UNSUPPORTED_VERSION: "Unsupported RPC version"
};
var MAX_PAYLOAD_BYTES = 15360;
function byteLength(str) {
  const encoder = new TextEncoder();
  return encoder.encode(str).length;
}
function truncateBytes(str, maxBytes) {
  if (byteLength(str) <= maxBytes) {
    return str;
  }
  let low = 0;
  let high = str.length;
  const encoder = new TextEncoder();
  while (low < high) {
    const mid = Math.floor((low + high + 1) / 2);
    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
      low = mid;
    } else {
      high = mid - 1;
    }
  }
  return str.slice(0, low);
}
var monitorFrequency = 2e3;
function computeBitrate(currentStats, prevStats) {
  if (!prevStats) {
    return 0;
  }
  let bytesNow;
  let bytesPrev;
  if ("bytesReceived" in currentStats) {
    bytesNow = currentStats.bytesReceived;
    bytesPrev = prevStats.bytesReceived;
  } else if ("bytesSent" in currentStats) {
    bytesNow = currentStats.bytesSent;
    bytesPrev = prevStats.bytesSent;
  }
  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
    return 0;
  }
  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
}
var isMediaRecorderAvailable = typeof MediaRecorder !== "undefined";
var FallbackRecorder = class {
  constructor() {
    throw new Error("MediaRecorder is not available in this environment");
  }
};
var RecorderBase = isMediaRecorderAvailable ? MediaRecorder : FallbackRecorder;
var LocalTrackRecorder = class extends RecorderBase {
  constructor(track2, options) {
    if (!isMediaRecorderAvailable) {
      throw new Error("MediaRecorder is not available in this environment");
    }
    super(new MediaStream([track2.mediaStreamTrack]), options);
    let dataListener;
    let streamController;
    const isClosed = () => streamController === void 0;
    const onStop = () => {
      this.removeEventListener("dataavailable", dataListener);
      this.removeEventListener("stop", onStop);
      this.removeEventListener("error", onError);
      streamController === null || streamController === void 0 ? void 0 : streamController.close();
      streamController = void 0;
    };
    const onError = (event) => {
      streamController === null || streamController === void 0 ? void 0 : streamController.error(event);
      this.removeEventListener("dataavailable", dataListener);
      this.removeEventListener("stop", onStop);
      this.removeEventListener("error", onError);
      streamController = void 0;
    };
    this.byteStream = new ReadableStream({
      start: (controller) => {
        streamController = controller;
        dataListener = (event) => __awaiter(this, void 0, void 0, function* () {
          const arrayBuffer = yield event.data.arrayBuffer();
          if (isClosed()) {
            return;
          }
          controller.enqueue(new Uint8Array(arrayBuffer));
        });
        this.addEventListener("dataavailable", dataListener);
      },
      cancel: () => {
        onStop();
      }
    });
    this.addEventListener("stop", onStop);
    this.addEventListener("error", onError);
  }
};
function isRecordingSupported() {
  return isMediaRecorderAvailable;
}
var DEFAULT_DIMENSIONS_TIMEOUT = 1e3;
var PRE_CONNECT_BUFFER_TIMEOUT = 1e4;
var LocalTrack = class extends Track {
  /** @internal */
  get sender() {
    return this._sender;
  }
  /** @internal */
  set sender(sender) {
    this._sender = sender;
  }
  get constraints() {
    return this._constraints;
  }
  get hasPreConnectBuffer() {
    return !!this.localTrackRecorder;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(mediaTrack, kind, constraints) {
    let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
    super(mediaTrack, kind, loggerOptions);
    this.manuallyStopped = false;
    this._isUpstreamPaused = false;
    this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext));
    this.debouncedTrackMuteHandler = r3(() => __awaiter(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3);
    this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute");
      yield this.resumeUpstream();
    });
    this.handleEnded = () => {
      if (this.isInBackground) {
        this.reacquireTrack = true;
      }
      this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      this.emit(TrackEvent.Ended, this);
    };
    this.reacquireTrack = false;
    this.providedByUser = userProvidedTrack;
    this.muteLock = new _3();
    this.pauseUpstreamLock = new _3();
    this.processorLock = new _3();
    this.restartLock = new _3();
    this.setMediaStreamTrack(mediaTrack, true);
    this._constraints = mediaTrack.getConstraints();
    if (constraints) {
      this._constraints = constraints;
    }
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video) {
      return void 0;
    }
    const {
      width,
      height
    } = this._mediaStreamTrack.getSettings();
    if (width && height) {
      return {
        width,
        height
      };
    }
    return void 0;
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var _a3, _b;
    return (_b = (_a3 = this.processor) === null || _a3 === void 0 ? void 0 : _a3.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;
  }
  get isLocal() {
    return true;
  }
  /**
   * @internal
   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
   */
  getSourceTrackSettings() {
    return this._mediaStreamTrack.getSettings();
  }
  setMediaStreamTrack(newTrack, force) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (newTrack === this._mediaStreamTrack && !force) {
        return;
      }
      if (this._mediaStreamTrack) {
        this.attachedElements.forEach((el) => {
          detachTrack(this._mediaStreamTrack, el);
        });
        this.debouncedTrackMuteHandler.cancel("new-track");
        this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
        this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
        this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      }
      this.mediaStream = new MediaStream([newTrack]);
      if (newTrack) {
        newTrack.addEventListener("ended", this.handleEnded);
        newTrack.addEventListener("mute", this.handleTrackMuteEvent);
        newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);
        this._constraints = newTrack.getConstraints();
      }
      let processedTrack;
      if (this.processor && newTrack) {
        const unlock = yield this.processorLock.lock();
        try {
          this.log.debug("restarting processor", this.logContext);
          if (this.kind === "unknown") {
            throw TypeError("cannot set processor on track of unknown kind");
          }
          if (this.processorElement) {
            attachToElement(newTrack, this.processorElement);
            this.processorElement.muted = true;
          }
          yield this.processor.restart({
            track: newTrack,
            kind: this.kind,
            element: this.processorElement
          });
          processedTrack = this.processor.processedTrack;
        } finally {
          unlock();
        }
      }
      if (this.sender && ((_a3 = this.sender.transport) === null || _a3 === void 0 ? void 0 : _a3.state) !== "closed") {
        yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);
      }
      if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
        this._mediaStreamTrack.stop();
      }
      this._mediaStreamTrack = newTrack;
      if (newTrack) {
        this._mediaStreamTrack.enabled = !this.isMuted;
        yield this.resumeUpstream();
        this.attachedElements.forEach((el) => {
          attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);
        });
      }
    });
  }
  waitForDimensions() {
    return __awaiter(this, arguments, void 0, function() {
      var _this = this;
      let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_DIMENSIONS_TIMEOUT;
      return function* () {
        var _a3;
        if (_this.kind === Track.Kind.Audio) {
          throw new Error("cannot get dimensions for audio tracks");
        }
        if (((_a3 = getBrowser()) === null || _a3 === void 0 ? void 0 : _a3.os) === "iOS") {
          yield sleep(10);
        }
        const started = Date.now();
        while (Date.now() - started < timeout) {
          const dims = _this.dimensions;
          if (dims) {
            return dims;
          }
          yield sleep(50);
        }
        throw new TrackInvalidError("unable to get track dimensions after timeout");
      }();
    });
  }
  setDeviceId(deviceId) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {
        return true;
      }
      this._constraints.deviceId = deviceId;
      if (this.isMuted) {
        return true;
      }
      yield this.restartTrack();
      return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter(this, arguments, void 0, function() {
      var _this2 = this;
      let normalize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return function* () {
        if (_this2.source === Track.Source.ScreenShare) {
          return;
        }
        const {
          deviceId,
          groupId
        } = _this2._mediaStreamTrack.getSettings();
        const kind = _this2.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
        return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;
      }();
    });
  }
  mute() {
    return __awaiter(this, void 0, void 0, function* () {
      this.setTrackMuted(true);
      return this;
    });
  }
  unmute() {
    return __awaiter(this, void 0, void 0, function* () {
      this.setTrackMuted(false);
      return this;
    });
  }
  replaceTrack(track2, userProvidedOrOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        throw new TrackInvalidError("unable to replace an unpublished track");
      }
      let userProvidedTrack;
      let stopProcessor;
      if (typeof userProvidedOrOptions === "boolean") {
        userProvidedTrack = userProvidedOrOptions;
      } else if (userProvidedOrOptions !== void 0) {
        userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
        stopProcessor = userProvidedOrOptions.stopProcessor;
      }
      this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
      this.log.debug("replace MediaStreamTrack", this.logContext);
      yield this.setMediaStreamTrack(track2);
      if (stopProcessor && this.processor) {
        yield this.stopProcessor();
      }
      return this;
    });
  }
  restart(constraints) {
    return __awaiter(this, void 0, void 0, function* () {
      this.manuallyStopped = false;
      const unlock = yield this.restartLock.lock();
      try {
        if (!constraints) {
          constraints = this._constraints;
        }
        const {
          deviceId,
          facingMode
        } = constraints, otherConstraints = __rest(constraints, ["deviceId", "facingMode"]);
        this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
          constraints
        }));
        const streamConstraints = {
          audio: false,
          video: false
        };
        if (this.kind === Track.Kind.Video) {
          streamConstraints.video = deviceId || facingMode ? {
            deviceId,
            facingMode
          } : true;
        } else {
          streamConstraints.audio = deviceId ? {
            deviceId
          } : true;
        }
        this.attachedElements.forEach((el) => {
          detachTrack(this.mediaStreamTrack, el);
        });
        this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
        this._mediaStreamTrack.stop();
        const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
        const newTrack = mediaStream.getTracks()[0];
        yield newTrack.applyConstraints(otherConstraints);
        newTrack.addEventListener("ended", this.handleEnded);
        this.log.debug("re-acquired MediaStreamTrack", this.logContext);
        yield this.setMediaStreamTrack(newTrack);
        this._constraints = constraints;
        this.emit(TrackEvent.Restarted, this);
        if (this.manuallyStopped) {
          this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext);
          this.stop();
        }
        return this;
      } finally {
        unlock();
      }
    });
  }
  setTrackMuted(muted) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);
    if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
      return;
    }
    this.isMuted = muted;
    this._mediaStreamTrack.enabled = !muted;
    this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const _super = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.handleAppVisibilityChanged.call(this);
      if (!isMobile())
        return;
      this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);
      if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {
        this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);
        yield this.restart();
        this.reacquireTrack = false;
      }
    });
  }
  stop() {
    var _a3;
    this.manuallyStopped = true;
    super.stop();
    this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
    this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
    this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
    (_a3 = this.processor) === null || _a3 === void 0 ? void 0 : _a3.destroy();
    this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const unlock = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === true) {
          return;
        }
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = true;
        this.emit(TrackEvent.UpstreamPaused, this);
        const browser = getBrowser();
        if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0) {
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        }
        if (((_a3 = this.sender.transport) === null || _a3 === void 0 ? void 0 : _a3.state) !== "closed") {
          yield this.sender.replaceTrack(null);
        }
      } finally {
        unlock();
      }
    });
  }
  resumeUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const unlock = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === false) {
          return;
        }
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = false;
        this.emit(TrackEvent.UpstreamResumed, this);
        if (((_a3 = this.sender.transport) === null || _a3 === void 0 ? void 0 : _a3.state) !== "closed") {
          yield this.sender.replaceTrack(this.mediaStreamTrack);
        }
      } finally {
        unlock();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!((_a3 = this.sender) === null || _a3 === void 0 ? void 0 : _a3.getStats)) {
        return;
      }
      const statsReport = yield this.sender.getStats();
      return statsReport;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(processor_1) {
    return __awaiter(this, arguments, void 0, function(processor) {
      var _this3 = this;
      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return function* () {
        var _a3;
        const unlock = yield _this3.processorLock.lock();
        try {
          _this3.log.debug("setting up processor", _this3.logContext);
          const processorElement = document.createElement(_this3.kind);
          const processorOptions = {
            kind: _this3.kind,
            track: _this3._mediaStreamTrack,
            element: processorElement,
            audioContext: _this3.audioContext
          };
          yield processor.init(processorOptions);
          _this3.log.debug("processor initialized", _this3.logContext);
          if (_this3.processor) {
            yield _this3.stopProcessor();
          }
          if (_this3.kind === "unknown") {
            throw TypeError("cannot set processor on track of unknown kind");
          }
          attachToElement(_this3._mediaStreamTrack, processorElement);
          processorElement.muted = true;
          processorElement.play().catch((error) => _this3.log.error("failed to play processor element", Object.assign(Object.assign({}, _this3.logContext), {
            error
          })));
          _this3.processor = processor;
          _this3.processorElement = processorElement;
          if (_this3.processor.processedTrack) {
            for (const el of _this3.attachedElements) {
              if (el !== _this3.processorElement && showProcessedStreamLocally) {
                detachTrack(_this3._mediaStreamTrack, el);
                attachToElement(_this3.processor.processedTrack, el);
              }
            }
            yield (_a3 = _this3.sender) === null || _a3 === void 0 ? void 0 : _a3.replaceTrack(_this3.processor.processedTrack);
          }
          _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);
        } finally {
          unlock();
        }
      }();
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    return __awaiter(this, arguments, void 0, function() {
      var _this4 = this;
      let keepElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      return function* () {
        var _a3, _b;
        if (!_this4.processor)
          return;
        _this4.log.debug("stopping processor", _this4.logContext);
        (_a3 = _this4.processor.processedTrack) === null || _a3 === void 0 ? void 0 : _a3.stop();
        yield _this4.processor.destroy();
        _this4.processor = void 0;
        if (!keepElement) {
          (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
          _this4.processorElement = void 0;
        }
        yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);
        yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);
        _this4.emit(TrackEvent.TrackProcessorUpdate);
      }();
    });
  }
  /** @internal */
  startPreConnectBuffer() {
    let timeslice = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    if (!isRecordingSupported()) {
      this.log.warn("MediaRecorder is not available, cannot start preconnect buffer", this.logContext);
      return;
    }
    if (!this.localTrackRecorder) {
      this.localTrackRecorder = new LocalTrackRecorder(this, {
        mimeType: "audio/webm;codecs=opus"
      });
    } else {
      this.log.warn("preconnect buffer already started");
      return;
    }
    this.localTrackRecorder.start(timeslice);
    this.autoStopPreConnectBuffer = setTimeout(() => {
      this.log.warn("preconnect buffer timed out, stopping recording automatically", this.logContext);
      this.stopPreConnectBuffer();
    }, PRE_CONNECT_BUFFER_TIMEOUT);
  }
  /** @internal */
  stopPreConnectBuffer() {
    clearTimeout(this.autoStopPreConnectBuffer);
    if (this.localTrackRecorder) {
      this.localTrackRecorder.stop();
      this.localTrackRecorder = void 0;
    }
  }
  /** @internal */
  getPreConnectBuffer() {
    var _a3;
    return (_a3 = this.localTrackRecorder) === null || _a3 === void 0 ? void 0 : _a3.byteStream;
  }
};
var LocalAudioTrack = class extends LocalTrack {
  /**
   * boolean indicating whether enhanced noise cancellation is currently being used on this track
   */
  get enhancedNoiseCancellation() {
    return this.isKrispNoiseFilterEnabled;
  }
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(mediaTrack, constraints) {
    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let audioContext = arguments.length > 3 ? arguments[3] : void 0;
    let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
    super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);
    this.stopOnMute = false;
    this.isKrispNoiseFilterEnabled = false;
    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let stats;
      try {
        stats = yield this.getSenderStats();
      } catch (e4) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: e4
        }));
        return;
      }
      if (stats && this.prevStats) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    });
    this.handleKrispNoiseFilterEnable = () => {
      this.isKrispNoiseFilterEnabled = true;
      this.log.debug("Krisp noise filter enabled", this.logContext);
      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);
    };
    this.handleKrispNoiseFilterDisable = () => {
      this.isKrispNoiseFilterEnabled = false;
      this.log.debug("Krisp noise filter disabled", this.logContext);
      this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);
    };
    this.audioContext = audioContext;
    this.checkForSilence();
  }
  mute() {
    const _super = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.muteLock.lock();
      try {
        if (this.isMuted) {
          this.log.debug("Track already muted", this.logContext);
          return this;
        }
        if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
          this.log.debug("stopping mic track", this.logContext);
          this._mediaStreamTrack.stop();
        }
        yield _super.mute.call(this);
        return this;
      } finally {
        unlock();
      }
    });
  }
  unmute() {
    const _super = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.muteLock.lock();
      try {
        if (!this.isMuted) {
          this.log.debug("Track already unmuted", this.logContext);
          return this;
        }
        const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided) {
          this.log.debug("reacquiring mic track", this.logContext);
          yield this.restartTrack();
        }
        yield _super.unmute.call(this);
        return this;
      } finally {
        unlock();
      }
    });
  }
  restartTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      let constraints;
      if (options) {
        const streamConstraints = constraintsForOptions({
          audio: options
        });
        if (typeof streamConstraints.audio !== "boolean") {
          constraints = streamConstraints.audio;
        }
      }
      yield this.restart(constraints);
    });
  }
  restart(constraints) {
    const _super = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const track2 = yield _super.restart.call(this, constraints);
      this.checkForSilence();
      return track2;
    });
  }
  /* @internal */
  startMonitor() {
    if (!isWeb()) {
      return;
    }
    if (this.monitorInterval) {
      return;
    }
    this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency);
  }
  setProcessor(processor) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const unlock = yield this.processorLock.lock();
      try {
        if (!isReactNative() && !this.audioContext) {
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        }
        if (this.processor) {
          yield this.stopProcessor();
        }
        const processorOptions = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          // RN won't have or use AudioContext
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);
        yield processor.init(processorOptions);
        this.processor = processor;
        if (this.processor.processedTrack) {
          yield (_a3 = this.sender) === null || _a3 === void 0 ? void 0 : _a3.replaceTrack(this.processor.processedTrack);
          this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable);
          this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable);
        }
        this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        unlock();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(audioContext) {
    this.audioContext = audioContext;
  }
  getSenderStats() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!((_a3 = this.sender) === null || _a3 === void 0 ? void 0 : _a3.getStats)) {
        return void 0;
      }
      const stats = yield this.sender.getStats();
      let audioStats;
      stats.forEach((v3) => {
        if (v3.type === "outbound-rtp") {
          audioStats = {
            type: "audio",
            streamId: v3.id,
            packetsSent: v3.packetsSent,
            packetsLost: v3.packetsLost,
            bytesSent: v3.bytesSent,
            timestamp: v3.timestamp,
            roundTripTime: v3.roundTripTime,
            jitter: v3.jitter
          };
        }
      });
      return audioStats;
    });
  }
  checkForSilence() {
    return __awaiter(this, void 0, void 0, function* () {
      const trackIsSilent = yield detectSilence(this);
      if (trackIsSilent) {
        if (!this.isMuted) {
          this.log.warn("silence detected on local audio track", this.logContext);
        }
        this.emit(TrackEvent.AudioSilenceDetected);
      }
      return trackIsSilent;
    });
  }
};
function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
  switch (mediaStreamTrack.kind) {
    case "audio":
      return new LocalAudioTrack(mediaStreamTrack, constraints, false, void 0, loggerOptions);
    case "video":
      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
  }
}
var presets169 = Object.values(VideoPresets);
var presets43 = Object.values(VideoPresets43);
var presetsScreenShare = Object.values(ScreenSharePresets);
var defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
var defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
var computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
  const layers = [{
    scaleResolutionDownBy: 2,
    fps: fromPreset.encoding.maxFramerate
  }];
  return layers.map((t3) => {
    var _a3, _b;
    return new VideoPreset(Math.floor(fromPreset.width / t3.scaleResolutionDownBy), Math.floor(fromPreset.height / t3.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t3.scaleResolutionDownBy, 2) * (((_a3 = fromPreset.encoding.maxFramerate) !== null && _a3 !== void 0 ? _a3 : 30) / ((_b = t3.fps) !== null && _b !== void 0 ? _b : 30))))), t3.fps, fromPreset.encoding.priority);
  });
};
var videoRids = ["q", "h", "f"];
function computeVideoEncodings(isScreenShare, width, height, options) {
  var _a3, _b;
  let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
  if (isScreenShare) {
    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
  }
  const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
  const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
  const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
    return [{}];
  }
  if (!videoEncoding) {
    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
    livekitLogger.debug("using video encoding", videoEncoding);
  }
  const sourceFramerate = videoEncoding.maxFramerate;
  const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);
  if (scalabilityMode && isSVCCodec(videoCodec)) {
    const sm = new ScalabilityMode(scalabilityMode);
    const encodings = [];
    if (sm.spatial > 3) {
      throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
    }
    const browser = getBrowser();
    if (isSafariBased() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
    // is provided. So we'll use the legacy SVC specification for now.
    // TODO: when we upstream libwebrtc, this will need additional verification
    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, "113") < 0) {
      const bitratesRatio = sm.suffix == "h" ? 2 : 3;
      const requireScale = isSafariSvcApi(browser);
      for (let i3 = 0; i3 < sm.spatial; i3 += 1) {
        encodings.push({
          rid: videoRids[2 - i3],
          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i3),
          maxFramerate: original.encoding.maxFramerate,
          scaleResolutionDownBy: requireScale ? Math.pow(2, i3) : void 0
        });
      }
      encodings[0].scalabilityMode = scalabilityMode;
    } else {
      encodings.push({
        maxBitrate: videoEncoding.maxBitrate,
        maxFramerate: original.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode
      });
    }
    if (original.encoding.priority) {
      encodings[0].priority = original.encoding.priority;
      encodings[0].networkPriority = original.encoding.priority;
    }
    livekitLogger.debug("using svc encoding", {
      encodings
    });
    return encodings;
  }
  if (!useSimulcast) {
    return [videoEncoding];
  }
  let presets = [];
  if (isScreenShare) {
    presets = (_a3 = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a3 !== void 0 ? _a3 : defaultSimulcastLayers(isScreenShare, original);
  } else {
    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
  }
  let midPreset;
  if (presets.length > 0) {
    const lowPreset = presets[0];
    if (presets.length > 1) {
      [, midPreset] = presets;
    }
    const size = Math.max(width, height);
    if (size >= 960 && midPreset) {
      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);
    }
    if (size >= 480) {
      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);
    }
  }
  return encodingsFromPresets(width, height, [original]);
}
function computeTrackBackupEncodings(track2, videoCodec, opts) {
  var _a3, _b, _c3, _d;
  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {
    return;
  }
  if (videoCodec !== opts.backupCodec.codec) {
    livekitLogger.warn("requested a different codec than specified as backup", {
      serverRequested: videoCodec,
      backup: opts.backupCodec.codec
    });
  }
  opts.videoCodec = videoCodec;
  opts.videoEncoding = opts.backupCodec.encoding;
  const settings = track2.mediaStreamTrack.getSettings();
  const width = (_a3 = settings.width) !== null && _a3 !== void 0 ? _a3 : (_b = track2.dimensions) === null || _b === void 0 ? void 0 : _b.width;
  const height = (_c3 = settings.height) !== null && _c3 !== void 0 ? _c3 : (_d = track2.dimensions) === null || _d === void 0 ? void 0 : _d.height;
  if (track2.source === Track.Source.ScreenShare && opts.simulcast) {
    opts.simulcast = false;
  }
  const encodings = computeVideoEncodings(track2.source === Track.Source.ScreenShare, width, height, opts);
  return encodings;
}
function determineAppropriateEncoding(isScreenShare, width, height, codec) {
  const presets = presetsForResolution(isScreenShare, width, height);
  let {
    encoding
  } = presets[0];
  const size = Math.max(width, height);
  for (let i3 = 0; i3 < presets.length; i3 += 1) {
    const preset = presets[i3];
    encoding = preset.encoding;
    if (preset.width >= size) {
      break;
    }
  }
  if (codec) {
    switch (codec) {
      case "av1":
      case "h265":
        encoding = Object.assign({}, encoding);
        encoding.maxBitrate = encoding.maxBitrate * 0.7;
        break;
      case "vp9":
        encoding = Object.assign({}, encoding);
        encoding.maxBitrate = encoding.maxBitrate * 0.85;
        break;
    }
  }
  return encoding;
}
function presetsForResolution(isScreenShare, width, height) {
  if (isScreenShare) {
    return presetsScreenShare;
  }
  const aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return presets169;
  }
  return presets43;
}
function defaultSimulcastLayers(isScreenShare, original) {
  if (isScreenShare) {
    return computeDefaultScreenShareSimulcastPresets(original);
  }
  const {
    width,
    height
  } = original;
  const aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return defaultSimulcastPresets169;
  }
  return defaultSimulcastPresets43;
}
function encodingsFromPresets(width, height, presets, sourceFramerate) {
  const encodings = [];
  presets.forEach((preset, idx) => {
    if (idx >= videoRids.length) {
      return;
    }
    const size = Math.min(width, height);
    const rid = videoRids[idx];
    const encoding = {
      rid,
      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
      maxBitrate: preset.encoding.maxBitrate
    };
    const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;
    if (maxFramerate) {
      encoding.maxFramerate = maxFramerate;
    }
    const canSetPriority = isFireFox() || idx === 0;
    if (preset.encoding.priority && canSetPriority) {
      encoding.priority = preset.encoding.priority;
      encoding.networkPriority = preset.encoding.priority;
    }
    encodings.push(encoding);
  });
  if (isReactNative() && getReactNativeOs() === "ios") {
    let topFramerate = void 0;
    encodings.forEach((encoding) => {
      if (!topFramerate) {
        topFramerate = encoding.maxFramerate;
      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
        topFramerate = encoding.maxFramerate;
      }
    });
    let notifyOnce = true;
    encodings.forEach((encoding) => {
      var _a3;
      if (encoding.maxFramerate != topFramerate) {
        if (notifyOnce) {
          notifyOnce = false;
          livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");
        }
        livekitLogger.info('Setting framerate of encoding "'.concat((_a3 = encoding.rid) !== null && _a3 !== void 0 ? _a3 : "", '" to ').concat(topFramerate));
        encoding.maxFramerate = topFramerate;
      }
    });
  }
  return encodings;
}
function sortPresets(presets) {
  if (!presets)
    return;
  return presets.sort((a3, b3) => {
    const {
      encoding: aEnc
    } = a3;
    const {
      encoding: bEnc
    } = b3;
    if (aEnc.maxBitrate > bEnc.maxBitrate) {
      return 1;
    }
    if (aEnc.maxBitrate < bEnc.maxBitrate)
      return -1;
    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
    }
    return 0;
  });
}
var ScalabilityMode = class {
  constructor(scalabilityMode) {
    const results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!results) {
      throw new Error("invalid scalability mode");
    }
    this.spatial = parseInt(results[1]);
    this.temporal = parseInt(results[2]);
    if (results.length > 3) {
      switch (results[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = results[3];
      }
    }
  }
  toString() {
    var _a3;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a3 = this.suffix) !== null && _a3 !== void 0 ? _a3 : "");
  }
};
function getDefaultDegradationPreference(track2) {
  if (track2.source === Track.Source.ScreenShare || track2.constraints.height && unwrapConstraint(track2.constraints.height) >= 1080) {
    return "maintain-resolution";
  } else {
    return "balanced";
  }
}
var refreshSubscribedCodecAfterNewCodec = 5e3;
var LocalVideoTrack = class extends LocalTrack {
  get sender() {
    return this._sender;
  }
  set sender(sender) {
    this._sender = sender;
    if (this.degradationPreference) {
      this.setDegradationPreference(this.degradationPreference);
    }
  }
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(mediaTrack, constraints) {
    let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let loggerOptions = arguments.length > 3 ? arguments[3] : void 0;
    super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);
    this.simulcastCodecs = /* @__PURE__ */ new Map();
    this.degradationPreference = "balanced";
    this.isCpuConstrained = false;
    this.optimizeForPerformance = false;
    this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let stats;
      try {
        stats = yield this.getSenderStats();
      } catch (e4) {
        this.log.error("could not get video sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: e4
        }));
        return;
      }
      const statsMap = new Map(stats.map((s3) => [s3.rid, s3]));
      const isCpuConstrained = stats.some((s3) => s3.qualityLimitationReason === "cpu");
      if (isCpuConstrained !== this.isCpuConstrained) {
        this.isCpuConstrained = isCpuConstrained;
        if (this.isCpuConstrained) {
          this.emit(TrackEvent.CpuConstrained);
        }
      }
      if (this.prevStats) {
        let totalBitrate = 0;
        statsMap.forEach((s3, key) => {
          var _a3;
          const prev = (_a3 = this.prevStats) === null || _a3 === void 0 ? void 0 : _a3.get(key);
          totalBitrate += computeBitrate(s3, prev);
        });
        this._currentBitrate = totalBitrate;
      }
      this.prevStats = statsMap;
    });
    this.senderLock = new _3();
  }
  get isSimulcast() {
    if (this.sender && this.sender.getParameters().encodings.length > 1) {
      return true;
    }
    return false;
  }
  /* @internal */
  startMonitor(signalClient) {
    var _a3;
    this.signalClient = signalClient;
    if (!isWeb()) {
      return;
    }
    const params = (_a3 = this.sender) === null || _a3 === void 0 ? void 0 : _a3.getParameters();
    if (params) {
      this.encodings = params.encodings;
    }
    if (this.monitorInterval) {
      return;
    }
    this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency);
  }
  stop() {
    this._mediaStreamTrack.getConstraints();
    this.simulcastCodecs.forEach((trackInfo) => {
      trackInfo.mediaStreamTrack.stop();
    });
    super.stop();
  }
  pauseUpstream() {
    const _super = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, e_1, _b, _c3;
      var _d;
      yield _super.pauseUpstream.call(this);
      try {
        for (var _e3 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a3 = _g.done, !_a3; _e3 = true) {
          _c3 = _g.value;
          _e3 = false;
          const sc3 = _c3;
          yield (_d = sc3.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (!_e3 && !_a3 && (_b = _f.return))
            yield _b.call(_f);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  resumeUpstream() {
    const _super = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, e_2, _b, _c3;
      var _d;
      yield _super.resumeUpstream.call(this);
      try {
        for (var _e3 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a3 = _g.done, !_a3; _e3 = true) {
          _c3 = _g.value;
          _e3 = false;
          const sc3 = _c3;
          yield (_d = sc3.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc3.mediaStreamTrack);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (!_e3 && !_a3 && (_b = _f.return))
            yield _b.call(_f);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    });
  }
  mute() {
    const _super = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.muteLock.lock();
      try {
        if (this.isMuted) {
          this.log.debug("Track already muted", this.logContext);
          return this;
        }
        if (this.source === Track.Source.Camera && !this.isUserProvided) {
          this.log.debug("stopping camera track", this.logContext);
          this._mediaStreamTrack.stop();
        }
        yield _super.mute.call(this);
        return this;
      } finally {
        unlock();
      }
    });
  }
  unmute() {
    const _super = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.muteLock.lock();
      try {
        if (!this.isMuted) {
          this.log.debug("Track already unmuted", this.logContext);
          return this;
        }
        if (this.source === Track.Source.Camera && !this.isUserProvided) {
          this.log.debug("reacquiring camera track", this.logContext);
          yield this.restartTrack();
        }
        yield _super.unmute.call(this);
        return this;
      } finally {
        unlock();
      }
    });
  }
  setTrackMuted(muted) {
    super.setTrackMuted(muted);
    for (const sc3 of this.simulcastCodecs.values()) {
      sc3.mediaStreamTrack.enabled = !muted;
    }
  }
  getSenderStats() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!((_a3 = this.sender) === null || _a3 === void 0 ? void 0 : _a3.getStats)) {
        return [];
      }
      const items = [];
      const stats = yield this.sender.getStats();
      stats.forEach((v3) => {
        var _a4;
        if (v3.type === "outbound-rtp") {
          const vs3 = {
            type: "video",
            streamId: v3.id,
            frameHeight: v3.frameHeight,
            frameWidth: v3.frameWidth,
            framesPerSecond: v3.framesPerSecond,
            framesSent: v3.framesSent,
            firCount: v3.firCount,
            pliCount: v3.pliCount,
            nackCount: v3.nackCount,
            packetsSent: v3.packetsSent,
            bytesSent: v3.bytesSent,
            qualityLimitationReason: v3.qualityLimitationReason,
            qualityLimitationDurations: v3.qualityLimitationDurations,
            qualityLimitationResolutionChanges: v3.qualityLimitationResolutionChanges,
            rid: (_a4 = v3.rid) !== null && _a4 !== void 0 ? _a4 : v3.id,
            retransmittedPacketsSent: v3.retransmittedPacketsSent,
            targetBitrate: v3.targetBitrate,
            timestamp: v3.timestamp
          };
          const r4 = stats.get(v3.remoteId);
          if (r4) {
            vs3.jitter = r4.jitter;
            vs3.packetsLost = r4.packetsLost;
            vs3.roundTripTime = r4.roundTripTime;
          }
          items.push(vs3);
        }
      });
      items.sort((a3, b3) => {
        var _a4, _b;
        return ((_a4 = b3.frameWidth) !== null && _a4 !== void 0 ? _a4 : 0) - ((_b = a3.frameWidth) !== null && _b !== void 0 ? _b : 0);
      });
      return items;
    });
  }
  setPublishingQuality(maxQuality) {
    const qualities = [];
    for (let q3 = VideoQuality.LOW; q3 <= VideoQuality.HIGH; q3 += 1) {
      qualities.push(new SubscribedQuality({
        quality: q3,
        enabled: q3 <= maxQuality
      }));
    }
    this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);
    this.setPublishingLayers(isSVCCodec(this.codec), qualities);
  }
  restartTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, e_3, _b, _c3;
      var _d;
      let constraints;
      if (options) {
        const streamConstraints = constraintsForOptions({
          video: options
        });
        if (typeof streamConstraints.video !== "boolean") {
          constraints = streamConstraints.video;
        }
      }
      yield this.restart(constraints);
      this.isCpuConstrained = false;
      try {
        for (var _e3 = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a3 = _g.done, !_a3; _e3 = true) {
          _c3 = _g.value;
          _e3 = false;
          const sc3 = _c3;
          if (sc3.sender && ((_d = sc3.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== "closed") {
            sc3.mediaStreamTrack = this.mediaStreamTrack.clone();
            yield sc3.sender.replaceTrack(sc3.mediaStreamTrack);
          }
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (!_e3 && !_a3 && (_b = _f.return))
            yield _b.call(_f);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    });
  }
  setProcessor(processor_1) {
    const _super = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    return __awaiter(this, arguments, void 0, function(processor) {
      var _this = this;
      let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return function* () {
        var _a3, e_4, _b, _c3;
        var _d, _e3;
        yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);
        if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {
          try {
            for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a3 = _h.done, !_a3; _f = true) {
              _c3 = _h.value;
              _f = false;
              const sc3 = _c3;
              yield (_e3 = sc3.sender) === null || _e3 === void 0 ? void 0 : _e3.replaceTrack(_this.processor.processedTrack);
            }
          } catch (e_4_1) {
            e_4 = {
              error: e_4_1
            };
          } finally {
            try {
              if (!_f && !_a3 && (_b = _g.return))
                yield _b.call(_g);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
        }
      }();
    });
  }
  setDegradationPreference(preference) {
    return __awaiter(this, void 0, void 0, function* () {
      this.degradationPreference = preference;
      if (this.sender) {
        try {
          this.log.debug("setting degradationPreference to ".concat(preference), this.logContext);
          const params = this.sender.getParameters();
          params.degradationPreference = preference;
          this.sender.setParameters(params);
        } catch (e4) {
          this.log.warn("failed to set degradationPreference", Object.assign({
            error: e4
          }, this.logContext));
        }
      }
    });
  }
  addSimulcastTrack(codec, encodings) {
    if (this.simulcastCodecs.has(codec)) {
      this.log.error("".concat(codec, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const simulcastCodecInfo = {
      codec,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings
    };
    this.simulcastCodecs.set(codec, simulcastCodecInfo);
    return simulcastCodecInfo;
  }
  setSimulcastTrackSender(codec, sender) {
    const simulcastCodecInfo = this.simulcastCodecs.get(codec);
    if (!simulcastCodecInfo) {
      return;
    }
    simulcastCodecInfo.sender = sender;
    setTimeout(() => {
      if (this.subscribedCodecs) {
        this.setPublishingCodecs(this.subscribedCodecs);
      }
    }, refreshSubscribedCodecAfterNewCodec);
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(codecs) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, codecs_1, codecs_1_1;
      var _b, e_5, _c3, _d;
      this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs,
        currentCodec: this.codec
      }));
      if (!this.codec && codecs.length > 0) {
        yield this.setPublishingLayers(isSVCCodec(codecs[0].codec), codecs[0].qualities);
        return [];
      }
      this.subscribedCodecs = codecs;
      const newCodecs = [];
      try {
        for (_a3 = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a3 = true) {
          _d = codecs_1_1.value;
          _a3 = false;
          const codec = _d;
          if (!this.codec || this.codec === codec.codec) {
            yield this.setPublishingLayers(isSVCCodec(codec.codec), codec.qualities);
          } else {
            const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
            this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo
            }));
            if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
              for (const q3 of codec.qualities) {
                if (q3.enabled) {
                  newCodecs.push(codec.codec);
                  break;
                }
              }
            } else if (simulcastCodecInfo.encodings) {
              this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);
              yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, isSVCCodec(codec.codec), this.log, this.logContext);
            }
          }
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (!_a3 && !_b && (_c3 = codecs_1.return))
            yield _c3.call(codecs_1);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return newCodecs;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(isSvc, qualities) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.optimizeForPerformance) {
        this.log.info("skipping setPublishingLayers due to optimized publishing performance", Object.assign(Object.assign({}, this.logContext), {
          qualities
        }));
        return;
      }
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities
      }));
      if (!this.sender || !this.encodings) {
        return;
      }
      yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, isSvc, this.log, this.logContext);
    });
  }
  /**
   * Designed for lower powered devices, reduces video publishing quality and disables simulcast.
   * @experimental
   */
  prioritizePerformance() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        throw new Error("sender not found");
      }
      const unlock = yield this.senderLock.lock();
      try {
        this.optimizeForPerformance = true;
        const params = this.sender.getParameters();
        params.encodings = params.encodings.map((e4, idx) => {
          var _a3;
          return Object.assign(Object.assign({}, e4), {
            active: idx === 0,
            scaleResolutionDownBy: Math.max(1, Math.ceil(((_a3 = this.mediaStreamTrack.getSettings().height) !== null && _a3 !== void 0 ? _a3 : 360) / 360)),
            scalabilityMode: idx === 0 && isSVCCodec(this.codec) ? "L1T3" : void 0,
            maxFramerate: idx === 0 ? 15 : 0,
            maxBitrate: idx === 0 ? e4.maxBitrate : 0
          });
        });
        this.log.debug("setting performance optimised encodings", Object.assign(Object.assign({}, this.logContext), {
          encodings: params.encodings
        }));
        this.encodings = params.encodings;
        yield this.sender.setParameters(params);
      } catch (e4) {
        this.log.error("failed to set performance optimised encodings", Object.assign(Object.assign({}, this.logContext), {
          error: e4
        }));
        this.optimizeForPerformance = false;
      } finally {
        unlock();
      }
    });
  }
  handleAppVisibilityChanged() {
    const _super = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.handleAppVisibilityChanged.call(this);
      if (!isMobile())
        return;
      if (this.isInBackground && this.source === Track.Source.Camera) {
        this._mediaStreamTrack.enabled = false;
      }
    });
  }
};
function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, isSVC, log2, logContext) {
  return __awaiter(this, void 0, void 0, function* () {
    const unlock = yield senderLock.lock();
    log2.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {
      sender,
      qualities,
      senderEncodings
    }));
    try {
      const params = sender.getParameters();
      const {
        encodings
      } = params;
      if (!encodings) {
        return;
      }
      if (encodings.length !== senderEncodings.length) {
        log2.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, logContext), {
          encodings,
          senderEncodings
        }));
        return;
      }
      let hasChanged = false;
      const closableSpatial = false;
      if (closableSpatial && encodings[0].scalabilityMode)
        ;
      else {
        if (isSVC) {
          const hasEnabledEncoding = qualities.some((q3) => q3.enabled);
          if (hasEnabledEncoding) {
            qualities.forEach((q3) => q3.enabled = true);
          }
        }
        encodings.forEach((encoding, idx) => {
          var _a3;
          let rid = (_a3 = encoding.rid) !== null && _a3 !== void 0 ? _a3 : "";
          if (rid === "") {
            rid = "q";
          }
          const quality = videoQualityForRid(rid);
          const subscribedQuality = qualities.find((q3) => q3.quality === quality);
          if (!subscribedQuality) {
            return;
          }
          if (encoding.active !== subscribedQuality.enabled) {
            hasChanged = true;
            encoding.active = subscribedQuality.enabled;
            log2.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"), logContext);
            if (isFireFox()) {
              if (subscribedQuality.enabled) {
                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                encoding.maxBitrate = senderEncodings[idx].maxBitrate;
                encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
              } else {
                encoding.scaleResolutionDownBy = 4;
                encoding.maxBitrate = 10;
                encoding.maxFrameRate = 2;
              }
            }
          }
        });
      }
      if (hasChanged) {
        params.encodings = encodings;
        log2.debug("setting encodings", Object.assign(Object.assign({}, logContext), {
          encodings: params.encodings
        }));
        yield sender.setParameters(params);
      }
    } finally {
      unlock();
    }
  });
}
function videoQualityForRid(rid) {
  switch (rid) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(width, height, encodings, svc) {
  if (!encodings) {
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width,
      height,
      bitrate: 0,
      ssrc: 0
    })];
  }
  if (svc) {
    const encodingSM = encodings[0].scalabilityMode;
    const sm = new ScalabilityMode(encodingSM);
    const layers = [];
    const resRatio = sm.suffix == "h" ? 1.5 : 2;
    const bitratesRatio = sm.suffix == "h" ? 2 : 3;
    for (let i3 = 0; i3 < sm.spatial; i3 += 1) {
      layers.push(new VideoLayer({
        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i3,
        width: Math.ceil(width / Math.pow(resRatio, i3)),
        height: Math.ceil(height / Math.pow(resRatio, i3)),
        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i3)) : 0,
        ssrc: 0
      }));
    }
    return layers;
  }
  return encodings.map((encoding) => {
    var _a3, _b, _c3;
    const scale = (_a3 = encoding.scaleResolutionDownBy) !== null && _a3 !== void 0 ? _a3 : 1;
    let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
    return new VideoLayer({
      quality,
      width: Math.ceil(width / scale),
      height: Math.ceil(height / scale),
      bitrate: (_c3 = encoding.maxBitrate) !== null && _c3 !== void 0 ? _c3 : 0,
      ssrc: 0
    });
  });
}
var lossyDataChannel = "_lossy";
var reliableDataChannel = "_reliable";
var minReconnectWait = 2 * 1e3;
var leaveReconnect = "leave-reconnect";
var reliabeReceiveStateTTL = 3e4;
var PCState;
(function(PCState2) {
  PCState2[PCState2["New"] = 0] = "New";
  PCState2[PCState2["Connected"] = 1] = "Connected";
  PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
  PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
  PCState2[PCState2["Closed"] = 4] = "Closed";
})(PCState || (PCState = {}));
var RTCEngine = class extends eventsExports.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(options) {
    var _a3;
    super();
    this.options = options;
    this.rtcConfig = {};
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
    this.fullReconnectOnNext = false;
    this.latestRemoteOfferId = 0;
    this.subscriberPrimary = false;
    this.pcState = PCState.New;
    this._isClosed = true;
    this.pendingTrackResolvers = {};
    this.reconnectAttempts = 0;
    this.reconnectStart = 0;
    this.attemptingReconnect = false;
    this.joinAttempts = 0;
    this.maxJoinAttempts = 1;
    this.shouldFailNext = false;
    this.log = livekitLogger;
    this.reliableDataSequence = 1;
    this.reliableMessageBuffer = new DataPacketBuffer();
    this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL);
    this.handleDataChannel = (_a4) => __awaiter(this, [_a4], void 0, function(_ref) {
      var _this = this;
      let {
        channel
      } = _ref;
      return function* () {
        if (!channel) {
          return;
        }
        if (channel.label === reliableDataChannel) {
          _this.reliableDCSub = channel;
        } else if (channel.label === lossyDataChannel) {
          _this.lossyDCSub = channel;
        } else {
          return;
        }
        _this.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), _this.logContext);
        channel.onmessage = _this.handleDataMessage;
      }();
    });
    this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
      var _a4, _b;
      const unlock = yield this.dataProcessLock.lock();
      try {
        let buffer;
        if (message.data instanceof ArrayBuffer) {
          buffer = message.data;
        } else if (message.data instanceof Blob) {
          buffer = yield message.data.arrayBuffer();
        } else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: message.data
          }));
          return;
        }
        const dp = DataPacket.fromBinary(new Uint8Array(buffer));
        if (dp.sequence > 0 && dp.participantSid !== "") {
          const lastSeq = this.reliableReceivedState.get(dp.participantSid);
          if (lastSeq && dp.sequence <= lastSeq) {
            return;
          }
          this.reliableReceivedState.set(dp.participantSid, dp.sequence);
        }
        if (((_a4 = dp.value) === null || _a4 === void 0 ? void 0 : _a4.case) === "speaker") {
          this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
        } else {
          if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === "user") {
            applyUserDataCompat(dp, dp.value.value);
          }
          this.emit(EngineEvent.DataPacketReceived, dp);
        }
      } finally {
        unlock();
      }
    });
    this.handleDataError = (event) => {
      const channel = event.currentTarget;
      const channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";
      if (event instanceof ErrorEvent && event.error) {
        const {
          error
        } = event.error;
        this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, this.logContext), {
          error
        }));
      } else {
        this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {
          event
        }));
      }
    };
    this.handleBufferedAmountLow = (event) => {
      const channel = event.currentTarget;
      const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(channelKind);
    };
    this.handleDisconnect = (connection, disconnectReason) => {
      if (this._isClosed) {
        return;
      }
      this.log.warn("".concat(connection, " disconnected"), this.logContext);
      if (this.reconnectAttempts === 0) {
        this.reconnectStart = Date.now();
      }
      const disconnect = (duration2) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"), this.logContext);
        this.emit(EngineEvent.Disconnected);
        this.close();
      };
      const duration = Date.now() - this.reconnectStart;
      let delay = this.getNextRetryDelay({
        elapsedMs: duration,
        retryCount: this.reconnectAttempts
      });
      if (delay === null) {
        disconnect(duration);
        return;
      }
      if (connection === leaveReconnect) {
        delay = 0;
      }
      this.log.debug("reconnecting in ".concat(delay, "ms"), this.logContext);
      this.clearReconnectTimeout();
      if (this.token && this.regionUrlProvider) {
        this.regionUrlProvider.updateToken(this.token);
      }
      this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = void 0), delay);
    };
    this.waitForRestarted = () => {
      return new Promise((resolve, reject) => {
        if (this.pcState === PCState.Connected) {
          resolve();
        }
        const onRestarted = () => {
          this.off(EngineEvent.Disconnected, onDisconnected);
          resolve();
        };
        const onDisconnected = () => {
          this.off(EngineEvent.Restarted, onRestarted);
          reject();
        };
        this.once(EngineEvent.Restarted, onRestarted);
        this.once(EngineEvent.Disconnected, onDisconnected);
      });
    };
    this.updateAndEmitDCBufferStatus = (kind) => {
      const status = this.isBufferStatusLow(kind);
      if (typeof status !== "undefined" && status !== this.dcBufferStatus.get(kind)) {
        this.dcBufferStatus.set(kind, status);
        this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
      }
    };
    this.isBufferStatusLow = (kind) => {
      const dc3 = this.dataChannelForKind(kind);
      if (dc3) {
        if (kind === DataPacket_Kind.RELIABLE) {
          this.reliableMessageBuffer.alignBufferedAmount(dc3.bufferedAmount);
        }
        return dc3.bufferedAmount <= dc3.bufferedAmountLowThreshold;
      }
    };
    this.handleBrowserOnLine = () => {
      if (this.client.currentState === SignalConnectionState.RECONNECTING) {
        this.clearReconnectTimeout();
        this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
      }
    };
    this.log = getLogger((_a3 = options.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Engine);
    this.loggerOptions = {
      loggerName: options.loggerName,
      loggerContextCb: () => this.logContext
    };
    this.client = new SignalClient(void 0, this.loggerOptions);
    this.client.signalLatency = this.options.expSignalLatency;
    this.reconnectPolicy = this.options.reconnectPolicy;
    this.registerOnLineListener();
    this.closingLock = new _3();
    this.dataProcessLock = new _3();
    this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);
    this.client.onParticipantUpdate = (updates) => this.emit(EngineEvent.ParticipantUpdate, updates);
    this.client.onConnectionQuality = (update) => this.emit(EngineEvent.ConnectionQualityUpdate, update);
    this.client.onRoomUpdate = (update) => this.emit(EngineEvent.RoomUpdate, update);
    this.client.onSubscriptionError = (resp) => this.emit(EngineEvent.SubscriptionError, resp);
    this.client.onSubscriptionPermissionUpdate = (update) => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
    this.client.onSpeakersChanged = (update) => this.emit(EngineEvent.SpeakersChanged, update);
    this.client.onStreamStateUpdate = (update) => this.emit(EngineEvent.StreamStateChanged, update);
    this.client.onRequestResponse = (response) => this.emit(EngineEvent.SignalRequestResponse, response);
  }
  /** @internal */
  get logContext() {
    var _a3, _b, _c3, _d, _e3, _f;
    return {
      room: (_b = (_a3 = this.latestJoinResponse) === null || _a3 === void 0 ? void 0 : _a3.room) === null || _b === void 0 ? void 0 : _b.name,
      roomID: (_d = (_c3 = this.latestJoinResponse) === null || _c3 === void 0 ? void 0 : _c3.room) === null || _d === void 0 ? void 0 : _d.sid,
      participant: (_f = (_e3 = this.latestJoinResponse) === null || _e3 === void 0 ? void 0 : _e3.participant) === null || _f === void 0 ? void 0 : _f.identity,
      pID: this.participantSid
    };
  }
  join(url, token, opts, abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
      this.url = url;
      this.token = token;
      this.signalOpts = opts;
      this.maxJoinAttempts = opts.maxRetries;
      try {
        this.joinAttempts += 1;
        this.setupSignalClientCallbacks();
        const joinResponse = yield this.client.join(url, token, opts, abortSignal);
        this._isClosed = false;
        this.latestJoinResponse = joinResponse;
        this.subscriberPrimary = joinResponse.subscriberPrimary;
        if (!this.pcManager) {
          yield this.configure(joinResponse);
        }
        if (!this.subscriberPrimary || joinResponse.fastPublish) {
          this.negotiate();
        }
        this.clientConfiguration = joinResponse.clientConfiguration;
        this.emit(EngineEvent.SignalConnected, joinResponse);
        return joinResponse;
      } catch (e4) {
        if (e4 instanceof ConnectionError) {
          if (e4.reason === ConnectionErrorReason.ServerUnreachable) {
            this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);
            if (this.joinAttempts < this.maxJoinAttempts) {
              return this.join(url, token, opts, abortSignal);
            }
          }
        }
        throw e4;
      }
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield this.closingLock.lock();
      if (this.isClosed) {
        unlock();
        return;
      }
      try {
        this._isClosed = true;
        this.joinAttempts = 0;
        this.emit(EngineEvent.Closing);
        this.removeAllListeners();
        this.deregisterOnLineListener();
        this.clearPendingReconnect();
        yield this.cleanupPeerConnections();
        yield this.cleanupClient();
      } finally {
        unlock();
      }
    });
  }
  cleanupPeerConnections() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.pcManager) === null || _a3 === void 0 ? void 0 : _a3.close();
      this.pcManager = void 0;
      const dcCleanup = (dc3) => {
        if (!dc3)
          return;
        dc3.close();
        dc3.onbufferedamountlow = null;
        dc3.onclose = null;
        dc3.onclosing = null;
        dc3.onerror = null;
        dc3.onmessage = null;
        dc3.onopen = null;
      };
      dcCleanup(this.lossyDC);
      dcCleanup(this.lossyDCSub);
      dcCleanup(this.reliableDC);
      dcCleanup(this.reliableDCSub);
      this.lossyDC = void 0;
      this.lossyDCSub = void 0;
      this.reliableDC = void 0;
      this.reliableDCSub = void 0;
      this.reliableMessageBuffer = new DataPacketBuffer();
      this.reliableDataSequence = 1;
      this.reliableReceivedState.clear();
    });
  }
  cleanupClient() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.client.close();
      this.client.resetCallbacks();
    });
  }
  addTrack(req) {
    if (this.pendingTrackResolvers[req.cid]) {
      throw new TrackInvalidError("a track with the same ID has already been published");
    }
    return new Promise((resolve, reject) => {
      const publicationTimeout = setTimeout(() => {
        delete this.pendingTrackResolvers[req.cid];
        reject(new ConnectionError("publication of local track timed out, no response from server", ConnectionErrorReason.Timeout));
      }, 1e4);
      this.pendingTrackResolvers[req.cid] = {
        resolve: (info) => {
          clearTimeout(publicationTimeout);
          resolve(info);
        },
        reject: () => {
          clearTimeout(publicationTimeout);
          reject(new Error("Cancelled publication by calling unpublish"));
        }
      };
      this.client.sendAddTrack(req);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(sender) {
    if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
      const {
        reject
      } = this.pendingTrackResolvers[sender.track.id];
      if (reject) {
        reject();
      }
      delete this.pendingTrackResolvers[sender.track.id];
    }
    try {
      this.pcManager.removeTrack(sender);
      return true;
    } catch (e4) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: e4
      }));
    }
    return false;
  }
  updateMuteStatus(trackSid, muted) {
    this.client.sendMuteTrack(trackSid, muted);
  }
  get dataSubscriberReadyState() {
    var _a3;
    return (_a3 = this.reliableDCSub) === null || _a3 === void 0 ? void 0 : _a3.readyState;
  }
  getConnectedServerAddress() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      return (_a3 = this.pcManager) === null || _a3 === void 0 ? void 0 : _a3.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(provider) {
    this.regionUrlProvider = provider;
  }
  configure(joinResponse) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {
        return;
      }
      this.participantSid = (_a3 = joinResponse.participant) === null || _a3 === void 0 ? void 0 : _a3.sid;
      const rtcConfig = this.makeRTCConfiguration(joinResponse);
      this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);
      this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);
      this.pcManager.onIceCandidate = (candidate, target) => {
        this.client.sendIceCandidate(candidate, target);
      };
      this.pcManager.onPublisherOffer = (offer, offerId) => {
        this.client.sendOffer(offer, offerId);
      };
      this.pcManager.onDataChannel = this.handleDataChannel;
      this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {
        this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);
        if (["closed", "disconnected", "failed"].includes(publisherState)) {
          this.publisherConnectionPromise = void 0;
        }
        if (connectionState === PCTransportState.CONNECTED) {
          const shouldEmit = this.pcState === PCState.New;
          this.pcState = PCState.Connected;
          if (shouldEmit) {
            this.emit(EngineEvent.Connected, joinResponse);
          }
        } else if (connectionState === PCTransportState.FAILED) {
          if (this.pcState === PCState.Connected) {
            this.pcState = PCState.Disconnected;
            this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
          }
        }
        const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;
        const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);
        if (isSignalSevered && isPCSevered && !this._isClosed) {
          this.emit(EngineEvent.Offline);
        }
      });
      this.pcManager.onTrack = (ev) => {
        this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
      };
      if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {
        this.createDataChannels();
      }
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (sd, offerId) => __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager) {
        return;
      }
      this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: sd.type
      }));
      yield this.pcManager.setPublisherAnswer(sd, offerId);
    });
    this.client.onTrickle = (candidate, target) => {
      if (!this.pcManager) {
        return;
      }
      this.log.debug("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate,
        target
      }));
      this.pcManager.addIceCandidate(candidate, target);
    };
    this.client.onOffer = (sd, offerId) => __awaiter(this, void 0, void 0, function* () {
      this.latestRemoteOfferId = offerId;
      if (!this.pcManager) {
        return;
      }
      const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd, offerId);
      if (answer) {
        this.client.sendAnswer(answer, offerId);
      }
    });
    this.client.onLocalTrackPublished = (res) => {
      var _a3;
      this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: res.cid,
        track: (_a3 = res.track) === null || _a3 === void 0 ? void 0 : _a3.sid
      }));
      if (!this.pendingTrackResolvers[res.cid]) {
        this.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: res.cid
        }));
        return;
      }
      const {
        resolve
      } = this.pendingTrackResolvers[res.cid];
      delete this.pendingTrackResolvers[res.cid];
      resolve(res.track);
    };
    this.client.onLocalTrackUnpublished = (response) => {
      this.emit(EngineEvent.LocalTrackUnpublished, response);
    };
    this.client.onLocalTrackSubscribed = (trackSid) => {
      this.emit(EngineEvent.LocalTrackSubscribed, trackSid);
    };
    this.client.onTokenRefresh = (token) => {
      this.token = token;
    };
    this.client.onRemoteMuteChanged = (trackSid, muted) => {
      this.emit(EngineEvent.RemoteMute, trackSid, muted);
    };
    this.client.onSubscribedQualityUpdate = (update) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, update);
    };
    this.client.onRoomMoved = (res) => {
      var _a3;
      this.participantSid = (_a3 = res.participant) === null || _a3 === void 0 ? void 0 : _a3.sid;
      if (this.latestJoinResponse) {
        this.latestJoinResponse.room = res.room;
      }
      this.emit(EngineEvent.RoomMoved, res);
    };
    this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    };
    this.client.onLeave = (leave) => {
      this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: leave === null || leave === void 0 ? void 0 : leave.reason
      }));
      if (leave.regions && this.regionUrlProvider) {
        this.log.debug("updating regions", this.logContext);
        this.regionUrlProvider.setServerReportedRegions(leave.regions);
      }
      switch (leave.action) {
        case LeaveRequest_Action.DISCONNECT:
          this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
          this.close();
          break;
        case LeaveRequest_Action.RECONNECT:
          this.fullReconnectOnNext = true;
          this.handleDisconnect(leaveReconnect);
          break;
        case LeaveRequest_Action.RESUME:
          this.handleDisconnect(leaveReconnect);
      }
    };
  }
  makeRTCConfiguration(serverResponse) {
    var _a3;
    const rtcConfig = Object.assign({}, this.rtcConfig);
    if ((_a3 = this.signalOpts) === null || _a3 === void 0 ? void 0 : _a3.e2eeEnabled) {
      this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);
      rtcConfig.encodedInsertableStreams = true;
    }
    if (serverResponse.iceServers && !rtcConfig.iceServers) {
      const rtcIceServers = [];
      serverResponse.iceServers.forEach((iceServer) => {
        const rtcIceServer = {
          urls: iceServer.urls
        };
        if (iceServer.username)
          rtcIceServer.username = iceServer.username;
        if (iceServer.credential) {
          rtcIceServer.credential = iceServer.credential;
        }
        rtcIceServers.push(rtcIceServer);
      });
      rtcConfig.iceServers = rtcIceServers;
    }
    if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
      rtcConfig.iceTransportPolicy = "relay";
    }
    rtcConfig.sdpSemantics = "unified-plan";
    rtcConfig.continualGatheringPolicy = "gather_continually";
    return rtcConfig;
  }
  createDataChannels() {
    if (!this.pcManager) {
      return;
    }
    if (this.lossyDC) {
      this.lossyDC.onmessage = null;
      this.lossyDC.onerror = null;
    }
    if (this.reliableDC) {
      this.reliableDC.onmessage = null;
      this.reliableDC.onerror = null;
    }
    this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      ordered: false,
      maxRetransmits: 0
    });
    this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: true
    });
    this.lossyDC.onmessage = this.handleDataMessage;
    this.reliableDC.onmessage = this.handleDataMessage;
    this.lossyDC.onerror = this.handleDataError;
    this.reliableDC.onerror = this.handleDataError;
    this.lossyDC.bufferedAmountLowThreshold = 65535;
    this.reliableDC.bufferedAmountLowThreshold = 65535;
    this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
    this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
  }
  createSender(track2, opts, encodings) {
    return __awaiter(this, void 0, void 0, function* () {
      if (supportsTransceiver()) {
        const sender = yield this.createTransceiverRTCRtpSender(track2, opts, encodings);
        return sender;
      }
      if (supportsAddTrack()) {
        this.log.warn("using add-track fallback", this.logContext);
        const sender = yield this.createRTCRtpSender(track2.mediaStreamTrack);
        return sender;
      }
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(track2, simulcastTrack, opts, encodings) {
    return __awaiter(this, void 0, void 0, function* () {
      if (supportsTransceiver()) {
        return this.createSimulcastTransceiverSender(track2, simulcastTrack, opts, encodings);
      }
      if (supportsAddTrack()) {
        this.log.debug("using add-track fallback", this.logContext);
        return this.createRTCRtpSender(track2.mediaStreamTrack);
      }
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(track2, opts, encodings) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager) {
        throw new UnexpectedConnectionState("publisher is closed");
      }
      const streams = [];
      if (track2.mediaStream) {
        streams.push(track2.mediaStream);
      }
      if (isVideoTrack(track2)) {
        track2.codec = opts.videoCodec;
      }
      const transceiverInit = {
        direction: "sendonly",
        streams
      };
      if (encodings) {
        transceiverInit.sendEncodings = encodings;
      }
      const transceiver = yield this.pcManager.addPublisherTransceiver(track2.mediaStreamTrack, transceiverInit);
      return transceiver.sender;
    });
  }
  createSimulcastTransceiverSender(track2, simulcastTrack, opts, encodings) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager) {
        throw new UnexpectedConnectionState("publisher is closed");
      }
      const transceiverInit = {
        direction: "sendonly"
      };
      if (encodings) {
        transceiverInit.sendEncodings = encodings;
      }
      const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
      if (!opts.videoCodec) {
        return;
      }
      track2.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
      return transceiver.sender;
    });
  }
  createRTCRtpSender(track2) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager) {
        throw new UnexpectedConnectionState("publisher is closed");
      }
      return this.pcManager.addPublisherTrack(track2);
    });
  }
  attemptReconnect(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3;
      if (this._isClosed) {
        return;
      }
      if (this.attemptingReconnect) {
        livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
        return;
      }
      if (((_a3 = this.clientConfiguration) === null || _a3 === void 0 ? void 0 : _a3.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
      // those connections cannot be resumed
      ((_c3 = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c3 !== void 0 ? _c3 : PCTransportState.NEW) === PCTransportState.NEW) {
        this.fullReconnectOnNext = true;
      }
      try {
        this.attemptingReconnect = true;
        if (this.fullReconnectOnNext) {
          yield this.restartConnection();
        } else {
          yield this.resumeConnection(reason);
        }
        this.clearPendingReconnect();
        this.fullReconnectOnNext = false;
      } catch (e4) {
        this.reconnectAttempts += 1;
        let recoverable = true;
        if (e4 instanceof UnexpectedConnectionState) {
          this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: e4
          }));
          recoverable = false;
        } else if (!(e4 instanceof SignalReconnectError)) {
          this.fullReconnectOnNext = true;
        }
        if (recoverable) {
          this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);
        } else {
          this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);
          this.emit(EngineEvent.Disconnected);
          yield this.close();
        }
      } finally {
        this.attemptingReconnect = false;
      }
    });
  }
  getNextRetryDelay(context) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(context);
    } catch (e4) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: e4
      }));
    }
    return null;
  }
  restartConnection(regionUrl) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3;
      try {
        if (!this.url || !this.token) {
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        }
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);
        this.emit(EngineEvent.Restarting);
        if (!this.client.isDisconnected) {
          yield this.client.sendLeave();
        }
        yield this.cleanupPeerConnections();
        yield this.cleanupClient();
        let joinResponse;
        try {
          if (!this.signalOpts) {
            this.log.warn("attempted connection restart, without signal options present", this.logContext);
            throw new SignalReconnectError();
          }
          joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);
        } catch (e4) {
          if (e4 instanceof ConnectionError && e4.reason === ConnectionErrorReason.NotAllowed) {
            throw new UnexpectedConnectionState("could not reconnect, token might be expired");
          }
          throw new SignalReconnectError();
        }
        if (this.shouldFailNext) {
          this.shouldFailNext = false;
          throw new Error("simulated failure");
        }
        this.client.setReconnected();
        this.emit(EngineEvent.SignalRestarted, joinResponse);
        yield this.waitForPCReconnected();
        if (this.client.currentState !== SignalConnectionState.CONNECTED) {
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        }
        (_a3 = this.regionUrlProvider) === null || _a3 === void 0 ? void 0 : _a3.resetAttempts();
        this.emit(EngineEvent.Restarted);
      } catch (error) {
        const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();
        if (nextRegionUrl) {
          yield this.restartConnection(nextRegionUrl);
          return;
        } else {
          (_c3 = this.regionUrlProvider) === null || _c3 === void 0 ? void 0 : _c3.resetAttempts();
          throw error;
        }
      }
    });
  }
  resumeConnection(reason) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!this.url || !this.token) {
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      }
      if (!this.pcManager) {
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      }
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);
      this.emit(EngineEvent.Resuming);
      let res;
      try {
        this.setupSignalClientCallbacks();
        res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);
      } catch (error) {
        let message = "";
        if (error instanceof Error) {
          message = error.message;
          this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        }
        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {
          throw new UnexpectedConnectionState("could not reconnect, token might be expired");
        }
        if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {
          throw error;
        }
        throw new SignalReconnectError(message);
      }
      this.emit(EngineEvent.SignalResumed);
      if (res) {
        const rtcConfig = this.makeRTCConfiguration(res);
        this.pcManager.updateConfiguration(rtcConfig);
        if (this.latestJoinResponse) {
          this.latestJoinResponse.serverInfo = res.serverInfo;
        }
      } else {
        this.log.warn("Did not receive reconnect response", this.logContext);
      }
      if (this.shouldFailNext) {
        this.shouldFailNext = false;
        throw new Error("simulated failure");
      }
      yield this.pcManager.triggerIceRestart();
      yield this.waitForPCReconnected();
      if (this.client.currentState !== SignalConnectionState.CONNECTED) {
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      }
      this.client.setReconnected();
      if (((_a3 = this.reliableDC) === null || _a3 === void 0 ? void 0 : _a3.readyState) === "open" && this.reliableDC.id === null) {
        this.createDataChannels();
      }
      if (res === null || res === void 0 ? void 0 : res.lastMessageSeq) {
        this.resendReliableMessagesForResume(res.lastMessageSeq);
      }
      this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(timeout, abortController) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager) {
        throw new UnexpectedConnectionState("PC manager is closed");
      }
      yield this.pcManager.ensurePCTransportConnection(abortController, timeout);
    });
  }
  waitForPCReconnected() {
    return __awaiter(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting;
      this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        yield sleep(minReconnectWait);
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("PC manager is closed");
        }
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout);
        this.pcState = PCState.Connected;
      } catch (e4) {
        this.pcState = PCState.Disconnected;
        throw new ConnectionError("could not establish PC connection, ".concat(e4.message), ConnectionErrorReason.InternalError);
      }
    });
  }
  /** @internal */
  publishRpcResponse(destinationIdentity, requestId, payload, error) {
    return __awaiter(this, void 0, void 0, function* () {
      const packet = new DataPacket({
        destinationIdentities: [destinationIdentity],
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "rpcResponse",
          value: new RpcResponse({
            requestId,
            value: error ? {
              case: "error",
              value: error.toProto()
            } : {
              case: "payload",
              value: payload !== null && payload !== void 0 ? payload : ""
            }
          })
        }
      });
      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
    });
  }
  /** @internal */
  publishRpcAck(destinationIdentity, requestId) {
    return __awaiter(this, void 0, void 0, function* () {
      const packet = new DataPacket({
        destinationIdentities: [destinationIdentity],
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "rpcAck",
          value: new RpcAck({
            requestId
          })
        }
      });
      yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
    });
  }
  /* @internal */
  sendDataPacket(packet, kind) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.ensurePublisherConnected(kind);
      if (kind === DataPacket_Kind.RELIABLE) {
        packet.sequence = this.reliableDataSequence;
        this.reliableDataSequence += 1;
      }
      const msg = packet.toBinary();
      const dc3 = this.dataChannelForKind(kind);
      if (dc3) {
        if (kind === DataPacket_Kind.RELIABLE) {
          this.reliableMessageBuffer.push({
            data: msg,
            sequence: packet.sequence
          });
        }
        if (this.attemptingReconnect) {
          return;
        }
        dc3.send(msg);
      }
      this.updateAndEmitDCBufferStatus(kind);
    });
  }
  resendReliableMessagesForResume(lastMessageSeq) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);
      const dc3 = this.dataChannelForKind(DataPacket_Kind.RELIABLE);
      if (dc3) {
        this.reliableMessageBuffer.popToSequence(lastMessageSeq);
        this.reliableMessageBuffer.getAll().forEach((msg) => {
          dc3.send(msg.data);
        });
      }
      this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);
    });
  }
  waitForBufferStatusLow(kind) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      if (this.isBufferStatusLow(kind)) {
        resolve();
      } else {
        const onClosing = () => reject("Engine closed");
        this.once(EngineEvent.Closing, onClosing);
        while (!this.dcBufferStatus.get(kind)) {
          yield sleep(10);
        }
        this.off(EngineEvent.Closing, onClosing);
        resolve();
      }
    }));
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(kind_1) {
    return __awaiter(this, arguments, void 0, function(kind) {
      var _this2 = this;
      let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
      return function* () {
        var _a3;
        if (!_this2.pcManager) {
          throw new UnexpectedConnectionState("PC manager is closed");
        }
        const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;
        const transportName = subscriber ? "Subscriber" : "Publisher";
        if (!transport) {
          throw new ConnectionError("".concat(transportName, " connection not set"), ConnectionErrorReason.InternalError);
        }
        let needNegotiation = false;
        if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {
          _this2.createDataChannels();
          needNegotiation = true;
        }
        if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== "checking") {
          needNegotiation = true;
        }
        if (needNegotiation) {
          _this2.negotiate();
        }
        const targetChannel = _this2.dataChannelForKind(kind, subscriber);
        if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
          return;
        }
        const endTime = (/* @__PURE__ */ new Date()).getTime() + _this2.peerConnectionTimeout;
        while ((/* @__PURE__ */ new Date()).getTime() < endTime) {
          if (transport.isICEConnected && ((_a3 = _this2.dataChannelForKind(kind, subscriber)) === null || _a3 === void 0 ? void 0 : _a3.readyState) === "open") {
            return;
          }
          yield sleep(50);
        }
        throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);
      }();
    });
  }
  ensurePublisherConnected(kind) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.publisherConnectionPromise) {
        this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
      }
      yield this.publisherConnectionPromise;
    });
  }
  /* @internal */
  verifyTransport() {
    if (!this.pcManager) {
      return false;
    }
    if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
      return false;
    }
    if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
      return false;
    }
    return true;
  }
  /** @internal */
  negotiate() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          reject(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {
          this.createDataChannels();
        }
        const abortController = new AbortController();
        const handleClosed = () => {
          abortController.abort();
          this.log.debug("engine disconnected while negotiation was ongoing", this.logContext);
          resolve();
          return;
        };
        if (this.isClosed) {
          reject("cannot negotiate on closed engine");
        }
        this.on(EngineEvent.Closing, handleClosed);
        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes) => {
          const rtpMap = /* @__PURE__ */ new Map();
          rtpTypes.forEach((rtp) => {
            const codec = rtp.codec.toLowerCase();
            if (isVideoCodec(codec)) {
              rtpMap.set(rtp.payload, codec);
            }
          });
          this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
        });
        try {
          yield this.pcManager.negotiate(abortController);
          resolve();
        } catch (e4) {
          if (e4 instanceof NegotiationError) {
            this.fullReconnectOnNext = true;
          }
          this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);
          reject(e4);
        } finally {
          this.off(EngineEvent.Closing, handleClosed);
        }
      }));
    });
  }
  dataChannelForKind(kind, sub) {
    if (!sub) {
      if (kind === DataPacket_Kind.LOSSY) {
        return this.lossyDC;
      }
      if (kind === DataPacket_Kind.RELIABLE) {
        return this.reliableDC;
      }
    } else {
      if (kind === DataPacket_Kind.LOSSY) {
        return this.lossyDCSub;
      }
      if (kind === DataPacket_Kind.RELIABLE) {
        return this.reliableDCSub;
      }
    }
  }
  /** @internal */
  sendSyncState(remoteTracks, localTracks) {
    var _a3, _b;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const previousAnswer = this.pcManager.subscriber.getLocalDescription();
    const previousOffer = this.pcManager.subscriber.getRemoteDescription();
    const autoSubscribe = (_b = (_a3 = this.signalOpts) === null || _a3 === void 0 ? void 0 : _a3.autoSubscribe) !== null && _b !== void 0 ? _b : true;
    const trackSids = new Array();
    const trackSidsDisabled = new Array();
    remoteTracks.forEach((track2) => {
      if (track2.isDesired !== autoSubscribe) {
        trackSids.push(track2.trackSid);
      }
      if (!track2.isEnabled) {
        trackSidsDisabled.push(track2.trackSid);
      }
    });
    this.client.sendSyncState(new SyncState({
      answer: previousAnswer ? toProtoSessionDescription({
        sdp: previousAnswer.sdp,
        type: previousAnswer.type
      }) : void 0,
      offer: previousOffer ? toProtoSessionDescription({
        sdp: previousOffer.sdp,
        type: previousOffer.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids,
        subscribe: !autoSubscribe,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(localTracks),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled,
      datachannelReceiveStates: this.reliableReceivedState.map((seq, sid) => {
        return new DataChannelReceiveState({
          publisherSid: sid,
          lastSeq: seq
        });
      })
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = true;
  }
  dataChannelsInfo() {
    const infos = [];
    const getInfo = (dc3, target) => {
      if ((dc3 === null || dc3 === void 0 ? void 0 : dc3.id) !== void 0 && dc3.id !== null) {
        infos.push(new DataChannelInfo({
          label: dc3.label,
          id: dc3.id,
          target
        }));
      }
    };
    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
    getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
    getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
    return infos;
  }
  clearReconnectTimeout() {
    if (this.reconnectTimeout) {
      CriticalTimers.clearTimeout(this.reconnectTimeout);
    }
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout();
    this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    if (isWeb()) {
      window.addEventListener("online", this.handleBrowserOnLine);
    }
  }
  deregisterOnLineListener() {
    if (isWeb()) {
      window.removeEventListener("online", this.handleBrowserOnLine);
    }
  }
};
var SignalReconnectError = class extends Error {
};
function supportOptionalDatachannel(protocol) {
  return protocol !== void 0 && protocol > 13;
}
function applyUserDataCompat(newObj, oldObj) {
  const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;
  newObj.participantIdentity = participantIdentity;
  oldObj.participantIdentity = participantIdentity;
  const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;
  newObj.destinationIdentities = destinationIdentities;
  oldObj.destinationIdentities = destinationIdentities;
}
var RegionUrlProvider = class {
  constructor(url, token) {
    this.lastUpdateAt = 0;
    this.settingsCacheTime = 3e3;
    this.attemptedRegions = [];
    this.serverUrl = new URL(url);
    this.token = token;
  }
  updateToken(token) {
    this.token = token;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(abortSignal) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isCloud()) {
        throw Error("region availability is only supported for LiveKit Cloud domains");
      }
      if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {
        this.regionSettings = yield this.fetchRegionSettings(abortSignal);
      }
      const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));
      if (regionsLeft.length > 0) {
        const nextRegion = regionsLeft[0];
        this.attemptedRegions.push(nextRegion);
        livekitLogger.debug("next region: ".concat(nextRegion.region));
        return nextRegion.url;
      } else {
        return null;
      }
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(signal) {
    return __awaiter(this, void 0, void 0, function* () {
      const regionSettingsResponse = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal
      });
      if (regionSettingsResponse.ok) {
        const regionSettings = yield regionSettingsResponse.json();
        this.lastUpdateAt = Date.now();
        return regionSettings;
      } else {
        throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);
      }
    });
  }
  setServerReportedRegions(regions) {
    this.regionSettings = regions;
    this.lastUpdateAt = Date.now();
  }
};
function getCloudConfigUrl(serverUrl) {
  return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");
}
var BaseStreamReader = class {
  get info() {
    return this._info;
  }
  constructor(info, stream, totalByteSize) {
    this.reader = stream;
    this.totalByteSize = totalByteSize;
    this._info = info;
    this.bytesReceived = 0;
  }
};
var ByteStreamReader = class extends BaseStreamReader {
  handleChunkReceived(chunk) {
    var _a3;
    this.bytesReceived += chunk.content.byteLength;
    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
    (_a3 = this.onProgress) === null || _a3 === void 0 ? void 0 : _a3.call(this, currentProgress);
  }
  [Symbol.asyncIterator]() {
    const reader = this.reader.getReader();
    return {
      next: () => __awaiter(this, void 0, void 0, function* () {
        try {
          const {
            done,
            value
          } = yield reader.read();
          if (done) {
            return {
              done: true,
              value: void 0
            };
          } else {
            this.handleChunkReceived(value);
            return {
              done: false,
              value: value.content
            };
          }
        } catch (error) {
          return {
            done: true,
            value: void 0
          };
        }
      }),
      return() {
        return __awaiter(this, void 0, void 0, function* () {
          reader.releaseLock();
          return {
            done: true,
            value: void 0
          };
        });
      }
    };
  }
  readAll() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, e_1, _b, _c3;
      let chunks = /* @__PURE__ */ new Set();
      try {
        for (var _d = true, _e3 = __asyncValues(this), _f; _f = yield _e3.next(), _a3 = _f.done, !_a3; _d = true) {
          _c3 = _f.value;
          _d = false;
          const chunk = _c3;
          chunks.add(chunk);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (!_d && !_a3 && (_b = _e3.return))
            yield _b.call(_e3);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return Array.from(chunks);
    });
  }
};
var TextStreamReader = class extends BaseStreamReader {
  /**
   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string
   * that has been received up to the current point in time.
   */
  constructor(info, stream, totalChunkCount) {
    super(info, stream, totalChunkCount);
    this.receivedChunks = /* @__PURE__ */ new Map();
  }
  handleChunkReceived(chunk) {
    var _a3;
    const index = bigIntToNumber(chunk.chunkIndex);
    const previousChunkAtIndex = this.receivedChunks.get(index);
    if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {
      return;
    }
    this.receivedChunks.set(index, chunk);
    this.bytesReceived += chunk.content.byteLength;
    const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : void 0;
    (_a3 = this.onProgress) === null || _a3 === void 0 ? void 0 : _a3.call(this, currentProgress);
  }
  /**
   * Async iterator implementation to allow usage of `for await...of` syntax.
   * Yields structured chunks from the stream.
   *
   */
  [Symbol.asyncIterator]() {
    const reader = this.reader.getReader();
    const decoder = new TextDecoder();
    return {
      next: () => __awaiter(this, void 0, void 0, function* () {
        try {
          const {
            done,
            value
          } = yield reader.read();
          if (done) {
            return {
              done: true,
              value: void 0
            };
          } else {
            this.handleChunkReceived(value);
            return {
              done: false,
              value: decoder.decode(value.content)
            };
          }
        } catch (error) {
          return {
            done: true,
            value: void 0
          };
        }
      }),
      return() {
        return __awaiter(this, void 0, void 0, function* () {
          reader.releaseLock();
          return {
            done: true,
            value: void 0
          };
        });
      }
    };
  }
  readAll() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, e_2, _b, _c3;
      let finalString = "";
      try {
        for (var _d = true, _e3 = __asyncValues(this), _f; _f = yield _e3.next(), _a3 = _f.done, !_a3; _d = true) {
          _c3 = _f.value;
          _d = false;
          const chunk = _c3;
          finalString += chunk;
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (!_d && !_a3 && (_b = _e3.return))
            yield _b.call(_e3);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return finalString;
    });
  }
};
var BaseStreamWriter = class {
  constructor(writableStream, info, onClose) {
    this.writableStream = writableStream;
    this.defaultWriter = writableStream.getWriter();
    this.onClose = onClose;
    this.info = info;
  }
  write(chunk) {
    return this.defaultWriter.write(chunk);
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield this.defaultWriter.close();
      this.defaultWriter.releaseLock();
      (_a3 = this.onClose) === null || _a3 === void 0 ? void 0 : _a3.call(this);
    });
  }
};
var TextStreamWriter = class extends BaseStreamWriter {
};
var ByteStreamWriter = class extends BaseStreamWriter {
};
var RemoteTrack = class extends Track {
  constructor(mediaTrack, sid, kind, receiver, loggerOptions) {
    super(mediaTrack, kind, loggerOptions);
    this.sid = sid;
    this.receiver = receiver;
  }
  get isLocal() {
    return false;
  }
  /** @internal */
  setMuted(muted) {
    if (this.isMuted !== muted) {
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
  }
  /** @internal */
  setMediaStream(stream) {
    this.mediaStream = stream;
    const onRemoveTrack = (event) => {
      if (event.track === this._mediaStreamTrack) {
        stream.removeEventListener("removetrack", onRemoveTrack);
        if (this.receiver && "playoutDelayHint" in this.receiver) {
          this.receiver.playoutDelayHint = void 0;
        }
        this.receiver = void 0;
        this._currentBitrate = 0;
        this.emit(TrackEvent.Ended, this);
      }
    };
    stream.addEventListener("removetrack", onRemoveTrack);
  }
  start() {
    this.startMonitor();
    super.enable();
  }
  stop() {
    this.stopMonitor();
    super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (!((_a3 = this.receiver) === null || _a3 === void 0 ? void 0 : _a3.getStats)) {
        return;
      }
      const statsReport = yield this.receiver.getStats();
      return statsReport;
    });
  }
  /**
   * Allows to set a playout delay (in seconds) for this track.
   * A higher value allows for more buffering of the track in the browser
   * and will result in a delay of media being played back of `delayInSeconds`
   */
  setPlayoutDelay(delayInSeconds) {
    if (this.receiver) {
      if ("playoutDelayHint" in this.receiver) {
        this.receiver.playoutDelayHint = delayInSeconds;
      } else {
        this.log.warn("Playout delay not supported in this browser");
      }
    } else {
      this.log.warn("Cannot set playout delay, track already ended");
    }
  }
  /**
   * Returns the current playout delay (in seconds) of this track.
   */
  getPlayoutDelay() {
    if (this.receiver) {
      if ("playoutDelayHint" in this.receiver) {
        return this.receiver.playoutDelayHint;
      } else {
        this.log.warn("Playout delay not supported in this browser");
      }
    } else {
      this.log.warn("Cannot get playout delay, track already ended");
    }
    return 0;
  }
  /* @internal */
  startMonitor() {
    if (!this.monitorInterval) {
      this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
    }
    if (supportsSynchronizationSources()) {
      this.registerTimeSyncUpdate();
    }
  }
  registerTimeSyncUpdate() {
    const loop = () => {
      var _a3;
      this.timeSyncHandle = requestAnimationFrame(() => loop());
      const sources = (_a3 = this.receiver) === null || _a3 === void 0 ? void 0 : _a3.getSynchronizationSources()[0];
      if (sources) {
        const {
          timestamp,
          rtpTimestamp
        } = sources;
        if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {
          this.emit(TrackEvent.TimeSyncUpdate, {
            timestamp,
            rtpTimestamp
          });
          this.rtpTimestamp = rtpTimestamp;
        }
      }
    };
    loop();
  }
};
var RemoteAudioTrack = class extends RemoteTrack {
  constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
    super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);
    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats = yield this.getReceiverStats();
      if (stats && this.prevStats && this.receiver) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    });
    this.audioContext = audioContext;
    this.webAudioPluginNodes = [];
    if (audioOutput) {
      this.sinkId = audioOutput.deviceId;
    }
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(volume) {
    var _a3;
    for (const el of this.attachedElements) {
      if (this.audioContext) {
        (_a3 = this.gainNode) === null || _a3 === void 0 ? void 0 : _a3.gain.setTargetAtTime(volume, 0, 0.1);
      } else {
        el.volume = volume;
      }
    }
    if (isReactNative()) {
      this._mediaStreamTrack._setVolume(volume);
    }
    this.elementVolume = volume;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume) {
      return this.elementVolume;
    }
    if (isReactNative()) {
      return 1;
    }
    let highestVolume = 0;
    this.attachedElements.forEach((element) => {
      if (element.volume > highestVolume) {
        highestVolume = element.volume;
      }
    });
    return highestVolume;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(deviceId) {
    return __awaiter(this, void 0, void 0, function* () {
      this.sinkId = deviceId;
      yield Promise.all(this.attachedElements.map((elm) => {
        if (!supportsSetSinkId(elm)) {
          return;
        }
        return elm.setSinkId(deviceId);
      }));
    });
  }
  attach(element) {
    const needsNewWebAudioConnection = this.attachedElements.length === 0;
    if (!element) {
      element = super.attach();
    } else {
      super.attach(element);
    }
    if (this.sinkId && supportsSetSinkId(element)) {
      element.setSinkId(this.sinkId).catch((e4) => {
        this.log.error("Failed to set sink id on remote audio track", e4, this.logContext);
      });
    }
    if (this.audioContext && needsNewWebAudioConnection) {
      this.log.debug("using audio context mapping", this.logContext);
      this.connectWebAudio(this.audioContext, element);
      element.volume = 0;
      element.muted = true;
    }
    if (this.elementVolume) {
      this.setVolume(this.elementVolume);
    }
    return element;
  }
  detach(element) {
    let detached;
    if (!element) {
      detached = super.detach();
      this.disconnectWebAudio();
    } else {
      detached = super.detach(element);
      if (this.audioContext) {
        if (this.attachedElements.length > 0) {
          this.connectWebAudio(this.audioContext, this.attachedElements[0]);
        } else {
          this.disconnectWebAudio();
        }
      }
    }
    return detached;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(audioContext) {
    this.audioContext = audioContext;
    if (audioContext && this.attachedElements.length > 0) {
      this.connectWebAudio(audioContext, this.attachedElements[0]);
    } else if (!audioContext) {
      this.disconnectWebAudio();
    }
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(nodes) {
    this.webAudioPluginNodes = nodes;
    if (this.attachedElements.length > 0 && this.audioContext) {
      this.connectWebAudio(this.audioContext, this.attachedElements[0]);
    }
  }
  connectWebAudio(context, element) {
    this.disconnectWebAudio();
    this.sourceNode = context.createMediaStreamSource(element.srcObject);
    let lastNode = this.sourceNode;
    this.webAudioPluginNodes.forEach((node) => {
      lastNode.connect(node);
      lastNode = node;
    });
    this.gainNode = context.createGain();
    lastNode.connect(this.gainNode);
    this.gainNode.connect(context.destination);
    if (this.elementVolume) {
      this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
    }
    if (context.state !== "running") {
      context.resume().then(() => {
        if (context.state !== "running") {
          this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
        }
      }).catch((e4) => {
        this.emit(TrackEvent.AudioPlaybackFailed, e4);
      });
    }
  }
  disconnectWebAudio() {
    var _a3, _b;
    (_a3 = this.gainNode) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
    (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
    this.gainNode = void 0;
    this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats) {
        return;
      }
      const stats = yield this.receiver.getStats();
      let receiverStats;
      stats.forEach((v3) => {
        if (v3.type === "inbound-rtp") {
          receiverStats = {
            type: "audio",
            streamId: v3.id,
            timestamp: v3.timestamp,
            jitter: v3.jitter,
            bytesReceived: v3.bytesReceived,
            concealedSamples: v3.concealedSamples,
            concealmentEvents: v3.concealmentEvents,
            silentConcealedSamples: v3.silentConcealedSamples,
            silentConcealmentEvents: v3.silentConcealmentEvents,
            totalAudioEnergy: v3.totalAudioEnergy,
            totalSamplesDuration: v3.totalSamplesDuration
          };
        }
      });
      return receiverStats;
    });
  }
};
var REACTION_DELAY = 100;
var RemoteVideoTrack = class extends RemoteTrack {
  constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
    super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);
    this.elementInfos = [];
    this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const stats = yield this.getReceiverStats();
      if (stats && this.prevStats && this.receiver) {
        this._currentBitrate = computeBitrate(stats, this.prevStats);
      }
      this.prevStats = stats;
    });
    this.debouncedHandleResize = r3(() => {
      this.updateDimensions();
    }, REACTION_DELAY);
    this.adaptiveStreamSettings = adaptiveStreamSettings;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(muted) {
    super.setMuted(muted);
    this.attachedElements.forEach((element) => {
      if (muted) {
        detachTrack(this._mediaStreamTrack, element);
      } else {
        attachToElement(this._mediaStreamTrack, element);
      }
    });
  }
  attach(element) {
    if (!element) {
      element = super.attach();
    } else {
      super.attach(element);
    }
    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {
      const elementInfo = new HTMLElementInfo(element);
      this.observeElementInfo(elementInfo);
    }
    return element;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(elementInfo) {
    if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {
      elementInfo.handleResize = () => {
        this.debouncedHandleResize();
      };
      elementInfo.handleVisibilityChanged = () => {
        this.updateVisibility();
      };
      this.elementInfos.push(elementInfo);
      elementInfo.observe();
      this.debouncedHandleResize();
      this.updateVisibility();
    } else {
      this.log.warn("visibility resize observer not triggered", this.logContext);
    }
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(elementInfo) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
    for (const info of stopElementInfos) {
      info.stopObserving();
    }
    this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
    this.updateVisibility();
    this.debouncedHandleResize();
  }
  detach(element) {
    let detachedElements = [];
    if (element) {
      this.stopObservingElement(element);
      return super.detach(element);
    }
    detachedElements = super.detach();
    for (const e4 of detachedElements) {
      this.stopObservingElement(e4);
    }
    return detachedElements;
  }
  /** @internal */
  getDecoderImplementation() {
    var _a3;
    return (_a3 = this.prevStats) === null || _a3 === void 0 ? void 0 : _a3.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats) {
        return;
      }
      const stats = yield this.receiver.getStats();
      let receiverStats;
      let codecID = "";
      let codecs = /* @__PURE__ */ new Map();
      stats.forEach((v3) => {
        if (v3.type === "inbound-rtp") {
          codecID = v3.codecId;
          receiverStats = {
            type: "video",
            streamId: v3.id,
            framesDecoded: v3.framesDecoded,
            framesDropped: v3.framesDropped,
            framesReceived: v3.framesReceived,
            packetsReceived: v3.packetsReceived,
            packetsLost: v3.packetsLost,
            frameWidth: v3.frameWidth,
            frameHeight: v3.frameHeight,
            pliCount: v3.pliCount,
            firCount: v3.firCount,
            nackCount: v3.nackCount,
            jitter: v3.jitter,
            timestamp: v3.timestamp,
            bytesReceived: v3.bytesReceived,
            decoderImplementation: v3.decoderImplementation
          };
        } else if (v3.type === "codec") {
          codecs.set(v3.id, v3);
        }
      });
      if (receiverStats && codecID !== "" && codecs.get(codecID)) {
        receiverStats.mimeType = codecs.get(codecID).mimeType;
      }
      return receiverStats;
    });
  }
  stopObservingElement(element) {
    const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
    for (const info of stopElementInfos) {
      this.stopObservingElementInfo(info);
    }
  }
  handleAppVisibilityChanged() {
    const _super = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield _super.handleAppVisibilityChanged.call(this);
      if (!this.isAdaptiveStream)
        return;
      this.updateVisibility();
    });
  }
  updateVisibility() {
    var _a3, _b;
    const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
    const backgroundPause = ((_b = (_a3 = this.adaptiveStreamSettings) === null || _a3 === void 0 ? void 0 : _a3.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
    const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);
    const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;
    if (this.lastVisible === isVisible) {
      return;
    }
    if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
      CriticalTimers.setTimeout(() => {
        this.updateVisibility();
      }, REACTION_DELAY);
      return;
    }
    this.lastVisible = isVisible;
    this.emit(TrackEvent.VisibilityChanged, isVisible, this);
  }
  updateDimensions() {
    var _a3, _b;
    let maxWidth = 0;
    let maxHeight = 0;
    const pixelDensity = this.getPixelDensity();
    for (const info of this.elementInfos) {
      const currentElementWidth = info.width() * pixelDensity;
      const currentElementHeight = info.height() * pixelDensity;
      if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
        maxWidth = currentElementWidth;
        maxHeight = currentElementHeight;
      }
    }
    if (((_a3 = this.lastDimensions) === null || _a3 === void 0 ? void 0 : _a3.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
      return;
    }
    this.lastDimensions = {
      width: maxWidth,
      height: maxHeight
    };
    this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
  }
  getPixelDensity() {
    var _a3;
    const pixelDensity = (_a3 = this.adaptiveStreamSettings) === null || _a3 === void 0 ? void 0 : _a3.pixelDensity;
    if (pixelDensity === "screen") {
      return getDevicePixelRatio();
    } else if (!pixelDensity) {
      const devicePixelRatio = getDevicePixelRatio();
      if (devicePixelRatio > 2) {
        return 2;
      } else {
        return 1;
      }
    }
    return pixelDensity;
  }
};
var HTMLElementInfo = class {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(element, visible) {
    this.onVisibilityChanged = (entry) => {
      var _a3;
      const {
        target,
        isIntersecting
      } = entry;
      if (target === this.element) {
        this.isIntersecting = isIntersecting;
        this.isPiP = isElementInPiP(this.element);
        this.visibilityChangedAt = Date.now();
        (_a3 = this.handleVisibilityChanged) === null || _a3 === void 0 ? void 0 : _a3.call(this);
      }
    };
    this.onEnterPiP = () => {
      var _a3, _b, _c3;
      (_b = (_a3 = window.documentPictureInPicture) === null || _a3 === void 0 ? void 0 : _a3.window) === null || _b === void 0 ? void 0 : _b.addEventListener("pagehide", this.onLeavePiP);
      this.isPiP = isElementInPiP(this.element);
      (_c3 = this.handleVisibilityChanged) === null || _c3 === void 0 ? void 0 : _c3.call(this);
    };
    this.onLeavePiP = () => {
      var _a3;
      this.isPiP = isElementInPiP(this.element);
      (_a3 = this.handleVisibilityChanged) === null || _a3 === void 0 ? void 0 : _a3.call(this);
    };
    this.element = element;
    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
    this.isPiP = isWeb() && isElementInPiP(element);
    this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    var _a3, _b, _c3;
    this.isIntersecting = isElementInViewport(this.element);
    this.isPiP = isElementInPiP(this.element);
    this.element.handleResize = () => {
      var _a4;
      (_a4 = this.handleResize) === null || _a4 === void 0 ? void 0 : _a4.call(this);
    };
    this.element.handleVisibilityChanged = this.onVisibilityChanged;
    getIntersectionObserver().observe(this.element);
    getResizeObserver().observe(this.element);
    this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);
    this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
    (_a3 = window.documentPictureInPicture) === null || _a3 === void 0 ? void 0 : _a3.addEventListener("enter", this.onEnterPiP);
    (_c3 = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c3 === void 0 ? void 0 : _c3.addEventListener("pagehide", this.onLeavePiP);
  }
  stopObserving() {
    var _a3, _b, _c3, _d, _e3;
    (_a3 = getIntersectionObserver()) === null || _a3 === void 0 ? void 0 : _a3.unobserve(this.element);
    (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
    this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);
    this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
    (_c3 = window.documentPictureInPicture) === null || _c3 === void 0 ? void 0 : _c3.removeEventListener("enter", this.onEnterPiP);
    (_e3 = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e3 === void 0 ? void 0 : _e3.removeEventListener("pagehide", this.onLeavePiP);
  }
};
function isElementInPiP(el) {
  var _a3, _b;
  if (document.pictureInPictureElement === el)
    return true;
  if ((_a3 = window.documentPictureInPicture) === null || _a3 === void 0 ? void 0 : _a3.window)
    return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);
  return false;
}
function isElementInViewport(el, win) {
  const viewportWindow = win || window;
  let top = el.offsetTop;
  let left = el.offsetLeft;
  const width = el.offsetWidth;
  const height = el.offsetHeight;
  const {
    hidden
  } = el;
  const {
    display
  } = getComputedStyle(el);
  while (el.offsetParent) {
    el = el.offsetParent;
    top += el.offsetTop;
    left += el.offsetLeft;
  }
  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== "none";
}
var TrackPublication = class extends eventsExports.EventEmitter {
  constructor(kind, id, name, loggerOptions) {
    var _a3;
    super();
    this.metadataMuted = false;
    this.encryption = Encryption_Type.NONE;
    this.log = livekitLogger;
    this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    };
    this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    };
    this.log = getLogger((_a3 = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Publication);
    this.loggerContextCb = this.loggerContextCb;
    this.setMaxListeners(100);
    this.kind = kind;
    this.trackSid = id;
    this.trackName = name;
    this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(track2) {
    if (this.track) {
      this.track.off(TrackEvent.Muted, this.handleMuted);
      this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
    }
    this.track = track2;
    if (track2) {
      track2.on(TrackEvent.Muted, this.handleMuted);
      track2.on(TrackEvent.Unmuted, this.handleUnmuted);
    }
  }
  get logContext() {
    var _a3;
    return Object.assign(Object.assign({}, (_a3 = this.loggerContextCb) === null || _a3 === void 0 ? void 0 : _a3.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return true;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (isAudioTrack(this.track)) {
      return this.track;
    }
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (isVideoTrack(this.track)) {
      return this.track;
    }
  }
  /** @internal */
  updateInfo(info) {
    this.trackSid = info.sid;
    this.trackName = info.name;
    this.source = Track.sourceFromProto(info.source);
    this.mimeType = info.mimeType;
    if (this.kind === Track.Kind.Video && info.width > 0) {
      this.dimensions = {
        width: info.width,
        height: info.height
      };
      this.simulcasted = info.simulcast;
    }
    this.encryption = info.encryption;
    this.trackInfo = info;
    this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info
    }));
  }
};
(function(TrackPublication3) {
  (function(SubscriptionStatus) {
    SubscriptionStatus["Desired"] = "desired";
    SubscriptionStatus["Subscribed"] = "subscribed";
    SubscriptionStatus["Unsubscribed"] = "unsubscribed";
  })(TrackPublication3.SubscriptionStatus || (TrackPublication3.SubscriptionStatus = {}));
  (function(PermissionStatus) {
    PermissionStatus["Allowed"] = "allowed";
    PermissionStatus["NotAllowed"] = "not_allowed";
  })(TrackPublication3.PermissionStatus || (TrackPublication3.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
var LocalTrackPublication = class extends TrackPublication {
  get isUpstreamPaused() {
    var _a3;
    return (_a3 = this.track) === null || _a3 === void 0 ? void 0 : _a3.isUpstreamPaused;
  }
  constructor(kind, ti3, track2, loggerOptions) {
    super(kind, ti3.sid, ti3.name, loggerOptions);
    this.track = void 0;
    this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    };
    this.handleCpuConstrained = () => {
      if (this.track && isVideoTrack(this.track)) {
        this.emit(TrackEvent.CpuConstrained, this.track);
      }
    };
    this.updateInfo(ti3);
    this.setTrack(track2);
  }
  setTrack(track2) {
    if (this.track) {
      this.track.off(TrackEvent.Ended, this.handleTrackEnded);
      this.track.off(TrackEvent.CpuConstrained, this.handleCpuConstrained);
    }
    super.setTrack(track2);
    if (track2) {
      track2.on(TrackEvent.Ended, this.handleTrackEnded);
      track2.on(TrackEvent.CpuConstrained, this.handleCpuConstrained);
    }
  }
  get isMuted() {
    if (this.track) {
      return this.track.isMuted;
    }
    return super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  get isLocal() {
    return true;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      return (_a3 = this.track) === null || _a3 === void 0 ? void 0 : _a3.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      return (_a3 = this.track) === null || _a3 === void 0 ? void 0 : _a3.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.track) === null || _a3 === void 0 ? void 0 : _a3.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      yield (_a3 = this.track) === null || _a3 === void 0 ? void 0 : _a3.resumeUpstream();
    });
  }
  getTrackFeatures() {
    var _a3;
    if (isAudioTrack(this.track)) {
      const settings = this.track.getSourceTrackSettings();
      const features = /* @__PURE__ */ new Set();
      if (settings.autoGainControl) {
        features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
      }
      if (settings.echoCancellation) {
        features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
      }
      if (settings.noiseSuppression) {
        features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
      }
      if (settings.channelCount && settings.channelCount > 1) {
        features.add(AudioTrackFeature.TF_STEREO);
      }
      if (!((_a3 = this.options) === null || _a3 === void 0 ? void 0 : _a3.dtx)) {
        features.add(AudioTrackFeature.TF_NO_DTX);
      }
      if (this.track.enhancedNoiseCancellation) {
        features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
      }
      return Array.from(features.values());
    } else
      return [];
  }
};
function createLocalTracks(options, loggerOptions) {
  return __awaiter(this, void 0, void 0, function* () {
    options !== null && options !== void 0 ? options : options = {};
    let attemptExactMatch = false;
    const {
      audioProcessor,
      videoProcessor,
      optionsWithoutProcessor: internalOptions
    } = extractProcessorsFromOptions(options);
    let retryAudioOptions = internalOptions.audio;
    let retryVideoOptions = internalOptions.video;
    if (audioProcessor && typeof internalOptions.audio === "object") {
      internalOptions.audio.processor = audioProcessor;
    }
    if (videoProcessor && typeof internalOptions.video === "object") {
      internalOptions.video.processor = videoProcessor;
    }
    if (options.audio && typeof internalOptions.audio === "object" && typeof internalOptions.audio.deviceId === "string") {
      const deviceId = internalOptions.audio.deviceId;
      internalOptions.audio.deviceId = {
        exact: deviceId
      };
      attemptExactMatch = true;
      retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {
        deviceId: {
          ideal: deviceId
        }
      });
    }
    if (internalOptions.video && typeof internalOptions.video === "object" && typeof internalOptions.video.deviceId === "string") {
      const deviceId = internalOptions.video.deviceId;
      internalOptions.video.deviceId = {
        exact: deviceId
      };
      attemptExactMatch = true;
      retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {
        deviceId: {
          ideal: deviceId
        }
      });
    }
    if (internalOptions.audio === true || typeof internalOptions.audio === "object" && !internalOptions.audio.deviceId) {
      internalOptions.audio = {
        deviceId: "default"
      };
    }
    if (internalOptions.video === true) {
      internalOptions.video = {
        deviceId: "default"
      };
    } else if (typeof internalOptions.video === "object" && !internalOptions.video.deviceId) {
      internalOptions.video.deviceId = "default";
    }
    const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);
    const constraints = constraintsForOptions(opts);
    const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
    if (internalOptions.audio) {
      DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);
      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"));
    }
    if (internalOptions.video) {
      DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);
      mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput"));
    }
    try {
      const stream = yield mediaPromise;
      return yield Promise.all(stream.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
        const isAudio = mediaStreamTrack.kind === "audio";
        let trackOptions = isAudio ? opts.audio : opts.video;
        if (typeof trackOptions === "boolean" || !trackOptions) {
          trackOptions = {};
        }
        let trackConstraints;
        const conOrBool = isAudio ? constraints.audio : constraints.video;
        if (typeof conOrBool !== "boolean") {
          trackConstraints = conOrBool;
        }
        const newDeviceId = mediaStreamTrack.getSettings().deviceId;
        if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {
          trackConstraints.deviceId = newDeviceId;
        } else if (!trackConstraints) {
          trackConstraints = {
            deviceId: newDeviceId
          };
        }
        const track2 = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);
        if (track2.kind === Track.Kind.Video) {
          track2.source = Track.Source.Camera;
        } else if (track2.kind === Track.Kind.Audio) {
          track2.source = Track.Source.Microphone;
        }
        track2.mediaStream = stream;
        if (isAudioTrack(track2) && audioProcessor) {
          yield track2.setProcessor(audioProcessor);
        } else if (isVideoTrack(track2) && videoProcessor) {
          yield track2.setProcessor(videoProcessor);
        }
        return track2;
      })));
    } catch (e4) {
      if (!attemptExactMatch) {
        throw e4;
      }
      return createLocalTracks(Object.assign(Object.assign({}, options), {
        audio: retryAudioOptions,
        video: retryVideoOptions
      }), loggerOptions);
    }
  });
}
function createLocalVideoTrack(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const tracks = yield createLocalTracks({
      audio: false,
      video: options !== null && options !== void 0 ? options : true
    });
    return tracks[0];
  });
}
function createLocalAudioTrack(options) {
  return __awaiter(this, void 0, void 0, function* () {
    const tracks = yield createLocalTracks({
      audio: options !== null && options !== void 0 ? options : true,
      video: false
    });
    return tracks[0];
  });
}
var ConnectionQuality;
(function(ConnectionQuality2) {
  ConnectionQuality2["Excellent"] = "excellent";
  ConnectionQuality2["Good"] = "good";
  ConnectionQuality2["Poor"] = "poor";
  ConnectionQuality2["Lost"] = "lost";
  ConnectionQuality2["Unknown"] = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(q3) {
  switch (q3) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
var Participant = class extends eventsExports.EventEmitter {
  get logContext() {
    var _a3, _b;
    return Object.assign({}, (_b = (_a3 = this.loggerOptions) === null || _a3 === void 0 ? void 0 : _a3.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a3));
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr3) => tr3.isEncrypted);
  }
  get isAgent() {
    var _a3;
    return ((_a3 = this.permissions) === null || _a3 === void 0 ? void 0 : _a3.agent) || this.kind === ParticipantInfo_Kind.AGENT;
  }
  get isActive() {
    var _a3;
    return ((_a3 = this.participantInfo) === null || _a3 === void 0 ? void 0 : _a3.state) === ParticipantInfo_State.ACTIVE;
  }
  get kind() {
    return this._kind;
  }
  /** participant attributes, similar to metadata, but as a key/value map */
  get attributes() {
    return Object.freeze(Object.assign({}, this._attributes));
  }
  /** @internal */
  constructor(sid, identity, name, metadata, attributes, loggerOptions) {
    let kind = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ParticipantInfo_Kind.STANDARD;
    var _a3;
    super();
    this.audioLevel = 0;
    this.isSpeaking = false;
    this._connectionQuality = ConnectionQuality.Unknown;
    this.log = livekitLogger;
    this.log = getLogger((_a3 = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Participant);
    this.loggerOptions = loggerOptions;
    this.setMaxListeners(100);
    this.sid = sid;
    this.identity = identity;
    this.name = name;
    this.metadata = metadata;
    this.audioTrackPublications = /* @__PURE__ */ new Map();
    this.videoTrackPublications = /* @__PURE__ */ new Map();
    this.trackPublications = /* @__PURE__ */ new Map();
    this._kind = kind;
    this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(source) {
    for (const [, pub] of this.trackPublications) {
      if (pub.source === source) {
        return pub;
      }
    }
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(name) {
    for (const [, pub] of this.trackPublications) {
      if (pub.trackName === name) {
        return pub;
      }
    }
  }
  /**
   * Waits until the participant is active and ready to receive data messages
   * @returns a promise that resolves when the participant is active
   */
  waitUntilActive() {
    if (this.isActive) {
      return Promise.resolve();
    }
    if (this.activeFuture) {
      return this.activeFuture.promise;
    }
    this.activeFuture = new Future();
    this.once(ParticipantEvent.Active, () => {
      var _a3, _b;
      (_b = (_a3 = this.activeFuture) === null || _a3 === void 0 ? void 0 : _a3.resolve) === null || _b === void 0 ? void 0 : _b.call(_a3);
      this.activeFuture = void 0;
    });
    return this.activeFuture.promise;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var _a3;
    const track2 = this.getTrackPublication(Track.Source.Camera);
    return !((_a3 = track2 === null || track2 === void 0 ? void 0 : track2.isMuted) !== null && _a3 !== void 0 ? _a3 : true);
  }
  get isMicrophoneEnabled() {
    var _a3;
    const track2 = this.getTrackPublication(Track.Source.Microphone);
    return !((_a3 = track2 === null || track2 === void 0 ? void 0 : track2.isMuted) !== null && _a3 !== void 0 ? _a3 : true);
  }
  get isScreenShareEnabled() {
    const track2 = this.getTrackPublication(Track.Source.ScreenShare);
    return !!track2;
  }
  get isLocal() {
    return false;
  }
  /** when participant joined the room */
  get joinedAt() {
    if (this.participantInfo) {
      return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3);
    }
    return /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(info) {
    var _a3;
    if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {
      return false;
    }
    this.identity = info.identity;
    this.sid = info.sid;
    this._setName(info.name);
    this._setMetadata(info.metadata);
    this._setAttributes(info.attributes);
    if (info.state === ParticipantInfo_State.ACTIVE && ((_a3 = this.participantInfo) === null || _a3 === void 0 ? void 0 : _a3.state) !== ParticipantInfo_State.ACTIVE) {
      this.emit(ParticipantEvent.Active);
    }
    if (info.permission) {
      this.setPermissions(info.permission);
    }
    this.participantInfo = info;
    return true;
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(md) {
    const changed = this.metadata !== md;
    const prevMetadata = this.metadata;
    this.metadata = md;
    if (changed) {
      this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
    }
  }
  _setName(name) {
    const changed = this.name !== name;
    this.name = name;
    if (changed) {
      this.emit(ParticipantEvent.ParticipantNameChanged, name);
    }
  }
  /**
   * Updates metadata from server
   **/
  _setAttributes(attributes) {
    const diff = diffAttributes(this.attributes, attributes);
    this._attributes = attributes;
    if (Object.keys(diff).length > 0) {
      this.emit(ParticipantEvent.AttributesChanged, diff);
    }
  }
  /** @internal */
  setPermissions(permissions) {
    var _a3, _b, _c3, _d, _e3, _f;
    const prevPermissions = this.permissions;
    const changed = permissions.canPublish !== ((_a3 = this.permissions) === null || _a3 === void 0 ? void 0 : _a3.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c3 = this.permissions) === null || _c3 === void 0 ? void 0 : _c3.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e3 = this.permissions) === null || _e3 === void 0 ? void 0 : _e3.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {
      var _a4;
      return value !== ((_a4 = this.permissions) === null || _a4 === void 0 ? void 0 : _a4.canPublishSources[index]);
    }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
    this.permissions = permissions;
    if (changed) {
      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
    }
    return changed;
  }
  /** @internal */
  setIsSpeaking(speaking) {
    if (speaking === this.isSpeaking) {
      return;
    }
    this.isSpeaking = speaking;
    if (speaking) {
      this.lastSpokeAt = /* @__PURE__ */ new Date();
    }
    this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
  }
  /** @internal */
  setConnectionQuality(q3) {
    const prevQuality = this._connectionQuality;
    this._connectionQuality = qualityFromProto(q3);
    if (prevQuality !== this._connectionQuality) {
      this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
    }
  }
  /**
   * @internal
   */
  setDisconnected() {
    var _a3, _b;
    if (this.activeFuture) {
      (_b = (_a3 = this.activeFuture).reject) === null || _b === void 0 ? void 0 : _b.call(_a3, new Error("Participant disconnected"));
      this.activeFuture = void 0;
    }
  }
  /**
   * @internal
   */
  setAudioContext(ctx) {
    this.audioContext = ctx;
    this.audioTrackPublications.forEach((track2) => isAudioTrack(track2.track) && track2.track.setAudioContext(ctx));
  }
  addTrackPublication(publication) {
    publication.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, publication);
    });
    publication.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, publication);
    });
    const pub = publication;
    if (pub.track) {
      pub.track.sid = publication.trackSid;
    }
    this.trackPublications.set(publication.trackSid, publication);
    switch (publication.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(publication.trackSid, publication);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(publication.trackSid, publication);
        break;
    }
  }
};
function trackPermissionToProto(perms) {
  var _a3, _b, _c3;
  if (!perms.participantSid && !perms.participantIdentity) {
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  }
  return new TrackPermission({
    participantIdentity: (_a3 = perms.participantIdentity) !== null && _a3 !== void 0 ? _a3 : "",
    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
    allTracks: (_c3 = perms.allowAll) !== null && _c3 !== void 0 ? _c3 : false,
    trackSids: perms.allowedTrackSids || []
  });
}
var STREAM_CHUNK_SIZE = 15e3;
var LocalParticipant = class extends Participant {
  /** @internal */
  constructor(sid, identity, engine, options, roomRpcHandlers) {
    super(sid, identity, void 0, void 0, void 0, {
      loggerName: options.loggerName,
      loggerContextCb: () => this.engine.logContext
    });
    this.pendingPublishing = /* @__PURE__ */ new Set();
    this.pendingPublishPromises = /* @__PURE__ */ new Map();
    this.participantTrackPermissions = [];
    this.allParticipantsAllowedToSubscribe = true;
    this.encryptionType = Encryption_Type.NONE;
    this.enabledPublishVideoCodecs = [];
    this.pendingAcks = /* @__PURE__ */ new Map();
    this.pendingResponses = /* @__PURE__ */ new Map();
    this.handleReconnecting = () => {
      if (!this.reconnectFuture) {
        this.reconnectFuture = new Future();
      }
    };
    this.handleReconnected = () => {
      var _a3, _b;
      (_b = (_a3 = this.reconnectFuture) === null || _a3 === void 0 ? void 0 : _a3.resolve) === null || _b === void 0 ? void 0 : _b.call(_a3);
      this.reconnectFuture = void 0;
      this.updateTrackSubscriptionPermissions();
    };
    this.handleDisconnected = () => {
      var _a3, _b, _c3, _d, _e3, _f;
      if (this.reconnectFuture) {
        this.reconnectFuture.promise.catch((e4) => this.log.warn(e4.message, this.logContext));
        (_b = (_a3 = this.reconnectFuture) === null || _a3 === void 0 ? void 0 : _a3.reject) === null || _b === void 0 ? void 0 : _b.call(_a3, "Got disconnected during reconnection attempt");
        this.reconnectFuture = void 0;
      }
      if (this.signalConnectedFuture) {
        (_d = (_c3 = this.signalConnectedFuture).reject) === null || _d === void 0 ? void 0 : _d.call(_c3, "Got disconnected without signal connected");
        this.signalConnectedFuture = void 0;
      }
      (_f = (_e3 = this.activeAgentFuture) === null || _e3 === void 0 ? void 0 : _e3.reject) === null || _f === void 0 ? void 0 : _f.call(_e3, "Got disconnected without active agent present");
      this.activeAgentFuture = void 0;
      this.firstActiveAgent = void 0;
    };
    this.handleSignalConnected = (joinResponse) => {
      var _a3, _b;
      if (joinResponse.participant) {
        this.updateInfo(joinResponse.participant);
      }
      if (!this.signalConnectedFuture) {
        this.signalConnectedFuture = new Future();
      }
      (_b = (_a3 = this.signalConnectedFuture).resolve) === null || _b === void 0 ? void 0 : _b.call(_a3);
    };
    this.handleSignalRequestResponse = (response) => {
      const {
        requestId,
        reason,
        message
      } = response;
      const targetRequest = this.pendingSignalRequests.get(requestId);
      if (targetRequest) {
        if (reason !== RequestResponse_Reason.OK) {
          targetRequest.reject(new SignalRequestError(message, reason));
        }
        this.pendingSignalRequests.delete(requestId);
      }
    };
    this.handleDataPacket = (packet) => {
      switch (packet.value.case) {
        case "rpcResponse":
          let rpcResponse = packet.value.value;
          let payload = null;
          let error = null;
          if (rpcResponse.value.case === "payload") {
            payload = rpcResponse.value.value;
          } else if (rpcResponse.value.case === "error") {
            error = RpcError.fromProto(rpcResponse.value.value);
          }
          this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
          break;
        case "rpcAck":
          let rpcAck = packet.value.value;
          this.handleIncomingRpcAck(rpcAck.requestId);
          break;
      }
    };
    this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      }));
      this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p3) => trackPermissionToProto(p3)));
    };
    this.onTrackUnmuted = (track2) => {
      this.onTrackMuted(track2, track2.isUpstreamPaused);
    };
    this.onTrackMuted = (track2, muted) => {
      if (muted === void 0) {
        muted = true;
      }
      if (!track2.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
        return;
      }
      this.engine.updateMuteStatus(track2.sid, muted);
    };
    this.onTrackUpstreamPaused = (track2) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
      this.onTrackMuted(track2, true);
    };
    this.onTrackUpstreamResumed = (track2) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
      this.onTrackMuted(track2, track2.isMuted);
    };
    this.onTrackFeatureUpdate = (track2) => {
      const pub = this.audioTrackPublications.get(track2.sid);
      if (!pub) {
        this.log.warn("Could not update local audio track settings, missing publication for track ".concat(track2.sid), this.logContext);
        return;
      }
      this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
    };
    this.onTrackCpuConstrained = (track2, publication) => {
      this.log.debug("track cpu constrained", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
      this.emit(ParticipantEvent.LocalTrackCpuConstrained, track2, publication);
    };
    this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {
      var _a3, e_1, _b, _c3;
      var _d;
      if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {
        return;
      }
      const pub = this.videoTrackPublications.get(update.trackSid);
      if (!pub) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: update.trackSid
        }));
        return;
      }
      if (!pub.videoTrack) {
        return;
      }
      const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
      try {
        for (var _e3 = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a3 = newCodecs_1_1.done, !_a3; _e3 = true) {
          _c3 = newCodecs_1_1.value;
          _e3 = false;
          const codec = _c3;
          if (isBackupCodec(codec)) {
            this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));
            yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (!_e3 && !_a3 && (_b = newCodecs_1.return))
            yield _b.call(newCodecs_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
    this.handleLocalTrackUnpublished = (unpublished) => {
      const track2 = this.trackPublications.get(unpublished.trackSid);
      if (!track2) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: unpublished.trackSid
        }));
        return;
      }
      this.unpublishTrack(track2.track);
    };
    this.handleTrackEnded = (track2) => __awaiter(this, void 0, void 0, function* () {
      if (track2.source === Track.Source.ScreenShare || track2.source === Track.Source.ScreenShareAudio) {
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
        this.unpublishTrack(track2);
      } else if (track2.isUserProvided) {
        yield track2.mute();
      } else if (isLocalAudioTrack(track2) || isLocalVideoTrack(track2)) {
        try {
          if (isWeb()) {
            try {
              const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: track2.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (currentPermissions && currentPermissions.state === "denied") {
                this.log.warn("user has revoked access to ".concat(track2.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
                currentPermissions.onchange = () => {
                  if (currentPermissions.state !== "denied") {
                    if (!track2.isMuted) {
                      track2.restartTrack();
                    }
                    currentPermissions.onchange = null;
                  }
                };
                throw new Error("GetUserMedia Permission denied");
              }
            } catch (e4) {
            }
          }
          if (!track2.isMuted) {
            this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
            if (isLocalAudioTrack(track2)) {
              yield track2.restartTrack({
                deviceId: "default"
              });
            } else {
              yield track2.restartTrack();
            }
          }
        } catch (e4) {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
          yield track2.mute();
        }
      }
    });
    this.audioTrackPublications = /* @__PURE__ */ new Map();
    this.videoTrackPublications = /* @__PURE__ */ new Map();
    this.trackPublications = /* @__PURE__ */ new Map();
    this.engine = engine;
    this.roomOptions = options;
    this.setupEngine(engine);
    this.activeDeviceMap = /* @__PURE__ */ new Map([["audioinput", "default"], ["videoinput", "default"], ["audiooutput", "default"]]);
    this.pendingSignalRequests = /* @__PURE__ */ new Map();
    this.rpcHandlers = roomRpcHandlers;
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(source) {
    const track2 = super.getTrackPublication(source);
    if (track2) {
      return track2;
    }
  }
  getTrackPublicationByName(name) {
    const track2 = super.getTrackPublicationByName(name);
    if (track2) {
      return track2;
    }
  }
  /**
   * @internal
   */
  setupEngine(engine) {
    this.engine = engine;
    this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {
      const pub = this.trackPublications.get(trackSid);
      if (!pub || !pub.track) {
        return;
      }
      if (muted) {
        pub.mute();
      } else {
        pub.unmute();
      }
    });
    this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalConnected, this.handleSignalConnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * method will throw if the user doesn't have the required permissions
   * @param metadata
   */
  setMetadata(metadata) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        metadata
      });
    });
  }
  /**
   * Sets and updates the name of the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * method will throw if the user doesn't have the required permissions
   * @param metadata
   */
  setName(name) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        name
      });
    });
  }
  /**
   * Set or update participant attributes. It will make updates only to keys that
   * are present in `attributes`, and will not override others.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param attributes attributes to update
   */
  setAttributes(attributes) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({
        attributes
      });
    });
  }
  requestMetadataUpdate(_a3) {
    return __awaiter(this, arguments, void 0, function(_ref) {
      var _this = this;
      let {
        metadata,
        name,
        attributes
      } = _ref;
      return function* () {
        return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
          var _a4, _b;
          try {
            let isRejected = false;
            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a4 = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a4 !== void 0 ? _a4 : "", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : "", attributes);
            const startTime = performance.now();
            this.pendingSignalRequests.set(requestId, {
              resolve,
              reject: (error) => {
                reject(error);
                isRejected = true;
              },
              values: {
                name,
                metadata,
                attributes
              }
            });
            while (performance.now() - startTime < 5e3 && !isRejected) {
              if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2) => {
                let [key, value] = _ref2;
                return this.attributes[key] === value || value === "" && !this.attributes[key];
              }))) {
                this.pendingSignalRequests.delete(requestId);
                resolve();
                return;
              }
              yield sleep(50);
            }
            reject(new SignalRequestError("Request to update local metadata timed out", "TimeoutError"));
          } catch (e4) {
            if (e4 instanceof Error)
              reject(e4);
          }
        }));
      }();
    });
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(enabled, options, publishOptions) {
    return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
  }
  /** @internal */
  setPermissions(permissions) {
    const prevPermissions = this.permissions;
    const changed = super.setPermissions(permissions);
    if (changed && prevPermissions) {
      this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
    }
    return changed;
  }
  /** @internal */
  setE2EEEnabled(enabled) {
    return __awaiter(this, void 0, void 0, function* () {
      this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
      yield this.republishAllTracks(void 0, false);
    });
  }
  setTrackEnabled(source, enabled, options, publishOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source,
        enabled
      }));
      if (this.republishPromise) {
        yield this.republishPromise;
      }
      let track2 = this.getTrackPublication(source);
      if (enabled) {
        if (track2) {
          yield track2.unmute();
        } else {
          let localTracks;
          if (this.pendingPublishing.has(source)) {
            const pendingTrack = yield this.waitForPendingPublicationOfSource(source);
            if (!pendingTrack) {
              this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                source
              }));
            }
            yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();
            return pendingTrack;
          }
          this.pendingPublishing.add(source);
          try {
            switch (source) {
              case Track.Source.Camera:
                localTracks = yield this.createTracks({
                  video: (_a3 = options) !== null && _a3 !== void 0 ? _a3 : true
                });
                break;
              case Track.Source.Microphone:
                localTracks = yield this.createTracks({
                  audio: (_b = options) !== null && _b !== void 0 ? _b : true
                });
                break;
              case Track.Source.ScreenShare:
                localTracks = yield this.createScreenTracks(Object.assign({}, options));
                break;
              default:
                throw new TrackInvalidError(source);
            }
          } catch (e4) {
            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr3) => {
              tr3.stop();
            });
            if (e4 instanceof Error) {
              this.emit(ParticipantEvent.MediaDevicesError, e4, sourceToKind(source));
            }
            this.pendingPublishing.delete(source);
            throw e4;
          }
          for (const localTrack of localTracks) {
            if (source === Track.Source.Microphone && isAudioTrack(localTrack) && (publishOptions === null || publishOptions === void 0 ? void 0 : publishOptions.preConnectBuffer)) {
              this.log.info("starting preconnect buffer for microphone", Object.assign({}, this.logContext));
              localTrack.startPreConnectBuffer();
            }
          }
          try {
            const publishPromises = [];
            for (const localTrack of localTracks) {
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));
              publishPromises.push(this.publishTrack(localTrack, publishOptions));
            }
            const publishedTracks = yield Promise.all(publishPromises);
            [track2] = publishedTracks;
          } catch (e4) {
            localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr3) => {
              tr3.stop();
            });
            throw e4;
          } finally {
            this.pendingPublishing.delete(source);
          }
        }
      } else {
        if (!(track2 === null || track2 === void 0 ? void 0 : track2.track) && this.pendingPublishing.has(source)) {
          track2 = yield this.waitForPendingPublicationOfSource(source);
          if (!track2) {
            this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
              source
            }));
          }
        }
        if (track2 && track2.track) {
          if (source === Track.Source.ScreenShare) {
            track2 = yield this.unpublishTrack(track2.track);
            const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
            if (screenAudioTrack && screenAudioTrack.track) {
              this.unpublishTrack(screenAudioTrack.track);
            }
          } else {
            yield track2.mute();
          }
        }
      }
      return track2;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {
        return;
      }
      this.pendingPublishing.add(Track.Source.Camera);
      this.pendingPublishing.add(Track.Source.Microphone);
      try {
        const tracks = yield this.createTracks({
          audio: true,
          video: true
        });
        yield Promise.all(tracks.map((track2) => this.publishTrack(track2)));
      } finally {
        this.pendingPublishing.delete(Track.Source.Camera);
        this.pendingPublishing.delete(Track.Source.Microphone);
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      options !== null && options !== void 0 ? options : options = {};
      const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a3 = this.roomOptions) === null || _a3 === void 0 ? void 0 : _a3.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
      try {
        const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        const localTracks = tracks.map((track2) => {
          if (isAudioTrack(track2)) {
            this.microphoneError = void 0;
            track2.setAudioContext(this.audioContext);
            track2.source = Track.Source.Microphone;
            this.emit(ParticipantEvent.AudioStreamAcquired);
          }
          if (isVideoTrack(track2)) {
            this.cameraError = void 0;
            track2.source = Track.Source.Camera;
          }
          return track2;
        });
        return localTracks;
      } catch (err) {
        if (err instanceof Error) {
          if (options.audio) {
            this.microphoneError = err;
          }
          if (options.video) {
            this.cameraError = err;
          }
        }
        throw err;
      }
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      if (options === void 0) {
        options = {};
      }
      if (navigator.mediaDevices.getDisplayMedia === void 0) {
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      }
      if (options.resolution === void 0 && !isSafari17Based()) {
        options.resolution = ScreenSharePresets.h1080fps30.resolution;
      }
      const constraints = screenCaptureToDisplayMediaStreamOptions(options);
      const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);
      const tracks = stream.getVideoTracks();
      if (tracks.length === 0) {
        throw new TrackInvalidError("no video track found");
      }
      const screenVideo = new LocalVideoTrack(tracks[0], void 0, false, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      screenVideo.source = Track.Source.ScreenShare;
      if (options.contentHint) {
        screenVideo.mediaStreamTrack.contentHint = options.contentHint;
      }
      const localTracks = [screenVideo];
      if (stream.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        screenAudio.source = Track.Source.ScreenShareAudio;
        localTracks.push(screenAudio);
      }
      return localTracks;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(track2, options) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.publishOrRepublishTrack(track2, options);
    });
  }
  publishOrRepublishTrack(track_1, options_1) {
    return __awaiter(this, arguments, void 0, function(track2, options) {
      var _this2 = this;
      let isRepublish = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return function* () {
        var _a3, _b, _c3, _d;
        if (isLocalAudioTrack(track2)) {
          track2.setAudioContext(_this2.audioContext);
        }
        yield (_a3 = _this2.reconnectFuture) === null || _a3 === void 0 ? void 0 : _a3.promise;
        if (_this2.republishPromise && !isRepublish) {
          yield _this2.republishPromise;
        }
        if (isLocalTrack(track2) && _this2.pendingPublishPromises.has(track2)) {
          yield _this2.pendingPublishPromises.get(track2);
        }
        let defaultConstraints;
        if (track2 instanceof MediaStreamTrack) {
          defaultConstraints = track2.getConstraints();
        } else {
          defaultConstraints = track2.constraints;
          let deviceKind = void 0;
          switch (track2.source) {
            case Track.Source.Microphone:
              deviceKind = "audioinput";
              break;
            case Track.Source.Camera:
              deviceKind = "videoinput";
          }
          if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {
            defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
              deviceId: _this2.activeDeviceMap.get(deviceKind)
            });
          }
        }
        if (track2 instanceof MediaStreamTrack) {
          switch (track2.kind) {
            case "audio":
              track2 = new LocalAudioTrack(track2, defaultConstraints, true, _this2.audioContext, {
                loggerName: _this2.roomOptions.loggerName,
                loggerContextCb: () => _this2.logContext
              });
              break;
            case "video":
              track2 = new LocalVideoTrack(track2, defaultConstraints, true, {
                loggerName: _this2.roomOptions.loggerName,
                loggerContextCb: () => _this2.logContext
              });
              break;
            default:
              throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track2.kind));
          }
        } else {
          track2.updateLoggerOptions({
            loggerName: _this2.roomOptions.loggerName,
            loggerContextCb: () => _this2.logContext
          });
        }
        let existingPublication;
        _this2.trackPublications.forEach((publication) => {
          if (!publication.track) {
            return;
          }
          if (publication.track === track2) {
            existingPublication = publication;
          }
        });
        if (existingPublication) {
          _this2.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));
          return existingPublication;
        }
        const isStereoInput = "channelCount" in track2.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
        track2.mediaStreamTrack.getSettings().channelCount === 2 || track2.mediaStreamTrack.getConstraints().channelCount === 2;
        const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
        if (isStereo) {
          if (!options) {
            options = {};
          }
          if (options.dtx === void 0) {
            _this2.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track2)));
          }
          if (options.red === void 0) {
            _this2.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
          }
          (_c3 = options.dtx) !== null && _c3 !== void 0 ? _c3 : options.dtx = false;
          (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;
        }
        const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);
        if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {
          _this2.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, _this2.logContext));
          opts.simulcast = false;
        }
        if (opts.source) {
          track2.source = opts.source;
        }
        const publishPromise = new Promise((resolve, reject) => __awaiter(_this2, void 0, void 0, function* () {
          try {
            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {
              this.log.debug("deferring track publication until signal is connected", Object.assign(Object.assign({}, this.logContext), {
                track: getLogContextFromTrack(track2)
              }));
              const timeout = setTimeout(() => {
                reject(new PublishTrackError("publishing rejected as engine not connected within timeout", 408));
              }, 15e3);
              yield this.waitUntilEngineConnected();
              clearTimeout(timeout);
              const publication = yield this.publish(track2, opts, isStereo);
              resolve(publication);
            } else {
              try {
                const publication = yield this.publish(track2, opts, isStereo);
                resolve(publication);
              } catch (e4) {
                reject(e4);
              }
            }
          } catch (e4) {
            reject(e4);
          }
        }));
        _this2.pendingPublishPromises.set(track2, publishPromise);
        try {
          const publication = yield publishPromise;
          return publication;
        } catch (e4) {
          throw e4;
        } finally {
          _this2.pendingPublishPromises.delete(track2);
        }
      }();
    });
  }
  waitUntilEngineConnected() {
    if (!this.signalConnectedFuture) {
      this.signalConnectedFuture = new Future();
    }
    return this.signalConnectedFuture.promise;
  }
  hasPermissionsToPublish(track2) {
    if (!this.permissions) {
      this.log.warn("no permissions present for publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
      return false;
    }
    const {
      canPublish,
      canPublishSources
    } = this.permissions;
    if (canPublish && (canPublishSources.length === 0 || canPublishSources.map((source) => getTrackSourceFromProto(source)).includes(track2.source))) {
      return true;
    }
    this.log.warn("insufficient permissions to publish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
    return false;
  }
  publish(track2, opts, isStereo) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3, _d, _e3, _f, _g, _h, _j, _k;
      if (!this.hasPermissionsToPublish(track2)) {
        throw new PublishTrackError("failed to publish track, insufficient permissions", 403);
      }
      const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => isLocalTrack(track2) && publishedTrack.source === track2.source);
      if (existingTrackOfSource && track2.source !== Track.Source.Unknown) {
        this.log.info("publishing a second track with the same source: ".concat(track2.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
      }
      if (opts.stopMicTrackOnMute && isAudioTrack(track2)) {
        track2.stopOnMute = true;
      }
      if (track2.source === Track.Source.ScreenShare && isFireFox()) {
        opts.simulcast = false;
      }
      if (opts.videoCodec === "av1" && !supportsAV1()) {
        opts.videoCodec = void 0;
      }
      if (opts.videoCodec === "vp9" && !supportsVP9()) {
        opts.videoCodec = void 0;
      }
      if (opts.videoCodec === void 0) {
        opts.videoCodec = defaultVideoCodec;
      }
      if (this.enabledPublishVideoCodecs.length > 0) {
        if (!this.enabledPublishVideoCodecs.some((c3) => opts.videoCodec === mimeTypeToVideoCodecString(c3.mime))) {
          opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
        }
      }
      const videoCodec = opts.videoCodec;
      track2.on(TrackEvent.Muted, this.onTrackMuted);
      track2.on(TrackEvent.Unmuted, this.onTrackUnmuted);
      track2.on(TrackEvent.Ended, this.handleTrackEnded);
      track2.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
      track2.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      track2.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
      const audioFeatures = [];
      const disableDtx = !((_a3 = opts.dtx) !== null && _a3 !== void 0 ? _a3 : true);
      const settings = track2.getSourceTrackSettings();
      if (settings.autoGainControl) {
        audioFeatures.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
      }
      if (settings.echoCancellation) {
        audioFeatures.push(AudioTrackFeature.TF_ECHO_CANCELLATION);
      }
      if (settings.noiseSuppression) {
        audioFeatures.push(AudioTrackFeature.TF_NOISE_SUPPRESSION);
      }
      if (settings.channelCount && settings.channelCount > 1) {
        audioFeatures.push(AudioTrackFeature.TF_STEREO);
      }
      if (disableDtx) {
        audioFeatures.push(AudioTrackFeature.TF_NO_DTX);
      }
      if (isLocalAudioTrack(track2) && track2.hasPreConnectBuffer) {
        audioFeatures.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);
      }
      const req = new AddTrackRequest({
        // get local track id for use during publishing
        cid: track2.mediaStreamTrack.id,
        name: opts.name,
        type: Track.kindToProto(track2.kind),
        muted: track2.isMuted,
        source: Track.sourceToProto(track2.source),
        disableDtx,
        encryption: this.encryptionType,
        stereo: isStereo,
        disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
        stream: opts === null || opts === void 0 ? void 0 : opts.stream,
        backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy,
        audioFeatures
      });
      let encodings;
      if (track2.kind === Track.Kind.Video) {
        let dims = {
          width: 0,
          height: 0
        };
        try {
          dims = yield track2.waitForDimensions();
        } catch (e4) {
          const defaultRes = (_d = (_c3 = this.roomOptions.videoCaptureDefaults) === null || _c3 === void 0 ? void 0 : _c3.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;
          dims = {
            width: defaultRes.width,
            height: defaultRes.height
          };
          this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)), {
            dims
          }));
        }
        req.width = dims.width;
        req.height = dims.height;
        if (isLocalVideoTrack(track2)) {
          if (isSVCCodec(videoCodec)) {
            if (track2.source === Track.Source.ScreenShare) {
              opts.scalabilityMode = "L1T3";
              if ("contentHint" in track2.mediaStreamTrack) {
                track2.mediaStreamTrack.contentHint = "motion";
                this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
              }
            }
            opts.scalabilityMode = (_e3 = opts.scalabilityMode) !== null && _e3 !== void 0 ? _e3 : "L3T3_KEY";
          }
          req.simulcastCodecs = [new SimulcastCodec({
            codec: videoCodec,
            cid: track2.mediaStreamTrack.id
          })];
          if (opts.backupCodec === true) {
            opts.backupCodec = {
              codec: defaultVideoCodec
            };
          }
          if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
          req.encryption === Encryption_Type.NONE) {
            if (!this.roomOptions.dynacast) {
              this.roomOptions.dynacast = true;
            }
            req.simulcastCodecs.push(new SimulcastCodec({
              codec: opts.backupCodec.codec,
              cid: ""
            }));
          }
        }
        encodings = computeVideoEncodings(track2.source === Track.Source.ScreenShare, req.width, req.height, opts);
        req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));
      } else if (track2.kind === Track.Kind.Audio) {
        encodings = [{
          maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
          priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : "high",
          networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : "high"
        }];
      }
      if (!this.engine || this.engine.isClosed) {
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      }
      const negotiate = () => __awaiter(this, void 0, void 0, function* () {
        var _a4, _b2, _c4;
        if (!this.engine.pcManager) {
          throw new UnexpectedConnectionState("pcManager is not ready");
        }
        track2.sender = yield this.engine.createSender(track2, opts, encodings);
        this.emit(ParticipantEvent.LocalSenderCreated, track2.sender, track2);
        if (isLocalVideoTrack(track2)) {
          (_a4 = opts.degradationPreference) !== null && _a4 !== void 0 ? _a4 : opts.degradationPreference = getDefaultDegradationPreference(track2);
          track2.setDegradationPreference(opts.degradationPreference);
        }
        if (encodings) {
          if (isFireFox() && track2.kind === Track.Kind.Audio) {
            let trackTransceiver = void 0;
            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
              if (transceiver.sender === track2.sender) {
                trackTransceiver = transceiver;
                break;
              }
            }
            if (trackTransceiver) {
              this.engine.pcManager.publisher.setTrackCodecBitrate({
                transceiver: trackTransceiver,
                codec: "opus",
                maxbr: ((_b2 = encodings[0]) === null || _b2 === void 0 ? void 0 : _b2.maxBitrate) ? encodings[0].maxBitrate / 1e3 : 0
              });
            }
          } else if (track2.codec && isSVCCodec(track2.codec) && ((_c4 = encodings[0]) === null || _c4 === void 0 ? void 0 : _c4.maxBitrate)) {
            this.engine.pcManager.publisher.setTrackCodecBitrate({
              cid: req.cid,
              codec: track2.codec,
              maxbr: encodings[0].maxBitrate / 1e3
            });
          }
        }
        yield this.engine.negotiate();
      });
      let ti3;
      const addTrackPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        var _a4;
        try {
          ti3 = yield this.engine.addTrack(req);
          resolve(ti3);
        } catch (err) {
          if (track2.sender && ((_a4 = this.engine.pcManager) === null || _a4 === void 0 ? void 0 : _a4.publisher)) {
            this.engine.pcManager.publisher.removeTrack(track2.sender);
            yield this.engine.negotiate().catch((negotiateErr) => {
              this.log.error("failed to negotiate after removing track due to failed add track request", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)), {
                error: negotiateErr
              }));
            });
          }
          reject(err);
        }
      }));
      if (this.enabledPublishVideoCodecs.length > 0) {
        const rets = yield Promise.all([addTrackPromise, negotiate()]);
        ti3 = rets[0];
      } else {
        ti3 = yield addTrackPromise;
        let primaryCodecMime;
        ti3.codecs.forEach((codec) => {
          if (primaryCodecMime === void 0) {
            primaryCodecMime = codec.mimeType;
          }
        });
        if (primaryCodecMime && track2.kind === Track.Kind.Video) {
          const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
          if (updatedCodec !== videoCodec) {
            this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)), {
              codec: updatedCodec
            }));
            opts.videoCodec = updatedCodec;
            encodings = computeVideoEncodings(track2.source === Track.Source.ScreenShare, req.width, req.height, opts);
          }
        }
        yield negotiate();
      }
      const publication = new LocalTrackPublication(track2.kind, ti3, track2, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      publication.on(TrackEvent.CpuConstrained, (constrainedTrack) => this.onTrackCpuConstrained(constrainedTrack, publication));
      publication.options = opts;
      track2.sid = ti3.sid;
      this.log.debug("publishing ".concat(track2.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings,
        trackInfo: ti3
      }));
      if (isLocalVideoTrack(track2)) {
        track2.startMonitor(this.engine.client);
      } else if (isLocalAudioTrack(track2)) {
        track2.startMonitor();
      }
      this.addTrackPublication(publication);
      this.emit(ParticipantEvent.LocalTrackPublished, publication);
      if (isLocalAudioTrack(track2) && ti3.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER)) {
        const stream = track2.getPreConnectBuffer();
        this.on(ParticipantEvent.LocalTrackSubscribed, (pub) => {
          if (pub.trackSid === ti3.sid) {
            if (!track2.hasPreConnectBuffer) {
              this.log.warn("subscribe event came to late, buffer already closed", this.logContext);
              return;
            }
            this.log.debug("finished recording preconnect buffer", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
            track2.stopPreConnectBuffer();
          }
        });
        if (stream) {
          const bufferStreamPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a4, e_2, _b2, _c4;
            var _d2, _e4;
            try {
              this.log.debug("waiting for agent", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
              const agentActiveTimeout = setTimeout(() => {
                reject(new Error("agent not active within 10 seconds"));
              }, 1e4);
              const agent = yield this.waitUntilActiveAgentPresent();
              clearTimeout(agentActiveTimeout);
              this.log.debug("sending preconnect buffer", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
              const writer2 = yield this.streamBytes({
                name: "preconnect-buffer",
                mimeType: "audio/opus",
                topic: "lk.agent.pre-connect-audio-buffer",
                destinationIdentities: [agent.identity],
                attributes: {
                  trackId: publication.trackSid,
                  sampleRate: String((_d2 = settings.sampleRate) !== null && _d2 !== void 0 ? _d2 : "48000"),
                  channels: String((_e4 = settings.channelCount) !== null && _e4 !== void 0 ? _e4 : "1")
                }
              });
              try {
                for (var _f2 = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), _a4 = stream_1_1.done, !_a4; _f2 = true) {
                  _c4 = stream_1_1.value;
                  _f2 = false;
                  const chunk = _c4;
                  yield writer2.write(chunk);
                }
              } catch (e_2_1) {
                e_2 = {
                  error: e_2_1
                };
              } finally {
                try {
                  if (!_f2 && !_a4 && (_b2 = stream_1.return))
                    yield _b2.call(stream_1);
                } finally {
                  if (e_2)
                    throw e_2.error;
                }
              }
              yield writer2.close();
              resolve();
            } catch (e4) {
              reject(e4);
            }
          }));
          bufferStreamPromise.then(() => {
            this.log.debug("preconnect buffer sent successfully", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
          }).catch((e4) => {
            this.log.error("error sending preconnect buffer", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)), {
              error: e4
            }));
          });
        }
      }
      return publication;
    });
  }
  get isLocal() {
    return true;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(track2, videoCodec, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (this.encryptionType !== Encryption_Type.NONE) {
        return;
      }
      let existingPublication;
      this.trackPublications.forEach((publication) => {
        if (!publication.track) {
          return;
        }
        if (publication.track === track2) {
          existingPublication = publication;
        }
      });
      if (!existingPublication) {
        throw new TrackInvalidError("track is not published");
      }
      if (!isLocalVideoTrack(track2)) {
        throw new TrackInvalidError("track is not a video track");
      }
      const opts = Object.assign(Object.assign({}, (_a3 = this.roomOptions) === null || _a3 === void 0 ? void 0 : _a3.publishDefaults), options);
      const encodings = computeTrackBackupEncodings(track2, videoCodec, opts);
      if (!encodings) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
        return;
      }
      const simulcastTrack = track2.addSimulcastTrack(videoCodec, encodings);
      if (!simulcastTrack) {
        return;
      }
      const req = new AddTrackRequest({
        cid: simulcastTrack.mediaStreamTrack.id,
        type: Track.kindToProto(track2.kind),
        muted: track2.isMuted,
        source: Track.sourceToProto(track2.source),
        sid: track2.sid,
        simulcastCodecs: [{
          codec: opts.videoCodec,
          cid: simulcastTrack.mediaStreamTrack.id
        }]
      });
      req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
      if (!this.engine || this.engine.isClosed) {
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      }
      const negotiate = () => __awaiter(this, void 0, void 0, function* () {
        yield this.engine.createSimulcastSender(track2, simulcastTrack, opts, encodings);
        yield this.engine.negotiate();
      });
      const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
      const ti3 = rets[0];
      this.log.debug("published ".concat(videoCodec, " for track ").concat(track2.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings,
        trackInfo: ti3
      }));
    });
  }
  unpublishTrack(track2, stopOnUnpublish) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      if (isLocalTrack(track2)) {
        const publishPromise = this.pendingPublishPromises.get(track2);
        if (publishPromise) {
          this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track2)));
          yield publishPromise;
        }
      }
      const publication = this.getPublicationForTrack(track2);
      const pubLogContext = publication ? getLogContextFromTrack(publication) : void 0;
      this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));
      if (!publication || !publication.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));
        return void 0;
      }
      track2 = publication.track;
      track2.off(TrackEvent.Muted, this.onTrackMuted);
      track2.off(TrackEvent.Unmuted, this.onTrackUnmuted);
      track2.off(TrackEvent.Ended, this.handleTrackEnded);
      track2.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
      track2.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      track2.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
      if (stopOnUnpublish === void 0) {
        stopOnUnpublish = (_b = (_a3 = this.roomOptions) === null || _a3 === void 0 ? void 0 : _a3.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
      }
      if (stopOnUnpublish) {
        track2.stop();
      } else {
        track2.stopMonitor();
      }
      let negotiationNeeded = false;
      const trackSender = track2.sender;
      track2.sender = void 0;
      if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {
        try {
          for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
            if (transceiver.sender === trackSender) {
              transceiver.direction = "inactive";
              negotiationNeeded = true;
            }
          }
          if (this.engine.removeTrack(trackSender)) {
            negotiationNeeded = true;
          }
          if (isLocalVideoTrack(track2)) {
            for (const [, trackInfo] of track2.simulcastCodecs) {
              if (trackInfo.sender) {
                if (this.engine.removeTrack(trackInfo.sender)) {
                  negotiationNeeded = true;
                }
                trackInfo.sender = void 0;
              }
            }
            track2.simulcastCodecs.clear();
          }
        } catch (e4) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
            error: e4
          }));
        }
      }
      this.trackPublications.delete(publication.trackSid);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(publication.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(publication.trackSid);
          break;
      }
      this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
      publication.setTrack(void 0);
      if (negotiationNeeded) {
        yield this.engine.negotiate();
      }
      return publication;
    });
  }
  unpublishTracks(tracks) {
    return __awaiter(this, void 0, void 0, function* () {
      const results = yield Promise.all(tracks.map((track2) => this.unpublishTrack(track2)));
      return results.filter((track2) => !!track2);
    });
  }
  republishAllTracks(options_1) {
    return __awaiter(this, arguments, void 0, function(options) {
      var _this3 = this;
      let restartTracks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return function* () {
        if (_this3.republishPromise) {
          yield _this3.republishPromise;
        }
        _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {
          try {
            const localPubs = [];
            this.trackPublications.forEach((pub) => {
              if (pub.track) {
                if (options) {
                  pub.options = Object.assign(Object.assign({}, pub.options), options);
                }
                localPubs.push(pub);
              }
            });
            yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
              const track2 = pub.track;
              yield this.unpublishTrack(track2, false);
              if (restartTracks && !track2.isMuted && track2.source !== Track.Source.ScreenShare && track2.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track2) || isLocalVideoTrack(track2)) && !track2.isUserProvided) {
                this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                  track: pub.trackSid
                }));
                yield track2.restartTrack();
              }
              yield this.publishOrRepublishTrack(track2, pub.options, true);
            })));
            resolve();
          } catch (error) {
            reject(error);
          } finally {
            this.republishPromise = void 0;
          }
        }));
        yield _this3.republishPromise;
      }();
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(data_1) {
    return __awaiter(this, arguments, void 0, function(data) {
      var _this4 = this;
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return function* () {
        const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
        const destinationIdentities = options.destinationIdentities;
        const topic = options.topic;
        const packet = new DataPacket({
          kind,
          value: {
            case: "user",
            value: new UserPacket({
              participantIdentity: _this4.identity,
              payload: data,
              destinationIdentities,
              topic
            })
          }
        });
        yield _this4.engine.sendDataPacket(packet, kind);
      }();
    });
  }
  /**
   * Publish SIP DTMF message to the room.
   *
   * @param code DTMF code
   * @param digit DTMF digit
   */
  publishDtmf(code, digit) {
    return __awaiter(this, void 0, void 0, function* () {
      const packet = new DataPacket({
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "sipDtmf",
          value: new SipDTMF({
            code,
            digit
          })
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
    });
  }
  sendChatMessage(text, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const msg = {
        id: crypto.randomUUID(),
        message: text,
        timestamp: Date.now(),
        attachedFiles: options === null || options === void 0 ? void 0 : options.attachments
      };
      const packet = new DataPacket({
        value: {
          case: "chatMessage",
          value: new ChatMessage(Object.assign(Object.assign({}, msg), {
            timestamp: protoInt64.parse(msg.timestamp)
          }))
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      this.emit(ParticipantEvent.ChatMessage, msg);
      return msg;
    });
  }
  editChatMessage(editText, originalMessage) {
    return __awaiter(this, void 0, void 0, function* () {
      const msg = Object.assign(Object.assign({}, originalMessage), {
        message: editText,
        editTimestamp: Date.now()
      });
      const packet = new DataPacket({
        value: {
          case: "chatMessage",
          value: new ChatMessage(Object.assign(Object.assign({}, msg), {
            timestamp: protoInt64.parse(msg.timestamp),
            editTimestamp: protoInt64.parse(msg.editTimestamp)
          }))
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      this.emit(ParticipantEvent.ChatMessage, msg);
      return msg;
    });
  }
  sendText(text, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const streamId = crypto.randomUUID();
      const textInBytes = new TextEncoder().encode(text);
      const totalTextLength = textInBytes.byteLength;
      const fileIds = (_a3 = options === null || options === void 0 ? void 0 : options.attachments) === null || _a3 === void 0 ? void 0 : _a3.map(() => crypto.randomUUID());
      const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);
      const handleProgress = (progress, idx) => {
        var _a4;
        progresses[idx] = progress;
        const totalProgress = progresses.reduce((acc, val) => acc + val, 0);
        (_a4 = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a4 === void 0 ? void 0 : _a4.call(options, totalProgress);
      };
      const writer2 = yield this.streamText({
        streamId,
        totalSize: totalTextLength,
        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,
        topic: options === null || options === void 0 ? void 0 : options.topic,
        attachedStreamIds: fileIds,
        attributes: options === null || options === void 0 ? void 0 : options.attributes
      });
      yield writer2.write(text);
      handleProgress(1, 0);
      yield writer2.close();
      if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {
        yield Promise.all(options.attachments.map((file, idx) => __awaiter(this, void 0, void 0, function* () {
          return this._sendFile(fileIds[idx], file, {
            topic: options.topic,
            mimeType: file.type,
            onProgress: (progress) => {
              handleProgress(progress, idx + 1);
            }
          });
        })));
      }
      return writer2.info;
    });
  }
  /**
   * @internal
   * @experimental CAUTION, might get removed in a minor release
   */
  streamText(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      const streamId = (_a3 = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a3 !== void 0 ? _a3 : crypto.randomUUID();
      const info = {
        id: streamId,
        mimeType: "text/plain",
        timestamp: Date.now(),
        topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : "",
        size: options === null || options === void 0 ? void 0 : options.totalSize,
        attributes: options === null || options === void 0 ? void 0 : options.attributes
      };
      const header = new DataStream_Header({
        streamId,
        mimeType: info.mimeType,
        topic: info.topic,
        timestamp: numberToBigInt(info.timestamp),
        totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),
        attributes: info.attributes,
        contentHeader: {
          case: "textHeader",
          value: new DataStream_TextHeader({
            version: options === null || options === void 0 ? void 0 : options.version,
            attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,
            replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,
            operationType: (options === null || options === void 0 ? void 0 : options.type) === "update" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE
          })
        }
      });
      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
      const packet = new DataPacket({
        destinationIdentities,
        value: {
          case: "streamHeader",
          value: header
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      let chunkId = 0;
      const localP = this;
      const writableStream = new WritableStream({
        // Implement the sink
        write(text) {
          return __awaiter(this, void 0, void 0, function* () {
            for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)) {
              yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
              const chunk = new DataStream_Chunk({
                content: textByteChunk,
                streamId,
                chunkIndex: numberToBigInt(chunkId)
              });
              const chunkPacket = new DataPacket({
                destinationIdentities,
                value: {
                  case: "streamChunk",
                  value: chunk
                }
              });
              yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
              chunkId += 1;
            }
          });
        },
        close() {
          return __awaiter(this, void 0, void 0, function* () {
            const trailer = new DataStream_Trailer({
              streamId
            });
            const trailerPacket = new DataPacket({
              destinationIdentities,
              value: {
                case: "streamTrailer",
                value: trailer
              }
            });
            yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
          });
        },
        abort(err) {
          console.log("Sink error:", err);
        }
      });
      let onEngineClose = () => __awaiter(this, void 0, void 0, function* () {
        yield writer2.close();
      });
      localP.engine.once(EngineEvent.Closing, onEngineClose);
      const writer2 = new TextStreamWriter(writableStream, info, () => this.engine.off(EngineEvent.Closing, onEngineClose));
      return writer2;
    });
  }
  sendFile(file, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const streamId = crypto.randomUUID();
      yield this._sendFile(streamId, file, options);
      return {
        id: streamId
      };
    });
  }
  _sendFile(streamId, file, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const writer2 = yield this.streamBytes({
        streamId,
        totalSize: file.size,
        name: file.name,
        mimeType: (_a3 = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a3 !== void 0 ? _a3 : file.type,
        topic: options === null || options === void 0 ? void 0 : options.topic,
        destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities
      });
      const reader = file.stream().getReader();
      while (true) {
        const {
          done,
          value
        } = yield reader.read();
        if (done) {
          break;
        }
        yield writer2.write(value);
      }
      yield writer2.close();
      return writer2.info;
    });
  }
  streamBytes(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3, _d, _e3;
      const streamId = (_a3 = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a3 !== void 0 ? _a3 : crypto.randomUUID();
      const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;
      const info = {
        id: streamId,
        mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : "application/octet-stream",
        topic: (_c3 = options === null || options === void 0 ? void 0 : options.topic) !== null && _c3 !== void 0 ? _c3 : "",
        timestamp: Date.now(),
        attributes: options === null || options === void 0 ? void 0 : options.attributes,
        size: options === null || options === void 0 ? void 0 : options.totalSize,
        name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : "unknown"
      };
      const header = new DataStream_Header({
        totalLength: numberToBigInt((_e3 = info.size) !== null && _e3 !== void 0 ? _e3 : 0),
        mimeType: info.mimeType,
        streamId,
        topic: info.topic,
        timestamp: numberToBigInt(Date.now()),
        attributes: info.attributes,
        contentHeader: {
          case: "byteHeader",
          value: new DataStream_ByteHeader({
            name: info.name
          })
        }
      });
      const packet = new DataPacket({
        destinationIdentities,
        value: {
          case: "streamHeader",
          value: header
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      let chunkId = 0;
      const writeMutex = new _3();
      const engine = this.engine;
      const log2 = this.log;
      const writableStream = new WritableStream({
        write(chunk) {
          return __awaiter(this, void 0, void 0, function* () {
            const unlock = yield writeMutex.lock();
            let byteOffset = 0;
            try {
              while (byteOffset < chunk.byteLength) {
                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);
                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                const chunkPacket = new DataPacket({
                  destinationIdentities,
                  value: {
                    case: "streamChunk",
                    value: new DataStream_Chunk({
                      content: subChunk,
                      streamId,
                      chunkIndex: numberToBigInt(chunkId)
                    })
                  }
                });
                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);
                chunkId += 1;
                byteOffset += subChunk.byteLength;
              }
            } finally {
              unlock();
            }
          });
        },
        close() {
          return __awaiter(this, void 0, void 0, function* () {
            const trailer = new DataStream_Trailer({
              streamId
            });
            const trailerPacket = new DataPacket({
              destinationIdentities,
              value: {
                case: "streamTrailer",
                value: trailer
              }
            });
            yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);
          });
        },
        abort(err) {
          log2.error("Sink error:", err);
        }
      });
      const byteWriter = new ByteStreamWriter(writableStream, info);
      return byteWriter;
    });
  }
  /**
   * Initiate an RPC call to a remote participant
   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
   * @returns A promise that resolves with the response payload or rejects with an error.
   * @throws Error on failure. Details in `message`.
   */
  performRpc(_a3) {
    return __awaiter(this, arguments, void 0, function(_ref3) {
      var _this5 = this;
      let {
        destinationIdentity,
        method,
        payload,
        responseTimeout = 1e4
      } = _ref3;
      return function* () {
        const maxRoundTripLatency = 2e3;
        return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {
          var _a4, _b, _c3, _d;
          if (byteLength(payload) > MAX_PAYLOAD_BYTES) {
            reject(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
            return;
          }
          if (((_b = (_a4 = this.engine.latestJoinResponse) === null || _a4 === void 0 ? void 0 : _a4.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c3 = this.engine.latestJoinResponse) === null || _c3 === void 0 ? void 0 : _c3.serverInfo) === null || _d === void 0 ? void 0 : _d.version, "1.8.0") < 0) {
            reject(RpcError.builtIn("UNSUPPORTED_SERVER"));
            return;
          }
          const id = crypto.randomUUID();
          yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);
          const ackTimeoutId = setTimeout(() => {
            this.pendingAcks.delete(id);
            reject(RpcError.builtIn("CONNECTION_TIMEOUT"));
            this.pendingResponses.delete(id);
            clearTimeout(responseTimeoutId);
          }, maxRoundTripLatency);
          this.pendingAcks.set(id, {
            resolve: () => {
              clearTimeout(ackTimeoutId);
            },
            participantIdentity: destinationIdentity
          });
          const responseTimeoutId = setTimeout(() => {
            this.pendingResponses.delete(id);
            reject(RpcError.builtIn("RESPONSE_TIMEOUT"));
          }, responseTimeout);
          this.pendingResponses.set(id, {
            resolve: (responsePayload, responseError) => {
              clearTimeout(responseTimeoutId);
              if (this.pendingAcks.has(id)) {
                console.warn("RPC response received before ack", id);
                this.pendingAcks.delete(id);
                clearTimeout(ackTimeoutId);
              }
              if (responseError) {
                reject(responseError);
              } else {
                resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : "");
              }
            },
            participantIdentity: destinationIdentity
          });
        }));
      }();
    });
  }
  /**
   * @deprecated use `room.registerRpcMethod` instead
   */
  registerRpcMethod(method, handler) {
    if (this.rpcHandlers.has(method)) {
      this.log.warn("you're overriding the RPC handler for method ".concat(method, ", in the future this will throw an error"));
    }
    this.rpcHandlers.set(method, handler);
  }
  /**
   * @deprecated use `room.unregisterRpcMethod` instead
   */
  unregisterRpcMethod(method) {
    this.rpcHandlers.delete(method);
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(allParticipantsAllowed) {
    let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = participantTrackPermissions;
    this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
    if (!this.engine.client.isDisconnected) {
      this.updateTrackSubscriptionPermissions();
    }
  }
  handleIncomingRpcAck(requestId) {
    const handler = this.pendingAcks.get(requestId);
    if (handler) {
      handler.resolve();
      this.pendingAcks.delete(requestId);
    } else {
      console.error("Ack received for unexpected RPC request", requestId);
    }
  }
  handleIncomingRpcResponse(requestId, payload, error) {
    const handler = this.pendingResponses.get(requestId);
    if (handler) {
      handler.resolve(payload, error);
      this.pendingResponses.delete(requestId);
    } else {
      console.error("Response received for unexpected RPC request", requestId);
    }
  }
  /** @internal */
  publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {
    return __awaiter(this, void 0, void 0, function* () {
      const packet = new DataPacket({
        destinationIdentities: [destinationIdentity],
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "rpcRequest",
          value: new RpcRequest({
            id: requestId,
            method,
            payload,
            responseTimeoutMs: responseTimeout,
            version: 1
          })
        }
      });
      yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
    });
  }
  /** @internal */
  handleParticipantDisconnected(participantIdentity) {
    for (const [id, {
      participantIdentity: pendingIdentity
    }] of this.pendingAcks) {
      if (pendingIdentity === participantIdentity) {
        this.pendingAcks.delete(id);
      }
    }
    for (const [id, {
      participantIdentity: pendingIdentity,
      resolve
    }] of this.pendingResponses) {
      if (pendingIdentity === participantIdentity) {
        resolve(null, RpcError.builtIn("RECIPIENT_DISCONNECTED"));
        this.pendingResponses.delete(id);
      }
    }
  }
  /** @internal */
  setEnabledPublishCodecs(codecs) {
    this.enabledPublishVideoCodecs = codecs.filter((c3) => c3.mime.split("/")[0].toLowerCase() === "video");
  }
  /** @internal */
  updateInfo(info) {
    if (!super.updateInfo(info)) {
      return false;
    }
    info.tracks.forEach((ti3) => {
      var _a3, _b;
      const pub = this.trackPublications.get(ti3.sid);
      if (pub) {
        const mutedOnServer = pub.isMuted || ((_b = (_a3 = pub.track) === null || _a3 === void 0 ? void 0 : _a3.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);
        if (mutedOnServer !== ti3.muted) {
          this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {
            mutedOnServer
          }));
          this.engine.client.sendMuteTrack(ti3.sid, mutedOnServer);
        }
      }
    });
    return true;
  }
  /** @internal */
  setActiveAgent(agent) {
    var _a3, _b, _c3, _d;
    this.firstActiveAgent = agent;
    if (agent && !this.firstActiveAgent) {
      this.firstActiveAgent = agent;
    }
    if (agent) {
      (_b = (_a3 = this.activeAgentFuture) === null || _a3 === void 0 ? void 0 : _a3.resolve) === null || _b === void 0 ? void 0 : _b.call(_a3, agent);
    } else {
      (_d = (_c3 = this.activeAgentFuture) === null || _c3 === void 0 ? void 0 : _c3.reject) === null || _d === void 0 ? void 0 : _d.call(_c3, "Agent disconnected");
    }
    this.activeAgentFuture = void 0;
  }
  waitUntilActiveAgentPresent() {
    if (this.firstActiveAgent) {
      return Promise.resolve(this.firstActiveAgent);
    }
    if (!this.activeAgentFuture) {
      this.activeAgentFuture = new Future();
    }
    return this.activeAgentFuture.promise;
  }
  getPublicationForTrack(track2) {
    let publication;
    this.trackPublications.forEach((pub) => {
      const localTrack = pub.track;
      if (!localTrack) {
        return;
      }
      if (track2 instanceof MediaStreamTrack) {
        if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {
          if (localTrack.mediaStreamTrack === track2) {
            publication = pub;
          }
        }
      } else if (track2 === localTrack) {
        publication = pub;
      }
    });
    return publication;
  }
  waitForPendingPublicationOfSource(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const waitForPendingTimeout = 1e4;
      const startTime = Date.now();
      while (Date.now() < startTime + waitForPendingTimeout) {
        const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref4) => {
          let [pendingTrack] = _ref4;
          return pendingTrack.source === source;
        });
        if (publishPromiseEntry) {
          return publishPromiseEntry[1];
        }
        yield sleep(20);
      }
    });
  }
};
var RemoteTrackPublication = class extends TrackPublication {
  constructor(kind, ti3, autoSubscribe, loggerOptions) {
    super(kind, ti3.sid, ti3.name, loggerOptions);
    this.track = void 0;
    this.allowed = true;
    this.requestedDisabled = void 0;
    this.visible = true;
    this.handleEnded = (track2) => {
      this.setTrack(void 0);
      this.emit(TrackEvent.Ended, track2);
    };
    this.handleVisibilityChange = (visible) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), this.logContext);
      this.visible = visible;
      this.emitTrackUpdate();
    };
    this.handleVideoDimensionsChange = (dimensions) => {
      this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), this.logContext);
      this.videoDimensionsAdaptiveStream = dimensions;
      this.emitTrackUpdate();
    };
    this.subscribed = autoSubscribe;
    this.updateInfo(ti3);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(subscribed) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    this.subscribed = subscribed;
    if (subscribed) {
      this.allowed = true;
    }
    const sub = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, sub);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
    this.emitPermissionUpdateIfChanged(prevPermission);
  }
  get subscriptionStatus() {
    if (this.subscribed === false) {
      return TrackPublication.SubscriptionStatus.Unsubscribed;
    }
    if (!super.isSubscribed) {
      return TrackPublication.SubscriptionStatus.Desired;
    }
    return TrackPublication.SubscriptionStatus.Subscribed;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    if (this.subscribed === false) {
      return false;
    }
    return super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== false;
  }
  get isEnabled() {
    return this.requestedDisabled !== void 0 ? !this.requestedDisabled : this.isAdaptiveStream ? this.visible : true;
  }
  get isLocal() {
    return false;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(enabled) {
    if (!this.isManualOperationAllowed() || this.requestedDisabled === !enabled) {
      return;
    }
    this.requestedDisabled = !enabled;
    this.emitTrackUpdate();
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(quality) {
    if (!this.isManualOperationAllowed() || this.requestedMaxQuality === quality) {
      return;
    }
    this.requestedMaxQuality = quality;
    this.requestedVideoDimensions = void 0;
    this.emitTrackUpdate();
  }
  /**
   * Explicitly set the video dimensions for this track.
   *
   * This will take precedence over adaptive stream dimensions.
   *
   * @param dimensions The video dimensions to set.
   */
  setVideoDimensions(dimensions) {
    var _a3, _b;
    if (!this.isManualOperationAllowed()) {
      return;
    }
    if (((_a3 = this.requestedVideoDimensions) === null || _a3 === void 0 ? void 0 : _a3.width) === dimensions.width && ((_b = this.requestedVideoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
      return;
    }
    if (isRemoteVideoTrack(this.track)) {
      this.requestedVideoDimensions = dimensions;
    }
    this.requestedMaxQuality = void 0;
    this.emitTrackUpdate();
  }
  setVideoFPS(fps) {
    if (!this.isManualOperationAllowed()) {
      return;
    }
    if (!isRemoteVideoTrack(this.track)) {
      return;
    }
    if (this.fps === fps) {
      return;
    }
    this.fps = fps;
    this.emitTrackUpdate();
  }
  get videoQuality() {
    var _a3;
    return (_a3 = this.requestedMaxQuality) !== null && _a3 !== void 0 ? _a3 : VideoQuality.HIGH;
  }
  /** @internal */
  setTrack(track2) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    const prevTrack = this.track;
    if (prevTrack === track2) {
      return;
    }
    if (prevTrack) {
      prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      prevTrack.off(TrackEvent.Ended, this.handleEnded);
      prevTrack.detach();
      prevTrack.stopMonitor();
      this.emit(TrackEvent.Unsubscribed, prevTrack);
    }
    super.setTrack(track2);
    if (track2) {
      track2.sid = this.trackSid;
      track2.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
      track2.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
      track2.on(TrackEvent.Ended, this.handleEnded);
      this.emit(TrackEvent.Subscribed, track2);
    }
    this.emitPermissionUpdateIfChanged(prevPermission);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
  }
  /** @internal */
  setAllowed(allowed) {
    const prevStatus = this.subscriptionStatus;
    const prevPermission = this.permissionStatus;
    this.allowed = allowed;
    this.emitPermissionUpdateIfChanged(prevPermission);
    this.emitSubscriptionUpdateIfChanged(prevStatus);
  }
  /** @internal */
  setSubscriptionError(error) {
    this.emit(TrackEvent.SubscriptionFailed, error);
  }
  /** @internal */
  updateInfo(info) {
    super.updateInfo(info);
    const prevMetadataMuted = this.metadataMuted;
    this.metadataMuted = info.muted;
    if (this.track) {
      this.track.setMuted(info.muted);
    } else if (prevMetadataMuted !== info.muted) {
      this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
    }
  }
  emitSubscriptionUpdateIfChanged(previousStatus) {
    const currentStatus = this.subscriptionStatus;
    if (previousStatus === currentStatus) {
      return;
    }
    this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
  }
  emitPermissionUpdateIfChanged(previousPermissionStatus) {
    const currentPermissionStatus = this.permissionStatus;
    if (currentPermissionStatus !== previousPermissionStatus) {
      this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
    }
  }
  isManualOperationAllowed() {
    if (!this.isDesired) {
      this.log.warn("cannot update track settings when not subscribed", this.logContext);
      return false;
    }
    return true;
  }
  get isAdaptiveStream() {
    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const settings = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: !this.isEnabled,
      fps: this.fps
    });
    if (this.kind === Track.Kind.Video) {
      let minDimensions = this.requestedVideoDimensions;
      if (this.videoDimensionsAdaptiveStream !== void 0) {
        if (minDimensions) {
          const smallerAdaptive = areDimensionsSmaller(this.videoDimensionsAdaptiveStream, minDimensions);
          if (smallerAdaptive) {
            this.log.debug("using adaptive stream dimensions instead of requested", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));
            minDimensions = this.videoDimensionsAdaptiveStream;
          }
        } else if (this.requestedMaxQuality !== void 0 && this.trackInfo) {
          const maxQualityLayer = layerDimensionsFor(this.trackInfo, this.requestedMaxQuality);
          if (maxQualityLayer && areDimensionsSmaller(this.videoDimensionsAdaptiveStream, maxQualityLayer)) {
            this.log.debug("using adaptive stream dimensions instead of max quality layer", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));
            minDimensions = this.videoDimensionsAdaptiveStream;
          }
        } else {
          this.log.debug("using adaptive stream dimensions", Object.assign(Object.assign({}, this.logContext), this.videoDimensionsAdaptiveStream));
          minDimensions = this.videoDimensionsAdaptiveStream;
        }
      }
      if (minDimensions) {
        settings.width = Math.ceil(minDimensions.width);
        settings.height = Math.ceil(minDimensions.height);
      } else if (this.requestedMaxQuality !== void 0) {
        this.log.debug("using requested max quality", Object.assign(Object.assign({}, this.logContext), {
          quality: this.requestedMaxQuality
        }));
        settings.quality = this.requestedMaxQuality;
      } else {
        this.log.debug("using default quality", Object.assign(Object.assign({}, this.logContext), {
          quality: VideoQuality.HIGH
        }));
        settings.quality = VideoQuality.HIGH;
      }
    }
    this.emit(TrackEvent.UpdateSettings, settings);
  }
};
var RemoteParticipant = class _RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(signalClient, pi3, loggerOptions) {
    return new _RemoteParticipant(signalClient, pi3.sid, pi3.identity, pi3.name, pi3.metadata, pi3.attributes, loggerOptions, pi3.kind);
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity
    });
  }
  /** @internal */
  constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
    let kind = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : ParticipantInfo_Kind.STANDARD;
    super(sid, identity || "", name, metadata, attributes, loggerOptions, kind);
    this.signalClient = signalClient;
    this.trackPublications = /* @__PURE__ */ new Map();
    this.audioTrackPublications = /* @__PURE__ */ new Map();
    this.videoTrackPublications = /* @__PURE__ */ new Map();
    this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(publication) {
    super.addTrackPublication(publication);
    publication.on(TrackEvent.UpdateSettings, (settings) => {
      this.log.debug("send update settings", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)), {
        settings
      }));
      this.signalClient.sendUpdateTrackSettings(settings);
    });
    publication.on(TrackEvent.UpdateSubscription, (sub) => {
      sub.participantTracks.forEach((pt3) => {
        pt3.participantSid = this.sid;
      });
      this.signalClient.sendUpdateSubscription(sub);
    });
    publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
    });
    publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
    });
    publication.on(TrackEvent.Subscribed, (track2) => {
      this.emit(ParticipantEvent.TrackSubscribed, track2, publication);
    });
    publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
    });
    publication.on(TrackEvent.SubscriptionFailed, (error) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
    });
  }
  getTrackPublication(source) {
    const track2 = super.getTrackPublication(source);
    if (track2) {
      return track2;
    }
  }
  getTrackPublicationByName(name) {
    const track2 = super.getTrackPublicationByName(name);
    if (track2) {
      return track2;
    }
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(volume) {
    let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(source, volume);
    const audioPublication = this.getTrackPublication(source);
    if (audioPublication && audioPublication.track) {
      audioPublication.track.setVolume(volume);
    }
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const audioPublication = this.getTrackPublication(source);
    if (audioPublication && audioPublication.track) {
      return audioPublication.track.getVolume();
    }
    return this.volumeMap.get(source);
  }
  /** @internal */
  addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
    let publication = this.getTrackPublicationBySid(sid);
    if (!publication) {
      if (!sid.startsWith("TR")) {
        this.trackPublications.forEach((p3) => {
          if (!publication && mediaTrack.kind === p3.kind.toString()) {
            publication = p3;
          }
        });
      }
    }
    if (!publication) {
      if (triesLeft === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: sid
        }));
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      if (triesLeft === void 0)
        triesLeft = 20;
      setTimeout(() => {
        this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
      }, 150);
      return;
    }
    if (mediaTrack.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
      this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
      return;
    }
    const isVideo = mediaTrack.kind === "video";
    let track2;
    if (isVideo) {
      track2 = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
    } else {
      track2 = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
    }
    track2.source = publication.source;
    track2.isMuted = publication.isMuted;
    track2.setMediaStream(mediaStream);
    track2.start();
    publication.setTrack(track2);
    if (this.volumeMap.has(publication.source) && isRemoteTrack(track2) && isAudioTrack(track2)) {
      track2.setVolume(this.volumeMap.get(publication.source));
    }
    return publication;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(sid) {
    return this.trackPublications.get(sid);
  }
  /** @internal */
  updateInfo(info) {
    if (!super.updateInfo(info)) {
      return false;
    }
    const validTracks = /* @__PURE__ */ new Map();
    const newTracks = /* @__PURE__ */ new Map();
    info.tracks.forEach((ti3) => {
      var _a3, _b;
      let publication = this.getTrackPublicationBySid(ti3.sid);
      if (!publication) {
        const kind = Track.kindFromProto(ti3.type);
        if (!kind) {
          return;
        }
        publication = new RemoteTrackPublication(kind, ti3, (_a3 = this.signalClient.connectOptions) === null || _a3 === void 0 ? void 0 : _a3.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName
        });
        publication.updateInfo(ti3);
        newTracks.set(ti3.sid, publication);
        const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));
        if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
          this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {
            oldTrack: getLogContextFromTrack(existingTrackOfSource),
            newTrack: getLogContextFromTrack(publication)
          }));
        }
        this.addTrackPublication(publication);
      } else {
        publication.updateInfo(ti3);
      }
      validTracks.set(ti3.sid, publication);
    });
    this.trackPublications.forEach((publication) => {
      if (!validTracks.has(publication.trackSid)) {
        this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.unpublishTrack(publication.trackSid, true);
      }
    });
    newTracks.forEach((publication) => {
      this.emit(ParticipantEvent.TrackPublished, publication);
    });
    return true;
  }
  /** @internal */
  unpublishTrack(sid, sendUnpublish) {
    const publication = this.trackPublications.get(sid);
    if (!publication) {
      return;
    }
    const {
      track: track2
    } = publication;
    if (track2) {
      track2.stop();
      publication.setTrack(void 0);
    }
    this.trackPublications.delete(sid);
    switch (publication.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(sid);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(sid);
        break;
    }
    if (sendUnpublish) {
      this.emit(ParticipantEvent.TrackUnpublished, publication);
    }
  }
  /**
   * @internal
   */
  setAudioOutput(output) {
    return __awaiter(this, void 0, void 0, function* () {
      this.audioOutput = output;
      const promises = [];
      this.audioTrackPublications.forEach((pub) => {
        var _a3;
        if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {
          promises.push(pub.track.setSinkId((_a3 = output.deviceId) !== null && _a3 !== void 0 ? _a3 : "default"));
        }
      });
      yield Promise.all(promises);
    });
  }
  /** @internal */
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event,
      args
    }));
    return super.emit(event, ...args);
  }
};
var ConnectionState;
(function(ConnectionState3) {
  ConnectionState3["Disconnected"] = "disconnected";
  ConnectionState3["Connecting"] = "connecting";
  ConnectionState3["Connected"] = "connected";
  ConnectionState3["Reconnecting"] = "reconnecting";
  ConnectionState3["SignalReconnecting"] = "signalReconnecting";
})(ConnectionState || (ConnectionState = {}));
var connectionReconcileFrequency = 4 * 1e3;
var Room = class _Room extends eventsExports.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(options) {
    var _this;
    var _a3, _b, _c3;
    super();
    _this = this;
    this.state = ConnectionState.Disconnected;
    this.activeSpeakers = [];
    this.isE2EEEnabled = false;
    this.audioEnabled = true;
    this.isVideoPlaybackBlocked = false;
    this.log = livekitLogger;
    this.bufferedEvents = [];
    this.isResuming = false;
    this.byteStreamControllers = /* @__PURE__ */ new Map();
    this.textStreamControllers = /* @__PURE__ */ new Map();
    this.byteStreamHandlers = /* @__PURE__ */ new Map();
    this.textStreamHandlers = /* @__PURE__ */ new Map();
    this.rpcHandlers = /* @__PURE__ */ new Map();
    this.connect = (url, token, opts) => __awaiter(this, void 0, void 0, function* () {
      var _a4;
      if (!isBrowserSupported()) {
        if (isReactNative()) {
          throw Error("WebRTC isn't detected, have you called registerGlobals?");
        } else {
          throw Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
        }
      }
      const unlockDisconnect = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected) {
        this.log.info("already connected to room ".concat(this.name), this.logContext);
        unlockDisconnect();
        return Promise.resolve();
      }
      if (this.connectFuture) {
        unlockDisconnect();
        return this.connectFuture.promise;
      }
      this.setAndEmitConnectionState(ConnectionState.Connecting);
      if (((_a4 = this.regionUrlProvider) === null || _a4 === void 0 ? void 0 : _a4.getServerUrl().toString()) !== url) {
        this.regionUrl = void 0;
        this.regionUrlProvider = void 0;
      }
      if (isCloud(new URL(url))) {
        if (this.regionUrlProvider === void 0) {
          this.regionUrlProvider = new RegionUrlProvider(url, token);
        } else {
          this.regionUrlProvider.updateToken(token);
        }
        this.regionUrlProvider.fetchRegionSettings().then((settings) => {
          var _a5;
          (_a5 = this.regionUrlProvider) === null || _a5 === void 0 ? void 0 : _a5.setServerReportedRegions(settings);
        }).catch((e4) => {
          this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
            error: e4
          }));
        });
      }
      const connectFn = (resolve, reject, regionUrl2) => __awaiter(this, void 0, void 0, function* () {
        var _a5, _b2;
        if (this.abortController) {
          this.abortController.abort();
        }
        const abortController = new AbortController();
        this.abortController = abortController;
        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();
        try {
          yield this.attemptConnection(regionUrl2 !== null && regionUrl2 !== void 0 ? regionUrl2 : url, token, opts, abortController);
          this.abortController = void 0;
          resolve();
        } catch (e4) {
          if (this.regionUrlProvider && e4 instanceof ConnectionError && e4.reason !== ConnectionErrorReason.Cancelled && e4.reason !== ConnectionErrorReason.NotAllowed) {
            let nextUrl = null;
            try {
              nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a5 = this.abortController) === null || _a5 === void 0 ? void 0 : _a5.signal);
            } catch (error) {
              if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                reject(error);
                return;
              }
            }
            if (nextUrl && !((_b2 = this.abortController) === null || _b2 === void 0 ? void 0 : _b2.signal.aborted)) {
              this.log.info("Initial connection failed with ConnectionError: ".concat(e4.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);
              this.recreateEngine();
              yield connectFn(resolve, reject, nextUrl);
            } else {
              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e4));
              reject(e4);
            }
          } else {
            let disconnectReason = DisconnectReason.UNKNOWN_REASON;
            if (e4 instanceof ConnectionError) {
              disconnectReason = getDisconnectReasonFromConnectionError(e4);
            }
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
            reject(e4);
          }
        }
      });
      const regionUrl = this.regionUrl;
      this.regionUrl = void 0;
      this.connectFuture = new Future((resolve, reject) => {
        connectFn(resolve, reject, regionUrl);
      }, () => {
        this.clearConnectionFutures();
      });
      return this.connectFuture.promise;
    });
    this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {
      var _a4, _b2, _c4;
      const joinResponse = yield engine.join(url, token, {
        autoSubscribe: connectOptions.autoSubscribe,
        adaptiveStream: typeof roomOptions.adaptiveStream === "object" ? true : roomOptions.adaptiveStream,
        maxRetries: connectOptions.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: connectOptions.websocketTimeout
      }, abortController.signal);
      let serverInfo = joinResponse.serverInfo;
      if (!serverInfo) {
        serverInfo = {
          version: joinResponse.serverVersion,
          region: joinResponse.serverRegion
        };
      }
      this.serverInfo = serverInfo;
      this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref) => {
        let [key, value] = _ref;
        return "".concat(key, ": ").concat(value);
      }).join(", ")), {
        room: (_a4 = joinResponse.room) === null || _a4 === void 0 ? void 0 : _a4.name,
        roomSid: (_b2 = joinResponse.room) === null || _b2 === void 0 ? void 0 : _b2.sid,
        identity: (_c4 = joinResponse.participant) === null || _c4 === void 0 ? void 0 : _c4.identity
      });
      if (!serverInfo.version) {
        throw new UnsupportedServer("unknown server version");
      }
      if (serverInfo.version === "0.15.1" && this.options.dynacast) {
        this.log.debug("disabling dynacast due to server version", this.logContext);
        roomOptions.dynacast = false;
      }
      return joinResponse;
    });
    this.applyJoinResponse = (joinResponse) => {
      const pi3 = joinResponse.participant;
      this.localParticipant.sid = pi3.sid;
      this.localParticipant.identity = pi3.identity;
      this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
      if (this.options.e2ee && this.e2eeManager) {
        try {
          this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
        } catch (e4) {
          this.log.error(e4 instanceof Error ? e4.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
            error: e4
          }));
        }
      }
      this.handleParticipantUpdates([pi3, ...joinResponse.otherParticipants]);
      if (joinResponse.room) {
        this.handleRoomUpdate(joinResponse.room);
      }
    };
    this.attemptConnection = (url, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {
      var _a4, _b2;
      if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a4 = this.engine) === null || _a4 === void 0 ? void 0 : _a4.pendingReconnect)) {
        this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);
        this.recreateEngine();
      } else {
        this.maybeCreateEngine();
      }
      if ((_b2 = this.regionUrlProvider) === null || _b2 === void 0 ? void 0 : _b2.isCloud()) {
        this.engine.setRegionUrlProvider(this.regionUrlProvider);
      }
      this.acquireAudioContext();
      this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
      if (this.connOptions.rtcConfig) {
        this.engine.rtcConfig = this.connOptions.rtcConfig;
      }
      if (this.connOptions.peerConnectionTimeout) {
        this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
      }
      try {
        const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);
        this.applyJoinResponse(joinResponse);
        this.setupLocalParticipantEvents();
        this.emit(RoomEvent.SignalConnected);
      } catch (err) {
        yield this.engine.close();
        this.recreateEngine();
        const resultingError = new ConnectionError("could not establish signal connection", ConnectionErrorReason.ServerUnreachable);
        if (err instanceof Error) {
          resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);
        }
        if (err instanceof ConnectionError) {
          resultingError.reason = err.reason;
          resultingError.status = err.status;
        }
        this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: err
        }));
        throw resultingError;
      }
      if (abortController.signal.aborted) {
        yield this.engine.close();
        this.recreateEngine();
        throw new ConnectionError("Connection attempt aborted", ConnectionErrorReason.Cancelled);
      }
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);
      } catch (e4) {
        yield this.engine.close();
        this.recreateEngine();
        throw e4;
      }
      if (isWeb() && this.options.disconnectOnPageLeave) {
        window.addEventListener("pagehide", this.onPageLeave);
        window.addEventListener("beforeunload", this.onPageLeave);
      }
      if (isWeb()) {
        document.addEventListener("freeze", this.onPageLeave);
      }
      this.setAndEmitConnectionState(ConnectionState.Connected);
      this.emit(RoomEvent.Connected);
      this.registerConnectionReconcile();
    });
    this.disconnect = function() {
      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
        args_1[_key] = arguments[_key];
      }
      return __awaiter(_this, [...args_1], void 0, function() {
        var _this2 = this;
        let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          var _a4, _b2, _c4, _d;
          const unlock = yield _this2.disconnectLock.lock();
          try {
            if (_this2.state === ConnectionState.Disconnected) {
              _this2.log.debug("already disconnected", _this2.logContext);
              return;
            }
            _this2.log.info("disconnect from room", Object.assign({}, _this2.logContext));
            if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {
              _this2.log.warn("abort connection attempt", _this2.logContext);
              (_a4 = _this2.abortController) === null || _a4 === void 0 ? void 0 : _a4.abort();
              (_c4 = (_b2 = _this2.connectFuture) === null || _b2 === void 0 ? void 0 : _b2.reject) === null || _c4 === void 0 ? void 0 : _c4.call(_b2, new ConnectionError("Client initiated disconnect", ConnectionErrorReason.Cancelled));
              _this2.connectFuture = void 0;
            }
            if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {
              yield _this2.engine.client.sendLeave();
            }
            if (_this2.engine) {
              yield _this2.engine.close();
            }
            _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
            _this2.engine = void 0;
          } finally {
            unlock();
          }
        }();
      });
    };
    this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {
      this.log.info("Page leave detected, disconnecting", this.logContext);
      yield this.disconnect();
    });
    this.startAudio = () => __awaiter(this, void 0, void 0, function* () {
      const elements = [];
      const browser = getBrowser();
      if (browser && browser.os === "iOS") {
        const audioId = "livekit-dummy-audio-el";
        let dummyAudioEl = document.getElementById(audioId);
        if (!dummyAudioEl) {
          dummyAudioEl = document.createElement("audio");
          dummyAudioEl.id = audioId;
          dummyAudioEl.autoplay = true;
          dummyAudioEl.hidden = true;
          const track2 = getEmptyAudioStreamTrack();
          track2.enabled = true;
          const stream = new MediaStream([track2]);
          dummyAudioEl.srcObject = stream;
          document.addEventListener("visibilitychange", () => {
            if (!dummyAudioEl) {
              return;
            }
            dummyAudioEl.srcObject = document.hidden ? null : stream;
            if (!document.hidden) {
              this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext);
              this.startAudio();
            }
          });
          document.body.append(dummyAudioEl);
          this.once(RoomEvent.Disconnected, () => {
            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
            dummyAudioEl = null;
          });
        }
        elements.push(dummyAudioEl);
      }
      this.remoteParticipants.forEach((p3) => {
        p3.audioTrackPublications.forEach((t3) => {
          if (t3.track) {
            t3.track.attachedElements.forEach((e4) => {
              elements.push(e4);
            });
          }
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...elements.map((e4) => {
          e4.muted = false;
          return e4.play();
        })]);
        this.handleAudioPlaybackStarted();
      } catch (err) {
        this.handleAudioPlaybackFailed(err);
        throw err;
      }
    });
    this.startVideo = () => __awaiter(this, void 0, void 0, function* () {
      const elements = [];
      for (const p3 of this.remoteParticipants.values()) {
        p3.videoTrackPublications.forEach((tr3) => {
          var _a4;
          (_a4 = tr3.track) === null || _a4 === void 0 ? void 0 : _a4.attachedElements.forEach((el) => {
            if (!elements.includes(el)) {
              elements.push(el);
            }
          });
        });
      }
      yield Promise.all(elements.map((el) => el.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((e4) => {
        if (e4.name === "NotAllowedError") {
          this.handleVideoPlaybackFailed();
        } else {
          this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
        }
      });
    });
    this.handleRestarting = () => {
      this.clearConnectionReconcile();
      this.isResuming = false;
      for (const p3 of this.remoteParticipants.values()) {
        this.handleParticipantDisconnected(p3.identity, p3);
      }
      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
        this.emit(RoomEvent.Reconnecting);
      }
    };
    this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: joinResponse.serverRegion
      }));
      this.bufferedEvents = [];
      this.applyJoinResponse(joinResponse);
      try {
        yield this.localParticipant.republishAllTracks(void 0, true);
      } catch (error) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error
        }));
      }
      try {
        yield this.engine.waitForRestarted();
        this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: joinResponse.serverRegion
        }));
      } catch (_a4) {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected);
      this.emit(RoomEvent.Reconnected);
      this.registerConnectionReconcile();
      this.emitBufferedEvents();
    });
    this.handleParticipantUpdates = (participantInfos) => {
      participantInfos.forEach((info) => {
        var _a4;
        if (info.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(info);
          return;
        }
        if (info.identity === "") {
          info.identity = (_a4 = this.sidToIdentity.get(info.sid)) !== null && _a4 !== void 0 ? _a4 : "";
        }
        let remoteParticipant = this.remoteParticipants.get(info.identity);
        if (info.state === ParticipantInfo_State.DISCONNECTED) {
          this.handleParticipantDisconnected(info.identity, remoteParticipant);
        } else {
          remoteParticipant = this.getOrCreateParticipant(info.identity, info);
        }
      });
    };
    this.handleActiveSpeakersUpdate = (speakers) => {
      const activeSpeakers = [];
      const seenSids = {};
      speakers.forEach((speaker) => {
        seenSids[speaker.sid] = true;
        if (speaker.sid === this.localParticipant.sid) {
          this.localParticipant.audioLevel = speaker.level;
          this.localParticipant.setIsSpeaking(true);
          activeSpeakers.push(this.localParticipant);
        } else {
          const p3 = this.getRemoteParticipantBySid(speaker.sid);
          if (p3) {
            p3.audioLevel = speaker.level;
            p3.setIsSpeaking(true);
            activeSpeakers.push(p3);
          }
        }
      });
      if (!seenSids[this.localParticipant.sid]) {
        this.localParticipant.audioLevel = 0;
        this.localParticipant.setIsSpeaking(false);
      }
      this.remoteParticipants.forEach((p3) => {
        if (!seenSids[p3.sid]) {
          p3.audioLevel = 0;
          p3.setIsSpeaking(false);
        }
      });
      this.activeSpeakers = activeSpeakers;
      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    this.handleSpeakersChanged = (speakerUpdates) => {
      const lastSpeakers = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((p3) => {
        const remoteParticipant = this.remoteParticipants.get(p3.identity);
        if (remoteParticipant && remoteParticipant.sid !== p3.sid) {
          return;
        }
        lastSpeakers.set(p3.sid, p3);
      });
      speakerUpdates.forEach((speaker) => {
        let p3 = this.getRemoteParticipantBySid(speaker.sid);
        if (speaker.sid === this.localParticipant.sid) {
          p3 = this.localParticipant;
        }
        if (!p3) {
          return;
        }
        p3.audioLevel = speaker.level;
        p3.setIsSpeaking(speaker.active);
        if (speaker.active) {
          lastSpeakers.set(speaker.sid, p3);
        } else {
          lastSpeakers.delete(speaker.sid);
        }
      });
      const activeSpeakers = Array.from(lastSpeakers.values());
      activeSpeakers.sort((a3, b3) => b3.audioLevel - a3.audioLevel);
      this.activeSpeakers = activeSpeakers;
      this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    this.handleStreamStateUpdate = (streamStateUpdate) => {
      streamStateUpdate.streamStates.forEach((streamState) => {
        const participant = this.getRemoteParticipantBySid(streamState.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(streamState.trackSid);
        if (!pub || !pub.track) {
          return;
        }
        const newStreamState = Track.streamStateFromProto(streamState.state);
        if (newStreamState !== pub.track.streamState) {
          pub.track.streamState = newStreamState;
          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
          this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
        }
      });
    };
    this.handleSubscriptionPermissionUpdate = (update) => {
      const participant = this.getRemoteParticipantBySid(update.participantSid);
      if (!participant) {
        return;
      }
      const pub = participant.getTrackPublicationBySid(update.trackSid);
      if (!pub) {
        return;
      }
      pub.setAllowed(update.allowed);
    };
    this.handleSubscriptionError = (update) => {
      const participant = Array.from(this.remoteParticipants.values()).find((p3) => p3.trackPublications.has(update.trackSid));
      if (!participant) {
        return;
      }
      const pub = participant.getTrackPublicationBySid(update.trackSid);
      if (!pub) {
        return;
      }
      pub.setSubscriptionError(update.err);
    };
    this.handleDataPacket = (packet) => {
      const participant = this.remoteParticipants.get(packet.participantIdentity);
      if (packet.value.case === "user") {
        this.handleUserPacket(participant, packet.value.value, packet.kind);
      } else if (packet.value.case === "transcription") {
        this.handleTranscription(participant, packet.value.value);
      } else if (packet.value.case === "sipDtmf") {
        this.handleSipDtmf(participant, packet.value.value);
      } else if (packet.value.case === "chatMessage") {
        this.handleChatMessage(participant, packet.value.value);
      } else if (packet.value.case === "metrics") {
        this.handleMetrics(packet.value.value, participant);
      } else if (packet.value.case === "streamHeader") {
        this.handleStreamHeader(packet.value.value, packet.participantIdentity);
      } else if (packet.value.case === "streamChunk") {
        this.handleStreamChunk(packet.value.value);
      } else if (packet.value.case === "streamTrailer") {
        this.handleStreamTrailer(packet.value.value);
      } else if (packet.value.case === "rpcRequest") {
        const rpc = packet.value.value;
        this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);
      }
    };
    this.handleUserPacket = (participant, userPacket, kind) => {
      this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);
    };
    this.handleSipDtmf = (participant, dtmf) => {
      this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
    };
    this.bufferedSegments = /* @__PURE__ */ new Map();
    this.handleTranscription = (_remoteParticipant, transcription) => {
      const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
      const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);
      const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);
      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
      this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
    };
    this.handleChatMessage = (participant, chatMessage) => {
      const msg = extractChatMessage(chatMessage);
      this.emit(RoomEvent.ChatMessage, msg, participant);
    };
    this.handleMetrics = (metrics, participant) => {
      this.emit(RoomEvent.MetricsReceived, metrics, participant);
    };
    this.handleAudioPlaybackStarted = () => {
      if (this.canPlaybackAudio) {
        return;
      }
      this.audioEnabled = true;
      this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
    };
    this.handleAudioPlaybackFailed = (e4) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: e4
      }));
      if (!this.canPlaybackAudio) {
        return;
      }
      this.audioEnabled = false;
      this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
    };
    this.handleVideoPlaybackStarted = () => {
      if (this.isVideoPlaybackBlocked) {
        this.isVideoPlaybackBlocked = false;
        this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
      }
    };
    this.handleVideoPlaybackFailed = () => {
      if (!this.isVideoPlaybackBlocked) {
        this.isVideoPlaybackBlocked = true;
        this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
      }
    };
    this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
      var _a4;
      if (((_a4 = getBrowser()) === null || _a4 === void 0 ? void 0 : _a4.os) !== "iOS") {
        yield this.selectDefaultDevices();
      }
      this.emit(RoomEvent.MediaDevicesChanged);
    });
    this.handleRoomUpdate = (room) => {
      const oldRoom = this.roomInfo;
      this.roomInfo = room;
      if (oldRoom && oldRoom.metadata !== room.metadata) {
        this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
      }
      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {
        this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
      }
    };
    this.handleConnectionQualityUpdate = (update) => {
      update.updates.forEach((info) => {
        if (info.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(info.quality);
          return;
        }
        const participant = this.getRemoteParticipantBySid(info.participantSid);
        if (participant) {
          participant.setConnectionQuality(info.quality);
        }
      });
    };
    this.onLocalParticipantMetadataChanged = (metadata) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
    };
    this.onLocalParticipantNameChanged = (name) => {
      this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);
    };
    this.onLocalAttributesChanged = (changedAttributes) => {
      this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);
    };
    this.onLocalTrackMuted = (pub) => {
      this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
    };
    this.onLocalTrackUnmuted = (pub) => {
      this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
    };
    this.onTrackProcessorUpdate = (processor) => {
      var _a4;
      (_a4 = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a4 === void 0 ? void 0 : _a4.call(processor, this);
    };
    this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {
      var _a4, _b2, _c4, _d, _e3, _f;
      (_a4 = pub.track) === null || _a4 === void 0 ? void 0 : _a4.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
      (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
      (_e3 = (_d = (_c4 = pub.track) === null || _c4 === void 0 ? void 0 : _c4.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e3 === void 0 ? void 0 : _e3.call(_d, this);
      this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
      if (isLocalAudioTrack(pub.track)) {
        const trackIsSilent = yield pub.track.checkForSilence();
        if (trackIsSilent) {
          this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
        }
      }
      const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);
      const deviceKind = sourceToKind(pub.source);
      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
      }
    });
    this.onLocalTrackUnpublished = (pub) => {
      var _a4, _b2;
      (_a4 = pub.track) === null || _a4 === void 0 ? void 0 : _a4.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
      (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.off(TrackEvent.Restarted, this.onLocalTrackRestarted);
      this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
    };
    this.onLocalTrackRestarted = (track2) => __awaiter(this, void 0, void 0, function* () {
      const deviceId = yield track2.getDeviceId(false);
      const deviceKind = sourceToKind(track2.source);
      if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
        this.log.debug("local track restarted, setting ".concat(deviceKind, " ").concat(deviceId, " active"), this.logContext);
        this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
        this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
      }
    });
    this.onLocalConnectionQualityChanged = (quality) => {
      this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
    };
    this.onMediaDevicesError = (e4, kind) => {
      this.emit(RoomEvent.MediaDevicesError, e4, kind);
    };
    this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
    };
    this.onLocalChatMessageSent = (msg) => {
      this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);
    };
    this.setMaxListeners(100);
    this.remoteParticipants = /* @__PURE__ */ new Map();
    this.sidToIdentity = /* @__PURE__ */ new Map();
    this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
    this.log = getLogger((_a3 = this.options.loggerName) !== null && _a3 !== void 0 ? _a3 : LoggerNames.Room);
    this.transcriptionReceivedTimes = /* @__PURE__ */ new Map();
    this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
    this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
    this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
    this.maybeCreateEngine();
    this.disconnectLock = new _3();
    this.localParticipant = new LocalParticipant("", "", this.engine, this.options, this.rpcHandlers);
    if (this.options.videoCaptureDefaults.deviceId) {
      this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));
    }
    if (this.options.audioCaptureDefaults.deviceId) {
      this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));
    }
    if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
      this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e4) => this.log.warn("Could not set audio output: ".concat(e4.message), this.logContext));
    }
    if (this.options.e2ee) {
      this.setupE2EE();
    }
    if (isWeb()) {
      const abortController = new AbortController();
      (_c3 = navigator.mediaDevices) === null || _c3 === void 0 ? void 0 : _c3.addEventListener("devicechange", this.handleDeviceChange, {
        signal: abortController.signal
      });
      if (_Room.cleanupRegistry) {
        _Room.cleanupRegistry.register(this, () => {
          abortController.abort();
        });
      }
    }
  }
  registerTextStreamHandler(topic, callback) {
    if (this.textStreamHandlers.has(topic)) {
      throw new TypeError('A text stream handler for topic "'.concat(topic, '" has already been set.'));
    }
    this.textStreamHandlers.set(topic, callback);
  }
  unregisterTextStreamHandler(topic) {
    this.textStreamHandlers.delete(topic);
  }
  registerByteStreamHandler(topic, callback) {
    if (this.byteStreamHandlers.has(topic)) {
      throw new TypeError('A byte stream handler for topic "'.concat(topic, '" has already been set.'));
    }
    this.byteStreamHandlers.set(topic, callback);
  }
  unregisterByteStreamHandler(topic) {
    this.byteStreamHandlers.delete(topic);
  }
  /**
   * Establishes the participant as a receiver for calls of the specified RPC method.
   *
   * @param method - The name of the indicated RPC method
   * @param handler - Will be invoked when an RPC request for this method is received
   * @returns A promise that resolves when the method is successfully registered
   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)
   *
   * @example
   * ```typescript
   * room.localParticipant?.registerRpcMethod(
   *   'greet',
   *   async (data: RpcInvocationData) => {
   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
   *     return `Hello, ${data.callerIdentity}!`;
   *   }
   * );
   * ```
   *
   * The handler should return a Promise that resolves to a string.
   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
   *
   * You may throw errors of type `RpcError` with a string `message` in the handler,
   * and they will be received on the caller's side with the message intact.
   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
   */
  registerRpcMethod(method, handler) {
    if (this.rpcHandlers.has(method)) {
      throw Error("RPC handler already registered for method ".concat(method, ", unregisterRpcMethod before trying to register again"));
    }
    this.rpcHandlers.set(method, handler);
  }
  /**
   * Unregisters a previously registered RPC method.
   *
   * @param method - The name of the RPC method to unregister
   */
  unregisterRpcMethod(method) {
    this.rpcHandlers.delete(method);
  }
  handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version2) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.engine.publishRpcAck(callerIdentity, requestId);
      if (version2 !== 1) {
        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_VERSION"));
        return;
      }
      const handler = this.rpcHandlers.get(method);
      if (!handler) {
        yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_METHOD"));
        return;
      }
      let responseError = null;
      let responsePayload = null;
      try {
        const response = yield handler({
          requestId,
          callerIdentity,
          payload,
          responseTimeout
        });
        if (byteLength(response) > MAX_PAYLOAD_BYTES) {
          responseError = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE");
          console.warn("RPC Response payload too large for ".concat(method));
        } else {
          responsePayload = response;
        }
      } catch (error) {
        if (error instanceof RpcError) {
          responseError = error;
        } else {
          console.warn("Uncaught error returned by RPC handler for ".concat(method, ". Returning APPLICATION_ERROR instead."), error);
          responseError = RpcError.builtIn("APPLICATION_ERROR");
        }
      }
      yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);
    });
  }
  /**
   * @experimental
   */
  setE2EEEnabled(enabled) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.e2eeManager) {
        yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
        if (this.localParticipant.identity !== "") {
          this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
        }
      } else {
        throw Error("e2ee not configured, please set e2ee settings within the room options");
      }
    });
  }
  setupE2EE() {
    var _a3;
    if (this.options.e2ee) {
      if ("e2eeManager" in this.options.e2ee) {
        this.e2eeManager = this.options.e2ee.e2eeManager;
      } else {
        this.e2eeManager = new E2EEManager(this.options.e2ee);
      }
      this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {
        if (isLocalParticipant(participant)) {
          this.isE2EEEnabled = enabled;
        }
        this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
      });
      this.e2eeManager.on(EncryptionEvent.EncryptionError, (error) => this.emit(RoomEvent.EncryptionError, error));
      (_a3 = this.e2eeManager) === null || _a3 === void 0 ? void 0 : _a3.setup(this);
    }
  }
  get logContext() {
    var _a3;
    return {
      room: this.name,
      roomID: (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var _a3, _b;
    return (_b = (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.activeRecording) !== null && _b !== void 0 ? _b : false;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        return "";
      }
      if (this.roomInfo && this.roomInfo.sid !== "") {
        return this.roomInfo.sid;
      }
      return new Promise((resolve, reject) => {
        const handleRoomUpdate = (roomInfo) => {
          if (roomInfo.sid !== "") {
            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
            resolve(roomInfo.sid);
          }
        };
        this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);
        this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
          reject("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var _a3, _b;
    return (_b = (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.name) !== null && _b !== void 0 ? _b : "";
  }
  /** room metadata */
  get metadata() {
    var _a3;
    return (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.metadata;
  }
  get numParticipants() {
    var _a3, _b;
    return (_b = (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.numParticipants) !== null && _b !== void 0 ? _b : 0;
  }
  get numPublishers() {
    var _a3, _b;
    return (_b = (_a3 = this.roomInfo) === null || _a3 === void 0 ? void 0 : _a3.numPublishers) !== null && _b !== void 0 ? _b : 0;
  }
  maybeCreateEngine() {
    if (this.engine && !this.engine.isClosed) {
      return;
    }
    this.engine = new RTCEngine(this.options);
    this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver) => {
      this.onTrackAdded(mediaTrack, stream, receiver);
    }).on(EngineEvent.Disconnected, (reason) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile();
      this.isResuming = true;
      this.log.info("Resuming signal connection", this.logContext);
      if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
        this.emit(RoomEvent.SignalReconnecting);
      }
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile();
      this.isResuming = false;
      this.log.info("Resumed signal connection", this.logContext);
      this.updateSubscriptions();
      this.emitBufferedEvents();
      if (this.setAndEmitConnectionState(ConnectionState.Connected)) {
        this.emit(RoomEvent.Reconnected);
      }
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [];
      if (this.state === ConnectionState.Reconnecting || this.isResuming) {
        this.sendSyncState();
      }
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
      if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
        this.emit(RoomEvent.Reconnecting);
      }
    }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {
      this.emit(RoomEvent.DCBufferStatusChanged, status, kind);
    }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid) => {
      const trackPublication = this.localParticipant.getTrackPublications().find((_ref2) => {
        let {
          trackSid
        } = _ref2;
        return trackSid === subscribedSid;
      });
      if (!trackPublication) {
        this.log.warn("could not find local track subscription for subscribed event", this.logContext);
        return;
      }
      this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
      this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);
    }).on(EngineEvent.RoomMoved, (roomMoved) => {
      this.log.debug("room moved", roomMoved);
      if (roomMoved.room) {
        this.handleRoomUpdate(roomMoved.room);
      }
      this.remoteParticipants.forEach((participant, identity) => {
        this.handleParticipantDisconnected(identity, participant);
      });
      this.emit(RoomEvent.Moved, roomMoved.room.name);
      if (roomMoved.participant) {
        this.handleParticipantUpdates([roomMoved.participant, ...roomMoved.otherParticipants]);
      } else {
        this.handleParticipantUpdates(roomMoved.otherParticipants);
      }
    });
    if (this.localParticipant) {
      this.localParticipant.setupEngine(this.engine);
    }
    if (this.e2eeManager) {
      this.e2eeManager.setupEngine(this.engine);
    }
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it requests device permissions by default if needed
   * and makes sure the returned device does not consist of dummy devices
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(kind) {
    let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return DeviceManager.getInstance().getDevices(kind, requestPermissions);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(url, token) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state !== ConnectionState.Disconnected) {
        return;
      }
      this.log.debug("prepareConnection to ".concat(url), this.logContext);
      try {
        if (isCloud(new URL(url)) && token) {
          this.regionUrlProvider = new RegionUrlProvider(url, token);
          const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();
          if (regionUrl && this.state === ConnectionState.Disconnected) {
            this.regionUrl = regionUrl;
            yield fetch(toHttpUrl(regionUrl), {
              method: "HEAD"
            });
            this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);
          }
        } else {
          yield fetch(toHttpUrl(url), {
            method: "HEAD"
          });
        }
      } catch (e4) {
        this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
          error: e4
        }));
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(identity) {
    if (this.localParticipant.identity === identity) {
      return this.localParticipant;
    }
    return this.remoteParticipants.get(identity);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(scenario, arg) {
    return __awaiter(this, void 0, void 0, function* () {
      let postAction = () => {
      };
      let req;
      switch (scenario) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          req = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          req = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: true
            }
          });
          break;
        case "server-leave":
          req = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: true
            }
          });
          break;
        case "migration":
          req = new SimulateScenario({
            scenario: {
              case: "migration",
              value: true
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext();
          yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          postAction = () => __awaiter(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          });
          req = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: true
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          postAction = () => __awaiter(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          });
          req = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: true
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = true;
          yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          req = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: scenario === "force-tls" ? 2 : 1
            }
          });
          postAction = () => __awaiter(this, void 0, void 0, function* () {
            const onLeave = this.engine.client.onLeave;
            if (onLeave) {
              onLeave(new LeaveRequest({
                reason: DisconnectReason.CLIENT_INITIATED,
                action: LeaveRequest_Action.RECONNECT
              }));
            }
          });
          break;
        case "subscriber-bandwidth":
          if (arg === void 0 || typeof arg !== "number") {
            throw new Error("subscriber-bandwidth requires a number as argument");
          }
          req = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: numberToBigInt(arg)
            }
          });
          break;
        case "leave-full-reconnect":
          req = new SimulateScenario({
            scenario: {
              case: "leaveRequestFullReconnect",
              value: true
            }
          });
      }
      if (req) {
        yield this.engine.client.sendSimulateScenario(req);
        yield postAction();
      }
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(kind) {
    return this.localParticipant.activeDeviceMap.get(kind);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(kind_1, deviceId_1) {
    return __awaiter(this, arguments, void 0, function(kind, deviceId) {
      var _this3 = this;
      let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      return function* () {
        var _a3, _b, _c3, _d, _e3, _f;
        var _g;
        let success = true;
        let shouldTriggerImmediateDeviceChange = false;
        const deviceConstraint = exact ? {
          exact: deviceId
        } : deviceId;
        if (kind === "audioinput") {
          shouldTriggerImmediateDeviceChange = _this3.localParticipant.audioTrackPublications.size === 0;
          const prevDeviceId = (_a3 = _this3.getActiveDevice(kind)) !== null && _a3 !== void 0 ? _a3 : _this3.options.audioCaptureDefaults.deviceId;
          _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;
          const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track2) => track2.source === Track.Source.Microphone);
          try {
            success = (yield Promise.all(tracks.map((t3) => {
              var _a4;
              return (_a4 = t3.audioTrack) === null || _a4 === void 0 ? void 0 : _a4.setDeviceId(deviceConstraint);
            }))).every((val) => val === true);
          } catch (e4) {
            _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;
            throw e4;
          }
          const isMuted = tracks.some((t3) => {
            var _a4, _b2;
            return (_b2 = (_a4 = t3.track) === null || _a4 === void 0 ? void 0 : _a4.isMuted) !== null && _b2 !== void 0 ? _b2 : false;
          });
          if (success && isMuted)
            shouldTriggerImmediateDeviceChange = true;
        } else if (kind === "videoinput") {
          shouldTriggerImmediateDeviceChange = _this3.localParticipant.videoTrackPublications.size === 0;
          const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;
          _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;
          const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track2) => track2.source === Track.Source.Camera);
          try {
            success = (yield Promise.all(tracks.map((t3) => {
              var _a4;
              return (_a4 = t3.videoTrack) === null || _a4 === void 0 ? void 0 : _a4.setDeviceId(deviceConstraint);
            }))).every((val) => val === true);
          } catch (e4) {
            _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;
            throw e4;
          }
          const isMuted = tracks.some((t3) => {
            var _a4, _b2;
            return (_b2 = (_a4 = t3.track) === null || _a4 === void 0 ? void 0 : _a4.isMuted) !== null && _b2 !== void 0 ? _b2 : false;
          });
          if (success && isMuted)
            shouldTriggerImmediateDeviceChange = true;
        } else if (kind === "audiooutput") {
          shouldTriggerImmediateDeviceChange = true;
          if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !("setSinkId" in _this3.audioContext)) {
            throw new Error("cannot switch audio output, setSinkId not supported");
          }
          if (_this3.options.webAudioMix) {
            deviceId = (_c3 = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", deviceId)) !== null && _c3 !== void 0 ? _c3 : "";
          }
          (_d = (_g = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _g.audioOutput = {};
          const prevDeviceId = (_e3 = _this3.getActiveDevice(kind)) !== null && _e3 !== void 0 ? _e3 : _this3.options.audioOutput.deviceId;
          _this3.options.audioOutput.deviceId = deviceId;
          try {
            if (_this3.options.webAudioMix) {
              (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);
            }
            yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p3) => p3.setAudioOutput({
              deviceId
            })));
          } catch (e4) {
            _this3.options.audioOutput.deviceId = prevDeviceId;
            throw e4;
          }
        }
        if (shouldTriggerImmediateDeviceChange) {
          _this3.localParticipant.activeDeviceMap.set(kind, deviceId);
          _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
        }
        return success;
      }();
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var _a3;
    (_a3 = this.engine) === null || _a3 === void 0 ? void 0 : _a3.close();
    this.engine = void 0;
    this.isResuming = false;
    this.remoteParticipants.clear();
    this.sidToIdentity.clear();
    this.bufferedEvents = [];
    this.maybeCreateEngine();
  }
  onTrackAdded(mediaTrack, stream, receiver) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const reconnectedHandler = () => {
        this.onTrackAdded(mediaTrack, stream, receiver);
        cleanup();
      };
      const cleanup = () => {
        this.off(RoomEvent.Reconnected, reconnectedHandler);
        this.off(RoomEvent.Connected, reconnectedHandler);
        this.off(RoomEvent.Disconnected, cleanup);
      };
      this.once(RoomEvent.Reconnected, reconnectedHandler);
      this.once(RoomEvent.Connected, reconnectedHandler);
      this.once(RoomEvent.Disconnected, cleanup);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    if (mediaTrack.readyState === "ended") {
      this.log.info("skipping incoming track as it already ended", this.logContext);
      return;
    }
    const parts = unpackStreamId(stream.id);
    const participantSid = parts[0];
    let streamId = parts[1];
    let trackId = mediaTrack.id;
    if (streamId && streamId.startsWith("TR"))
      trackId = streamId;
    if (participantSid === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const participant = Array.from(this.remoteParticipants.values()).find((p3) => p3.sid === participantSid);
    if (!participant) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(participantSid), this.logContext);
      return;
    }
    let adaptiveStreamSettings;
    if (this.options.adaptiveStream) {
      if (typeof this.options.adaptiveStream === "object") {
        adaptiveStreamSettings = this.options.adaptiveStream;
      } else {
        adaptiveStreamSettings = {};
      }
    }
    participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
  }
  handleDisconnect() {
    let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    let reason = arguments.length > 1 ? arguments[1] : void 0;
    var _a3;
    this.clearConnectionReconcile();
    this.isResuming = false;
    this.bufferedEvents = [];
    this.transcriptionReceivedTimes.clear();
    if (this.state === ConnectionState.Disconnected) {
      return;
    }
    this.regionUrl = void 0;
    try {
      this.remoteParticipants.forEach((p3) => {
        p3.trackPublications.forEach((pub) => {
          p3.unpublishTrack(pub.trackSid);
        });
      });
      this.localParticipant.trackPublications.forEach((pub) => {
        var _a4, _b, _c3;
        if (pub.track) {
          this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
        }
        if (shouldStopTracks) {
          (_a4 = pub.track) === null || _a4 === void 0 ? void 0 : _a4.detach();
          (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
        } else {
          (_c3 = pub.track) === null || _c3 === void 0 ? void 0 : _c3.stopMonitor();
        }
      });
      this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
      this.localParticipant.trackPublications.clear();
      this.localParticipant.videoTrackPublications.clear();
      this.localParticipant.audioTrackPublications.clear();
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.activeSpeakers = [];
      if (this.audioContext && typeof this.options.webAudioMix === "boolean") {
        this.audioContext.close();
        this.audioContext = void 0;
      }
      if (isWeb()) {
        window.removeEventListener("beforeunload", this.onPageLeave);
        window.removeEventListener("pagehide", this.onPageLeave);
        window.removeEventListener("freeze", this.onPageLeave);
        (_a3 = navigator.mediaDevices) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("devicechange", this.handleDeviceChange);
      }
    } finally {
      this.setAndEmitConnectionState(ConnectionState.Disconnected);
      this.emit(RoomEvent.Disconnected, reason);
    }
  }
  handleParticipantDisconnected(identity, participant) {
    var _a3;
    this.remoteParticipants.delete(identity);
    if (!participant) {
      return;
    }
    participant.trackPublications.forEach((publication) => {
      participant.unpublishTrack(publication.trackSid, true);
    });
    this.emit(RoomEvent.ParticipantDisconnected, participant);
    participant.setDisconnected();
    (_a3 = this.localParticipant) === null || _a3 === void 0 ? void 0 : _a3.handleParticipantDisconnected(participant.identity);
  }
  handleStreamHeader(streamHeader, participantIdentity) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      if (streamHeader.contentHeader.case === "byteHeader") {
        const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);
        if (!streamHandlerCallback) {
          this.log.debug("ignoring incoming byte stream due to no handler for topic", streamHeader.topic);
          return;
        }
        let streamController;
        const info = {
          id: streamHeader.streamId,
          name: (_a3 = streamHeader.contentHeader.value.name) !== null && _a3 !== void 0 ? _a3 : "unknown",
          mimeType: streamHeader.mimeType,
          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
          topic: streamHeader.topic,
          timestamp: bigIntToNumber(streamHeader.timestamp),
          attributes: streamHeader.attributes
        };
        const stream = new ReadableStream({
          start: (controller) => {
            streamController = controller;
            this.byteStreamControllers.set(streamHeader.streamId, {
              info,
              controller: streamController,
              startTime: Date.now()
            });
          }
        });
        streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
          identity: participantIdentity
        });
      } else if (streamHeader.contentHeader.case === "textHeader") {
        const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);
        if (!streamHandlerCallback) {
          this.log.debug("ignoring incoming text stream due to no handler for topic", streamHeader.topic);
          return;
        }
        let streamController;
        const info = {
          id: streamHeader.streamId,
          mimeType: streamHeader.mimeType,
          size: streamHeader.totalLength ? Number(streamHeader.totalLength) : void 0,
          topic: streamHeader.topic,
          timestamp: Number(streamHeader.timestamp),
          attributes: streamHeader.attributes
        };
        const stream = new ReadableStream({
          start: (controller) => {
            streamController = controller;
            this.textStreamControllers.set(streamHeader.streamId, {
              info,
              controller: streamController,
              startTime: Date.now()
            });
          }
        });
        streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {
          identity: participantIdentity
        });
      }
    });
  }
  handleStreamChunk(chunk) {
    const fileBuffer = this.byteStreamControllers.get(chunk.streamId);
    if (fileBuffer) {
      if (chunk.content.length > 0) {
        fileBuffer.controller.enqueue(chunk);
      }
    }
    const textBuffer = this.textStreamControllers.get(chunk.streamId);
    if (textBuffer) {
      if (chunk.content.length > 0) {
        textBuffer.controller.enqueue(chunk);
      }
    }
  }
  handleStreamTrailer(trailer) {
    const textBuffer = this.textStreamControllers.get(trailer.streamId);
    if (textBuffer) {
      textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);
      textBuffer.controller.close();
      this.textStreamControllers.delete(trailer.streamId);
    }
    const fileBuffer = this.byteStreamControllers.get(trailer.streamId);
    if (fileBuffer) {
      {
        fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);
        fileBuffer.controller.close();
        this.byteStreamControllers.delete(trailer.streamId);
      }
    }
  }
  /**
   * attempt to select the default devices if the previously selected devices are no longer available after a device change event
   */
  selectDefaultDevices() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3;
      const previousDevices = DeviceManager.getInstance().previousDevices;
      const availableDevices = yield DeviceManager.getInstance().getDevices(void 0, false);
      const browser = getBrowser();
      if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && browser.os !== "iOS") {
        for (let availableDevice of availableDevices) {
          const previousDevice = previousDevices.find((info) => info.deviceId === availableDevice.deviceId);
          if (previousDevice && previousDevice.label !== "" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {
            if (this.getActiveDevice(availableDevice.kind) === "default") {
              this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);
            }
          }
        }
      }
      const kinds = ["audiooutput", "audioinput", "videoinput"];
      for (let kind of kinds) {
        const targetSource = kindToSource(kind);
        const targetPublication = this.localParticipant.getTrackPublication(targetSource);
        if (targetPublication && ((_a3 = targetPublication.track) === null || _a3 === void 0 ? void 0 : _a3.isUserProvided)) {
          continue;
        }
        const devicesOfKind = availableDevices.filter((d3) => d3.kind === kind);
        const activeDevice = this.getActiveDevice(kind);
        if (activeDevice === ((_b = previousDevices.filter((info) => info.kind === kind)[0]) === null || _b === void 0 ? void 0 : _b.deviceId)) {
          if (devicesOfKind.length > 0 && ((_c3 = devicesOfKind[0]) === null || _c3 === void 0 ? void 0 : _c3.deviceId) !== activeDevice) {
            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
            continue;
          }
        }
        if (kind === "audioinput" && !isSafariBased() || kind === "videoinput") {
          continue;
        }
        if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo) => deviceInfo.deviceId === this.getActiveDevice(kind)) && // avoid switching audio output on safari without explicit user action as it leads to slowed down audio playback
        (kind !== "audiooutput" || !isSafariBased())) {
          yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
        }
      }
    });
  }
  acquireAudioContext() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      if (typeof this.options.webAudioMix !== "boolean" && this.options.webAudioMix.audioContext) {
        this.audioContext = this.options.webAudioMix.audioContext;
      } else if (!this.audioContext || this.audioContext.state === "closed") {
        this.audioContext = (_a3 = getNewAudioContext()) !== null && _a3 !== void 0 ? _a3 : void 0;
      }
      if (this.options.webAudioMix) {
        this.remoteParticipants.forEach((participant) => participant.setAudioContext(this.audioContext));
      }
      this.localParticipant.setAudioContext(this.audioContext);
      if (this.audioContext && this.audioContext.state === "suspended") {
        try {
          yield Promise.race([this.audioContext.resume(), sleep(200)]);
        } catch (e4) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: e4
          }));
        }
      }
      const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
      if (newContextIsRunning !== this.canPlaybackAudio) {
        this.audioEnabled = newContextIsRunning;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
      }
    });
  }
  createParticipant(identity, info) {
    var _a3;
    let participant;
    if (info) {
      participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
        loggerContextCb: () => this.logContext,
        loggerName: this.options.loggerName
      });
    } else {
      participant = new RemoteParticipant(this.engine.client, "", identity, void 0, void 0, void 0, {
        loggerContextCb: () => this.logContext,
        loggerName: this.options.loggerName
      });
    }
    if (this.options.webAudioMix) {
      participant.setAudioContext(this.audioContext);
    }
    if ((_a3 = this.options.audioOutput) === null || _a3 === void 0 ? void 0 : _a3.deviceId) {
      participant.setAudioOutput(this.options.audioOutput).catch((e4) => this.log.warn("Could not set audio output: ".concat(e4.message), this.logContext));
    }
    return participant;
  }
  getOrCreateParticipant(identity, info) {
    if (this.remoteParticipants.has(identity)) {
      const existingParticipant = this.remoteParticipants.get(identity);
      if (info) {
        const wasUpdated = existingParticipant.updateInfo(info);
        if (wasUpdated) {
          this.sidToIdentity.set(info.sid, info.identity);
        }
      }
      return existingParticipant;
    }
    const participant = this.createParticipant(identity, info);
    this.remoteParticipants.set(identity, participant);
    this.sidToIdentity.set(info.sid, info.identity);
    this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
    participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
    }).on(ParticipantEvent.TrackSubscribed, (track2, publication) => {
      if (track2.kind === Track.Kind.Audio) {
        track2.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
        track2.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
      } else if (track2.kind === Track.Kind.Video) {
        track2.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);
        track2.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);
      }
      this.emit(RoomEvent.TrackSubscribed, track2, publication, participant);
    }).on(ParticipantEvent.TrackUnpublished, (publication) => {
      this.emit(RoomEvent.TrackUnpublished, publication, participant);
    }).on(ParticipantEvent.TrackUnsubscribed, (track2, publication) => {
      this.emit(RoomEvent.TrackUnsubscribed, track2, publication, participant);
    }).on(ParticipantEvent.TrackMuted, (pub) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
    }).on(ParticipantEvent.TrackUnmuted, (pub) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
    }).on(ParticipantEvent.ParticipantNameChanged, (name) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
    }).on(ParticipantEvent.AttributesChanged, (changedAttributes) => {
      this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
    }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
    }).on(ParticipantEvent.Active, () => {
      this.emitWhenConnected(RoomEvent.ParticipantActive, participant);
      if (participant.kind === ParticipantInfo_Kind.AGENT) {
        this.localParticipant.setActiveAgent(participant);
      }
    });
    if (info) {
      participant.updateInfo(info);
    }
    return participant;
  }
  sendSyncState() {
    const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {
      acc.push(...participant.getTrackPublications());
      return acc;
    }, []);
    const localTracks = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(remoteTracks, localTracks);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const p3 of this.remoteParticipants.values()) {
      for (const pub of p3.videoTrackPublications.values()) {
        if (pub.isSubscribed && isRemotePub(pub)) {
          pub.emitTrackUpdate();
        }
      }
    }
  }
  getRemoteParticipantBySid(sid) {
    const identity = this.sidToIdentity.get(sid);
    if (identity) {
      return this.remoteParticipants.get(identity);
    }
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let consecutiveFailures = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      if (
        // ensure we didn't tear it down
        !this.engine || // engine detected close, but Room missed it
        this.engine.isClosed || // transports failed without notifying engine
        !this.engine.verifyTransport()
      ) {
        consecutiveFailures++;
        this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
          numFailures: consecutiveFailures,
          engine: this.engine ? {
            closed: this.engine.isClosed,
            transportsConnected: this.engine.verifyTransport()
          } : void 0
        }));
        if (consecutiveFailures >= 3) {
          this.recreateEngine();
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);
        }
      } else {
        consecutiveFailures = 0;
      }
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    if (this.connectionReconcileInterval) {
      CriticalTimers.clearInterval(this.connectionReconcileInterval);
    }
  }
  setAndEmitConnectionState(state) {
    if (state === this.state) {
      return false;
    }
    this.state = state;
    this.emit(RoomEvent.ConnectionStateChanged, this.state);
    return true;
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((_ref3) => {
      let [ev, args] = _ref3;
      this.emit(ev, ...args);
    });
    this.bufferedEvents = [];
  }
  emitWhenConnected(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {
      this.bufferedEvents.push([event, args]);
    } else if (this.state === ConnectionState.Connected) {
      return this.emit(event, ...args);
    }
    return false;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      const publishOptions = Object.assign({
        audio: true,
        video: true,
        useRealTracks: false
      }, options.publish);
      const participantOptions = Object.assign({
        count: 9,
        audio: false,
        video: true,
        aspectRatios: [1.66, 1.7, 1.3]
      }, options.participants);
      this.handleDisconnect();
      this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: false
      });
      this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      }));
      this.setupLocalParticipantEvents();
      this.emit(RoomEvent.SignalConnected);
      this.emit(RoomEvent.Connected);
      this.setAndEmitConnectionState(ConnectionState.Connected);
      if (publishOptions.video) {
        const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: true
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a3 = participantOptions.aspectRatios[0]) !== null && _a3 !== void 0 ? _a3 : 1), 160, true, true), void 0, false, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(camPub);
        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
      }
      if (publishOptions.audio) {
        const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: true
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, false, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(audioPub);
        this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
      }
      for (let i3 = 0; i3 < participantOptions.count - 1; i3 += 1) {
        let info = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(i3),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const p3 = this.getOrCreateParticipant(info.identity, info);
        if (participantOptions.video) {
          const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i3 % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);
          const videoTrack = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          p3.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());
          info.tracks = [...info.tracks, videoTrack];
        }
        if (participantOptions.audio) {
          const dummyTrack = getEmptyAudioStreamTrack();
          const audioTrack = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          p3.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());
          info.tracks = [...info.tracks, audioTrack];
        }
        p3.updateInfo(info);
      }
    });
  }
  // /** @internal */
  emit(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {
      const minimizedArgs = mapArgs(args).filter((arg) => arg !== void 0);
      this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {
        event,
        args: minimizedArgs
      }));
    }
    return super.emit(event, ...args);
  }
};
Room.cleanupRegistry = typeof FinalizationRegistry !== "undefined" && new FinalizationRegistry((cleanup) => {
  cleanup();
});
function mapArgs(args) {
  return args.map((arg) => {
    if (!arg) {
      return;
    }
    if (Array.isArray(arg)) {
      return mapArgs(arg);
    }
    if (typeof arg === "object") {
      return "logContext" in arg ? arg.logContext : void 0;
    }
    return arg;
  });
}
var CheckStatus;
(function(CheckStatus2) {
  CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
  CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
  CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
  CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
  CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
var Checker = class extends eventsExports.EventEmitter {
  constructor(url, token) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super();
    this.status = CheckStatus.IDLE;
    this.logs = [];
    this.options = {};
    this.url = url;
    this.token = token;
    this.name = this.constructor.name;
    this.room = new Room(options.roomOptions);
    this.connectOptions = options.connectOptions;
    this.options = options;
  }
  run(onComplete) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE) {
        throw Error("check is running already");
      }
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (err) {
        if (err instanceof Error) {
          if (this.options.errorsAsWarnings) {
            this.appendWarning(err.message);
          } else {
            this.appendError(err.message);
          }
        }
      }
      yield this.disconnect();
      yield new Promise((resolve) => setTimeout(resolve, 500));
      if (this.status !== CheckStatus.SKIPPED) {
        this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
      }
      if (onComplete) {
        onComplete();
      }
      return this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((l3) => l3.level === "error");
  }
  connect(url) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.room.state === ConnectionState.Connected) {
        return this.room;
      }
      if (!url) {
        url = this.url;
      }
      yield this.room.connect(url, this.token, this.connectOptions);
      return this.room;
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.room && this.room.state !== ConnectionState.Disconnected) {
        yield this.room.disconnect();
        yield new Promise((resolve) => setTimeout(resolve, 500));
      }
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  switchProtocol(protocol) {
    return __awaiter(this, void 0, void 0, function* () {
      let hasReconnecting = false;
      let hasReconnected = false;
      this.room.on(RoomEvent.Reconnecting, () => {
        hasReconnecting = true;
      });
      this.room.once(RoomEvent.Reconnected, () => {
        hasReconnected = true;
      });
      this.room.simulateScenario("force-".concat(protocol));
      yield new Promise((resolve) => setTimeout(resolve, 1e3));
      if (!hasReconnecting) {
        return;
      }
      const timeout = Date.now() + 1e4;
      while (Date.now() < timeout) {
        if (hasReconnected) {
          return;
        }
        yield sleep(100);
      }
      throw new Error("Could not reconnect using ".concat(protocol, " protocol after 10 seconds"));
    });
  }
  appendMessage(message) {
    this.logs.push({
      level: "info",
      message
    });
    this.emit("update", this.getInfo());
  }
  appendWarning(message) {
    this.logs.push({
      level: "warning",
      message
    });
    this.emit("update", this.getInfo());
  }
  appendError(message) {
    this.logs.push({
      level: "error",
      message
    });
    this.emit("update", this.getInfo());
  }
  setStatus(status) {
    this.status = status;
    this.emit("update", this.getInfo());
  }
  get engine() {
    var _a3;
    return (_a3 = this.room) === null || _a3 === void 0 ? void 0 : _a3.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
};
var CloudRegionCheck = class extends Checker {
  get description() {
    return "Cloud regions";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      const regionProvider = new RegionUrlProvider(this.url, this.token);
      if (!regionProvider.isCloud()) {
        this.skip();
        return;
      }
      const regionStats = [];
      const seenUrls = /* @__PURE__ */ new Set();
      for (let i3 = 0; i3 < 3; i3++) {
        const regionUrl = yield regionProvider.getNextBestRegionUrl();
        if (!regionUrl) {
          break;
        }
        if (seenUrls.has(regionUrl)) {
          continue;
        }
        seenUrls.add(regionUrl);
        const stats = yield this.checkCloudRegion(regionUrl);
        this.appendMessage("".concat(stats.region, " RTT: ").concat(stats.rtt, "ms, duration: ").concat(stats.duration, "ms"));
        regionStats.push(stats);
      }
      regionStats.sort((a3, b3) => {
        return (a3.duration - b3.duration) * 0.5 + (a3.rtt - b3.rtt) * 0.5;
      });
      const bestRegion = regionStats[0];
      this.bestStats = bestRegion;
      this.appendMessage("best Cloud region: ".concat(bestRegion.region));
    });
  }
  getInfo() {
    const info = super.getInfo();
    info.data = this.bestStats;
    return info;
  }
  checkCloudRegion(url) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      yield this.connect(url);
      if (this.options.protocol === "tcp") {
        yield this.switchProtocol("tcp");
      }
      const region = (_a3 = this.room.serverInfo) === null || _a3 === void 0 ? void 0 : _a3.region;
      if (!region) {
        throw new Error("Region not found");
      }
      const writer2 = yield this.room.localParticipant.streamText({
        topic: "test"
      });
      const chunkSize = 1e3;
      const totalSize = 1e6;
      const numChunks = totalSize / chunkSize;
      const chunkData = "A".repeat(chunkSize);
      const startTime = Date.now();
      for (let i3 = 0; i3 < numChunks; i3++) {
        yield writer2.write(chunkData);
      }
      yield writer2.close();
      const endTime = Date.now();
      const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();
      const regionStats = {
        region,
        rtt: 1e4,
        duration: endTime - startTime
      };
      stats === null || stats === void 0 ? void 0 : stats.forEach((stat) => {
        if (stat.type === "candidate-pair" && stat.nominated) {
          regionStats.rtt = stat.currentRoundTripTime * 1e3;
        }
      });
      yield this.disconnect();
      return regionStats;
    });
  }
};
var TEST_DURATION = 1e4;
var ConnectionProtocolCheck = class extends Checker {
  get description() {
    return "Connection via UDP vs TCP";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      const udpStats = yield this.checkConnectionProtocol("udp");
      const tcpStats = yield this.checkConnectionProtocol("tcp");
      this.bestStats = udpStats;
      if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {
        this.appendMessage("best connection quality via tcp");
        this.bestStats = tcpStats;
      } else {
        this.appendMessage("best connection quality via udp");
      }
      const stats = this.bestStats;
      this.appendMessage("upstream bitrate: ".concat((stats.bitrateTotal / stats.count / 1e3 / 1e3).toFixed(2), " mbps"));
      this.appendMessage("RTT: ".concat((stats.rttTotal / stats.count * 1e3).toFixed(2), " ms"));
      this.appendMessage("jitter: ".concat((stats.jitterTotal / stats.count * 1e3).toFixed(2), " ms"));
      if (stats.packetsLost > 0) {
        this.appendWarning("packets lost: ".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), "%"));
      }
      if (stats.qualityLimitationDurations.bandwidth > 1) {
        this.appendWarning("bandwidth limited ".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1e3) * 100).toFixed(2), "%"));
      }
      if (stats.qualityLimitationDurations.cpu > 0) {
        this.appendWarning("cpu limited ".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1e3) * 100).toFixed(2), "%"));
      }
    });
  }
  getInfo() {
    const info = super.getInfo();
    info.data = this.bestStats;
    return info;
  }
  checkConnectionProtocol(protocol) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.connect();
      if (protocol === "tcp") {
        yield this.switchProtocol("tcp");
      } else {
        yield this.switchProtocol("udp");
      }
      const canvas = document.createElement("canvas");
      canvas.width = 1280;
      canvas.height = 720;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Could not get canvas context");
      }
      let hue = 0;
      const animate = () => {
        hue = (hue + 1) % 360;
        ctx.fillStyle = "hsl(".concat(hue, ", 100%, 50%)");
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        requestAnimationFrame(animate);
      };
      animate();
      const stream = canvas.captureStream(30);
      const videoTrack = stream.getVideoTracks()[0];
      const pub = yield this.room.localParticipant.publishTrack(videoTrack, {
        simulcast: false,
        degradationPreference: "maintain-resolution",
        videoEncoding: {
          maxBitrate: 2e6
        }
      });
      const track2 = pub.track;
      const protocolStats = {
        protocol,
        packetsLost: 0,
        packetsSent: 0,
        qualityLimitationDurations: {},
        rttTotal: 0,
        jitterTotal: 0,
        bitrateTotal: 0,
        count: 0
      };
      const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
        const stats = yield track2.getRTCStatsReport();
        stats === null || stats === void 0 ? void 0 : stats.forEach((stat) => {
          if (stat.type === "outbound-rtp") {
            protocolStats.packetsSent = stat.packetsSent;
            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;
            protocolStats.bitrateTotal += stat.targetBitrate;
            protocolStats.count++;
          } else if (stat.type === "remote-inbound-rtp") {
            protocolStats.packetsLost = stat.packetsLost;
            protocolStats.rttTotal += stat.roundTripTime;
            protocolStats.jitterTotal += stat.jitter;
          }
        });
      }), 1e3);
      yield new Promise((resolve) => setTimeout(resolve, TEST_DURATION));
      clearInterval(interval);
      videoTrack.stop();
      canvas.remove();
      yield this.disconnect();
      return protocolStats;
    });
  }
};
var PublishAudioCheck = class extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const room = yield this.connect();
      const track2 = yield createLocalAudioTrack();
      const trackIsSilent = yield detectSilence(track2, 1e3);
      if (trackIsSilent) {
        throw new Error("unable to detect audio from microphone");
      }
      this.appendMessage("detected audio from microphone");
      room.localParticipant.publishTrack(track2);
      yield new Promise((resolve) => setTimeout(resolve, 3e3));
      const stats = yield (_a3 = track2.sender) === null || _a3 === void 0 ? void 0 : _a3.getStats();
      if (!stats) {
        throw new Error("Could not get RTCStats");
      }
      let numPackets = 0;
      stats.forEach((stat) => {
        if (stat.type === "outbound-rtp" && (stat.kind === "audio" || !stat.kind && stat.mediaType === "audio")) {
          numPackets = stat.packetsSent;
        }
      });
      if (numPackets === 0) {
        throw new Error("Could not determine packets are sent");
      }
      this.appendMessage("published ".concat(numPackets, " audio packets"));
    });
  }
};
var PublishVideoCheck = class extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const room = yield this.connect();
      const track2 = yield createLocalVideoTrack();
      yield this.checkForVideo(track2.mediaStreamTrack);
      room.localParticipant.publishTrack(track2);
      yield new Promise((resolve) => setTimeout(resolve, 5e3));
      const stats = yield (_a3 = track2.sender) === null || _a3 === void 0 ? void 0 : _a3.getStats();
      if (!stats) {
        throw new Error("Could not get RTCStats");
      }
      let numPackets = 0;
      stats.forEach((stat) => {
        if (stat.type === "outbound-rtp" && (stat.kind === "video" || !stat.kind && stat.mediaType === "video")) {
          numPackets += stat.packetsSent;
        }
      });
      if (numPackets === 0) {
        throw new Error("Could not determine packets are sent");
      }
      this.appendMessage("published ".concat(numPackets, " video packets"));
    });
  }
  checkForVideo(track2) {
    return __awaiter(this, void 0, void 0, function* () {
      const stream = new MediaStream();
      stream.addTrack(track2.clone());
      const video = document.createElement("video");
      video.srcObject = stream;
      video.muted = true;
      yield new Promise((resolve) => {
        video.onplay = () => {
          setTimeout(() => {
            var _a3, _b, _c3, _d;
            const canvas = document.createElement("canvas");
            const settings = track2.getSettings();
            const width = (_b = (_a3 = settings.width) !== null && _a3 !== void 0 ? _a3 : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;
            const height = (_d = (_c3 = settings.height) !== null && _c3 !== void 0 ? _c3 : video.videoHeight) !== null && _d !== void 0 ? _d : 720;
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(video, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let isAllBlack = true;
            for (let i3 = 0; i3 < data.length; i3 += 4) {
              if (data[i3] !== 0 || data[i3 + 1] !== 0 || data[i3 + 2] !== 0) {
                isAllBlack = false;
                break;
              }
            }
            if (isAllBlack) {
              this.appendError("camera appears to be producing only black frames");
            } else {
              this.appendMessage("received video frames");
            }
            resolve();
          }, 1e3);
        };
        video.play();
      });
      stream.getTracks().forEach((t3) => t3.stop());
      video.remove();
    });
  }
};
var ReconnectCheck = class extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3;
      const room = yield this.connect();
      let reconnectingTriggered = false;
      let reconnected = false;
      let reconnectResolver;
      const reconnectTimeout = new Promise((resolve) => {
        setTimeout(resolve, 5e3);
        reconnectResolver = resolve;
      });
      const handleReconnecting = () => {
        reconnectingTriggered = true;
      };
      room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {
        reconnected = true;
        reconnectResolver(true);
      });
      (_a3 = room.engine.client.ws) === null || _a3 === void 0 ? void 0 : _a3.close();
      const onClose = room.engine.client.onClose;
      if (onClose) {
        onClose("");
      }
      yield reconnectTimeout;
      if (!reconnectingTriggered) {
        throw new Error("Did not attempt to reconnect");
      } else if (!reconnected || room.state !== ConnectionState.Connected) {
        this.appendWarning("reconnection is only possible in Redis-based configurations");
        throw new Error("Not able to reconnect");
      }
    });
  }
};
var TURNCheck = class extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b;
      const signalClient = new SignalClient();
      const joinRes = yield signalClient.join(this.url, this.token, {
        autoSubscribe: true,
        maxRetries: 0,
        e2eeEnabled: false,
        websocketTimeout: 15e3
      });
      let hasTLS = false;
      let hasTURN = false;
      let hasSTUN = false;
      for (let iceServer of joinRes.iceServers) {
        for (let url of iceServer.urls) {
          if (url.startsWith("turn:")) {
            hasTURN = true;
            hasSTUN = true;
          } else if (url.startsWith("turns:")) {
            hasTURN = true;
            hasSTUN = true;
            hasTLS = true;
          }
          if (url.startsWith("stun:")) {
            hasSTUN = true;
          }
        }
      }
      if (!hasSTUN) {
        this.appendWarning("No STUN servers configured on server side.");
      } else if (hasTURN && !hasTLS) {
        this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");
      }
      yield signalClient.close();
      if (((_b = (_a3 = this.connectOptions) === null || _a3 === void 0 ? void 0 : _a3.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {
        yield this.room.connect(this.url, this.token, {
          rtcConfig: {
            iceTransportPolicy: "relay"
          }
        });
      } else {
        this.appendWarning("No TURN servers configured.");
        this.skip();
        yield new Promise((resolve) => setTimeout(resolve, 0));
      }
    });
  }
};
var WebRTCCheck = class extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      let hasTcp = false;
      let hasIpv4Udp = false;
      this.room.on(RoomEvent.SignalConnected, () => {
        const prevTrickle = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (sd, target) => {
          if (sd.candidate) {
            const candidate = new RTCIceCandidate(sd);
            let str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);
            if (candidate.address) {
              if (isIPPrivate(candidate.address)) {
                str += " (private)";
              } else {
                if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {
                  hasTcp = true;
                  str += " (passive)";
                } else if (candidate.protocol === "udp") {
                  hasIpv4Udp = true;
                }
              }
            }
            this.appendMessage(str);
          }
          if (prevTrickle) {
            prevTrickle(sd, target);
          }
        };
        if (this.room.engine.pcManager) {
          this.room.engine.pcManager.subscriber.onIceCandidateError = (ev) => {
            if (ev instanceof RTCPeerConnectionIceErrorEvent) {
              this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));
            }
          };
        }
      });
      try {
        yield this.connect();
        livekitLogger.info("now the room is connected");
      } catch (err) {
        this.appendWarning("ports need to be open on firewall in order to connect.");
        throw err;
      }
      if (!hasTcp) {
        this.appendWarning("Server is not configured for ICE/TCP");
      }
      if (!hasIpv4Udp) {
        this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
      }
    });
  }
};
function isIPPrivate(address) {
  const parts = address.split(".");
  if (parts.length === 4) {
    if (parts[0] === "10") {
      return true;
    } else if (parts[0] === "192" && parts[1] === "168") {
      return true;
    } else if (parts[0] === "172") {
      const second = parseInt(parts[1], 10);
      if (second >= 16 && second <= 31) {
        return true;
      }
    }
  }
  return false;
}
var WebSocketCheck = class extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a3, _b, _c3;
      if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {
        this.appendWarning("Server is insecure, clients may block connections to it");
      }
      let signalClient = new SignalClient();
      const joinRes = yield signalClient.join(this.url, this.token, {
        autoSubscribe: true,
        maxRetries: 0,
        e2eeEnabled: false,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));
      if (((_a3 = joinRes.serverInfo) === null || _a3 === void 0 ? void 0 : _a3.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {
        this.appendMessage("LiveKit Cloud: ".concat((_c3 = joinRes.serverInfo) === null || _c3 === void 0 ? void 0 : _c3.region));
      }
      yield signalClient.close();
    });
  }
};
var ConnectionCheck = class extends eventsExports.EventEmitter {
  constructor(url, token) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super();
    this.options = {};
    this.checkResults = /* @__PURE__ */ new Map();
    this.url = url;
    this.token = token;
    this.options = options;
  }
  getNextCheckId() {
    const nextId = this.checkResults.size;
    this.checkResults.set(nextId, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    });
    return nextId;
  }
  updateCheck(checkId, info) {
    this.checkResults.set(checkId, info);
    this.emit("checkUpdate", checkId, info);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((r4) => r4.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(check) {
    return __awaiter(this, void 0, void 0, function* () {
      const checkId = this.getNextCheckId();
      const test = new check(this.url, this.token, this.options);
      const handleUpdate = (info) => {
        this.updateCheck(checkId, info);
      };
      test.on("update", handleUpdate);
      const result = yield test.run();
      test.off("update", handleUpdate);
      return result;
    });
  }
  checkWebsocket() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
  checkConnectionProtocol() {
    return __awaiter(this, void 0, void 0, function* () {
      const info = yield this.createAndRunCheck(ConnectionProtocolCheck);
      if (info.data && "protocol" in info.data) {
        const stats = info.data;
        this.options.protocol = stats.protocol;
      }
      return info;
    });
  }
  checkCloudRegion() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(CloudRegionCheck);
    });
  }
};

// src/transport/LivekitTransport.ts
var LiveKitTransport = class extends $4086f06442fcb7d7$export$86495b081fef8e52 {
  constructor(options) {
    super();
    this.options = options;
    this._state = "disconnected";
    this._bufferAudio = false;
    this._audioBuffer = [];
    this._messageHandler = () => {
    };
    this.room = new Room(this.options?.roomOptions);
  }
  get state() {
    return this._state;
  }
  set state(val) {
    this._state = val;
  }
  _emitInternalMessage(type) {
    this._messageHandler({
      id: `${type}-${Date.now()}`,
      label: "internal",
      type,
      data: {}
    });
  }
  async connect(auth, abortController) {
    console.debug("Room URL:", auth.room_url);
    console.debug("Token:", auth.token);
    if (abortController.signal.aborted)
      return;
    this.state = "connecting";
    try {
      await this.room.connect(auth.room_url, auth.token);
      this.state = "connected";
    } catch (err) {
      console.error("LiveKit connection failed:", err);
      this.state = "disconnected";
      return;
    }
    console.log("LiveKit room connected");
    try {
      const audioTrack = await createLocalAudioTrack({
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      });
      await this.room.localParticipant.publishTrack(audioTrack, {
        source: Track.Source.Microphone,
        name: "microphone"
      });
      console.log("Microphone track published successfully");
    } catch (err) {
      console.error("Failed to create or publish mic track:", err);
    }
    this.room.on("trackSubscribed", (track2, pub, participant) => {
      if (track2.kind === "audio" && track2 instanceof RemoteTrack) {
        const audioElement = track2.attach();
        audioElement.style.display = "none";
        document.body.appendChild(audioElement);
        console.log("Remote audio track attached from", participant.identity);
      }
    });
    this.room.on("dataReceived", (payload, participant) => {
      try {
        if (payload instanceof Uint8Array && payload.byteLength > 0) {
          return;
        }
        const msg = JSON.parse(new TextDecoder().decode(payload));
        this._messageHandler(msg);
      } catch (e4) {
        console.error("Invalid data message", e4);
      }
    });
    this.room.on("participantConnected", (participant) => {
      console.log("Participant connected:", participant.identity);
    });
    this.room.on("connectionStateChanged", (state) => {
      console.log("Room connection state changed:", state);
    });
  }
  async disconnect() {
    this.room.disconnect();
    this.state = "disconnected";
  }
  async initialize(options, messageHandler) {
    this._messageHandler = messageHandler;
  }
  handleUserAudioStream(data) {
    if (!this.room.localParticipant.isMicrophoneEnabled) {
      console.log("Microphone is disabled, enabling it");
      this.enableMic(true);
    }
    if (this.options?.bufferLocalAudioUntilBotReady && this.state !== "ready") {
      this._audioBuffer.push(data.slice(0));
      this._emitInternalMessage("audio-buffering-started" /* AUDIO_BUFFERING_STARTED */);
      return;
    }
    this._sendAudioBatch([data]);
    if (this._audioBuffer.length > 0) {
      this._audioBuffer = [];
      this._emitInternalMessage("audio-buffering-stopped" /* AUDIO_BUFFERING_STOPPED */);
    }
  }
  _sendAudioBatch(dataBatch) {
    for (const chunk of dataBatch) {
      this.room.localParticipant.publishData(new Uint8Array(chunk), {
        reliable: true
      });
    }
  }
  sendMessage(message) {
    const payload = new TextEncoder().encode(JSON.stringify(message));
    this.room.localParticipant.publishData(payload, {
      reliable: true
    });
  }
  async sendReadyMessage() {
    this.state = "ready";
    this._emitInternalMessage("audio-buffering-stopped" /* AUDIO_BUFFERING_STOPPED */);
    if (this._audioBuffer.length > 0) {
      this._sendAudioBatch(this._audioBuffer);
      this._audioBuffer = [];
    }
  }
  async getAllMics() {
    return (await navigator.mediaDevices.enumerateDevices()).filter((d3) => d3.kind === "audioinput");
  }
  async updateMic(deviceId) {
    const track2 = await createLocalAudioTrack({ deviceId: { exact: deviceId } });
    await this.room.localParticipant.publishTrack(track2);
  }
  get selectedMic() {
    return {};
  }
  async getAllCams() {
    return (await navigator.mediaDevices.enumerateDevices()).filter((d3) => d3.kind === "videoinput");
  }
  async updateCam(deviceId) {
    const track2 = await createLocalVideoTrack({ deviceId: { exact: deviceId } });
    await this.room.localParticipant.publishTrack(track2);
  }
  get selectedCam() {
    return {};
  }
  async getAllSpeakers() {
    return (await navigator.mediaDevices.enumerateDevices()).filter((d3) => d3.kind === "audiooutput");
  }
  updateSpeaker(speakerId) {
    console.warn("Speaker output selection is not implemented.");
  }
  get selectedSpeaker() {
    return {};
  }
  enableMic(enable) {
    try {
      this.room.localParticipant.setMicrophoneEnabled(enable);
      console.log(`Microphone ${enable ? "enabled" : "disabled"}`);
    } catch (err) {
      console.error("Error toggling microphone:", err);
    }
  }
  get isMicEnabled() {
    return this.room.localParticipant.isMicrophoneEnabled;
  }
  enableCam(enable) {
    this.room.localParticipant.setCameraEnabled(enable);
  }
  get isCamEnabled() {
    return this.room.localParticipant.isCameraEnabled;
  }
  enableScreenShare(enable) {
    console.warn("Screen sharing not implemented in this stub.");
  }
  get isSharingScreen() {
    return false;
  }
  tracks() {
    const audioPub = this.room.localParticipant.getTrackPublication(Track.Source.Microphone);
    const videoPub = this.room.localParticipant.getTrackPublication(Track.Source.Camera);
    const screenAudioPub = this.room.localParticipant.getTrackPublication(Track.Source.ScreenShareAudio);
    const screenVideoPub = this.room.localParticipant.getTrackPublication(Track.Source.ScreenShare);
    return {
      local: {
        audio: audioPub?.track?.mediaStreamTrack,
        video: videoPub?.track?.mediaStreamTrack,
        screenAudio: screenAudioPub?.track?.mediaStreamTrack,
        screenVideo: screenVideoPub?.track?.mediaStreamTrack
      }
    };
  }
  async preAuth() {
  }
  async initDevices() {
    await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
  }
};

// src/transport/transport.ts
var TransportFactory = class {
  static isBrowser() {
    return typeof window !== "undefined" && typeof window.document !== "undefined";
  }
  static create(transportType, options) {
    if (!this.isBrowser()) {
      throw new Error("Transport can only be created in a browser environment");
    }
    switch (transportType) {
      case "websocket":
        return new WebSocketTransport({
          serializer: new ProtobufFrameSerializer(),
          recorderSampleRate: 16e3
        });
      case "daily":
        return new $683f111f61e07358$export$b1ca982aa1e488c1(options);
      case "webrtc":
        return new $b31644dc78dca54a$export$62043589d053a879(options);
      case "gemini":
        return new $d4cf498bb51af8a5$export$bef67da0c82ecefe(options);
      case "openai":
        return new $4e887b6dcd7ec3e7$export$60a765086a8f0478(options);
      case "livekit":
        return new LiveKitTransport(options);
      default:
        throw new Error(`Unsupported transport type: ${transportType}`);
    }
  }
  static getAvailableTransports() {
    return ["websocket", "daily", "webrtc", "gemini", "openai", "livekit"];
  }
};
var TransportManager = class {
  constructor(transportType, options) {
    this.transport = null;
    this.transportType = transportType;
    this.transportOptions = options;
  }
  ensureTransport() {
    if (!this.transport) {
      this.transport = TransportFactory.create(this.transportType, this.transportOptions);
    }
    return this.transport;
  }
  async initialize(options, messageHandler) {
    return this.ensureTransport().initialize(options, messageHandler);
  }
  async connect(authBundle, abortController) {
    return this.ensureTransport().connect(authBundle, abortController);
  }
  async disconnect() {
    if (this.transport) {
      return this.transport.disconnect();
    }
  }
  get instance() {
    return this.ensureTransport();
  }
  get state() {
    return this.ensureTransport().state;
  }
  tracks() {
    return this.ensureTransport().tracks();
  }
  async enableMic(enable) {
    await this.ensureTransport().enableMic(enable);
  }
  async enableCam(enable) {
    await this.ensureTransport().enableCam(enable);
  }
  enableScreenShare(enable) {
    this.ensureTransport().enableScreenShare(enable);
  }
  get isSharingScreen() {
    return this.ensureTransport().isSharingScreen;
  }
  get isCamEnabled() {
    return this.ensureTransport().isCamEnabled;
  }
  get isMicEnabled() {
    return this.ensureTransport().isMicEnabled;
  }
  sendMessage(message) {
    this.ensureTransport().sendMessage(message);
  }
};

// src/utils/utils.ts
async function createRTVIClient(transportType, customOptions) {
  console.log(`Debug: Transport type chosen: ${transportType}`);
  let transport;
  switch (transportType) {
    case "websocket":
      transport = TransportFactory.create("websocket", {
        serializer: new ProtobufFrameSerializer2(),
        recorderSampleRate: 16e3
      });
      break;
    case "webrtc":
      transport = TransportFactory.create("webrtc", {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" }
        ]
      });
      break;
    case "daily":
      transport = TransportFactory.create("daily", {});
      break;
    case "gemini":
      transport = TransportFactory.create("gemini", {
        api_key: process.env.GEMINI_API_KEY || ""
      });
      break;
    case "openai":
      transport = TransportFactory.create("openai", {
        api_key: process.env.OPENAI_API_KEY || ""
      });
      break;
    case "livekit":
      transport = TransportFactory.create("livekit", {});
      break;
    default:
      throw new Error(`Invalid transport type: ${transportType}`);
  }
  console.log(`Transport chosen: ${transportType}`);
  const defaultOptions = {
    transport,
    params: {
      baseUrl: "http://localhost:8000",
      endpoints: {
        connect: transportType === "webrtc" ? "/api/offer" : "/connect"
      },
      audio: {
        sampleRate: 16e3,
        numChannels: 1,
        encoding: "raw",
        format: "protobuf",
        outputSampleRate: 16e3,
        outputChannels: 1
      },
      requestData: {
        transportType,
        type: "offer",
        sdp: "sdp"
      }
    },
    enableMic: true,
    enableCam: false,
    timeout: 15e3
  };
  const options = customOptions ? {
    ...defaultOptions,
    ...customOptions,
    // Handle nested params object separately to allow partial overrides
    params: customOptions.params ? {
      ...defaultOptions.params,
      ...customOptions.params,
      // Handle nested endpoints object
      endpoints: customOptions.params.endpoints && typeof customOptions.params.endpoints === "object" ? { ...defaultOptions.params.endpoints || {}, ...customOptions.params.endpoints } : defaultOptions.params.endpoints,
      // Handle nested audio object
      audio: customOptions.params.audio && typeof customOptions.params.audio === "object" ? { ...defaultOptions.params.audio || {}, ...customOptions.params.audio } : defaultOptions.params.audio,
      // Handle nested requestData object
      requestData: customOptions.params.requestData && typeof customOptions.params.requestData === "object" ? { ...defaultOptions.params.requestData || {}, ...customOptions.params.requestData } : defaultOptions.params.requestData
      // Note: We don't need to spread customOptions.params again as it's already spread above
    } : defaultOptions.params,
    // Ensure callbacks are properly merged if provided
    callbacks: customOptions.callbacks && typeof customOptions.callbacks === "object" ? { ...defaultOptions.callbacks || {}, ...customOptions.callbacks } : defaultOptions.callbacks,
    // Preserve transport if provided in customOptions
    transport: customOptions.transport || defaultOptions.transport,
    // Preserve other top-level options
    timeout: customOptions.timeout !== void 0 ? customOptions.timeout : defaultOptions.timeout,
    enableMic: customOptions.enableMic !== void 0 ? customOptions.enableMic : defaultOptions.enableMic,
    enableCam: customOptions.enableCam !== void 0 ? customOptions.enableCam : defaultOptions.enableCam,
    // Include customConnectHandler if provided
    customConnectHandler: customOptions.customConnectHandler || defaultOptions.customConnectHandler
  } : defaultOptions;
  const client = new Client(options);
  return client;
}

// src/index.ts
import { WebSocketTransport as WebSocketTransport2, ProtobufFrameSerializer as ProtobufFrameSerializer3 } from "@pipecat-ai/websocket-transport";
export {
  $8ead7b33b8402751$export$be839f0100cd3132 as ActionEndpointNotSetError,
  $8ead7b33b8402751$export$885fb96b850e8fbb as BotNotReadyError,
  Client,
  $8ead7b33b8402751$export$4eda4fd287fbbca5 as ConfigUpdateError,
  $8ead7b33b8402751$export$c67992fa684a81a6 as ConnectionTimeoutError,
  $683f111f61e07358$export$b1ca982aa1e488c1 as DailyTransport,
  $d4cf498bb51af8a5$export$bef67da0c82ecefe as GeminiLiveWebsocketTransport,
  $0908f693e3e0724c$export$43cdfb26f790451 as LLMActionType,
  $0908f693e3e0724c$export$3cf39a62d076dd5c as LLMHelper,
  $0908f693e3e0724c$export$441bcd2e10762760 as LLMMessageType,
  $7afbbd59ebaa42bf$export$243e62d78d3b544d as LogLevel,
  $b48f893ed1354c1e$export$e9a960646cc432aa as MessageDispatcher,
  $4e887b6dcd7ec3e7$export$60a765086a8f0478 as OpenAIRealTimeWebRTCTransport,
  ProtobufFrameSerializer3 as ProtobufFrameSerializer,
  $b48f893ed1354c1e$export$378529d7a8bead8b as RTVIActionRequest,
  $a7c324a73303ad55$export$fa42a01c1d60f4a1 as RTVIClient,
  $7614fb2168c523cc$export$23bc637255b2a471 as RTVIClientHelper,
  $8ead7b33b8402751$export$59b4786f333aac02 as RTVIError,
  $f9fc0c57b9aaed9c$export$6b4624d233c61fcb as RTVIEvent,
  $b48f893ed1354c1e$export$69aa9ab0334b212 as RTVIMessage,
  $b48f893ed1354c1e$export$38b3db05cbf0e240 as RTVIMessageType,
  $b48f893ed1354c1e$export$882b13c7fda338f5 as RTVI_MESSAGE_LABEL,
  $b31644dc78dca54a$export$62043589d053a879 as SmallWebRTCTransport,
  $8ead7b33b8402751$export$e7544ab812238a61 as StartBotError,
  $4086f06442fcb7d7$export$86495b081fef8e52 as Transport,
  TransportFactory,
  TransportManager,
  $8ead7b33b8402751$export$e0624a511a2c4e9 as TransportStartError,
  $4086f06442fcb7d7$export$82b6ede160a64a3c as TransportWrapper,
  WebSocketTransport2 as WebSocketTransport,
  createRTVIClient,
  $4bb349f22aee5185$export$8728b60ea57bf43e as httpActionGenerator,
  $7afbbd59ebaa42bf$export$af88d00dbe7f521 as logger
};
/*! Bundled license information:

shallow-clone/index.js:
  (*!
   * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

@daily-co/daily-js/dist/daily-esm.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)

@daily-co/daily-js/dist/daily-esm.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=index.js.map